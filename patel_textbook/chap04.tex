\documentclass{patt}
\usepackage[section]{placeins}
\graphicspath{{../art/ch04/},{../art/designelements/},{../art/designelements/UnNumberedArt/}}
\begin{document}

\setcounter{chapter}{3}
\setcounter{page}{97}

\chapter{The von Neumann Model}
\label{chapt:von_neumann}

We are now ready to raise our level of abstraction
another notch.  We will build on the logic structures that we
studied in Chapter~3, both decision elements and storage
elements, to construct the basic computer model first proposed 
in the 1940s, usually referred to as the von Neumann machine. ...and, we will
write our first computer program in the ISA of the LC-3.

\vspace{-6pt}

% 4.1

\section{Basic Components}

To get a task done by a computer, we need two things: (a) 
a {\bf computer program} that specifies what the computer must do to perform 
the task, and (b) the {\bf computer} that is to carry out the task.

A computer program consists of a set of instructions, each specifying a
well-defined piece of work for the computer to carry out.  
The {\em instruction}
is the smallest piece of work specified in a computer program.  That is, the
computer either carries out the work specified by an instruction or it does
not.  The computer does not have the luxury 
of carrying out only a piece of an instruction.

John von Neumann proposed a fundamental model of a computer for processing
computer programs in 1946.  Figure~\ref{fig:vonneumann} shows its basic 
components.  We have taken a little poetic license and added a few of our 
own minor embellishments to von Neumann's original diagram.
The von Neumann model consists of five parts: {\em memory, a processing unit,
input, output}, and {\em a control unit}. The computer program 
is contained in the computer's memory.  The data the program needs to carry out
the work of the program is either contained in the program's memory, or is 
obtained from the input devices.  The results of the program's execution is
provided by the output devices.  The order in which the
instructions are carried out is performed by the control unit.

\index{von Neumann!model}


We will describe each of the five parts of the von Neumann model in greater
detail.

%Figure 4.1
\begin{figure}
\vspace{2pt}
\centerline{\includegraphics{pat67509_0401.eps}}
\caption{The von Neumann model, overall block diagram}
\label{fig:vonneumann}
\vspace{-2pt}
\end{figure}

%4.1.1

\subsection{Memory}

Recall that in Chapter~3 we examined a simple $2^2$-by-3-bit
memory that was~constructed out of gates and latches. A more realistic
memory for one of today's computer systems is $2^{34}$ by 8 bits.  That is, a
typical memory in today's world of computers consists of $2^{34}$ distinct
memory locations, each of which is capable of storing 8 bits of information.
We say that such a memory has an {\em address space} of $2^{34}$ uniquely
identifiable locations, and an {\em addressability} of 8 bits.  We refer
to such a memory as a 16-gigabyte memory (abbreviated, 16\,GB).
The ``16~giga'' refers to the $2^{34}$ locations, and the ``byte''
refers to the 8 bits stored in each location. The term 16~giga because
16 is $2^{4}$ and {\em giga} is the term we use to represent $2^{30}$, which is
approximately one billion; $2^{4}$ times $2^{30}$ = $2^{34}$.  A {\em byte} is the word we use to describe 8 bits, much the
\index{byte}
way we use the word {\em gallon} to describe four quarts.

We note (as we will note again and again) that with $k$ bits, we can represent
uniquely $2^k$ items.  Thus, to uniquely identify $2^{34}$ memory locations, 
each location must have its own 34-bit address.  In Chapter~5, we will begin 
the complete definition of the LC-3
computer. We will see that the memory address space of the LC-3 is $2^{16}$,
and the addressability is 16 bits.

Recall from Chapter~3 that we access memory by providing the address from
which we wish to read, or to which we wish to write.  To read the contents
of a memory location, we first place the address of that location in the
memory's address register ({\bf MAR}), and then interrogate the computer's
memory.  The \nobreak information stored in the location having that address 
will be placed in the memory's data register ({\bf MDR}).  To write (or store)
a value in a memory location, we first write the address of the memory
location in the MAR, and the value to be stored in the MDR.  We then
interrogate the computer's memory with the Write Enable signal
asserted.  The information contained in the MDR will be written into
the memory location whose address is in the MAR.

Before we leave the notion of memory for the moment, let us again emphasize
the two characteristics of a memory location: its address and what is stored
there. Figure~\ref{fig:memvalue} shows a representation of a memory consisting 
of eight locations. Its addresses are shown at the left, numbered in binary 
from 0 to 7.  Each location contains 8 bits of information.  Note that the 
value 6 is stored in the memory location whose address is 4, and the value 4 
is stored in the memory location whose address is 6. These
represent two very different situations.

%Figure~4.2
\begin{figure}
\centerline{\includegraphics{pat67509_0402.eps}}
\caption{Location 6 contains the value 4; location 4 contains the value 6}
\label{fig:memvalue}
\vspace{-6pt}
\end{figure}

Finally, an analogy: the post office boxes in your local
post office.  The box number is like the memory location's address.  Each
box number is unique.  The information stored in the memory location is
like the letters contained in the post office box.  As time goes by,
what is contained in the post office box at any particular moment can
change.  But the box number remains the same.  So,~too, with each memory
location.  The value stored in that location can be changed, but the
location's memory address remains unchanged.

%4.1.2
\subsection{Processing Unit}
The actual processing of information in the computer is carried out by the
{\em \nobreak processing unit}.\index{processing unit} The processing unit in a modern
computer can consist of many sophisticated complex functional units, each
performing one particular operation (divide, square root, etc.).  The simplest
processing unit, and the one normally thought of when discussing the basic von
Neumann model, is the {\bf ALU}. {\em ALU} is the abbreviation for Arithmetic
and Logic Unit, so called because
\index{ALU}
it is usually capable of performing basic arithmetic functions (like ADD and
SUBTRACT) and basic logic operations (like bit-wise AND, OR, and NOT) that we
have already studied in Chapter~2.  We will see in Chapter~5, that the LC-3
has an ALU, which can perform ADD, AND, and NOT operations.  Two of these 
(ADD and AND) we will discuss in this chapter.

The ALU normally processes data elements of a fixed size referred to as the
{\em word length} of the computer.  The data elements are called {\em words}.
\index{word length}
\index{word}
For example, to perform ADD, the ALU receives two words as inputs and produces
a single word (the sum) as output.
Each ISA has its own word length, depending on the intended use of 
the computer.

Most microprocessors today that are used in PCs or workstations have a word
length of 64 bits (as is the case with Intel's "Core" processors) or 32
bits (as is the case with Intel's "Atom" processors). Even most 
microprocessors now used in cell phones have 64 bit word lengths, such as 
Apple's A7 through A11 processors, and Qualcomm's SnapDragon processors.
However, the microprocessors used in very inexpensive applications often
have word lengths of as little as 16 or even 8 bits.

In the LC-3, the ALU processes 16-bit words.  We say the LC-3 has a
word length of 16 bits.  

It is almost always the case that a computer provides some small amount of
storage very close to the ALU to allow results to be temporarily stored if
they will be needed to produce additional results in the near future.  
For example,
if a computer is to calculate $(A+B)\cdot C$, it could store the result of
$A+B$ in memory, and then subsequently read it in order to multiply that
result by $C$.  However, the time it takes to access memory is long compared
to the time it takes to perform the ADD or MULTIPLY.  Almost all computers,
therefore, have temporary storage for storing the result of $A+B$ in order
to avoid the much longer access time that would be necessary when
it came time to multiply.  The most common form of temporary storage is a set
of registers, like the register described in Section~3.7. Typically, the
size of each register is identical to the size of values processed by the
ALU, that is, they each contain one word.  The LC-3 has eight registers
(R0,~R1, $\ldots$ R7), each containing 16 bits. 

Current microprocessors typically contain 32 registers, each consisting of
32 or 64 bits, depending on the architecture.  These serve the same purpose 
as the eight 16-bit registers in the LC-3.  However, the importance of 
temporary storage for values that most modern computers will need shortly 
means many computers today have an additional set of special purpose 
registers consisting of 128 bits of information to handle special needs.
Those special needs we will have to save for later in your studies. 

%4.1.3
\subsection{Input and Output}
In order for a computer to process information, the information
must get into the computer.  In order to use the results of that processing,
those results
must be displayed in some fashion outside the computer.  Many devices exist
for the purposes of input and output.  They are generically referred to in
computer jargon as {\em peripherals} because they are in some sense accessories
\index{peripherals}
to the processing function.  Nonetheless, they are no less important.
\index{I/O}

In the LC-3 we will have the two most basic input and output devices.  For
input, we will use the keyboard; for output, we will use the monitor.

There are, of course, many other input and output devices in computer
systems today. For input we have among other things the mouse,
digital scanners, and shopping mall kiosks to help you navigate the shopping
mall.  For output we have among other things printers, LED displays, disks, and
shopping mall kiosks to help you navigate the shopping mall. :-)  In the old 
days, a lot of input and output was carried out by punched cards. Fortunately, 
for those who would have to lug around boxes of cards, the use of punched 
cards has largely disappeared.

%4.1.4
\subsection{Control Unit}
The control unit is like the conductor of an orchestra; it is in
charge of making all the other parts of the computer play together.  
As we will see when we describe the step-by-step process of executing a
computer program, it is the control unit that keeps track of both where we
are within the process of executing the program and where we are in the
process of executing each instruction.

To keep track of which instruction is being executed, the control unit has
an {\em instruction register} to contain that instruction.  To keep track of
which instruction is to be processed next, the control unit has a register
that contains the next instruction's address.  For historical reasons, that
register is called the {\em program counter} (abbreviated PC), although a
better name for it would be the {\em instruction pointer}, since the contents
of this register are, in some sense, ``pointing'' to the next instruction to
be processed.  Curiously, Intel does in fact call that register the instruction
pointer, but the simple elegance of that name has not caught on.
\index{Instruction Register}
\index{Program Counter}
\index{Instruction Pointer}

\vspace{-6pt}

%4.2
\section{The LC-3: An Example von Neumann Machine}

In Chapter~5, we will specify in detail the LC-3, a simple
computer that we will study extensively.  We have already shown you its
data path in Chapter~3 (Figure~3.35) and identified several of its structures
in Section~4.1.  In this section, we will pull together all the parts of
the LC-3 we need to describe it as a von Neumann computer (see 
Figure~\ref{fig:lc3_vonneumann}).

%Figure 4.3
\begin{figure}
\centerline{\includegraphics{lc3_vonneumann.eps}}
\caption{The LC-3 as an example of the von Neumann model}
\label{fig:lc3_vonneumann}
\end{figure}

We constructed Figure~\ref{fig:lc3_vonneumann}
by starting with the LC-3's full data path (Figure~3.35) and removing
all elements that are not essential to pointing out the five basic components
of the von Neumann model.

Note that there are two kinds of arrowheads in Figure~\ref{fig:lc3_vonneumann}:
filled-in and not-filled-in.  Filled-in arrowheads denote data elements that
flow along the corresponding paths.  Not-filled-in arrowheads denote
control signals that control the processing of the data elements.  For
example, the box labeled ALU in the processing unit processes two
16-bit values and produces a 16-bit result.  The two sources and the
result are all data, and are designated by filled-in arrowheads.  The
operation performed on those two 16-bit data elements (it is labeled
ALUK) is part of the control---therefore, a not-filled-in arrowhead.

\begin{description}
\leftskip1.5pc
\item[MEMORY] consists of the storage elements, along with the Memory Address
Regiser (MAR) for addressing individual locations and the Memory Data Register
(MDR) for holding the contents of a memory
location on its way to/from the storage.  Note that the MAR contains 16~bits,
reflecting the fact that the memory address space of the LC-3 is $2^{16}$
memory locations.  The MDR contains 16 bits, reflecting the fact that each
memory location contains 16 bits---that is, that the LC-3 is 16-bit addressable.

\item[INPUT/OUTPUT] consists of a keyboard and a monitor.  The
  simplest keyboard requires two registers, a keyboard data register (KBDR) for
  holding the ASCII codes of keys struck, and a keyboard status register (KBSR)
  for maintaining status information about the keys struck.  The
  simplest monitor also requires two registers, a display data register (DDR) 
  for holding the ASCII code of something to be displayed on the screen, and 
  a display status register (DSR) for maintaining associated status information.
  These input and output registers will be discussed in detail in Chapter~9.

\item[THE PROCESSING UNIT]
consists of a functional unit (ALU) that performs arithmetic
and logic operations and eight registers (R0, $\ldots$ R7) for storing
temporary values that will be needed in the near future as operands for
\nobreak subsequent instructions.  The LC-3 ALU can perform one arithmetic 
operation (addition) and two logical operations (bitwise AND and bitwise 
NOT).

\item[THE CONTROL UNIT] consists of all the structures 
needed to\enlargethispage*{6pt}
  manage the processing that is carried out by the computer.  Its most
  important structure is the finite state machine, which directs all
  the activity.  Recall the finite state machines in Section~3.6.
  Processing is carried out step by step, or rather, clock cycle by
  clock cycle.  Note the CLK input to the finite state machine in
  Figure~\ref{fig:lc3_vonneumann}.
  It specifies how long each clock cycle lasts.  The
  instruction register (IR) is also an input to the finite state
  machine since the LC-3 instruction being processed determines
  what activities must be carried out.  The program counter (PC) is
  also a part of the control unit; it keeps track of the next
  instruction to be executed after the current instruction finishes.
\end{description}

Note that all the external outputs of the finite
state machine in Figure~4.3 have arrowheads that are not filled in.  These
outputs control the processing throughout the computer.  For example, one of
these outputs (two bits) is ALUK, which controls the operation performed in
the ALU (ADD, AND, or NOT) during the current clock cycle.  Another output is
GateALU, which determines whether or not the output of the ALU
is provided to the processor bus during the current clock cycle.

The complete description of the data path, control, and finite state machine
for one implementation of the LC-3 is the subject of Appendix C.

\vspace{-9pt}

%4.3
\section{Instruction Processing}
The central idea in the von Neumann model of computer processing is that 
the program and data are both stored as sequences of bits in the computer's 
memory, and the program is executed one instruction at a time under the 
direction of the control unit.

%4.3.1
\subsection{The Instruction}
The most basic unit of computer processing is the instruction.  It is
made up of two parts, the {\em opcode} (what the instruction does) and the
{\em operands} (who it does it to!).
\index{opcode}
\index{operand}

There are fundamentally three kinds of instructions: {\em operates}, 
{\em data movement}, and {\em control}, although many ISAs have some
special instructions that are necessary for those ISAs.
{\bf Operate} instructions operate on data.  The LC-3 has
three operate instructions: one arithmetic (ADD), and two logicals
(AND and NOT).  {\bf Data movement} instructions move information from
the processing unit to and from memory and to and from input/output devices.
The LC-3 has six data movement instructions.  

{\bf Control} instructions are necessary for altering the sequential 
processing of instructions. That is, normally the next instruction executed 
is the instruction contained in the next memory location.  If a program 
consists of instructions 1,2,3,4...10 located in memory locations A, A+1,
A+2, ...A+9, normally the instructions would be executed in the sequence
1,2,3...10.  We will see before we leave Chapter~4, however, that sometimes 
we will want to change the sequence.  Control instructions enable us to do 
that.

An LC-3 instruction consists of 16 bits (one word), numbered
from left to right, bit [15] to bit [0].  Bits [15:12] contain the opcode.
This means there are at most $2^4$ distinct opcodes.  Actually, we only use
15 of the possible 4-bit codes.  One is reserved for some future use.  
Bits [11:0] are used to figure out where the operands are.  

In this chapter we will introduce five of the LC-3's 15 instructions, two
operates (ADD and AND), one data movement (LD), and two control (BR and TRAP).
We will save for Chapters 5, 8, and 9 the other ten instructions. 

\medskip

%Example 4.1
\begingroup
\makeatletter
\renewenvironment{example}{%
  \refstepcounter{example}%
  \begin{colourframed}%
    \def\@mathmargin{\z@}
    \let\enumargs\exenumargs
    \vspace*{-2\p@}%
    \rlap{\hspace*{29pc}\hbox{\hspace*{-\fboxsep}%
      \setlength{\fboxsep}{\z@}%
      {\colorbox{SPOThundred}{\vbox to 13\p@{%
          \vss\hbox to 7pc{\hss
          \color{white}\sansbold\fontsize{10}{12}\selectfont
          Example~\theexample\hss}\vss}}}}}%
  \normalfont\fontsize{9.5}{11}\selectfont
  \rightskip7.5pc\advance\rightskip by \fboxsep
  \leftskip3\p@
  \parindent1.5pc\@afterheading\@afterindentfalse
  \vspace*{-14.5\p@}}%
{\par\unskip\removelastskip\offinterlineskip\vspace{4\p@}\end{colourframed}}
\makeatother
\begin{example}

{\sffamily\footnotesize\bfseries\fontsize{10}{12}\selectfont The ADD
Instruction\quad}The ADD instruction is an operate instruction that requires 
three operands: two source operands (the data that is
to be added) and one destination operand (where the sum is to be stored after
the addition is performed).  We said that the processing unit of the LC-3 
contained eight registers for purposes of storing data that may
be needed later.  In fact, the ADD instruction {\bf requires} that at least one
of the two source operands is
contained in one of these registers, and that the result of the ADD is put
into one of these eight
registers.  Since there are eight registers, three bits are necessary to
identify each register.
The 16-bit LC-3 ADD instruction has one of the following two forms 
(we say {\em formats}):\par
\noindent\hspace*{-9pt}\begin{minipage}{28pc}
\fontsize{9.5}{12}\selectfont
\begin{equation*}
\mbox{\renewcommand{\tabcolsep}{6pt}
\begin{tabular}
{cccccccccccccccc}
15 & 14 & 13 & 12 & 11 & 10 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\
\hline
\multicolumn{1}{|c}{\rule{0pt}{10pt}0\rule{0pt}{10pt}}&
\multicolumn{1}{c}{0}&
\multicolumn{1}{c}{0}&
\multicolumn{1}{c}{1}&
\multicolumn{1}{|c}{1}&
\multicolumn{1}{c}{1}&
\multicolumn{1}{c}{0}&
\multicolumn{1}{|c}{0}&
\multicolumn{1}{c}{1}&
\multicolumn{1}{c}{0}&
\multicolumn{1}{|c}{0}&
\multicolumn{1}{|c}{0}&
\multicolumn{1}{c}{0}&
\multicolumn{1}{|c}{1}&
\multicolumn{1}{c}{1}&
\multicolumn{1}{c|}{0}\\
\hline
\multicolumn{4}{c}{\rule{0pt}{10pt}ADD\rule{0pt}{10pt}} &
\multicolumn{3}{c}{R6} &
\multicolumn{3}{c}{R2} &
\multicolumn{3}{c}{} &
\multicolumn{3}{c}{R6} \\
\end{tabular}}
\end{equation*}
\vspace{-5pt}
\end{minipage}

\noindent\hspace*{-9pt}\begin{minipage}{28pc}
\fontsize{9.5}{12}\selectfont
\begin{equation*}
\mbox{\renewcommand{\tabcolsep}{6pt}
\begin{tabular}
{cccccccccccccccc}
15 & 14 & 13 & 12 & 11 & 10 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\
\hline
\multicolumn{1}{|c}{\rule{0pt}{10pt}0\rule{0pt}{10pt}}&
\multicolumn{1}{c}{0}&
\multicolumn{1}{c}{0}&
\multicolumn{1}{c}{1}&
\multicolumn{1}{|c}{1}&
\multicolumn{1}{c}{1}&
\multicolumn{1}{c}{0}&
\multicolumn{1}{|c}{0}&
\multicolumn{1}{c}{1}&
\multicolumn{1}{c}{0}&
\multicolumn{1}{|c}{1}&
\multicolumn{1}{|c}{0}&
\multicolumn{1}{c}{0}&
\multicolumn{1}{ c}{1}&
\multicolumn{1}{c}{1}&
\multicolumn{1}{c|}{0}\\
\hline
\multicolumn{4}{c}{\rule{0pt}{10pt}ADD\rule{0pt}{10pt}} &
\multicolumn{3}{c}{R6} &
\multicolumn{3}{c}{R2} &
\multicolumn{3}{c}{} &
\multicolumn{3}{c}{imm} \\
\end{tabular}}
\end{equation*}
\vspace{-5pt}
\end{minipage}

\pagebreak

\leftskip7.5pc\rightskip3pt
\noindent Both formats show the 4-bit opcode for ADD,
contained in bits [15:12]:  0001.  Bits [11:9]
identify the location to be used for storing
the result, in this case register 6 (R6).  Bits [8:6] identify the register 
that contains one of the two source operands, in this case R2.  The only 
difference in the two formats is the 1 or 0 stored in bit 5, and what that 
means.  In the first case, bit 5 is 0, signifying that the second source
operand is in the register specified by bits [2:0], in this case R6.  In the 
second case, bit 5 is 1, signifying that the second source operand is formed by
sign-extending the integer in bits [4:0] to 16 bits.  In this case, the 
second source operand is the positive integer 6.

Thus, the instruction we have just encoded is interpreted, depending on whether
bit 5 is a 0 or a 1 as either ``Add the contents of register 2 (R2) to the 
contents of register 6 (R6) and store the result back into register 6 (R6),''
or "Add the contents of register 2 (R2) to the positive integer 6 and store
the result into register 6.  We will use both formats in a program we
will write before we leave Chapter~4.
\end{example}
\endgroup
\pagebreak
%Example 4.2
\begin{example}{}

{\sffamily\footnotesize\bfseries\fontsize{10}{12}\selectfont The AND
Instruction\quad}The AND instruction is also an operate instruction, and it
behaves essentially identical to the ADD instruction, except for one thing.
Instead of ADDing the two source operands, the AND instruction performs a
bit-wise AND of the corresponding bits of the two source operands.  
For example, the instruction shown below \par
\noindent\hspace*{-9pt}\begin{minipage}{28pc}
\fontsize{9.5}{12}\selectfont
\begin{equation*}
\mbox{\renewcommand{\tabcolsep}{6pt}
\begin{tabular}
{cccccccccccccccc}
15 & 14 & 13 & 12 & 11 & 10 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\
\hline
\multicolumn{1}{|c}{\rule{0pt}{10pt}0\rule{0pt}{10pt}}&
\multicolumn{1}{c}{1}&
\multicolumn{1}{c}{0}&
\multicolumn{1}{c}{1}&
\multicolumn{1}{|c}{0}&
\multicolumn{1}{c}{1}&
\multicolumn{1}{c}{0}&
\multicolumn{1}{|c}{0}&
\multicolumn{1}{c}{1}&
\multicolumn{1}{c}{1}&
\multicolumn{1}{|c}{1}&
\multicolumn{1}{|c}{0}&
\multicolumn{1}{c}{0}&
\multicolumn{1}{ c}{0}&
\multicolumn{1}{c}{0}&
\multicolumn{1}{c|}{0}\\
\hline
\multicolumn{4}{c}{\rule{0pt}{10pt}AND\rule{0pt}{10pt}} &
\multicolumn{3}{c}{R2} &
\multicolumn{3}{c}{R3} &
\multicolumn{3}{c}{} &
\multicolumn{3}{c}{imm} \\
\end{tabular}}
\end{equation*}
\vspace{-5pt}
\end{minipage}

\leftskip7.5pc\rightskip3pt
\noindent is an AND instruction since bits [15:12] = 0101.  The two sources
are R3 and the immediate value 0.  The instruction loads R2 with the value 0
since the AND instruction performs a bit-wise AND where the bit of the second
operand is always 0.  As we shall see, this instruction is a convenient
technique for making sure a particular register contains 0 at the start of
processing.  We refer to this technique as {\em initializing} R2 to 0. 
\end{example}

%Example 4.3
\begin{example}{}

{\sffamily\footnotesize\bfseries\normalsize The LD
Instruction\quad}The LD instruction requires
two operands. {\em LD} stands for load,
which is computerese for ``go to a particular memory location, read the
value that is contained there, and store that value in one of the registers.''
The two operands that are required are the value to be read from memory
and the destination register which will contain that value after the 
instruction has completed processing.  There are many formulas that can be 
used for calculating the address of the memory location to be read.  Each 
formula is called an {\em addressing mode}.\index{addressing mode}
The particular addressing mode identified by the use of the opcode LD
is called {\bf PC$+$offset}.  We will see in Chapter~5 that there are other
addressing modes in the LC-3 ISA corresponding to other formulas for 
calculating the address of a memory location.

The 16-bit LC-3 LD instruction has the following format:
{\fontsize{9.5}{12}\selectfont

\begin{equation*}
\mbox{\renewcommand{\tabcolsep}{6pt}
\begin{tabular}
{cccccccccccccccc}
15 & 14 & 13 & 12 & 11 & 10 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\
\hline
\multicolumn{1}{|c}{\rule{0pt}{10pt}0\rule{0pt}{10pt}}&
\multicolumn{1}{c}{0}&
\multicolumn{1}{c}{1}&
\multicolumn{1}{c}{0}&
\multicolumn{1}{|c}{0}&
\multicolumn{1}{c}{1}&
\multicolumn{1}{c}{0}&
\multicolumn{1}{|c}{0}&
\multicolumn{1}{c}{1}&
\multicolumn{1}{c}{1}&
\multicolumn{1}{ c}{0}&
\multicolumn{1}{c}{0}&
\multicolumn{1}{c}{0}&
\multicolumn{1}{c}{1}&
\multicolumn{1}{c}{1}&
\multicolumn{1}{c|}{0}\\
\hline
\multicolumn{4}{c}{\rule{0pt}{10pt}LD\rule{0pt}{10pt}} &
\multicolumn{3}{c}{R2} &
\multicolumn{3}{c}{  } &
\multicolumn{6}{c}{198} \\
\end{tabular}}
\end{equation*}}

\noindent The four-bit opcode for LD is 0010.  Bits [11:9] identify the
register that will contain the value read from memory after the instruction
is executed.  Bits [8:0] are used to calculate the address of the location
to be read.  Since the addressing mode for LD is PC+offset, this
address is computed by sign-extending the 2's complement integer contained in 
bits [8:0] to 16 bits, and adding it to the current contents of the program
counter.  In summary, the instruction tells the computer to add 198 to the 
contents of the PC to form the address of a memory location, and to load the 
contents of that memory location into R2.

If bits [8:0] had been 111111001, the
instruction would have been interpreted: "Add $-7$ to the contents of the PC
to form the address of a memory location.
\end{example}

%4.3.2
\subsection{The Instruction Cycle (not the clock cycle!)}
Instructions are processed under the direction of the control
unit in a very systematic, step-by-step manner.
The entire sequence of steps needed to process an instruction is called 
the {\em instruction cycle}.
\index{instruction cycle}
The instruction cycle consists of six sequential {\em phases}, each phase 
requiring zero or more steps.  We say zero steps to indicate that 
most computers have been designed such that not all
instructions require all six phases.  We will discuss this momentarily.
\index{instruction cycle!phases of}
But first, we will examine the six phases of the instruction cycle:

\begin{colorverbatim}
      FETCH
      DECODE
      EVALUATE ADDRESS
      FETCH OPERANDS
      EXECUTE
      STORE RESULT
\end{colorverbatim}

The process is as follows (again refer to Figure~\ref{fig:lc3_vonneumann}, our 
simplified version of the LC-3 data path):

\subsubsection{FETCH}
The FETCH phase obtains the next instruction from memory and loads it into the
instruction register (IR) of the control unit.  Recall that a computer program
consists of a number of instructions, that each instruction is represented
by a sequence of bits, and that the
entire program (in the von Neumann model) is
stored in the computer's memory.  In order to carry out the work of an
instruction, we must first identify where it is.
The program counter (PC) contains
the address of the next instruction to be processed.
Thus, the FETCH phase takes the following steps:

\vspace{3pt}

\begin{verblist}
\item[] First the MAR is loaded with the contents of the PC.

\item[] Next, the memory is interrogated, which results
in the next instruction being placed by the memory
into the MDR.

\item[] Finally, the IR is loaded with the contents
of the MDR.
\end{verblist}

\vspace{3pt}

\noindent
We are now ready for the next phase, decoding the instruction.  However, when 
the instruction finishes execution, and we wish to fetch the next instruction, 
we would like the PC to contain the address of the next instruction.  
This is accomplished by having the FETCH phase perform one more task, it 
increments the PC.  In that way, after the current instruction finishes,
the FETCH phase of the next instruction will load into the IR the contents of 
the next memory location, provided the execution of the current instruction 
does not involve changing the value in the~PC.

The complete description of the FETCH phase is as follows:

\smallskip

\begin{altdesc}
\item[Step 1:] Load the MAR with the contents of the PC,
        and\break simultaneously increment the PC.

\item[Step 2:] Interrogate memory, resulting in
        the instruction\break being placed in the MDR.

\item[Step 3:] Load the IR with the contents of the MDR.

\end{altdesc}

\smallskip

\noindent
\looseness=1
Each of these steps is under the direction of the control unit, much like,
as we said previously, the instruments in an orchestra are under the control of
a conductor's baton.  Each stroke of the conductor's baton corresponds to
one {\em machine cycle}.  We will see in Section~4.3.5 that the amount of time
taken by each machine cycle is one clock cycle.  In fact, we often use the
two terms interchangeably.
Step 1 takes one clock cycle.  Step 2 could take
one clock cycle, or many clock cycles, depending on how long it takes to
access the computer's memory.  Step 3 takes one clock cycle.  In a modern
digital computer, a clock cycle takes a very small fraction of a second.

Indeed, a 3.1 GHz Intel Core i7 completes 3.1 billion clock cycles 
in one second.  Said another way, one clock cycle 
takes 0.322 billionths of a second (0.322
nanoseconds).  Recall that the light bulb that is helping you read this text
is switching on and off at the rate of 60 times a second.  Thus, in the time
it takes a light bulb to switch on and off once, today's computers can
complete more than 51 million clock cycles!

\subsubsection{DECODE}
The DECODE phase examines the instruction in order to figure out what
the microarchitecture is being asked to do.  Recall the decoders we
studied in Chapter~3.  In the LC-3, a 4-to-16 decoder identifies which
of the 16 opcodes is to be processed (even though one of the 16 is not 
used!).  Input is the four-bit opcode
IR[15:12].  The output line asserted is the one corresponding to the
opcode at the input.  Depending on which output of the decoder is
asserted, the remaining 12 bits identify what else is needed to
process that instruction.

\subsubsection{EVALUATE ADDRESS}
This phase computes the address of the memory location that is needed
to process the instruction.  Recall the example of the LD
instruction: The LD instruction causes a value stored in memory to be
loaded into a register.  In that example, the address was obtained by
sign-extending bits [8:0] of the instruction to 16 bits, and adding that
value to the current contents of the PC.  This calculation was
performed during the EVALUATE ADDRESS phase.  It is worth noting that not
all instructions access memory to load or store data.  For example, we have
already seen that the ADD and AND instructions in the LC-3 obtain their 
source operands
from registers or from the instruction itself, and store the result of the 
ADD or AND instruction in a register.  For those instructions, the 
EVALUATE ADDRESS phase is not needed.  

\subsubsection{FETCH OPERANDS}
This phase obtains the source operands needed to process the
instruction.  In the LD example, this phase took two steps: loading
MAR with the address calculated in the EVALUATE ADDRESS phase, and
reading memory, which resulted in the source operand being placed in
MDR.

In the ADD example, this phase consisted of obtaining the source
operands from R2 and R6. In most current microprocessors, this phase
(for the ADD instruction) can be done at the same time the instruction
is being executed (the 5th phase of the instruction cycle).  Exactly 
how we can speed up the processing of an
instruction in this way is a fascinating subject, but one we are
forced to leave for later in your education.

\subsubsection{EXECUTE}
This phase carries out the execution of the instruction.  In the ADD
example, this phase consisted of the step of performing the
addition in the ALU.

\subsubsection{STORE RESULT}
The final phase of an instruction's execution.  The result is written
to its designated destination.  In the case of the ADD instruction, in many 
computers this action is performed during the EXECUTE phase.  That is,
in many computers, including the LC-3, an ADD instruction can fetch its
source operands, perform the ADD in the ALU, and store the result in the
destination register all in a single clock cycle.  A separate STORE RESULT
phase is not needed.

\bigskip

Once the instruction cycle has been completed, the control unit begins the 
instruction cycle for the next instruction, starting from the top with the
FETCH phase.  Since the PC was updated during the previous instruction
cycle, it contains at this point the address of the instruction stored
in the next sequential memory location.  Thus the next sequential
instruction is fetched next. Processing continues in this way until
something breaks this sequential flow, or the program finishes execution.

It is worth noting again that although the instruction cycle consists of 
six phases, not all instructions require all six phases.  As already pointed 
out, the LC-3 ADD instruction does not require a separate EVALUATE ADDRESS
phase or a separate STORE RESULT phase.  The LC-3 LD instruction does not 
require an EXECUTE phase.  On the other hand, there are instructions in other
ISAs that require all six phases.

\bigskip

\begingroup
\makeatletter
\renewenvironment{example}{%
  \refstepcounter{example}%
  \begin{colourframed}%
    \def\@mathmargin{\z@}
    \let\enumargs\exenumargs
    \vspace*{-2\p@}%
    \rlap{\hspace*{29pc}\hbox{\hspace*{-\fboxsep}%
      \setlength{\fboxsep}{\z@}%
      {\colorbox{SPOThundred}{\vbox to 13\p@{%
          \vss\hbox to 7pc{\hss
          \color{white}\sansbold\fontsize{10}{12}\selectfont
          Example~\theexample\hss}\vss}}}}}%
  \normalfont\fontsize{9.5}{11}\selectfont
  \rightskip7.5pc\advance\rightskip by \fboxsep
  \leftskip3\p@
  \parindent1.5pc\@afterheading\@afterindentfalse
  \vspace*{-14.5\p@}}%
{\par\unskip\removelastskip\offinterlineskip\vspace{4\p@}\end{colourframed}}
\makeatother

%Example 4.4

\begin{example}
  {\sffamily\footnotesize\bfseries\normalsize ADD [eax], edx\quad}This is
    an example of an Intel x86 instruction that requires all six
    phases of the instruction cycle.  All instructions require the
    first two phases, FETCH and DECODE.  This instruction uses the eax
    register to calculate the address of a memory location (EVALUATE
    ADDRESS).  The contents of that memory location are then read
    (FETCH OPERAND), added to the contents of the edx register
    (EXECUTE), and the result written into the memory location that
    originally contained the first source operand (STORE RESULT).
\end{example}
\endgroup

\vspace{-12pt}

%4.3.3
\subsection{Changing the Sequence of Execution}
Everything we have said thus far happens when a computer program is executed 
in sequence.  That is, the first instruction is executed, then the second 
instruction is executed, followed by the third instruction, and so on.

We have identified two types of instructions, the ADD and AND, which are
examples of {\em operate instructions} in that they operate on data, and
the LD, which is an example of a {\em data movement instruction} in that 
it moves data from one place to another.
There are other examples of both operate instructions and data movement 
instructions, as we will discover in Chapter~5 when we study the LC-3 in 
greater detail.
\index{operate instructions}
\index{data movement instructions}

There is a third type of instruction, the {\em control instruction}, whose
purpose is to change \index{control instructions} the sequence of instruction
execution.  For example, there are times, as we shall see very soon, when it 
is desirable
to first execute the first instruction, then the second, then the third, then
the first again, the second again, then the third again, then the first for
the third time, the second for the third time, and so on.  As we
know, each instruction cycle starts with loading the MAR with the PC.  Thus, if we wish to change
the sequence of instructions executed, we must change the contents of the PC 
between the time
it is incremented (during the FETCH phase of one instruction) and the start of
the FETCH phase of the next instruction.

Control instructions perform that function by loading the PC during the
\nobreak EXECUTE phase, which wipes out the incremented
PC that was loaded during the FETCH phase.  The result is that, at the start
of the next instruction cycle, when
the computer accesses the PC to obtain the address of an instruction to fetch,
it will get the address loaded during the previous instruction's EXECUTE phase,
rather than the next sequential instruction in the computer's program.

The most common control instruction is the {\em conditional branch} 
(BR), which either changes the contents of the PC or does not
change the contents of the PC, depending on the result of a previous
instruction (usually the instruction that is executed immediately before 
the conditional branch instruction).
\bigskip

%Example 4.5
\begin{example}
{\sffamily\footnotesize\bfseries\normalsize The BR Instruction\quad}
The BR instruction consists of three parts, the opcode (bits [15:12] = 0000),
the condition to be tested (bits [11:9]), and the addressing mode bits
(bits [8:0]) which are used to form the address to be loaded into the PC
if the result of the previous instruction agrees with the test specified by
bits [11:9].  The addressing mode, i.e., the mechanism used to determine the
actual address is the same one we used in the LD instruction.  Bits [8:0]
are sign-extended to 16 bits and then added to the current contents of the PC.

Suppose the BR instruction shown below is located in memory location x36C9.
\par\noindent
\hspace*{-6.5pc}\begin{minipage}{28pc}
\begin{equation*}
\mbox{\renewcommand{\tabcolsep}{6pt}
\begin{tabular}
{cccccccccccccccc}
15 & 14 & 13 & 12 & 11 & 10 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\
\hline
\multicolumn{1}{|c}{0}&
\multicolumn{1}{c}{0}&
\multicolumn{1}{c}{0}&
\multicolumn{1}{c}{0}&
\multicolumn{1}{|c}{1}&
\multicolumn{1}{ c}{0}&
\multicolumn{1}{c}{1}&
\multicolumn{1}{|c}{1}&
\multicolumn{1}{c}{1}&
\multicolumn{1}{c}{1}&
\multicolumn{1}{ c}{1}&
\multicolumn{1}{c}{1}&
\multicolumn{1}{c}{1}&
\multicolumn{1}{c}{0}&
\multicolumn{1}{c}{1}&
\multicolumn{1}{c|}{0}\\
\hline
\multicolumn{4}{c}{BR} &
\multicolumn{3}{c}{condition} &
\multicolumn{3}{c}{  } &
\multicolumn{6}{c}{-6} \\
\end{tabular}}
\end{equation*}
\end{minipage}


\noindent The opcode 0000 identifies the instruction as a conditional branch.
Bits [11:9] = 101 specifies that the test to be performed on the most recent 
result is whether or not that result is something other than 0.  
In Chapter~5 we will describe in detail all the tests that can be performed 
on the most recent result.  For now, we will just use one test: Is the result 
not zero?  Bits [8:0] is the value -6.

Assume the previous instruction executed (in memory location
x36C8) was an ADD instruction and the result of the ADD was 0.  Since the
test "not-zero" failed, the BR instruction would do nothing during its
EXECUTE phase, and so the next instruction executed would be the instruction
at M[x36CA], the address formed by incrementing the PC during the FETCH phase
of the BR instruction's instruction cycle.  

On the other hand, if the result of the ADD instruction is not 0, then the
test succeeds, causing the BR instruction to load PC with x36C4, the address 
formed by sign-extending bits [8:0] to 16 bits and adding that value (-6) 
to the incremented PC (x36CA).

Thus the next instruction executed after the BR instruction at x36C9 is either
the instruction at x36CA or the one at x36C4, depending on whether the result
of the ADD instruction was zero or not zero.
\end{example}

\subsection{Control of the Instruction Cycle} 

The instruction cycle is controlled by a synchronous finite state machine.
An abbreviated version of its state diagram, highlighting a few
of the LC-3 instructions discussed in this chapter is shown in
Figure~\ref{fig:abbreviated_state}. 
As is the case with the finite state machines studied in Section~3.6,
each state corresponds to one machine cycle of activity which takes one
clock cycle to perform.  The processing
controlled by each state is described within the node representing that
state. The arcs show the next state transitions.

Processing starts with state 1.  The FETCH phase takes three clock cycles,
corresponding to the three steps described earlier.
In the first clock cycle, the MAR is loaded with the contents of the PC,
and the PC is incremented.  In order for the contents of the PC to be
loaded into the MAR (see Figure~\ref{fig:lc3_vonneumann}), the finite state 
machine must assert GatePC and LD.MAR.  GatePC connects the PC to the
processor bus.  LD.MAR, the write enable signal of the MAR register,
loads the contents of the bus into the MAR at the end of the current clock
cycle.  (Registers are loaded at the end of the clock cycle if the corresponding
control signal is asserted.)

%Figure~4.4
\begin{figure}[b]
\centerline{\includegraphics{abbreviated_state.eps}}
\caption{An abbreviated state diagram of the LC-3}
\label{fig:abbreviated_state}
\vspace{-12pt}
\end{figure}

In order for the PC to be incremented (again, see 
Figure~\ref{fig:lc3_vonneumann}), the finite state machine must assert the 
PCMUX select lines to choose the output of the
box labeled $+1$ and must also assert the LD.PC signal
to load the output of the PCMUX into the PC at the end of the current cycle.

The finite state machine then goes to state 2.  Here, the MDR is loaded with
the instruction, which is read from memory.

In state 3, the instruction is transferred from the MDR to the instruction
register (IR).  This requires the finite state machine to assert GateMDR and
LD.IR, which causes the IR to be loaded at the end of the clock cycle,
concluding the FETCH phase of the instruction cycle.

The DECODE phase takes one clock cycle.  In state 4, using the external 
input IR,
and in particular the opcode bits of the instruction, the finite state machine
can go to the appropriate next state for processing instructions depending on
the particular opcode in IR[15:12].  Three of the 15 paths out of State 4 are
shown.  Processing continues clock cycle by clock cycle until the instruction
completes execution, and the next state logic returns the finite state machine
to state 1.

As has already been discussed, it is sometimes necessary not to execute the 
next sequential instruction but rather to access another location to find the
next instruction to execute.  As we have said, instructions that change the
flow of instruction processing in this way are called control instructions.  
In the case of the conditional branch instruction (BR), at the end of its
instruction cycle, the PC contains one of two addresses: Either the incremented
PC which was loaded in State 1 or the new address computed from sign-extending 
bits [8:0] of the BR instruction and adding it to the PC, which was loaded in
State 63.  Which address gets loaded into the PC depends on the test of the
most recent result. 

Appendix C contains a full description of the implementation of the LC-3,
including its full state diagram and data path.  We will not go into that
level of detail in this chapter.  Our objective here is to show you that
there is nothing magic about the processing of the instruction cycle, and that
a properly completed state diagram would be able to control, clock cycle by
clock cycle, all the steps required to execute all the phases of every
instruction cycle.  Since each instruction cycle ends by returning to state 1,
the finite state machine can process, clock cycle by clock cycle, a complete 
computer program.

\FloatBarrier
%4.3.4
\vspace{-12pt}
\subsection{Halting the Computer (the TRAP instruction)}
From everything we have said, it appears that the computer will
continue \nobreak processing
instructions, carrying out the instruction cycle again and again, {\em
  ad~\nobreak nauseum}.  Since the
computer does not have the capacity to be bored, must this continue until 
someone pulls the plug and disconnects power to the computer?

Usually, user programs execute under the control of an operating system.  
Linux, DOS, MacOS, and Windows are all examples of operating systems.  
Operating systems are just computer programs themselves.  As far as the 
computer is concerned, the instruction cycle continues whether a user program 
is being processed or the
operating system is being processed.  This is fine as far as user
programs are concerned since each user program terminates with a control instruction that
changes the PC to again start processing the operating system---often 
to initiate the execution of another user program.


%Figure 4.5
\begin{figure}[b]
\centerline{\includegraphics[scale=.92]{clockcircuit.eps}}
\caption{The clock circuit and its control}
\label{fig:clock}
\end{figure}

\enlargethispage{6pt}

But what if we actually want to stop this potentially infinite
sequence of instruction cycles?  Recall our analogy to the conductor's
baton, beating at the rate of billions of clock cycles per second.
Stopping the instruction sequencing requires stopping the conductor's
baton.  We have pointed out many times that there is inside the
computer a component that corresponds very closely to the conductor's
baton.  It is called the {\bf clock}, and it defines the amount of time 
each machine cycle takes.  We saw in Chapter~3 that the clock enables 
the synchronous  finite state machine to continue on to the next
clock cycle.  In Chapter~3 the next clock cycle corresponded to the 
next state of the danger sign we designed.  Here the next clock cycle 
corresponds to the next state of the instruction cycle which is  either the 
next state of the current phase of the instruction cycle, or the first state of the next phase of the instruction cycle.  Stopping the instruction cycle requires stopping the clock.

%Figure~4.5 describes the behavior of the clock.

Figure~\ref{fig:clock}a shows a block diagram of the clock circuit, 
consisting primarily
of a clock generator and a RUN latch.  The clock generator is a crystal
\index{run latch}
oscillator, a~piezoelectric device that you may have studied in your physics
or chemistry class.  For our purposes, the crystal oscillator is a black box
(recall our definition of black box in Section~1.4) that produces the
oscillating voltage shown in Figure~\ref{fig:clock}b.  Note the resemblance 
of that voltage to the conductor's baton.  Every clock cycle, the voltage 
rises to 1.2 volts and then drops back to 0 volts.

If the RUN latch is in the 1 state (i.e., $Q=1$), the output of the clock
circuit is the same as the output of the clock generator.  If the RUN latch
is in the 0 state (i.e., $Q=0$), the output of the clock circuit is 0.

Thus, stopping the instruction cycle requires only clearing the RUN latch.
Every computer has some mechanism for doing that.
In some older machines, it is done by executing a HALT instruction.
In the LC-3, as in many other machines, it is done under control of the
operating system, as we will see in Chapter~9.  For now it is enough to know
that if a user program requires help from the operating system, it requests that
help with the TRAP instruction (opcode = 1111) and an 8-bit code called
a {\em trap vector} which identifies the help that the user program needs.  
The 8-bit code x25 tells the operating
system that the program has finished executing and the computer can stop
processing instructions.


{\em Question:} If a HALT instruction can clear the RUN latch,
thereby stopping the instruction cycle, what instruction is needed
to set the RUN latch, thereby reinitiating\questionmark[-3.6pc]
the instruction cycle?  Hint: This is a trick question!

\vspace{-30pt}

%4.5
\section{Our first program: A multiplication algorithm}

We now have all that we need to write our first program.  We have a data
movement instruction LD to load data from memory into a register, we have two
operate instructions, ADD for performing arithmetic and AND for performing 
a bit-wise logical operation.  We have a control instruction BR for loading the
PC with an address different from the incremented PC so the instruction to be
executed next will NOT be the instruction in the next sequential location in 
memory.  And we have the TRAP instruction (aka system call) which allows us 
to ask the operating system for help, in this case to stop the computer.  
With all that under our belt, we can write our first program.

Suppose the computer does not know how to multiply two positive integers.
In the old days, that was true for a lot of computers!  They had ADD 
instructions, but they did not have multiply instructions.  What to do?
Suppose we wanted to multiply 5 times 4.  Even if we do not know how to
multiply, if we know that 5 times 4 is 5+5+5+5, and the computer has an ADD
instruction, we can write a program that can multiply.  All we have to do 
is add 5 to itself four times.  

Figure~\ref{fig:MUL1_flow} illustrates the process.

%Figure 4.6
\begin{figure}
\centerline{\includegraphics[scale=.92]{MUL1_flowchart.eps}}
\caption{Flowchart for an algorithm that multiplies two positive integers}
\label{fig:MUL1_flow}
\end{figure}

Let us assume that memory location x3007, abbreviated M[x3007], contains 
the value 5, and M[x3008] contains the
value 4.  We start by copying the two values from memory to the two registers 
R1 and R2.  We are going to accumulate the results of the additions in R3 so 
we initialize R3 to 0.  Then we add 5 to R3, and subtract 1 from R2 so we will 
know how many more times we will need to add 5 to R3.  We keep doing this 
(adding 5 to R3 and subtracting 1 from R2) until R2 contains the value 0.  
That tells us that we have added 5 to R3 four times and we are done, so we HALT
the computer.  R3 contains the value 20, the result of our multiplication.

Figure~\ref{fig:firstMUL_code} shows the actual LC-3 program, stored in
memory locations x3000 to x3008.  

The Program Counter, which keeps track of the next instruction to be executed,
initially contains the address x3000.

To move the data from memory locations M[x3007] and M[x3008] to R1 and R2, 
we use the data
movement instruction LD.  The LC-3 computer executes the LD instruction in
M[x3000] by sign-extending the offset (in this case 6) to 16 bits, adding it 
to the incremented PC (in this case x3001 since we incremented the PC during
the FETCH phase of this instruction), fetching the data from M[x3007], 
and loading it in R1.  The LD instruction in M[x3001] is executed in the same
way.

R3 is initialized to 0 by performing a bit-wise AND of the contents of R3 with
the sign-extended immediate value 0, and loading the result into R3.

Next the computer executes the ADD instructions at M[x3003] and M[x3004].
The ADD instruction at M[x3003] adds the contents of R1 to the contents of R3,
and loads the result into R3.  The ADD instruction at M[x3004] adds $-1$
to the contents of R2, which keeps track of how many times the value 5 has 
been added to R3.  

At this point, the PC contains the address x3005.  The BR instruction in 
M[x3005] loads the PC with the address x3003 if the result of the previous
instruction (the one in M[x3004]) is not 0.  If the result of the previous
instruction is 0, the BR instruction does nothing and so the next instruction
to be executed is the instruction at M[x3006], i.e., the incremented PC is
x3006.

Thus the two ADD instructions execute again and again, until the result of 
executing the instruction in M[x3004] produces the value 0, indicating that
the value 5 has been added four times.  Finally, the
TRAP instruction in M[x3006] is executed, which is a call to the operating
system to halt the computer.

%Figure 4.7
\begin{figure}
\hspace*{-8pc}\begin{minipage}{36pc}
\centerline
{$\mbox{\renewcommand{\tabcolsep}{4pt}
\begin{tabular}{@{}cccccccccccccccccr}
Address & 15 & 14 & 13 & 12 & 11 & 10 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & \\
\cline{2-17}
\multicolumn{1}{c}{x3000}&\multicolumn{1}{|c}{0} &
\multicolumn{1}{ c}{0} &\multicolumn{1}{ c}{1} &
\multicolumn{1}{ c}{0} &\multicolumn{1}{|c}{0} &
\multicolumn{1}{ c}{0} &\multicolumn{1}{ c}{1} &
\multicolumn{1}{|c}{0} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{ c}{0} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{ c}{0} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{ c}{1} &\multicolumn{1}{ c}{1} &
\multicolumn{1}{c|}{0} &\multicolumn{1}{l}{\tt\bfseries R1 <- M[x3007]} \\
\cline{2-17}
\multicolumn{1}{c}{x3001}&\multicolumn{1}{|c}{0} &
\multicolumn{1}{ c}{0} &\multicolumn{1}{ c}{1} &
\multicolumn{1}{ c}{0} &\multicolumn{1}{|c}{0} &
\multicolumn{1}{ c}{1} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{|c}{0} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{ c}{0} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{ c}{0} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{ c}{1} &\multicolumn{1}{ c}{1} &
\multicolumn{1}{c|}{0} &\multicolumn{1}{ l}{\tt\bfseries R2 <- M[x3008]} \\
\cline{2-17}
\multicolumn{1}{c}{x3002}&\multicolumn{1}{|c}{0} &
\multicolumn{1}{ c}{1} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{ c}{1} &\multicolumn{1}{|c}{0} &
\multicolumn{1}{ c}{1} &\multicolumn{1}{ c}{1} &
\multicolumn{1}{|c}{0} &\multicolumn{1}{ c}{1} &
\multicolumn{1}{ c}{1} &\multicolumn{1}{|c}{1} &
\multicolumn{1}{|c}{0} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{ c}{0} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{c|}{0} &\multicolumn{1}{ l}{\tt\bfseries R3 <- 0 } \\
\cline{2-17}
\multicolumn{1}{c}{x3003}&\multicolumn{1}{|c}{0} &
\multicolumn{1}{ c}{0} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{ c}{1} &\multicolumn{1}{|c}{0} &
\multicolumn{1}{ c}{1} &\multicolumn{1}{ c}{1} &
\multicolumn{1}{|c}{0} &\multicolumn{1}{ c}{1} &
\multicolumn{1}{ c}{1} &\multicolumn{1}{|c}{0} &
\multicolumn{1}{|c}{0} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{|c}{0} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{c|}{1} &\multicolumn{1}{ l}{\tt\bfseries R3 <- R3+R1} \\
\cline{2-17}
\multicolumn{1}{c}{x3004}&\multicolumn{1}{|c}{0} &
\multicolumn{1}{ c}{0} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{ c}{1} &\multicolumn{1}{|c}{0} &
\multicolumn{1}{ c}{1} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{|c}{0} &\multicolumn{1}{ c}{1} &
\multicolumn{1}{ c}{0} &\multicolumn{1}{|c}{1} &
\multicolumn{1}{|c}{1} &\multicolumn{1}{ c}{1} &
\multicolumn{1}{ c}{1} &\multicolumn{1}{ c}{1} &
\multicolumn{1}{c|}{1} &\multicolumn{1}{ l}{\tt\bfseries R2 <- R2-1 } \\
\cline{2-17}
\multicolumn{1}{c}{x3005}&\multicolumn{1}{|c}{0} &
\multicolumn{1}{ c}{0} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{ c}{0} &\multicolumn{1}{|c}{1} &
\multicolumn{1}{ c}{0} &\multicolumn{1}{ c}{1} &
\multicolumn{1}{|c}{1} &\multicolumn{1}{ c}{1} &
\multicolumn{1}{ c}{1} &\multicolumn{1}{ c}{1} &
\multicolumn{1}{ c}{1} &\multicolumn{1}{ c}{1} &
\multicolumn{1}{ c}{1} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{c|}{1} &\multicolumn{1}{ l}{\tt\bfseries BR not-zero M[x3003]} \\
\cline{2-17}
\multicolumn{1}{c}{x3006}&\multicolumn{1}{|c}{1} &
\multicolumn{1}{ c}{1} &\multicolumn{1}{ c}{1} &
\multicolumn{1}{ c}{1} &\multicolumn{1}{|c}{0} &
\multicolumn{1}{ c}{0} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{ c}{0} &\multicolumn{1}{|c}{0} &
\multicolumn{1}{ c}{0} &\multicolumn{1}{ c}{1} &
\multicolumn{1}{ c}{0} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{ c}{1} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{c|}{1} &\multicolumn{1}{l}{\tt\bfseries HALT} \\
\cline{2-17}
\multicolumn{1}{c}{x3007}&\multicolumn{1}{|c}{0} &
\multicolumn{1}{ c}{0} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{ c}{0} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{ c}{0} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{ c}{0} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{ c}{0} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{ c}{0} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{ c}{1} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{c|}{1} &\multicolumn{1}{l}{\tt\bfseries The value 5} \\
\cline{2-17}
\multicolumn{1}{c}{x3008}&\multicolumn{1}{|c}{0} &
\multicolumn{1}{ c}{0} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{ c}{0} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{ c}{0} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{ c}{0} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{ c}{0} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{ c}{0} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{ c}{1} &\multicolumn{1}{ c}{0} &
\multicolumn{1}{c|}{0} &\multicolumn{1}{ l}{\tt\bfseries The value 4} \\
\cline{2-17}
\end{tabular}}
$}
\vspace{6pt}
\caption{A program that multiplies without a multiply instruction
\label{fig:firstMUL_code}}
\end{minipage}
\end{figure}

\FloatBarrier

\begin{exercises}

\vspace{-6pt}

\item[4.1] Name the five components of the von Neumann model. For each component, state
its purpose.

\item[4.2] Briefly describe the interface between the memory and the processing unit.
That is, describe the method by which the memory and the processing unit
communicate.

\item[4.3] What is misleading about the name {\em program counter}? Why is the name
{\em instruction pointer} more insightful?

\item[4.4] What is the word length of a computer? How does the word
  length of a computer affect what the computer is able to compute?
  That is, is it a valid argument, in light of what you learned in
  Chapter~1, to say that~a computer with a larger word size can
  process more information and therefore is capable of computing more
  than a computer with a smaller word size?

\item[4.5] The following table represents a small memory. Refer to
  this table for the following questions.

\begin{inlinetable}
\begin{tabular}{cc}\hline
\rule{0pt}{10pt} {Address}\rule{0pt}{10pt} & {Data} \\ \hline
            \rule{0pt}{10pt}0000\rule{0pt}{10pt} &  0001 1110 0100 0011 \\[3pt]
            0001 &  1111 0000 0010 0101 \\[3pt]
            0010 &  0110 1111 0000 0001 \\[3pt]
            0011 &  0000 0000 0000 0000 \\[3pt]
            0100 &  0000 0000 0110 0101 \\[3pt]
            0101 &  0000 0000 0000 0110 \\[3pt]
            0110 &  1111 1110 1101 0011 \\[3pt]
         \rule{0pt}{10pt}  0111\rule{0pt}{10pt} &  0000 0110 1101 1001
            \\\hline
\end{tabular}
\end{inlinetable}\pagebreak

\begin{enumerate}
       \item[a.] What binary value does
        location 3 contain?  Location 6?

\item[b.] The binary value within each location can be
        interpreted in many ways. We have seen that binary
        values can represent unsigned numbers, 2's complement
        signed numbers, floating point numbers, and so forth.

\begin{enumerate}[(3)]
\item[\rm(1)] Interpret location 0 and location 1 as 2's complement integers.

\item[\rm(2)] Interpret location 4 as an ASCII value.

\item[\rm(3)] Interpret locations 6 and 7 as an IEEE floating point number.
Location 6 contains number [15:0]. Location 7 contains number [31:16].

\item[\rm(4)] Interpret location 0 and location 1 as unsigned integers.
\end{enumerate}

\item[c.] In the von Neumann model, the contents of a memory location
  can also be an instruction.  If the binary pattern in location 0
  were interpreted as an instruction, what instruction would it
  represent?

\item[d.]  A binary value can also be interpreted as a memory address.
  Say the value stored in location 5 is a memory address.  To which
  location does it refer?  What binary value does that location
  contain?
\end{enumerate}

\item[4.6]
What are the two components of an instruction? What information do~these
two components contain?

\item[4.7]
Suppose a 32-bit instruction takes the following format:

\begin{center}
\begin{tabular}{|c|c|c|c|} \hline
\rule{0pt}{10pt}OPCODE\rule{0pt}{10pt} & SR & DR & IMM \\ \hline
\end{tabular}
\end{center}

\noindent If there are 60 opcodes and 32 registers, what is the range of
values that can be represented by the immediate (IMM)? Assume
IMM is a~2's complement value.

\item[4.8] Suppose a 32-bit instruction takes the following format:

\begin{center}
\begin{tabular}{|c|c|c|c|c|} \hline
\rule{0pt}{10pt}OPCODE\rule{0pt}{10pt} & DR & SR1 & SR2 & UNUSED\\ \hline
\end{tabular}
\end{center}

\noindent If there are 225 opcodes and 120 registers,
\begin{enumerate}
\item[a.] What is the minimum number of bits required to represent the OPCODE?
\item[b.] What is the minimum number of bits required to represent the Destination Register (DR)?
\item[c.] What is maximum number of UNUSED bits in the instruction encoding?
\end{enumerate}

\item[4.9]
The FETCH phase of the instruction cycle does two important things. One is
that it loads the instruction to be processed next into the IR. What is
the other important thing?

\enlargethispage{-\baselineskip}

\item[4.10] Examples~4.1, 4.2, and 4.5 illustrate the processing of
  the ADD, LDR, and JMP instructions. The PC, IR, MAR, and MDR are
  written in various phases of the instruction cycle, depending on the
  opcode of the particular instruction. In each location in the table
  below, enter the opcodes\vadjust{\pagebreak}
  which write to the corresponding register
  (row) during the corresponding phase (column) of the instruction
  cycle.

\medskip
\vspace{6pt}

{\fontsize{9}{13}\selectfont
\noindent\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
& Fetch  &  & Evaluate & Fetch & & Store\\[-2pt]
&Instruction & Decode &Address & Data
& Execute &Result\\
\hline
\rule{0pt}{10pt}PC\rule{0pt}{10pt} & & & & & &\\
\hline
\rule{0pt}{10pt}IR\rule{0pt}{10pt} & & & & & &\\
\hline
\rule{0pt}{10pt}MAR\rule{0pt}{10pt} & & & & & &\\
\hline
\rule{0pt}{10pt}MDR\rule{0pt}{10pt} & & & & & &\\
\hline
\end{tabular}}

\vspace{12pt}
\medskip

\item[4.11]
State the phases of the instruction cycle and briefly describe what operations
occur in each phase.

\item[4.12]
For the instructions ADD, LDR, and JMP, write the operations that occur in each
phase of the instruction cycle.

\item[4.13]
Say it takes 100 cycles
to read from or write to memory and only one cycle to read from or write to
a register. Calculate the number of cycles it~takes for each phase of the
instruction cycle for both the IA-32 instruction ``ADD [eax], edx''
(refer to Example~4.3) and the LC-3 instruction ``ADD R6, R2, R6.''
Assume each phase (if required) takes one cycle,  unless a memory access
is required.

\item[4.14]
Describe the execution of the JMP instruction
if R3 contains x369C (refer to Example~4.5).

\item[4.15]
If a HALT instruction can clear the RUN latch, thereby stopping the instruction
cycle, what instruction is needed to set the RUN latch, thereby reinitiating
the instruction cycle?

\item[4.16]
\begin{enumerate}
\item[a.] If a machine cycle is 2 nanoseconds (i.e., $2\cdot 10^{-9}$
  seconds), how many machine cycles occur each second?

\item[b.] If the computer requires on the average eight cycles to
  process each instruction, and the computer processes instructions
  one at~a~time from beginning to end, how many instructions can the
  computer process in 1 second?

\enlargethispage{-\baselineskip}

\item[c.] Preview of future courses: In today's microprocessors, many
  features are added to increase the number of instructions processed
  each second.  One such feature is the computer's equivalent of an
  assembly line. Each phase of the instruction cycle is implemented as
  one or more separate pieces of logic.  Each step in the processing
  of an instruction picks up where the previous step left off in the
  previous machine cycle.  Using this feature, an instruction can be
  fetched\break
  from memory every machine cycle and handed off at the end of
  the machine cycle to the decoder, which performs the decoding
  function during the next machine cycle while the next instruction is
  being fetched.  Ergo, the assembly line.  Assuming instructions are
  located   at\break sequential addresses in memory, and nothing breaks the
  sequential flow, how many instructions can the microprocessor
  execute each second if the assembly line is present?  (The assembly
  line is called a pipeline, which you will encounter in your advanced
  courses.  There are many reasons why the assembly line cannot
  operate at its maximum rate, a topic you will consider at length in
  some of\break these courses.)
\end{enumerate}


\item[4.17]STAR In this problem we perform five successive accesses to memory.  The table below shows for each access whether it is a read (Load) or write (Store), and the contents of the MAR and MDR at the completion of the access.  Some entries are not shown.  Note that we have shortened the addressibility to
5 bits, rather than the 16 bits that we are used to in the LC-3 in order
to decrease the excess writing you would have to do.\\

\begin{center}
%\begin{tabular}[t]{c|c|C{2cm}|C{1cm}|C{1cm}|C{1cm}|C{1cm}|C{1cm}|}

\begin{tabular}[t]{c|c|c|c|c|c|c|c|}
\multicolumn{1}{c}{} & \multicolumn{7}{c}{Operations on Memory} \\
\cline{2-8}
\multicolumn{1}{c|}{} & R/W & MAR & \multicolumn{5}{c|}{MDR} \\
\cline{2-8}
Operation 1 & W &  & 1 & 1 & 1 & 1 & 0 \\
\cline{2-8}
\cline{2-8}
Operation 2 &   & &   &   &   &   &   \\
\cline{2-8}
Operation 3 & W & & 1 & 0 & & & \\
\cline{2-8}
Operation 4 & & & & & & & \\
\cline{2-8}
Operation 5 & & & & & & & \\
\cline{2-8}
\end{tabular}
\end{center}

\vspace{0.3in}

\noindent
The three tables below show the contents of memory locations x4000 to x4004
before the first access, after the third access, and after the fifth access.
Again, not all entries are shown. We have added an unusual constraint to this problem in order to get one correct answer.  The MDR can ONLY be loaded from memory as a result of a Load
(Read) access.\\

\begin{center}
\hspace{2.0in}
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{417_memory_states.eps}
\end{figure}
\end{center}

\noindent
Your job: Fill in the missing entries.\\

\noindent

\noindent
Hint: As you know, writes to memory require MAR to be loaded with the memory
address, and MDR to loaded with the data to be written (stored).  The data in
the MDR must come from a previous read (Load).\\

\newpage
\item[4.18]STAR The $2^{2}$ by 3 bit memory discussed in class is accessed during five consecutive clock cycles.  The table below shows the values of the
2-bit Address, 1-bit Write Enable, and 3-bit Data-In signals during
each access.

\vspace{0.1in}
\begin{center}
\begin{tabular}{c|c|c|c}
    & A[1:0] & WE & D$_{in}$[2:0] \\
    \hline
    cycle 1 & 0 1 & 1 & 1 0 1\\
    cycle 2 & 1 1 & 0 & 1 1 0\\
    cycle 3 & 1 0 & 1 & 0 1 0\\
    cycle 4 & 0 1 & 1 & 0 1 1\\
    cycle 5 & 0 0 & 0 & 0 0 0\\
\end{tabular}
\end{center}

\vspace{0.1in}
\noindent Your job: Fill in the value stored in each memory cell and the three
Data-Out lines just before the end of the $5^{th}$ cycle.  Assume initially
that all 12 memory cells store the value 1.  In the figure below,
each question mark (?) indicates a value that you need to fill in.

\vspace{0.1in}
\begin{figure}[h]
\centering
\includegraphics[scale=0.75]{418_new_mem.eps}
\end{figure}

\newpage
\item[4.19]STAR Shown below is a byte-addressible memory consisting of 8 locations, and its associated MAR and MDR. Both MAR and MDR consist of flip flops which are latched at the start of each clock cycle based on the values on their corresponding input lines.  A memory read is initiated every cycle and the data is available by the end of
that cycle.
\begin{figure}[h]
\centering
\includegraphics[width=9.0cm]{419.eps}
\end{figure}

%at the point shown on the clock diagram, and the
%data D[7:0] are available as outputs of memory at the point shown.\\

\noindent Just before the start of cycle 1, MAR contains 000, MDR contains 00010101,
and the contents of each memory location is as shown.
%\vspace{-0.2in}

\begin{table}[!h]
\begin{center}
\begin{tabular}{|c|c|}
\hline
{\bf Memory Location} & {\bf Value} \\
\hline
x0 & 01010000 \\
\hline
x1 & 11110001 \\
\hline
x2 & 10000011 \\
\hline
x3 & 00010101 \\
\hline
x4 & 11000110 \\
\hline
x5 & 10101011 \\
\hline
x6 & 00111001 \\
\hline
x7 & 01100010 \\
\hline
\end{tabular}
\end{center}
\end{table}

\noindent (a) What do MAR and MDR contain just before the end of cycle 1.

\begin{center}
\begin{tabular}{llll}
     
     \raisebox{1.8ex}[0pt]{MAR:} &
\setlength{\unitlength}{1in}
\begin{picture}(1.3,0.325)
\framebox(1.3,0.325){\underline{}}
\end{picture}
     & \raisebox{1.8ex}[0pt]{MDR:} & 
\setlength{\unitlength}{1in}
\begin{picture}(1.3,0.325)
\framebox(1.3,0.325){\underline{}}
\end{picture}

\end{tabular}

\end{center}


\noindent (b) What does MDR contain just before the end of cycle 4.
\begin{center}
\begin{tabular}{ll}
     
       \raisebox{1.8ex}[0pt]{MDR:} & 
\setlength{\unitlength}{1in}
\begin{picture}(1.3,0.325)
\framebox(1.3,0.325){\underline{}}
\end{picture}
\\
\end{tabular}
\end{center}


\end{exercises}
\end{document}
