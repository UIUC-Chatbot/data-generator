\documentclass{patt}
\usepackage{xr}
\usepackage{xr}
\usepackage{alltt}
\usepackage{longtable}
\usepackage[section]{placeins}
\externaldocument{chap08}
\graphicspath{{../art/ch10/},{../art/designelements/},{../art/designelements/UnNumberedArt/}}

 \makeatletter
 \def\@makechapterhead#1{%
  \begingroup
  \parindent \z@%
  \vspace*{-8.5\p@}%
  \begin{picture}(0,0)
    \put(432,-577){\includegraphics[width=0.723333in,height=9.52667in]{PattChp.eps}}
    \put(428,-577){\rule{1\p@}{9.52667in}}
    \put(381.5,-181){\vbox{%
        \includegraphics{PattIcon1\ifnum\value{part}=0
            a\else b\fi.eps}\vspace{1pc}\par
        \includegraphics{PattIcon2\ifnum\value{part}=5
            a\else b\fi.eps}\vspace{1pc}\par
        \includegraphics{PattIcon3\ifnum\value{part}=5
            a\else b\fi.eps}\vspace{1pc}\par
        \includegraphics{PattIcon4\ifnum\value{part}=5
            a\else b\fi.eps}\vspace{1pc}\par
        \includegraphics{PattIcon5\ifnum\value{part}=5
            a\else b\fi.eps}\vspace{1pc}}}
  \end{picture}%
  \settowidth{\chapternumberwidth}{\fontsize{12}{12}\selectfont\industriasolid\trackonefifty{chapter}}%
  \hfill\parbox{\chapternumberwidth}{%
    \centering\industriasolid
    \centerline{\hss\fontsize{12}{12}\selectfont\trackonefifty{chapter}\hss}\par\vspace{1.5pc}
    \centerline{\sans\fontsize{72}{12}\selectfont\colour\thechapter}}
  \par
  \vspace{6.48pc}
  {\industriasolid\fontsize{30}{32}\selectfont\trackten{#1}\par}%
  \vspace{1.5pc}%
  {\colour\rule{36.4pc}{4\p@}}
  \vspace{4pt}
  \endgroup}
\makeatother

\begin{document}

\setcounter{part}{1}
\setcounter{chapter}{9}
\setcounter{page}{251}

\chapter{A Calculator}
\label{chapt:calculator}

Before we leave LC-3 assembly language and raise the level of
abstraction to the C programming language, it is useful to step back 
and pull together much of what we have learned with a comprehensive example. 
The intent is to demonstrate the use of many of the concepts discussed 
thus far, as well as to show an example of well-documented, clearly written 
code, where the example is much more complicated than what can fit on one 
or two pages.  

Our example is a program that simulates the actions of a calculator that a 
person can use to add, subract, and multiply 2's complement integers.  
The person will enter numbers into the calculator-simulator by typing keys 
on the keyboard.  Results of a computation will be displayed on the monitor.  
The calculator simulation consists of a main program and 11 separate 
subroutines.  You are encouraged to study this example before moving on to 
Chapter 11 and High-Level Language Programming.

Two topics we have not discussed thus far are needed to understand the 
workings of the calculator simulation: (1) the conversion of integers between
ASCII strings and 2's complement, and (2) arithmetic using a stack, the
method most calculators use.

The reason for two data types and conversion between them: We need 
one data type for input/output and another for doing arithmetic.  Numbers
entered via the keyboard and displayed on the monitor use ASCII codes to
represent the numbers.  Arithmetic uses 2's complement integers.

We will need to convert the number the person 
types from ASCII codes to a 2's complement integer, and we will need to 
convert the result of the computation from a 2's complement integer to ASCII 
codes in order to display it on the monitor.  Section 10.1 deals with 
data type conversion.

With respect to the way calculators perform arithmetic, the mechanism used by
most calculators is very different from the way most desktop and laptop 
computers perform arithmetic.  The ISAs of most desktops and laptops are like
the LC-3, where arithmetic instructions get their source operands from general
purpose registers, and store the results of the arithmetic operations in 
general purpose registers.  Our simulation of a calculator, like most 
calculators, does not use general purpose registers.  Instead it uses a stack. 
Source operands are popped from the stack, and the result of the 
operation is pushed back onto the stack.  Section 10.2 deals with 
arithmetic using a stack instead of general purpose registers.

Finally, Section 10.3 contains a full discussion of the 
calculator-simulator, along with all the subroutines that are needed 
to make it work.

\FloatBarrier
\section{Data Type Conversion}
\index{data type conversion}

It has been a long time since we talked about data types.  We have already 
been exposed to several data types: unsigned integers for address
arithmetic, 2's complement integers for integer arithmetic, 16-bit
binary strings for logical operations, floating point numbers for
scientific computation, and ASCII codes for interaction with input and
output devices.

It is important that every instruction be provided with source
operands of the data type that the instruction requires. For example,
an ALU requires operands that are 2's complement integers to perform
an {\bf ADD}. If the ALU were supplied with floating point operands, the 
ALU would produce garbage results.

It is not uncommon in high-level language programs to find an
instruction of the form $A=R+I$ where $R$ (floating point) and $I$
(2's complement integer) are represented in different data types.

If the operation is to be performed by a floating point adder, then we
have a problem with $I$. To handle the problem, one must first convert
the value $I$ from its original data type (2's complement integer)
to the data type required by the functional unit performing the operation 
(floating point).  For those programming in some high level language, 
the compiler generally produces the code to do that conversion so the 
programmer does not even have to think about it.

Even in our "character count problem" way back in Chapter 5, we had to deal
with data type conversion.  Our program entered a character from the
keyboard, scanned a file counting the number of occurrences of that character,
and then displayed the count on the monitor.  Recall that before we could
display our final count on the monitor, we had to convert our 2's complement 
integer to an ASCII code.  Why?  Because when we were counting, we were 
performing arithmetic on 2's complement integers.  But when we were 
displaying, we needed to represent our count as an ASCII code.  You remember 
we restricted our program to work only on files where the total count was not 
greater than 9 so our conversion from a 2's complement integer to an ASCII code 
could be obtained by simply adding x30 to the 2's complement integer to get the 
ASCII code.  For example, The 2's complement representation for 6 (in one byte)
is 00000110, or x06.  The ASCII code for 6, on the other hand, is 00110110, 
or x36.
  
That was a severe limitation to put on our count, restricting it
to a single decimal digit.  But that was chapter 5 and now we are in 
chapter 10!  If our number is represented by more than one decimal digit, 
simply adding x30 does not work.  For example, consider the two decimal digit 
number 25.  If we enter 25 via the keyboard, we input the ASCII code x32, 
followed by the ASCII code x35.  The bit stream is 0011001000110101.  To 
perform arithmetic on this integer, we must first convert it to 
0000000000011001, the 2's complement integer representation of 25.  
Displaying the result of some arithmetic computation on the monitor causes
a similar problem.  To do that, we must first convert the result of the 
arithmetic (a 2's complement integer) to an ASCII string.

In this section, we develop routines to convert integers consisting of 
more than one decimal digit from a string of ASCII codes to 2's complement,
and from 2's complement to a string of ASCII codes. 

\subsection{Example: A Bogus Program: 2 $+$ 3 $=$ e}

Before we get into the actual conversion routines, it is worth looking at
a simple, concrete example that illustrates their importance.
Figure~\ref{fig:bogus.addition} shows how  we can get into trouble if we 
do not pay attention to the data types that we are working with.

Suppose we want to enter two single digit integers from the keyboard, add them,
and display the result on the monitor. At first blush, we write the
simple program of Figure~\ref{fig:bogus.addition}. What happens?

%10.1
\begin{figure}[h!]
\begin{Verbatim}[fontsize=\fontsize{9}{11}\selectfont]
01   TRAP   x23         ; Input from the keyboard.
02   ADD    R1,R0,#0    ; Make room for another input.
03   TRAP   x23         ; Input another character.
04   ADD    R0,R1,R0    ; Add the two inputs.
05   TRAP   x21         ; Display result on the monitor.
06   TRAP   x25         ; Halt.
\end{Verbatim}
\caption{ADDITION without paying attention to data types}
\label{fig:bogus.addition}
\end{figure}

Suppose the first digit entered via the keyboard is a 2 and the second
digit entered via the keyboard is a 3. What will be displayed on the
monitor before the program terminates? The value loaded into R0 as a
result of entering a 2 is the ASCII code for 2, which is x0032. When
the 3 is entered, the ASCII code for 3, which is x0033, is
loaded into R0 (after the ASCII code for 2 is moved to R1, of course).  
Thus, the ADD instruction adds the two binary strings
x0032 and x0033, producing x0065. When that value is displayed on the
monitor, it is treated as an ASCII code. Since x0065 is the ASCII
code for a lower case {\em e}, a lower case e is displayed on the monitor.

The reason we did not get 5 (which, at last calculation, is the
correct result when adding 2 $+$ 3) is that ($a$) we didn't convert
the two input characters from ASCII to 2's complement integers before
performing the addition and ($b$) we didn't convert the result back to 
ASCII before displaying it on the monitor.

{\em Exercise:} Correct Figure~\ref{fig:bogus.addition} so that it
will add two single-digit positive integers and produce the correct 
single-digit positive sum.  Assume that the two digits being added do in fact
produce a single-digit sum.

\FloatBarrier
\subsection{Input data (ASCII to Binary)}

Figure~\ref{fig:asciibuff.295} shows the ASCII
representation of the three-decimal-digit integer 295, stored as an ASCII
string in three consecutive LC-3 memory locations, starting at ASCIIBUFF. 
R1 contains the number of decimal digits in the positive integer.
Our ASCII to Binary subroutine restricts integers to the range 0 to 999.

%10.2
\begin{figure}[h!]
\centerline{\includegraphics{pat67509_1017.eps}}
\caption{The ASCII representation of 295 stored in consecutive memory locations}
\label{fig:asciibuff.295}
\end{figure}

ASCIIBUFF is the address of the first memory location of a sequence of four 
memory locations that we have allocated (a) to store the ASCII codes of decimal 
digits entered from the keyboard, and (b) to store the ASCII codes 
corresponding to the result of arithmetic operations in preparation for 
writing it (the result) to the monitor.

You might ask why, in Figure~\ref{fig:asciibuff.295}, we used a whole 16-bit 
word to store the ASCII code of each decimal digit when a byte would have been 
enough.  In fact, typically, one does store each ASCII code in a single byte
of memory.  In this example, we decided to give each ASCII character its own 
word of memory in order to simplify the algorithm.

Since we are restricting input to positive integers consisting of at most 
three decimal digits, you might also ask why we are allocating four words of
memory to ASCIIBUFF.  Wouldn't three words be enough?  For input yes, but you 
will see in Section~10.1.3 that in preparation for output, we will need one
more word for the sign (positive or negative) of the result, since the result
of the arithmetic could be negative.

Figure~\ref{fig:flowchart.ascii.to.binary} shows the flowchart for a subroutine
that converts the ASCII representation of an integer, stored in
Figure~\ref{fig:asciibuff.295}, into a binary integer. 

%10.3
\begin{figure}[h!]
\centerline{\includegraphics{pat67509_1018.eps}}
\caption{Flowchart, subroutine for ASCII-to-binary conversion}
\label{fig:flowchart.ascii.to.binary}
\end{figure}

The subroutine systematically takes each digit, converts it from its
ASCII code to its binary code by stripping away all but the last four
bits, and then uses those four bits to index into a table of 10 binary values. 
Since we are restricting conversion to integers consisting of at most three
decimal digits, only two tables are needed, one for the tens digit and one 
for the hundreds digit.  Each entry in each table corresponds to the value of 
one of the 10 digits.  For example, the entry for index 6 in the hundreds table
is the value \#600, which is in binary 0000001001011000.
That value is then added to R0. R0 is used to accumulate the contributions 
of all the digits. The result is returned in R0.

Question: If we wanted to be able to convert four decimal-digit integers, 
would we need a table of {\em thousands digits}?  Or, is there a way to 
convert larger numbers represented as larger decimal strings into their binary 
form without requiring a table of {\em thousands} digits, {\em ten-thousands} 
digits, etc.? 

{\em Exercise:} [Challenging] Suppose the decimal number is
arbitrarily long. Rather than store a table of 10 values for the
thousands-place digit, another table for the 10 ten-thousands-place
digit, and so on, design an algorithm to do the conversion without
requiring any tables at all. See Exercise~10.20.

\FloatBarrier
Figure~\ref{fig:code.ascii.to.binary} shows the LC-3 code that
implements this subroutine.

There are two points that we need to make about the subroutines in 
Chapter 10, which are all part of our calculator simulation, described
fully in Section~10.3.  First, they can not be assembled individually, 
and second (because of that), we need to be sure that no label is used more 
than once.  

Why cannot the subroutine of Figure~10.4 be assembled by itself?  Answer:
Line 36 specifies a .FILL having the value ASCIIBUFF, but there is no location
in the subroutine labeled ASCIIBUFF.  Therefore, trying to assemble
the subroutine by itself will fail.  We could have used .EXTERNAL, discussed 
briefly in Chapter~7, to enable the subroutines to be assembled individually, 
but we chose to not do that, preferring to assemble the entire 
calculator-simulator program including its 11 subroutines as a single entity.  
As you would expect, line 43 in the code of Figure~10.15 contains the label
ASCIIBUFF.

Second, if we are to assemble the main program and all the subroutines as a
single unit, we need to be sure to not use the same label in more than one 
subroutine.  Note that in Figure~10.4, most labels start with "AtoB\_."  
As expected, the same pattern of labeling is used in the rest of the 
subroutines.

%10.4
\begin{figure}
\begin{Verbatim}[fontsize=\fontsize{9}{11}\selectfont]
01   ;
02   ;  This subroutine takes an ASCII string of up to three decimal digits and
03   ;  converts it into a binary number.  R0 is used to collect the result.
04   ;  R1 keeps track of how many digits are left to process.  ASCIIBUFF
05   ;  contains the most significant digit in the ASCII string.
06   ;
07   ASCIItoBinary  ST     R1,AtoB_Save1
08                  ST     R2,AtoB_Save2
09                  ST     R3,AtoB_Save3
0A                  ST     R4,AtoB_Save4
0B                  AND    R0,R0,#0      ; R0 will be used for our result.
0C                  ADD    R1,R1,#0      ; Test number of digits.
0D                  BRz    AtoB_Done     ; There are no digits, result is 0.
0E   ;
0F                  LD     R2,AtoB_ASCIIBUFF ; R2 points to ASCIIBUFF
10                  ADD    R2,R2,R1
11                  ADD    R2,R2,#-1     ; R2 now points to "ones" digit.
12   ;
13                  LDR    R4,R2,#0      ; R4 <-- "ones" digit
14                  AND    R4,R4,x000F   ; Strip off the ASCII template.
15                  ADD    R0,R0,R4      ; Add ones contribution.
16   ;
17                  ADD    R1,R1,#-1
18                  BRz    AtoB_Done     ; The original number had one digit.
19                  ADD    R2,R2,#-1     ; R2  now points to "tens" digit.
1A   ;
1B                  LDR    R4,R2,#0      ; R4 <-- "tens" digit
1C                  AND    R4,R4,x000F   ; Strip off ASCII template.
1D                  LEA    R3,LookUp10   ; LookUp10 is BASE of tens values.
1E                  ADD    R3,R3,R4      ; R3 points to the right tens value.
1F                  LDR    R4,R3,#0
20                  ADD    R0,R0,R4      ; Add tens contribution to total.
\end{Verbatim}
\caption{ASCII-to-binary conversion subroutine}
\label{fig:code.ascii.to.binary}
\end{figure}
\newpage
%Figure 10.16 continued
\setcounter{figure}{3}
\begin{figure}[H]
\begin{minipage}{36pc}
\begin{Verbatim}[fontsize=\fontsize{9}{11}\selectfont]
21   ;
22                  ADD    R1,R1,#-1
23                  BRz    AtoB_Done     ; The original number had two digits.
24                  ADD    R2,R2,#-1     ; R2 now points to "hundreds" digit.
25   ;
26                  LDR    R4,R2,#0      ; R4 <-- "hundreds" digit
27                  AND    R4,R4,x000F   ; Strip off ASCII template.
28                  LEA    R3,LookUp100  ; LookUp100 is hundreds BASE.
29                  ADD    R3,R3,R4      ; R3 points to hundreds value.
2A                  LDR    R4,R3,#0
2B                  ADD    R0,R0,R4      ; Add hundreds contribution to total.
2C   ;
2D   AtoB_Done      LD     R1,AtoB_Save1
2E                  LD     R2,AtoB_Save2
2F                  LD     R3,AtoB_Save3
30                  LD     R4,AtoB_Save4
31                  RET
32   ;
33   AtoB_ASCIIBUFF  .FILL  ASCIIBUFF
34   AtoB_Save1      .BLKW  #1
35   AtoB_Save2      .BLKW  #1
36   AtoB_Save3      .BLKW  #1
37   AtoB_Save4      .BLKW  #1
38   LookUp10        .FILL  #0
39                   .FILL  #10
3A                   .FILL  #20
3B                   .FILL  #30
3C                   .FILL  #40
3D                   .FILL  #50
3E                   .FILL  #60
3F                   .FILL  #70
40                   .FILL  #80
41                   .FILL  #90
42   ;
43   LookUp100       .FILL  #0
44                   .FILL  #100
45                   .FILL  #200
46                   .FILL  #300
47                   .FILL  #400
48                   .FILL  #500
49                   .FILL  #600
4A                   .FILL  #700
4B                   .FILL  #800
4C                   .FILL  #900
\end{Verbatim}
\caption{ASCII-to-binary conversion subroutine ({\bf continued})}
\end{minipage}
\end{figure}


\FloatBarrier
\subsection{Display result (Binary to ASCII)}

To display the result of a computation on the monitor, we must first convert 
the 2's complement integer result into an ASCII string.
Figure~\ref{fig:code.binary.to.ascii} shows the subroutine for
converting a 2's complement integer stored in R0 into an ASCII string
stored in the four consecutive memory locations starting at
ASCIIBUFF. The value initially in R0 is restricted to the
range $-$999 to $+$999. After the subroutine completes execution,
ASCIIBUFF contains the sign (+ or -) of the value initially stored in R0, 
followed by three locations that contain the ASCII codes corresponding
to the decimal digits representing its magnitude.

%Figure 10.5
\begin{figure}[h!]
\begin{minipage}{36pc}
\begin{Verbatim}[fontsize=\fontsize{9}{11}\selectfont]
01   ; This subroutine converts a 2's complement integer within the range 
02   ; -999 to +999 (located in R0) into an ASCII character string consisting 
03   ; of a sign digit, followed by three decimal digits, and stores the 
04   ; character string into the four memory locations starting at ASCIIBUFF 
05   ; (see Figure 10.4).
06   ;
07   BinarytoASCII  ST    R0,BtoA_Save0
08                  ST    R1,BtoA_Save1
09                  ST    R2,BtoA_Save2
0A                  ST    R3,BtoA_Save3
0B                  LD    R1,BtoA_ASCIIBUFF  ; R1 keeps track of output string.
0C                  ADD   R0,R0,#0           ; R0 contains the binary value.
0D                  BRn   NegSign            ;
0E                  LD    R2,ASCIIplus       ; First store the ASCII plus sign.
0F                  STR   R2,R1,#0
10                  BRnzp Begin100
11   NegSign        LD    R2,ASCIIminus      ; First store ASCII minus sign.
12                  STR   R2,R1,#0
13                  NOT   R0,R0              ; Convert the number to absolute
14                  ADD   R0,R0,#1           ; value; it is easier to work with.
15   ;
16   Begin100       LD    R2,ASCIIoffset     ; Prepare for "hundreds" digit.
17   ;
18                  LD    R3,Neg100          ; Determine the hundreds digit.
19   Loop100        ADD   R0,R0,R3
1A                  BRn   End100
1B                  ADD   R2,R2,#1
1C                  BRnzp Loop100
1D   ;
1E   End100         STR    R2,R1,#1   ; Store ASCII code for hundreds digit.
1F                  LD     R3,Pos100
20                  ADD    R0,R0,R3   ; Correct R0 for one-too-many subtracts.
21   ;
22                  LD     R2,ASCIIoffset ; Prepare for "tens" digit.
23   ;
24   Loop10         ADD    R0,R0,#-10     ; Determine the tens digit.
25                  BRn    End10
26                  ADD    R2,R2,#1
27                  BRnzp  Loop10
28   ;
29   End10          STR    R2,R1,#2   ; Store ASCII code for tens digit.
2A                  ADD    R0,R0,#10  ; Correct R0 for one-too-many subtracts.
2B   Begin1         LD     R2,ASCIIoffset ; Prepare for "ones" digit.
2C                  ADD    R2,R2,R0
2D                  STR    R2,R1,#3
2E                  LD     R0,BtoA_Save0
2F                  LD     R1,BtoA_Save1
30                  LD     R2,BtoA_Save2
31                  LD     R3,BtoA_Save3
32                  RET
33   ;
34   ASCIIplus       .FILL  x002B
35   ASCIIminus      .FILL  x002D
36   ASCIIoffset     .FILL  x0030
37   Neg100          .FILL  #-100
38   Pos100          .FILL  #100
39   BtoA_Save0      .BLKW  #1
3A   BtoA_Save1      .BLKW  #1
3B   BtoA_Save2      .BLKW  #1
3C   BtoA_Save3      .BLKW  #1
3D   BtoA_ASCIIBUFF  .FILL  ASCIIBUFF
\end{Verbatim}
\caption{Binary-to-ASCII conversion subroutine}
\label{fig:code.binary.to.ascii}
\end{minipage}
\end{figure}

The subroutine works as follows: First, the sign of the result to be displayed
is determined, and the ASCII code for + or - is stored in ASCIIBUFF.  The 
result (in R0) is replaced by its absolute value. The algorithm determines the
hundreds-place digit by repeatedly subtracting \#100 from R0 until the
result goes negative. This is next repeated for the tens-place digit.
The value left is the ones digit.

{\em Exercise:} This subroutine always produces a string of four
characters independent of the sign and magnitude of the integer being
converted. Devise an algorithm that eliminates unnecessary characters,
that is, eliminate leading zeros and eliminate a leading $+$ sign. 
See Exercise~10.22.

\FloatBarrier
\section{Arithmetic Using a Stack}
\label{sec:stack.arithmetic}
\subsection{The Stack as Temporary Storage}

You know that the LC-3 ADD instruction takes two source operands which are
stored in registers, performs an addition, and stores the result into one of 
the LC-3's eight general purpose registers.  We call the register where the 
result is stored the {\em destination register}.  The eight general purpose 
registers R0 to R7 comprise the temporary storage that allows operate 
instructions like ADD to access both source registers and the destination 
register much more quickly than if the computer had to access memory for the 
operands.  Because the three locations are specified explicitly, 

\begin{colorverbatim}
                       ADD  R0,R1,R2
\end{colorverbatim}
\noindent
we call the LC-3 a three-address machine.  Most desktop and laptop computers
are either {\em three-address machines} like the LC-3, or {\em two-address 
machines} like the x86 ISA that is implemented in many of your laptop and 
desktop computers.  In a two-address machine, two locations are specified 
explicitly.  An example of an x86 ADD instruction is  

\begin{colorverbatim}
                       ADD  EAX,EBX
\end{colorverbatim}
\noindent
where EAX and EBX are two of the eight general purpose registers in the x86
ISA.  In this case, EAX serves as both the location of one of the source 
operands and the location of the destination operand.  With a two-address
machine, one of the source registers is overwritten with the result of the
operation.

There are also ISAs that do not use general purpose registers at all to store 
either source operands or the results of operate instructions.  Most common 
of these are called {\em stack machines} because a stack is used for temporary 
storage.  Most calculators, including the one we will simulate in Section 10.3,
use a stack for temporary storage, rather than a set of general purpose 
registers.  

Source operands are obtained by popping the top two elements from the stack.
The result (i.e., the destination operand) is subsequently pushed onto the 
stack.  Since the computer always pops and pushes operands from the stack, 
no addresses need to be specified explicitly.  Therefore, stack machines are 
sometimes referred to as zero-address machines.  The instruction would simply be

\begin{colorverbatim}
                              ADD
\end{colorverbatim}

\noindent 
and the computer would know where to find the operands.  For a calculator, 
that is convenient because a person can cause an ADD to be performed by simply 
pressing the {\bf +} button on the calculator.  Note that the pop, push, 
and add are not part of the ISA of the computer, and therefore not
available to the programmer. They are control signals that the
hardware uses to make the actual pop, push, and add occur. The control
signals are part of the microarchitecture, similar to the load enable
signals and mux select signals we discussed in Chapters 4 and 5.  As
is the case with LC-3 instructions LD and ST, and control signals
PCMUX and LD.MDR, the programmer simply instructs the computer to ADD,
and the microarchitecture does the rest.

%10.3.2
\subsection{An Example}

Suppose we want to evaluate $(A+B)\cdot(C+D)$, where $A$
contains 25, $B$ contains 17, $C$ contains 3, and $D$ contains 2, and store
the result in $E$. If the LC-3 had a multiply instruction (we would
probably call it MUL), we could use the following program:

\begin{colorverbatim}
                       LD    R0,A
                       LD    R1,B
                       ADD   R0,R0,R1
                       LD    R2,C
                       LD    R3,D
                       ADD   R2,R2,R3
                       MUL   R0,R0,R2
                       ST    R0,E
\end{colorverbatim}

With a calculator, we would execute the following
eight operations:

\begin{colorverbatim}
                      (1)    push     25
                      (2)    push     17
                      (3)    add
                      (4)    push     3
                      (5)    push     2
                      (6)    add
                      (7)    multiply
                      (8)    pop      E
\end{colorverbatim}

\noindent
with the final result popped (i.e., 210) being the result of the computation, 
Figure~\ref{fig:25+17*3+2} shows a snapshot of the stack after each of the
eight operations.  Note that in this example we have allocated memory locations
x3FFB to x3FFF for our stack, and the Stack Pointer is initially at x4000,
indicating that there is nothing initially on the stack.

%Figure 10.6
\begin{figure}[h]
\centerline{\includegraphics{pat67509_1008.eps}}
\caption{Stack usage during the computation
of $(25+17)\cdot (3+2)$}
\label{fig:25+17*3+2}
\end{figure}

\FloatBarrier
In Section~10.3, we write a program that causes the LC-3 (with keyboard and 
monitor) to act like such a calculator. We say the LC-3 {\em simulates} the 
calculator when it executes that program.  To do this, our program will need
subroutines to perform the various arithmetic operations.

\subsection{OpAdd, OpMult, and OpNeg}

The program we write in Section~10.3 to simulate a calculator will need 
three subroutines to be able to perform addition, subtraction, and 
multiplication.  They are:

\begin{enumerate}
\item %1
  OpAdd, which will pop two values from the stack, add them, and push
  the result onto the stack.

\item %[2:]
OpMult, which will pop two values from the stack, multiply them,
and push the result onto the stack.

\item %[3:]
  OpNeg, which will pop the top value, form its 2's complement
  negative value, and push the result onto the stack.  This will allow us
to subtract two numbers A minus B by first forming -B and then adding the
result to A.
\end{enumerate}

\paragraph{The OpAdd Subroutine}

Figure~\ref{fig:opadd.flowchart} shows the flowchart of the OpAdd
Subroutine. Basically, it attempts to pop two values off the
stack and, if successful, add them. If the result is within the range
of acceptable values (that is, an integer between $-999$ and $+999$),
then the result is pushed onto the stack.

%Figure 10.7
\begin{figure}[h!]
\centerline{\includegraphics{pat67509_1009.eps}}
\caption{Flowchart for OpAdd algorithm}
\label{fig:opadd.flowchart}
\end{figure}

\FloatBarrier
There are two things that could prevent OpAdd from
completing successfully: Fewer than two values are available on the
stack for source operands, or the result is out of range. In both
cases, the stack is put back to the way it was at the start of the
OpAdd subroutine.  If the first pop is unsuccessful,
the stack is not changed since the POP routine leaves the stack as it
was. If the second of the two pops reports back unsuccessfully, the
stack pointer is decremented, which effectively returns the first
value popped to the top of the stack. If the result is outside the
range of acceptable values, then the stack pointer is decremented
twice, returning both values to the top of the stack.

The OpAdd subroutine is shown in Figure~\ref{fig:opadd.algorithm}.

%Figure 10.8
\begin{figure}[h!]
\begin{minipage}{36pc}
\begin{Verbatim}[fontsize=\fontsize{9}{11}\selectfont]
01    ;
02    ;        Subroutine to pop the top two elements from the stack,
03    ;        add them, and push the sum onto the stack.  R6 is
04    ;        the stack pointer.
05    ;
06    OpAdd           ST      R0,OpAdd_Save0
07                    ST      R1,OpAdd_Save1
08                    ST      R5,OpAdd_Save5
09                    ST      R7,OpAdd_Save7
0A                    JSR     POP             ; Get first source operand.
0B                    ADD     R5,R5,#0        ; Test if POP was successful.
0C                    BRp     OpAdd_Exit      ; Branch if not successful.
0D                    ADD     R1,R0,#0        ; Make room for second operand.
0E                    JSR     POP             ; Get second source operand.
0F                    ADD     R5,R5,#0        ; Test if POP was successful.
10                    BRp     OpAdd_Restore1  ; Not successful, put back first.
11                    ADD     R0,R0,R1        ; THE Add.
12                    JSR     RangeCheck      ; Check size of result.
13                    ADD     R5,R5,#0        ; Check R5 for success/failure.
14                    BRp     OpAdd_Restore2  ; Out of range, restore both.
15                    JSR     PUSH            ; Push sum on the stack.
16                    BRnzp   OpAdd_Exit      ; On to the next task...
17    OpAdd_Restore2  ADD     R6,R6,#-1       ; Decrement stack pointer.
18    OpAdd_Restore1  ADD     R6,R6,#-1       ; Decrement stack pointer.
19    OpAdd_Exit      LD      R0,OpAdd_Save0
1A                    LD      R1,OpAdd_Save1
1B                    LD      R5,OpAdd_Save5
1C                    LD      R7,OpAdd_Save7
1D                    RET
1E    OpAdd_Save0     .BLKW   #1
1F    OpAdd_Save1     .BLKW   #1
20    OpAdd_Save5     .BLKW   #1
21    OpAdd_Save7     .BLKW   #1
\end{Verbatim}
\caption{The OpAdd Subroutine}
\label{fig:opadd.algorithm}
\end{minipage}
\end{figure}

\FloatBarrier
Note that the OpAdd subroutine calls the RangeCheck subroutine. This is
a simple test to be sure the result of the computation is within what
can successfully be stored in a single stack location. For our
purposes, we restrict values to integers in the range $-999$
to $+999$.  This will come in handy in Section~10.3 when we design our
home-brew calculator. The flowchart for the RangeCheck subroutine is
shown in Figure~\ref{fig:flowchart.rangecheck}. The LC-3 program that
implements this subroutine is shown in
Figure~\ref{fig:code.rangecheck}.

%Figure 10.9
\begin{figure}
\centerline{\includegraphics{pat67509_1011.eps}}
\caption{The RangeCheck algorithm flowchart}
\label{fig:flowchart.rangecheck}
\end{figure}

%Figure 10.10
\begin{figure}
\begin{Verbatim}[fontsize=\fontsize{9}{11}\selectfont]
01   ;
02   ;     Subroutine to check that a value is
03   ;     between -999 and +999.
04   ;
05   RangeCheck       LD        R5,Neg999
06                    ADD       R5,R0,R5             ; Recall that R0 contains the
07                    BRp       BadRange             ; result being checked.
08                    LD        R5,Pos999
09                    ADD       R5,R0,R5
0A                    BRn       BadRange
0B                    AND       R5,R5,#0             ; R5 <-- success
0C                    RET
0D   BadRange         ST        R0,RangeCheck_Save0
0E                    LEA       R0,RangeErrorMsg
0F                    TRAP      x22                  ; Output character string
10                    AND       R5,R5,#0             ;
11                    ADD       R5,R5,#1             ; R5 <-- failure
12                    LD        R0,RangeCheck_Save0
13                    RET
14   Neg999           .FILL     #-999
15   Pos999           .FILL     #999
16   RangeErrorMsg    .FILL     x000A
17                    .STRINGZ  "Error: Number is out of range."
18   RangeCheck_Save0 .BLKW     #1
\end{Verbatim}
\caption{The RangeCheck Subroutine}
\label{fig:code.rangecheck}
\end{figure}

\FloatBarrier
\paragraph{The OpMult Subroutine}

Figure~\ref{fig:mul.flowchart} shows the flowchart of the OpMult
subroutine, and Figure~\ref{fig:mul.algorithm} shows the LC-3 program
that implements it. Similar to the OpAdd subroutine, the
OpMult subroutine attempts to pop two values off the stack and, if
successful, multiplies them. Since the LC-3 does not have a multiply
instruction, multiplication is performed as we have done in the past
as a sequence of adds. Lines 17 to 19 of
Figure~\ref{fig:mul.algorithm} contain the crux of the actual
multiply.  If the result is within the range of acceptable values,
then the result is pushed onto the stack.

%Figure 10.11
\begin{figure}
\centerline{\includegraphics{pat67509_1013.eps}}
\caption{Flowchart for the OpMult Subroutine}
\label{fig:mul.flowchart}
\end{figure}

%Figure 10.12
\begin{figure}
\begin{Verbatim}[fontsize=\fontsize{9}{11}\selectfont]
01  ;
02  ;    Two values are popped from the stack, multiplied, and if 
03  ;    their product is within the acceptable range, the result 
04  ;    is pushed onto the stack.  R6 is the stack pointer.
05  ;
06  OpMult            ST     R0,OpMult_Save0
07                    ST     R1,OpMult_Save1
08                    ST     R2,OpMult_Save2
09                    ST     R3,OpMult_Save3
0A                    ST     R5,OpMult_Save5
0B                    ST     R7,OpMult_Save7
0C                    AND    R3,R3,#0         ; R3 holds sign of multiplier.
0D                    JSR    POP              ; Get first source from stack.
0E                    ADD    R5,R5,#0         ; Test for successful POP.
0F                    BRp    OpMult_Exit      ; Failure
10                    ADD    R1,R0,#0         ; Make room for next POP.
11                    JSR    POP              ; Get second source operand.
12                    ADD    R5,R5,#0         ; Test for successful POP.
13                    BRp    OpMult_Restore1  ; Failure; restore first POP.
14                    ADD    R2,R0,#0         ; Moves multiplier, tests sign.
15                    BRzp   PosMultiplier
16                    ADD    R3,R3,#1         ; Sets FLAG: Multiplier is neg.
17                    NOT    R2,R2
18                    ADD    R2,R2,#1         ; R2 contains -(multiplier).
19  PosMultiplier     AND    R0,R0,#0         ; Clear product register.
1A                    ADD    R2,R2,#0
1B                    BRz    PushMult         ; Multiplier = 0, Done.
1C  ;
1D  MultLoop          ADD    R0,R0,R1         ; THE actual "multiply"
1E                    ADD    R2,R2,#-1        ; Iteration Control
1F                    BRp    MultLoop
20  ;
21                    JSR    RangeCheck
22                    ADD    R5,R5,#0         ; R5 contains success/failure.
23                    BRp    OpMult_Restore2
24  ;
25                    ADD    R3,R3,#0         ; Test for negative multiplier.
26                    BRz    PushMult
27                    NOT    R0,R0            ; Adjust for
28                    ADD    R0,R0,#1         ; sign of result.
29  PushMult          JSR    PUSH             ; Push product on the stack.
2A                    BRnzp  OpMult_Exit
2B  OpMult_Restore2   ADD    R6,R6,#-1        ; Adjust stack pointer.
2C  OpMult_Restore1   ADD    R6,R6,#-1        ; Adjust stack pointer.
2D  OpMult_Exit       LD     R0,OpMult_Save0
2E                    LD     R1,OpMult_Save1
2F                    LD     R2,OpMult_Save2
30                    LD     R3,OpMult_Save3
31                    LD     R5,OpMult_Save5
32                    LD     R7,OpMult_Save7
33                    RET
34  OpMult_Save0     .BLKW   #1
35  OpMult_Save1     .BLKW   #1
36  OpMult_Save2     .BLKW   #1
37  OpMult_Save3     .BLKW   #1
38  OpMult_Save5     .BLKW   #1
39  OpMult_Save7     .BLKW   #1
\end{Verbatim}
\caption{The OpMult Subroutine}
\label{fig:mul.algorithm}
\end{figure}

If the second of the two pops reports back unsuccessfully, the stack
pointer is decremented, which effectively returns the first value
popped to the top of the stack. If the result is outside the range of
acceptable values, which as before will be indicated by a 1 in R5,
then the stack pointer is decremented twice, returning both values to
the top of the stack.

\FloatBarrier
\paragraph{The OpNeg Subroutine}

To perform subtraction with the top two elements on the stack, we first
replace the top element on the stack with its negative, and then use
OpADD.  That is, if the top of the stack contains A, and
the second element on the stack contains B, we can push B$-$A on the stack
by first negating the top of the stack and then performing OpAdd.
The subroutine OpNeg for computing the negative of the element on the top of 
the stack is shown in Figure~\ref{fig:neg.algorithm}.

%Figure 10.13
\begin{figure}
\begin{Verbatim}[fontsize=\fontsize{9}{11}\selectfont]
01   ; Subroutine to pop the top of the stack, form its negative,
02   ; and push the result onto the stack.
03   ;
04   OpNeg        ST     R0,OpNeg_Save0
05                ST     R5,OpNeg_Save5
06                ST     R7,OpNeg_Save7
07                JSR    POP        ; Get the source operand.
08                ADD    R5,R5,#0   ; Test for successful pop
09                BRp    OpNeg_Exit ; Branch if failure.
0A                NOT    R0,R0
0B                ADD    R0,R0,#1   ; Form the negative of source.
0C                JSR    PUSH       ; Push result onto the stack.
0D   OpNeg_Exit   LD     R0,OpNeg_Save0
0E                LD     R5,OpNeg_Save5
0F                LD     R7,OpNeg_Save7
10                RET
11   OpNeg_Save0  .BLKW  #1  
12   OpNeg_Save5  .BLKW  #1  
13   OpNeg_Save7  .BLKW  #1  
\end{Verbatim}
\caption{The OpNeg Subroutine}
\label{fig:neg.algorithm}
\end{figure}

\FloatBarrier
\section{The Calculator}
\subsection{Functionality}

We are now ready to specify all the code for our calculator.  As we already 
said, our calculator is not very sophisticated by today's standards.  It will 
allow a user to enter positive integers consisting of not more 
than three decimal digits, perform basic arithmetic (addition, subtraction, 
and multiplication) on these integers, and display the decimal result (which 
will also be limited to at most three decimal digits).

We will use the keyboard to tell the calculator what to do.  We can enter
positive integers having up to three decimal digits, the arithmetic
operators + (for ADD), * (for MUL), and - (for Negative), and three additional
commands D (to display the result of the calculation on the monitor), C (to 
erase all values entered), and X (to turn off the calculator).

The calculator algorithm works as follows: We use the keyboard to input 
commands and decimal values.  We use the monitor to display results.  We use a
stack to hold source operands for performing arithmetic operations and the
results of those arithmetic operations, as described in
Section~\ref{sec:stack.arithmetic}.  Values entered and displayed
are restricted to three decimal digits, that is, only values between
$-$999 and $+$999, inclusive.  

Figure~\ref{fig:calculator.overview} is a flowchart that provides an
overview of our algorithm that simulates a calculator. Simulation of the 
calculator starts with initialization, which includes setting R6, the stack
pointer, to an empty stack.  Then the user sitting at the keyboard is
prompted with: "Enter a Command."  

%Figure 10.14
\begin{figure}[h!]
\centerline{\includegraphics{pat67509_1021.eps}}
\caption{The calculator, overview}
\label{fig:calculator.overview}
\end{figure}

\FloatBarrier
The following commands are available to the user.

\begin{unlist}
\item{\bf X} Exit the simulation.
\item{\bf D} Display the value at the top of the stack.
\item{\bf C} Clear all values from the stack.
\item{\bf +} Pop the top two elements A,B off the stack and push A+B.
\item{\bf *} Pop the top two elements A,B off the stack and push A*B.
\item{\bf -} Pop the top element A off the stack and push "minus" A.
\item{\bf Enter} or {\bf LF} Push the value typed on the keyboard onto the top
of the stack.
\end{unlist}

If the user wants to enter a number, he/she types the number (up to three
decimal digits) followed by <Enter> or <Line Feed (LF)>.

Input is echoed, and the calculator simulation systematically tests
the character to identify the user's command.  Depending on the
user's command, the calculator calls the appropriate subroutine to carry out
the work specified.  After the work is carried out, the
subroutine returns, followed by a prompt for another command.  The
calculator simulation continues in this way until the user presses X,
signaling that the user is finished with the calculator.

For example, to calculate 

\begin{colorverbatim}
	     (51 - 49) * (172 + 205) - (17 * 2)  
\end{colorverbatim}
\noindent
and display the result 720 on the monitor, one types the following sequence of 
keys on the keyboard:

\noindent
5,1,LF,4,9,LF,-,+,1,7,2,LF,2,0,5,LF,+,*,1,7,LF,2,LF,*,-,+,D.

\subsection{Code}

Twelve routines comprise the calculator
simulation. Figure~\ref{fig:calculator.main.algorithm} is the main
algorithm, supported by eleven subroutines.  Note the three global labels,
StackMax, StackBase, and ASCIIBUFF are all part of the main algorithm,
shown in Figure~10.15.  They provide the symbol table entries needed by
the subroutines that reference those locations.  Note also that the stack
has been allocated ten entries in the main algorithm, and R6, the Stack
Pointer is initialized to an empty stack in line 05.

\FloatBarrier
%Figure 10.15
\begin{figure}[h!]
\begin{minipage}{36pc}
\begin{Verbatim}[fontsize=\fontsize{9}{10}\selectfont]
01   ;
02   ;  The Calculator, Main Algorithm
03   ;
04               LEA       R6,StackBase  ; Initialize the Stack Pointer.
05               ADD       R6,R6,#1      ; R6 = StackBase + 1 --> empty stack
06   
07   NewCommand  LEA       R0,PromptMsg
08               PUTS
09               GETC
0A               OUT
0B   ;
0C   ; Check the command
0D   ;
0E   TestX       LD        R1,NegX       ; Check for X.
0F               ADD       R1,R1,R0
10               BRnp      TestC
11               HALT
12   ;
13   TestC       LD        R1,NegC       ; Check for C.
14               ADD       R1,R1,R0
15               BRnp      TestAdd
16               JSR       OpClear       ; See Figure 10.20
17               BRnzp     NewCommand
18   ;
19   TestAdd     LD        R1,NegPlus    ; Check for +
1A               ADD       R1,R1,R0
1B               BRnp      TestMult
1C               JSR       OpAdd         ; See Figure 10.8
1D               BRnzp     NewCommand
1E   ;
1F   TestMult    LD        R1,NegMult    ; Check for *
20               ADD       R1,R1,R0
21               BRnp      TestMinus
22               JSR       OpMult        ; See Figure 10.12
23               BRnzp     NewCommand
24   ;
25   TestMinus   LD        R1,NegMinus   ; Check for -
26               ADD       R1,R1,R0
27               BRnp      TestD
28               JSR       OpNeg         ; See Figure 10.13
29               BRnzp     NewCommand
2A   ;
2B   TestD       LD        R1,NegD       ; Check for D
2C               ADD       R1,R1,R0
2D               BRnp      EnterNumber
2E               JSR       OpDisplay     ; See Figure 10.19
2F               BRnzp     NewCommand
30   ;
31   ; Then we must be entering an integer
32   ;
33   EnterNumber JSR       PushValue     ; See Figure 10.16
34               BRnzp     NewCommand
35   ;
36   PromptMsg   .FILL     x000A
37               .STRINGZ "Enter a command:"
38   NegX        .FILL     xFFA8
39   NegC        .FILL     xFFBD
3A   NegPlus     .FILL     xFFD5
3B   NegMinus    .FILL     xFFD3
3C   NegMult     .FILL     xFFD6
3D   NegD        .FILL     xFFBC
3E   
3F   ; Globals
40   StackMax    .BLKW     #9
41   StackBase   .BLKW     #1
42   ASCIIBUFF   .BLKW     #4
43               .FILL     x0000 ; ASCIIBUFF sentinel 
\end{Verbatim}
\caption{The calculator's main algorithm}
\label{fig:calculator.main.algorithm}
\end{minipage}
\end{figure}

\FloatBarrier

Figure~\ref{fig:code.pushvalue} takes an ASCII string of
characters terminating by a LF, checks to be sure it corresponds to a string
of not more than three decimal digits, and if so, converts it to a binary 
number, and pushes the binary number onto the top of the stack.  
Figure~\ref{fig:code.ascii.to.binary} provides the ASCII-to-binary conversion
routine.  Figure~\ref{fig:code.display} pops the entry on the top of
the stack, converts it to an ASCII character string, and displays the ASCII
string on the monitor.  Figure~\ref{fig:code.binary.to.ascii} provides
the binary-to-ASCII conversion routine.
Figures~\ref{fig:opadd.algorithm} (OpAdd),~\ref{fig:mul.algorithm}
(OpMult), and~\ref{fig:neg.algorithm} (OpNeg) supply the basic
arithmetic algorithms using a stack. Figures~\ref{fig:code.pop}
and~\ref{fig:code.push} contain the basic POP and PUSH routines
Finally, Figure~\ref{fig:code.opclear} clears the stack.

%Also, some labels are used in more than one
%subroutine. If the subroutines are assembled separately and certain
%labels are identified as .EXTERNAL (see Section~9.2.5), then the use
%of the same label in more than one subroutine is not a
%problem. However, if the entire program is assembled as a single
%module, then duplicate labels are not allowed. In that case, one must
%rename some of the labels (e.g., Restore1, Restore2, Exit, and Save)
%so that all labels are unique.

%Figure 10.16
\begin{figure}
\begin{Verbatim}[fontsize=\fontsize{9}{10}\selectfont]
01   ; This subroutine takes a sequence of not more than three decimal digits 
02   ; typed by the user, converts its ASCII string to a binary value using the
03   ; ASCIItoBinary subroutine, and pushes the binary value onto the stack.
04   ; Anything else typed results in an error message.
05   ;
06   PushValue         ST        R0,PushValue_Save0
07                     ST        R1,PushValue_Save1
08                     ST        R2,PushValue_Save2
09                     ST        R7,PushValue_Save7
0A                     LD        R1,PushValue_ASCIIBUFF  ; R1 points to string being
0B                     LD        R2,MaxDigits            ; generated.
0C   ;
0D   ValueLoop         ADD       R3,R0,x-0A    ; Test for line feed, x0A
0E                     BRz       GoodInput
0F                     ADD       R2,R2,#0
10                     BRz       TooLargeInput
11                     LD        R3,NEGASCII0
12                     ADD       R3,R0,R3
13                     BRn       NotInteger
14                     LD        R3,NEGASCII9
15                     ADD       R3,R0,R3
16                     BRp       NotInteger
17                     ADD       R2,R2,#-1     ; Still room for more digits.
18                     STR       R0,R1,#0      ; Store last character read.
19                     ADD       R1,R1,#1
1A                     GETC
1B                     OUT                     ; Echo it.
1C                     BRnzp     ValueLoop
1D   ;
1E   GoodInput         LD        R2,PushValue_ASCIIBUFF
1F                     NOT       R2,R2
20                     ADD       R2,R2,#1
21                     ADD       R1,R1,R2      ; R1 now contains no. of char.
22                     BRz       NoDigit
23                     JSR       ASCIItoBinary
24                     JSR       PUSH
25                     BRnzp     PushValue_Done
\end{Verbatim}
\caption{The calculator's PushValue routine}
\label{fig:code.pushvalue}
\end{figure}
\newpage
%Figure 10.16 continued
\setcounter{figure}{15}
\begin{figure}[H]
\begin{minipage}{36pc}
\begin{Verbatim}[fontsize=\fontsize{9}{11}\selectfont]
26   NoDigit           LEA       R0,NoDigitMsg
27                     PUTS
28                     BRnzp     PushValue_Done
29   NotInteger        GETC                    ; Spin until carriage return.
2A                     OUT
2B                     ADD       R3,R0,x-0A    ; Test for line feed, x0A
2C                     BRnp      NotInteger
2D                     LEA       R0,NotIntegerMsg
2E                     PUTS
2F                     BRnzp     PushValue_Done
30   TooLargeInput     GETC                    ; Spin until carriage return.
31                     OUT
32                     ADD       R3,R0,x-0A    ; Test for line feed, x0A
33                     BRnp      TooLargeInput
34                     LEA       R0,TooManyDigits
35                     PUTS
36   PushValue_Done    LD        R0,PushValue_Save0
37                     LD        R1,PushValue_Save1
38                     LD        R2,PushValue_Save2
39                     LD        R7,PushValue_Save7
3A                     RET
3B   TooManyDigits       .FILL     x000A
3C                       .STRINGZ "Too many digits"
3D   NoDigitMsg          .FILL     x000A
3E                       .STRINGZ "No number entered"
3F   NotIntegerMsg       .FILL     x000A
40                       .STRINGZ "Not an integer"
41   MaxDigits           .FILL     x0003
42   NegASCII0           .FILL     x-30
43   NegASCII9           .FILL     x-39
44   PushValue_ASCIIBUFF .FILL     ASCIIBUFF
45   PushValue_Save0     .BLKW     #1
46   PushValue_Save1     .BLKW     #1
47   PushValue_Save2     .BLKW     #1
48   PushValue_Save7     .BLKW     #1
\end{Verbatim}
\caption{The calculator's PushValue routine (continued)}
\label{fig:code.pushvalue}
\end{minipage}
\end{figure}

%Figure 10.17
\begin{figure}
\begin{minipage}{36pc}
\begin{Verbatim}[fontsize=\fontsize{9}{10}\selectfont]
01   ;  This subroutine POPs a value from the stack and puts it in
02   ;  R0 before returning to the calling program.  R5 is used to
03   ;  report success (R5 = 0) or failure (R5 = 1) of the POP operation.
04   POP            LD      R0,POP_StackBase
05                  NOT     R0,R0           ; R0 = -(addr. of StackBase + 1)
06                  ADD     R0,R0,R6        ; R6 = StackPointer
07                  BRz     Underflow
08                  LDR     R0,R6,#0        ; The actual POP
09                  ADD     R6,R6,#1        ; Adjust StackPointer
0A                  AND     R5,R5,#0        ; R5 <-- success
0B                  RET
0C   Underflow      LEA     R0,UnderflowMsg 
0D                  PUTS                    ; Print error message.
0E                  AND     R5,R5,#0
0F                  ADD     R5,R5,#1        ; R5 <-- failure
10                  RET
11   UnderflowMsg   .FILL   x000A
12                  .STRINGZ "Error: Too Few Values on the Stack."
13   POP_StackBase  .FILL   StackBase 
\end{Verbatim}
\caption{The calculator's POP routine}
\label{fig:code.pop}
\end{minipage}
\end{figure}


%Figure 10.18
\begin{figure}
\begin{minipage}{36pc}
\begin{Verbatim}[fontsize=\fontsize{9}{10}\selectfont]
01   ;  This subroutine PUSHes on the stack the value stored in R0.
02   ;  R5 is used to report success (R5 = 0) or failure (R5 = 1) of
03   ;  the PUSH operation.
04   PUSH           ST      R1,PUSH_Save1  ; R1 is needed by this routine.
05                  LD      R1,PUSH_StackMax
06                  NOT     R1,R1
07                  ADD     R1,R1,#1       ; R1 = - addr. of StackMax
08                  ADD     R1,R1,R6       ; R6 = StackPointer
09                  BRz     Overflow
0A                  ADD     R6,R6,#-1      ; Adjust StackPointer for PUSH.
0B                  STR     R0,R6,#0       ; The actual PUSH
0C                  LD      R1,PUSH_Save1  ; Restore R1.
0D                  AND     R5,R5,#0       ; R5 <-- success
0E                  RET
0F   Overflow       LEA     R0,OverflowMsg 
10                  PUTS
11                  LD      R1,PUSH_Save1 ; Restore R1.
12                  AND     R5,R5,#0
13                  ADD     R5,R5,#1       ; R5 <-- failure
14                  RET
15   PUSH_Save1     .BLKW   #1
16   OverflowMsg    .FILL   x000A
17                  .STRINGZ "Error: Stack is Full."
18   PUSH_StackMax  .FILL   StackMax
\end{Verbatim}
\caption{The calculator's PUSH routine}
\label{fig:code.push}
\end{minipage}
\end{figure}

%Figure 10.19
\begin{figure}
\begin{minipage}{36pc}
\begin{Verbatim}[fontsize=\fontsize{9}{10}\selectfont]
01   ; This subroutine calls BinarytoASCII to convert the 2's complement
02   ; number on the top of the stack into an ASCII character string, and
03   ; then calls PUTS to display that number on the screen.
04   OpDisplay        ST        R0,OpDisplay_Save0
05                    ST        R5,OpDisplay_Save5
06                    ST        R7,OpDisplay_Save7
07                    JSR       POP            ; R0 gets the value to be displayed.
08                    ADD       R5,R5,#0
09                    BRp       OpDisplay_DONE ; POP failed, nothing on the stack.
0A                    JSR       BinarytoASCII
0B                    LD        R0,NewlineChar
0C                    OUT
0D                    LD        R0,OpDisplay_ASCIIBUFF
0E                    PUTS
0F                    ADD       R6,R6,#-1      ; Push displayed number back on stack.
10   OpDisplay_DONE   LD        R0,OpDisplay_Save0
11                    LD        R5,OpDisplay_Save5
12                    LD        R7,OpDisplay_Save7
13                    RET
14   NewlineChar         .FILL     x000A
15   OpDisplay_ASCIIBUFF .FILL     ASCIIBUFF
16   OpDisplay_Save0     .BLKW     #1
17   OpDisplay_Save5     .BLKW     #1
18   OpDisplay_Save7     .BLKW     #1
\end{Verbatim}
\caption{The calculator's display routine}
\label{fig:code.display}
\end{minipage}
\end{figure}

%Figure 10.20
\begin{figure}
\begin{Verbatim}[fontsize=\fontsize{9}{11}\selectfont]
01 ;
02 ; This routine clears the stack by resetting the stack pointer (R6).
03 ;
04 OpClear           LD    R6,OpClear_StackBase  ; Initialize the Stack Pointer.
05                   ADD   R6,R6,#1         ; R6 = StackBase + 1 --> empty stack
06                   RET
07 OpClear_StackBase .FILL StackBase
\end{Verbatim}
\caption{The OpClear routine}
\label{fig:code.opclear}
\end{figure}

\clearpage

\begin{exercises}

\item [10.1]
  Describe, in your own words, how the Multiply step of the OpMult
  algorithm in Figure~10.14 works. How many instructions are executed
  to perform the Multiply step? Express your answer in terms of $n$,
  the value of the multiplier. ({\it Note:} If an instruction executes
  five times, it contributes 5 to the total count.) Write a program
  fragment that performs the Multiply step in fewer instructions if
  the value of the multiplier is less than 25. How many?

\item [10.2]
  Correct Figure~\ref{fig:bogus.addition} so that it will add two
  single-digit positive integers and produce a single-digit positive
  sum. Assume that the two digits being added do in fact produce a
  single-digit sum.

\item [10.3]
  Modify Figure~\ref{fig:bogus.addition}, assuming that the input
  numbers are one-digit positive hex numbers. Assume that the two hex
  digits being added together do in fact produce a single hex-digit
  sum.

\item [10.4]
  Figure~\ref{fig:code.ascii.to.binary} provides an algorithm for
  converting ASCII strings to binary values. Suppose the decimal
  number is arbitrarily long.  Rather than store a table of 10 values
  for the thousands-place digit, another table for the 10
  ten-thousands-place digit, and so on, design an algorithm to do the
  conversion without resorting to any tables whatsoever.

\item [10.5]
  The code in Figure~\ref{fig:code.ascii.to.binary} converts a decimal
  number represented as ASCII digits into binary. Extend this code to
  also convert a hexadecimal number represented in ASCII into
  binary. If the number is preceded by an x, then the subsequent ASCII
  digits (three at most) represent a hex number; otherwise it is
  decimal.

\item [10.6]
  The algorithm of Figure~\ref{fig:code.binary.to.ascii} always
  produces a string of four characters independent of the sign and
  magnitude of the integer being converted. Devise an algorithm that
  eliminates unnecessary characters in common representations, that
  is, an algorithm that does not store leading 0s nor a leading $+$
  sign.

\item [10.7]
  What does the following LC-3 program do?
\begin{colorverbatim}
          .ORIG    x3000
          LEA      R6, STACKBASE
          LEA      R0, PROMPT
          TRAP     x22            ; PUTS
          AND      R1, R1, #0
LOOP      TRAP     x20            ; IN
          TRAP     x21
          ADD      R3, R0, #-10   ; Check for newline
          BRz      INPUTDONE
          JSR      PUSH
          ADD      R1, R1, #1
          BRnzp    LOOP
INPUTDONE ADD      R1, R1, #0
          BRz      DONE
LOOP2     JSR      POP
          TRAP     x21
          ADD      R1, R1, #-1
          BRp      LOOP2
DONE      TRAP     x25            ; HALT

PUSH      ADD      R6, R6, #-2
          STR      R0, R6, #0
          RET

POP       LDR      R0, R6, #0
          ADD      R6, R6, #2
          RET
PROMPT    .STRINGZ ``Please enter a sentence: ''
STACKSPAC .BLKW #50
STACKBASE .FILL #0
          .END
\end{colorverbatim}

\item[10.8]STAR The calculator program assumes that if the user did not type one of the characters X,C,+,-,*,D, then it must be pushing a value and so executes BRnzp PushValue.  Modify the program so it is more rubust, that is, if the user typed something other than a digit, the main program would load R0 with the ascii code for X, and branch to Test. If the user typed a digit, the main program would branch to PushValue.

\item[10.9]STAR Improve the robustness by modifying PushValue to make sure
all the characers typed are digits.

\end{exercises}
\end{document}
