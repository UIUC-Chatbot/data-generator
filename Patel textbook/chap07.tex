\documentclass{patt}
\usepackage[section]{placeins}
\usepackage{xr}
\usepackage{alltt}
\usepackage{longtable}
\graphicspath{{../art/ch07/},{../art/designelements/},{../art/designelements/UnNumberedArt/}}

\setcounter{part}{1}
\setcounter{chapter}{6}
\setcounter{page}{177}

 \makeatletter
 \def\@makechapterhead#1{%
  \begingroup
  \parindent \z@%
  \vspace*{-8.5\p@}%
  \begin{picture}(0,0)
    \put(432,-577){\includegraphics[width=0.723333in,height=9.52667in]{PattChp.eps}}
    \put(428,-577){\rule{1\p@}{9.52667in}}
    \put(381.5,-181){\vbox{%
        \includegraphics{PattIcon1\ifnum\value{part}=0
            a\else b\fi.eps}\vspace{1pc}\par
        \includegraphics{PattIcon2\ifnum\value{part}=5
            a\else b\fi.eps}\vspace{1pc}\par
        \includegraphics{PattIcon3\ifnum\value{part}=5
            a\else b\fi.eps}\vspace{1pc}\par
        \includegraphics{PattIcon4\ifnum\value{part}=1
            a\else b\fi.eps}\vspace{1pc}\par
        \includegraphics{PattIcon5\ifnum\value{part}=5
            a\else b\fi.eps}\vspace{1pc}}}
  \end{picture}%
  \settowidth{\chapternumberwidth}{\fontsize{12}{12}\selectfont\industriasolid\trackonefifty{chapter}}%
  \hfill\parbox{\chapternumberwidth}{%
    \centering\industriasolid
    \centerline{\hss\fontsize{12}{12}\selectfont\trackonefifty{chapter}\hss}\par\vspace{1.5pc}
    \centerline{\sans\fontsize{72}{12}\selectfont\colour\thechapter}}
  \par
  \vspace{6.48pc}
  {\industriasolid\fontsize{30}{32}\selectfont\trackten{#1}\par}%
  \vspace{1.5pc}%
  {\colour\rule{36.4pc}{4\p@}}
  \vspace{4pt}
  \endgroup}
\makeatother

\begin{document}

% \bgroup

\chapter{Assembly Language}
\label{chapt:assembly}

 %\egroup

By now, you are probably a little tired of 1s and 0s and keeping track
of 0001 meaning ADD and 1001 meaning NOT. Also, wouldn't it be nice if
we could refer to a memory location by some meaningful symbolic name
instead of memorizing its 16-bit address? And wouldn't it be nice if
we could represent each instruction in some more easily comprehensible
way, instead of having to keep track of which bit of the instruction
conveys which individual piece of information about the instruction.
It turns out that help is on the way.

In this chapter, we introduce assembly language, a mechanism that does
all of the above, and more.

%\vspace{1pc}

%7.1
\section{Assembly Language Programming---Moving Up a Level}

Recall the levels of transformation identified in Figure~1.6 of
Chapter~1. Algorithms are transformed into programs described in some
mechanical language. This mechanical language can be, as it is in
Chapter~5, the machine language of a particular computer. Recall that
a program is in a computer's machine language if every instruction in
the program is from the ISA of that computer.

On the other hand, the mechanical language can be more user-friendly.
We generally partition mechanical languages into two classes,
high-level and low-level. Of the two, high-level languages are much
more user-friendly. Examples are C, C++, Java, Fortran, COBOL, Python,
plus more than a thousand others. Instructions in a high-level
language almost (but not quite) resemble statements in a natural
language such as English. High-level languages tend to be ISA
independent. That is, once you learn how to program in C (or Fortran
or Python) for one ISA, it is a small step to write programs in C (or
Fortran or Python) for another~ISA.

Before a program written in a high-level language can be executed, it
must be translated into a program in the ISA of the computer on which
it is expected to execute. It is often the case that each statement
in the high-level language specifies several instructions in the ISA
of the computer. In Chapter~11, we will~introduce the high-level
language C, and in Chapters~12 through 19, we will show the
relationship between various statements in C and their corresponding
translations to LC-3 code. In this chapter, however, we will only move
up a small step from the ISA we dealt with in Chapter~5.

A small step up from the ISA of a machine is that ISA's assembly
language. Assembly language is a low-level language. There is no
\index{assembly language} confusing an instruction in a low-level
language with a statement in English. Each assembly language
instruction usually specifies a single instruction in the ISA. Unlike
high-level languages, which are usually ISA independent, low-level
languages are very much ISA dependent. In fact, it is usually the case
that each ISA has only one assembly language.

The purpose of assembly language is to make the programming
process more user-friendly than programming in machine language
(i.e., in the ISA of the computer with which we are dealing), while
still providing the programmer with detailed control over the
instructions that the computer can execute. So, for example, while
still retaining control over the detailed instructions the
computer is to carry out, we are freed from having to remember
what opcode is 0001 and what opcode is 1001, or what is being
stored in memory location 0011111100001010 and what is being
stored in location 0011111100000101.  Assembly languages let us
use mnemonic devices for opcodes, such as ADD for 0001 and NOT for 1001, 
and they
let us give meaningful symbolic names to memory locations, such as
SUM or \nobreak PRODUCT, rather than use the memory locations'
16-bit addresses.
This makes it easier to differentiate which memory location is
keeping track of a SUM and which memory location is keeping track
of a PRODUCT. We call these names {\it symbolic addresses}.

We will see, starting in Chapter~11, that when we take the larger step
of moving up to a higher-level language (such as C), programming will
be even more user-friendly, but in doing so, we will relinquish some control 
over exactly
which detailed ISA instructions are to be carried out to accomplish the
work specified by a high-level language statement.

\vspace{-6pt}

%7.2
\section{An Assembly Language Program}
We will begin our study of the LC-3 assembly language by means of an
example.  The program in Figure~7.1 multiplies the integer intially
stored in NUMBER by~6 by adding the integer to itself six times.  For
example, if the integer is 123, the program computes the product by
adding $123 + 123 + 123 + 123 + 123 + 123$.
Where have you seen that before?  :-)

The program consists of 21 lines of code.  We have added a {\em line
  number} to each line of the program in order to be able to refer to
individual lines easily.  This is a common practice.  These line
numbers are not part of the program.  Ten lines start with a
semicolon, designating that they are strictly for the benefit of the
human reader. More on this momentarily.  Seven lines (06, 07, 08, 0C,
0D, 0E, and 10) specify assembly language instructions to be
translated into machine language instructions of the LC-3, which will
be executed when the program runs.  The remaining four
lines (05, 12, 13, and 15) contain pseudo-ops, which are
\index{pseudo-ops} messages from the programmer to the translation
program to help in the translation process.  The translation program
is called an {\em assembler} \index{assembler} (in this case the LC-3
assembler), and the translation process
is called {\em assembly}.\\
\index{assembly language}

% Figure 1
\begin{figure}
\begin{Verbatim}[fontsize=\fontsize{9}{11}\selectfont,formatcom=\color{seventyblack}]
01  ;
02  ; Program to multiply an integer by the constant 6.
03  ; Before execution, an integer must be stored in NUMBER.
04  ;
05          .ORIG   x3050
06          LD      R1,SIX
07          LD      R2,NUMBER
08          AND     R3,R3,#0      ; Clear R3. It will
09                                ; contain the product.
0A  ; The inner loop
0B  ;
0C  AGAIN   ADD     R3,R3,R2
0D          ADD     R1,R1,#-1     ; R1 keeps track of
0E          BRp     AGAIN         ; the iterations
0F  ;
10          HALT
11  ;
12  NUMBER  .BLKW   1
13  SIX     .FILL   x0006
14  ;
15          .END
\end{Verbatim}
\caption{An assembly language program}
\end{figure}

\vspace{-6pt}

%7.2.1
\subsection{Instructions}

Instead of an instruction being 16 0s and 1s, as is the case in the
LC-3 ISA, an instruction in assembly language consists of four parts,
as follows:
\begin{colorverbatim}
Label   Opcode   Operands   ; Comment
\end{colorverbatim}
Two of the parts (Label and Comment) are optional.  More on that
momentarily.
\vspace{-0.1in}
%7.2.1.1
\subsubsection{Opcodes and Operands}

Two of the parts (Opcode and Operands) are {\bf mandatory}.  For an
assembly language instruction to correspond to an instruction in the 
LC-3 ISA, it must have an Opcode (the thing the instruction is to do),
and the appropriate number of Operands (the things it is supposed to
do it to).  Not surprisingly, this was exactly what we encountered in
Chapter~5 when we studied the LC-3~ISA.

The Opcode is a symbolic name for the opcode of the corresponding
LC-3 instruction.  The idea is that it is easier to remember an
operation\vadjust{\pagebreak} by the \nobreak symbolic name ADD,
AND, or LDR than by the 4-bit quantity 0001, 0101, or 0110.
Figure~5.3 (also Figure~A.2) lists the Opcodes of the 15 LC-3
instructions.  Pages~xxx through~yyy show the assembly language
representations for the 15 LC-3 instructions.

The number of operands depends on the operation being performed.  For
example, the ADD instruction (line 0C in the program of Figure~7.1) 
requires three operands (two
sources to obtain the numbers to be added, and one destination to
designate where the result is to be stored).  All three operands must
be explicitly identified in the instruction.
\begin{colorverbatim}
AGAIN    ADD    R3,R3,R2
\end{colorverbatim}
In this case the operands to be added are obtained from register 2 and from
register 3. The result is to be placed in register 3.  We represent
each of the registers 0 through 7 as R0, R1, R2, $\ldots$ , R7,
rather than 000, 001, 010, $\ldots$ , 111.

The LD instruction (line 07 of the program in Figure~7.1) requires two operands 
(the memory location from which the value is to be read and the destination
register that is to contain the value after the instruction finishes 
execution).  In LC-3 Assembly Language, We assign symbolic names called {\em labels} 
to the memory locations so we will not have to remember their explicit 16 bit 
addresses.  In this case, the location from which \index{labels} the value is to 
be read is given the label {\em NUMBER}.  The destination (i.e., where 
the value is to be loaded) is register 2.
\begin{colorverbatim}
LD   R2, NUMBER
\end{colorverbatim}
As we discussed in Section~5.1.6, operands can be obtained from
registers, from memory, or they may be literal (i.e., immediate)
values in the instruction.  In the case of register operands, the
registers are explicitly represented (such as R2 and R3 in line 0C).
In the case of memory operands, the symbolic name of the memory
location is explicitly represented (such as NUMBER in line 07 and SIX
in line 06).  In the case of immediate operands, the actual value is
explicitly represented (such as the value 0 in line 08).
\begin{colorverbatim}
AND  R3, R3, #0 ; Clear R3. It will contain the product.
\end{colorverbatim}
A literal value must contain a symbol identifying the representation
base \index{literal} of the number.  We use \# for decimal, x for
hexadecimal, and b for binary.  Sometimes there is no ambiguity, such
as in the case 3F0A, which \index{decimal!symbol for}
\index{hexadecimal!symbol for} \index{binary!symbol for} is a hex
number.  Nonetheless, we write it as x3F0A.  Sometimes there is
ambiguity, such as in the case 1000.  x1000 represents the decimal
number 4096, b1000 represents the decimal number 8, and \#1000
represents the decimal number 1000.

%7.2.1.2
\subsubsection{Labels}

Labels are symbolic names that are used to identify memory locations
that are referred to explicitly in the program.  In LC-3 assembly
language, a label consists of from one to 20 alphanumeric characters
(i.e., each character is a capital or lowercase letter of the English 
alphabet, or a decimal digit), starting with a letter of the alphabet.  

However, not all sequences of characters that follow these rules can be
used as labels.  You know that computer programs can not tolerate
ambiguity.  So, ADD, NOT, x1000, R4 and other character strings 
that have specific meanings in an LC-3 program can not be used as labels. 
They could confuse the LC-3 Assembler as it tries to translate the
LC-3 Assembly Language program into a program in the LC-3 ISA.
Such not-allowed character strings are often referred to 
as {\em reserved words}.

NOW, Under21, R2D2, R785,
and C3PO are all examples of legitimate LC-3 assembly language labels.

We said we give a label (i.e., a symbolic name) to a memory locaton if we 
explicitly refer to it in the program.  There are two reasons for 
explicitly referring to a memory location.

\begin{enumerate}[2.]
\item[1.] The location is the target of a branch instruction
(for example, AGAIN in line 0C).  That is, the label AGAIN identifies the 
location of the instruction that will be executed next if the branch
is taken.  
\item[2.] The location contains a value that is loaded or stored (for
example, NUMBER in line 12, and SIX in line 13).
\end{enumerate}

Note the location AGAIN (identified in line 0C) is specifically 
referenced by the branch instruction in line~0E.

\begin{colorverbatim}
BRp   AGAIN
\end{colorverbatim}

If the result of ADD R1,R1,\#--1 is positive (which results in the 
P bit being set), then the program branches to the location
explicitly referenced as AGAIN to perform another iteration.

The location NUMBER is specifically referenced by the load instruction
in line 07.  The value stored in the memory location explicitly
referenced as NUMBER is loaded into R2.

If a location in the program is not explicitly referenced, then there
is no need to give it a label.  

%7.2.1.3
\subsubsection{Comments}
Comments are messages intended only for human consumption.  They have
\index{comments} no effect on the translation process and indeed are
not acted on by the LC-3 assembler.  They are identified in the
program by semicolons.  A semicolon signifies that the rest of the
line is a comment and is to be ignored by the assembler.  If the
semicolon~is the first nonblank character on the line, the entire line
is ignored.  If the semicolon follows the operands of an instruction,
then only the comment is ignored by the assembler.

The purpose of comments is to make the program more comprehensible to
the human reader.  Comments help explain a nonintuitive aspect of an
instruction or a set of instructions.  In lines 08 and 09, the comment
``Clear R3; it will contain the product'' lets the reader know that
the instruction on line 08 is initializing R3~prior to accumulating
the product of the two numbers.  While the purpose of line~08 may be
obvious to the programmer today, it may not be the case two years from
now, after the programmer has written an additional 30,000 instructions
and cannot remember why he/she wrote AND R3,R3,\#0.  It may also
be the case that two years from now, the programmer no longer works
for the company and the company needs to modify the program in
response to a product update.  If the task is assigned to someone who
has never seen the program before, comments go a long way toward
helping that person understand the program.

It is important to make comments that provide additional insight and
not just restate the obvious.  There are two reasons for this.  First,
comments that restate the obvious are a waste of everyone's time. \lightbulb[-11pt]
Second, they tend to obscure the comments that say something important
because they add clutter to the program.  For example, in line 0D, the
comment ``Decrement R1'' would be a bad idea.  It would provide no
additional insight to the instruction, and it would add clutter to the
page.

Another purpose of comments is to make the visual presentation of a program
easier to understand.  That is, comments are used to separate
pieces of a program from each other to make the program more
readable.  Lines of code that work together to compute a
single result are placed on successive lines, but are separated from the rest
of the program by blank lines.
For example, note that lines 0C through 0E, which together form the
loop body which is the crux of this computer program are separated 
from the rest of the code by lines 0B and 0F.  There is nothing on 
lines 0B and 0F other than the semicolons in the first column.

Incidentally, another opportunity to make a program easier to read
is the judicious use of white space, accomplished by adding extra spaces
to a line that are ignored by the assembler -- for example, having all the 
opcodes start in the same column on the page, whether or not the instruction
has a label.

%7.2.2
\subsection{Pseudo-ops (Assembler Directives)}

The LC-3 assembler is a program that takes as input a string of
characters representing a computer program written in LC-3 assembly
language and translates it into a program in the ISA of the LC-3.
Pseudo-ops help the assembler perform that task.
\index{pseudo-ops}

The more formal name for a pseudo-op is {\em assembler directive}.  
\index{assembler!directives} It is called a pseudo-op because, like its
Greek root "pseudes" (which means "false"), it does not refer to an
operation that will be performed by the program during execution.  Rather, 
the pseudo-op is strictly a message from the assembly language programmer 
to the assembler to help the assembler in the assembly process.  Once
the assembler handles the message, the pseudo-op is discarded.  The
LC-3 assembly language contains five pseudo-ops that we will find useful
in our assembly language programming: .ORIG, .FILL, .BLKW,
.STRINGZ, and .END.  All are easily recognizable by the dot as their
first character.

%7.2.2.1
\subsubsection{.ORIG}
.ORIG tells the assembler where in memory to place the LC-3 program.
In line~05, .ORIG x3050 says, place the first LC-3 ISA instruction in
location x3050.  As a result, 0010001000001100 (the translated 
LD R1,SIX instruction) is put in location x3050.  ...and the rest
of the translated LC-3 program is placed in the subsequent sequential
locations in memory.  For example, if the program consists of x100 LC-3
instructions, and .ORIG says to put the first instruction in x3050, the
remaining xFF instructions are placed in locations x3051 to x314F. 

%7.2.2.2
\subsubsection{.FILL}
.FILL tells the assembler to set aside the next location in the
program and initialize it with the value of the operand.  The value can be
either a number or a label.  In line 13,
the ninth location in the resulting LC-3 program is initialized to the
value x0006.

%7.2.2.3
\subsubsection{.BLKW}
.BLKW tells the assembler to set aside some number of sequential
memory locations (i.e., a {\bf BL}oc{\bf K} of {\bf W}ords) in the
program.  The actual number is the operand of the .BLKW pseudo-op.  In
line 12, the pseudo-op instructs the assembler to set aside one
location in memory (and, incidentally, to label it NUMBER).

The pseudo-op .BLKW is particularly useful when the
actual value of the operand is not yet known.  In our example we assumed
the number in location NUMBER was 123.  How did it get there?  A common
use of .BLKW is to set aside a location in the program, as we did here,
and have another section of code produce the number, perhaps from input
from a keyboard (which we can not know at the time we write the program), 
and store that value into NUMBER before we execute the code in Figure~7.1.

%7.2.2.4
\subsubsection{.STRINGZ}
.STRINGZ tells the assembler to initialize a sequence of $n+1$ memory
locations. The argument is a sequence of $n$ characters, inside double
quotation marks.  The first $n$ words of memory are initialized with
the zero-extended ASCII codes of the corresponding characters in the
string.  The final word of memory is initialized to 0. The last word, 
containing x0000, provides a convenient sentinel for processing the
string of ASCII codes.

For example, the code fragment
\begin{colorverbatim}
        .ORIG     x3010
HELLO   .STRINGZ  "Hello, World!"
\end{colorverbatim}
would result in the assembler initializing locations x3010 through
x301D to the following values:
\begin{colorverbatim}
x3010: x0048
x3011: x0065
x3012: x006C
x3013: x006C
x3014: x006F
x3015: x002C
x3016: x0020
x3017: x0057
x3018: x006F
x3019: x0072
x301A: x006C
x301B: x0064
x301C: x0021
x301D: x0000
\end{colorverbatim}

%7.2.2.5
\subsubsection{.END}
.END tells the assembler it has reached the end of the program, and need not
even look at anything after it.  That is, any characters that
come after .END will not be processed by the assembler.  {\em Note:} .END
does not stop the program during execution.  In fact, .END does not
even {\bf exist} at the time of execution.  It is simply a delimiter---it
marks the end of the program.  It is a message from the programmer,
telling the assembler where the assembly language program ends.


%7.2.3
\subsection{Example: The Character Count Example of Section 5.5,
  Revisited again!}

\looseness=-1
Now we are ready for a complete example.  Let's consider
again the problem of Section 5.5.  We wish to write a program that
will take a character that is input from the keyboard and
count the number of occurrences of that character in a file.  As
before, we first develop the algorithm by constructing the flowchart.
Recall that in Section 6.1, we showed how to decompose the problem
systematically so as to generate the flowchart of Figure~5.16.  In
fact, the final step of that process in Chapter~6 is the flowchart of
Figure~6.3e, which is essentially identical to Figure~5.16.  Next, we
use the flowchart to write the actual program.  This time, however, we
enjoy the luxury of not worrying about 0s and 1s and instead write the
program in LC-3 assembly language.  The program is shown in\break
Figure~7.2.

\pagebreak

%Figure 7.2
\begin{figure}
\begin{Verbatim}[fontsize=\fontsize{8}{9.5}\selectfont,formatcom=\color{seventyblack}]
01   ;
02   ; Program to count occurrences of a character in a file.
03   ; Character to be input from the keyboard.
04   ; Result to be displayed on the monitor.
05   ; Program works only if no more than 9 occurrences are found.
06   ;
07   ;
08   ; Initialization
09   ;
0A           .ORIG   x3000
0B           AND     R2,R2,#0      ; R2 is counter, initialize to 0
0C           LD      R3,PTR        ; R3 is pointer to characters
0D           TRAP    x23           ; R0 gets character input
0E           LDR     R1,R3,#0      ; R1 gets the next character
0F   ;
10   ; Test character for end of file
11   ;
12   ;
13   TEST    ADD     R4,R1,#-4     ; Test for EOT
14           BRz     OUTPUT        ; If done, prepare the output
15   ;
16   ; Test character for match.  If a match, increment count.
17   ;
18           NOT     R1,R1
19           ADD     R1,R1,#1      ; R1 <-- -R1
1A           ADD     R1,R1,R0      ; R1 <-- R0-R1. If R1=0, a match!
1B           BRnp    GETCHAR       ; If no match, do not increment
1C           ADD     R2,R2,#1
1D   ;
1E   ; Get next character from the file
1F   ;
20   GETCHAR ADD     R3,R3,#1      ; Increment the pointer
21           LDR     R1,R3,#0      ; R1 gets the next character to test
22           BRnzp   TEST
23   ;
24   ; Output the count.
25   ;
26   OUTPUT  LD      R0,ASCII      ; Load the ASCII template
27           ADD     R0,R0,R2      ; Convert binary to ASCII
28           TRAP    x21           ; ASCII code in R0 is displayed
29           TRAP    x25           ; Halt machine
2A   ;
2B   ; Storage for pointer and ASCII template
2C   ;
2D   ASCII   .FILL   x0030
2E   PTR     .FILL   x4000
2F           .END
\end{Verbatim}
\caption{The assembly language program to count occurrences of a
  character}
\vspace{-12pt}
\end{figure}

A few comments about this program: Three times during this program, 
assistance in the form of a service
call is required of the operating system.  In each case, a TRAP
instruction is used.  TRAP x23 causes a character to be input from the
keyboard and placed in R0 (line 0D).  TRAP x21 causes the ASCII code
in R0 to be displayed on the monitor (line 28).  TRAP x25 causes the
machine to be halted (line 29).  As we said before, we will leave the
details of how the TRAP instruction is carried out until Chapter~9.

The ASCII codes for the decimal digits 0 to 9 (0000 to 1001) are x30
to x39.  The conversion from binary to ASCII is done simply by adding
x30 to the binary value of the decimal digit.  Line 2D shows the label
ASCII used to identify the memory location containing x0030.  The LD
instruction in line 26 uses it to load x30 into R0, so it can convert
the count which is in R2 from a binary value to an ASCII code.  That is
done  by the ADD instruction in line 27.  TRAP x21 in line 28 prints 
the ASCII code to the monitor.

The file that is to be examined starts at address x4000 (see line 2E).
Usually, this starting address would not be known to the programmer
who is writing this program since we would want the program to work on
many files, not just the one starting at x4000.  To accomplish that,
line 2E would be replaced with .BLKW 1, and be filled in by some other
piece of code that knew the starting address of the desired file 
before executing the program of Figure~7.2.  That situation 
will be discussed in Section 7.4.

\vspace{-12pt}

%7.3
\section{The Assembly Process}

%7.3.1
\subsection{Introduction}

Before an LC-3 assembly language program can be executed, it must
first be translated into a machine language program, that is, one in
which each instruction is in the LC-3 ISA.  It is the job of the LC-3
assembler to perform that translation.

If you have available an LC-3 assembler, you can cause it to translate
your assembly language program into a machine language program by
executing an appropriate command.  In the LC-3 assembler that is
generally available via the Web, that command is {\em assemble} and
requires as an argument the filename of your assembly language
program.  For example, if the filename is solution1.asm, then
\begin{colorverbatim}
                 assemble solution1.asm outfile
\end{colorverbatim}
produces the file outfile, which is in the ISA of the LC-3.  It is
necessary to check with your instructor for the correct command line
to cause the LC-3 assembler to produce a file of 0s and 1s in the ISA
of the LC-3.

\vspace{-6pt}

%7.3.2
\subsection{A Two-Pass Process}

In this section, we will see how the assembler goes through the
process of translating an assembly language program into a machine
language program. We will use as our input to the process the assembly
language program of Figure~7.2.

You remember that there is in general a one-to-one correspondence
between instructions in an assembly language program and instructions
in the final machine language program.  We could try to perform this
translation in one pass through the assembly language program.
Starting from the top of Figure~7.2, the assembler discards lines 01
to 09, since they contain only comments.  Comments are strictly for
human consumption; they have no bearing on the translation process.
The assembler then moves on to line 0A.  Line 0A is a pseudo-op; it
tells the assembler that the machine language program is to start at
location x3000.  The assembler then moves on to line 0B, which it can
easily translate into LC-3 machine code.  At this point, we have
\begin{colorverbatim}
                   x3000:  0101010010100000
\end{colorverbatim}
The LC-3 assembler moves on to translate the next instruction (line
0C).  Unfortunately, it is unable to do so since it does not know
the meaning of the symbolic address PTR.  At this point the assembler
is stuck, and the assembly process fails.

To prevent this from occurring, the assembly process is done in two
complete passes (from beginning to .END) through the entire assembly
language program.  The objective of the first pass is to identify the
actual binary addresses corresponding to the symbolic names (or
labels).  This set of correspondences is known as the {\em symbol
  table}.  In pass 1, we construct the symbol table.  \index{symbol
  table} In pass 2, we translate the individual assembly language
instructions into their corresponding machine language instructions.

Thus, when the assembler examines line 0C for the purpose of
translating
\begin{colorverbatim}
                         LD R3,PTR
\end{colorverbatim}
during the second pass, it already knows that PTR is the symbolic 
address of memory location x3013 (from the first pass).  Thus it can 
easily translate line 0C to
\begin{colorverbatim}
                 x3001:  0010011000010001
\end{colorverbatim}
The problem of not knowing the
16-bit address corresponding to PTR no longer exists.

%7.3.2.1
\subsection{The First Pass: Creating the Symbol Table}
\label{sec:symbol_table}
For our purposes, the symbol table is simply a correspondence of
symbolic names with their 16-bit memory addresses.  We obtain these
correspondences by passing through the assembly language program once,
noting which instruction is assigned to which memory location, and 
identifying each label with the memory address of its assigned entry.

Recall that we provide labels in those cases where we have to refer to
a location, either because it is the target of a branch instruction or
because it contains data that must be loaded or stored.  Consequently,
if we have not made any programming mistakes, and if we identify all
the labels, we will have identified all the symbolic addresses used in
the program.

The preceding paragraph assumes that our entire program exists between
our .ORIG and .END pseudo-ops. This is true for the assembly language
program of Figure~7.2.  In Section 7.4, we will consider programs that
consist of multiple parts, each with its own .ORIG and .END, wherein
each part is assembled separately.

The first pass starts, after discarding the comments on lines 01 to
09, by noting (line 0A) that the first instruction will be assigned to
address x3000.  We keep track of the location assigned to each
instruction by means of a location counter (LC).  The LC is
initialized to the address specified in .ORIG, that is, x3000.

The assembler examines each instruction in sequence and increments the
LC once for each assembly language instruction.  If the instruction
examined contains a label, a symbol table entry is made for that
label, specifying the current contents of LC as its address.  The
first pass terminates when the .END pseudo-op is reached. 

The first instruction that has a label is at line 13.  Since it is the
fifth instruction in the program and since the LC at that point
contains x3004, a symbol table entry is constructed thus:
$$
\mbox{\begin{tabular}{cc}\hline
\multicolumn{1}{|c|}{{\ttfamily\fontsize{9}{10pt}\selectfont Symbol}}
& \multicolumn{1}{c|}{{\ttfamily\fontsize{9}{10pt}\selectfont Address}}\\\hline\hline
\multicolumn{1}{|c|}{{\ttfamily\fontsize{9}{10pt}\selectfont TEST}}
& \multicolumn{1}{c|}{{\ttfamily\fontsize{9}{10pt}\selectfont x3004}}\\\hline
\end{tabular}}
$$
The second instruction that has a label is at line 20.  At this
point, the LC has been incremented to x300B.  Thus a symbol table
entry is constructed, as follows:
$$
\mbox{
\begin{tabular}
{cc}
\hline
\multicolumn{1}{|c|}{{\ttfamily\fontsize{9}{10pt}\selectfont Symbol}}&
\multicolumn{1}{c|}{{\ttfamily\fontsize{9}{10pt}\selectfont Address}} \\
\hline
\hline
\multicolumn{1}{|c|}{{\ttfamily\fontsize{9}{10pt}\selectfont GETCHAR}}&
\multicolumn{1}{c|}{{\ttfamily\fontsize{9}{10pt}\selectfont x300B}}\\\hline
\end{tabular}}
$$
At the conclusion of the first pass, the symbol table has the
following entries:
$$
\mbox{
\begin{tabular}
{ll}
\hline
\multicolumn{1}{|c|}{{\ttfamily\fontsize{9}{10pt}\selectfont Symbol}}&
\multicolumn{1}{c|}{{\ttfamily\fontsize{9}{10pt}\selectfont Address}} \\
\hline
\hline
\multicolumn{1}{|l|}{{\ttfamily\fontsize{9}{10pt}\selectfont TEST}}&
\multicolumn{1}{l|}{{\ttfamily\fontsize{9}{10pt}\selectfont x3004}} \\
\hline
\multicolumn{1}{|l|}{{\ttfamily\fontsize{9}{10pt}\selectfont GETCHAR}}&
\multicolumn{1}{l|}{{\ttfamily\fontsize{9}{10pt}\selectfont x300B}} \\
\hline
\multicolumn{1}{|l|}{{\ttfamily\fontsize{9}{10pt}\selectfont OUTPUT}}&
\multicolumn{1}{l|}{{\ttfamily\fontsize{9}{10pt}\selectfont x300E}} \\
\hline
\multicolumn{1}{|l|}{{\ttfamily\fontsize{9}{10pt}\selectfont ASCII}}&
\multicolumn{1}{l|}{{\ttfamily\fontsize{9}{10pt}\selectfont x3012}} \\
\hline
\multicolumn{1}{|l|}{{\ttfamily\fontsize{9}{10pt}\selectfont PTR}}&
\multicolumn{1}{l|}{{\ttfamily\fontsize{9}{10pt}\selectfont x3013}} \\
\hline
\end{tabular}}
$$

%7.3.2.2
\subsection{The Second Pass: Generating the\break Machine
Language Program}

The second pass consists of going through the assembly language
program a second time, line by line, this time with the help of the
symbol table. At each line, the assembly language instruction is
translated into an LC-3 machine language instruction.

Starting again at the top, the assembler again discards lines 01
through 09 because they contain only comments.  Line 0A is the .ORIG
pseudo-op, which the assembler uses to initialize LC to x3000.  The
assembler moves on to line 0B and produces the machine language
instruction 0101010010100000.  Then the assembler moves on to line 0C.

This time, when the assembler gets to line 0C, it can completely
assemble the instruction since it knows that PTR corresponds to x3013.
The instruction is LD, which has an opcode encoding of 0010.  The
destination register (DR) is R3, that is, 011.

The only part of the LD instruction left to do is the PCoffset.
It is computed as follows: The assembler knows that PTR is the label for
address x3013, and that the incremented PC is LC+1, in this case
x3002.  Since PTR (x3013) must be the sum of the incremented PC
(x3002) and the sign-extended PCoffset, PCoffset must be x0011.
Putting this all together, the assembler sets x3001 to 0010011000010001, 
and increments the LC to x3002.

{\em Note}: In order to use the LD instruction, it is necessary that
the source of the load, in this case the address whose label is PTR,
is not more than $+$256 or $-$255 memory locations from the LD instruction
itself.  If the address of PTR had been greater than LC$+$1$+$255 or less
than LC$+$1$-$256, then the offset would not fit in bits [8:0] of the
instruction.  In such a case, an assembly error would have occurred,
preventing the assembly process from finishing successfully.
Fortunately, PTR is close enough to the LD instruction, so the
instruction assembled correctly.

The second pass continues.  At each step, the LC is incremented and
the location specified by LC is assigned the translated LC-3
instruction or, in the case of .FILL, the value specified. When the
second pass encounters the .END pseudo-op, assembly terminates.

The resulting translated program is shown in Figure~7.3.

%Figure 7.3
\begin{figure}
\begin{center}
\small
\begin{tabular}
{cc}
\hline
\multicolumn{1}{|c|}{Address}&
\multicolumn{1}{c|}{Binary} \\
\hline
\hline
\multicolumn{1}{|c|}{}&
\multicolumn{1}{|c|}{0011000000000000} \\
\hline
\multicolumn{1}{|c|}{x3000}&
\multicolumn{1}{|c|}{0101010010100000} \\
\hline
\multicolumn{1}{|c|}{x3001}&
\multicolumn{1}{|c|}{0010011000010001} \\
\hline
\multicolumn{1}{|c|}{x3002}&
\multicolumn{1}{|c|}{1111000000100011} \\
\hline
\multicolumn{1}{|c|}{x3003}&
\multicolumn{1}{|c|}{0110001011000000} \\
\hline
\multicolumn{1}{|c|}{x3004}&
\multicolumn{1}{|c|}{0001100001111100} \\
\hline
\multicolumn{1}{|c|}{x3005}&
\multicolumn{1}{|c|}{0000010000001000} \\
\hline
\multicolumn{1}{|c|}{x3006}&
\multicolumn{1}{|c|}{1001001001111111} \\
\hline
\multicolumn{1}{|c|}{x3007}&
\multicolumn{1}{|c|}{0001001001100001} \\
\hline
\multicolumn{1}{|c|}{x3008}&
\multicolumn{1}{|c|}{0001001001000000} \\
\hline
\multicolumn{1}{|c|}{x3009}&
\multicolumn{1}{|c|}{0000101000000001} \\
\hline
\multicolumn{1}{|c|}{x300A}&
\multicolumn{1}{|c|}{0001010010100001} \\
\hline
\multicolumn{1}{|c|}{x300B}&
\multicolumn{1}{|c|}{0001011011100001} \\
\hline
\multicolumn{1}{|c|}{x300C}&
\multicolumn{1}{|c|}{0110001011000000} \\
\hline
\multicolumn{1}{|c|}{x300D}&
\multicolumn{1}{|c|}{0000111111110110} \\
\hline
\multicolumn{1}{|c|}{x300E}&
\multicolumn{1}{|c|}{0010000000000011} \\
\hline
\multicolumn{1}{|c|}{x300F}&
\multicolumn{1}{|c|}{0001000000000010} \\
\hline
\multicolumn{1}{|c|}{x3010}&
\multicolumn{1}{|c|}{1111000000100001} \\
\hline
\multicolumn{1}{|c|}{x3011}&
\multicolumn{1}{|c|}{1111000000100101} \\
\hline
\multicolumn{1}{|c|}{x3012}&
\multicolumn{1}{|c|}{0000000000110000} \\
\hline
\multicolumn{1}{|c|}{x3013}&
\multicolumn{1}{|c|}{0100000000000000} \\
\hline
\end{tabular}
\end{center}
\caption{The machine language program for the
assembly language program of Figure~7.2}
\vspace{12pt}
\end{figure}

That process was, on a good day, merely tedious. Fortunately, you do
not have to do it for a living---the LC-3 assembler does that.  And,
since you now know the LC-3 assembly language, there is no need to program
in machine language.  Now we can write our programs symbolically in
LC-3 assembly language and invoke the LC-3 assembler to create the
machine language versions that can execute on an LC-3 computer.

\vspace{-6pt}

%7.4
\section{Beyond the Assembly of a Single Assembly Language Program}

Our purpose in this chapter has been to take you up one more step
from the ISA of the computer and introduce assembly language.
Although it is still quite a large step from C or C++, assembly
language does, in fact, save us a good deal of pain.  We have also
shown how a rudimentary two-pass assembler actually works to translate
an assembly language program into the machine language of the LC-3~ISA.

There are many more aspects to sophisticated assembly language
programming that go well beyond an introductory course. However, our
reason for teaching assembly language is not to deal with its
sophistication, but rather to show its innate simplicity. Before we
leave this chapter, however, there are a few additional highlights we
should explore.

%7.4.1
\subsection{The Executable Image}
\label{sec:exe_image}

When a computer begins execution of a program, the entity being
executed is called an {\em executable image}. The executable image is
created from modules \index{executable image} often created
independently by several different programmers.  Each module is
translated separately into an object file. We have just gone through
the process of performing that translation ourselves by mimicking the
LC-3 assembler. Other modules, some written in C perhaps, are
translated by the C compiler.  Some modules are written by users, and
some modules are supplied as library routines by the operating system.
Each object file consists of instructions in the ISA of the computer
being used, along with its associated data. The final step is to combine
(i.e., {\em link}) all the object modules together into one
\index{linking}
executable image. During execution of the program, the FETCH, DECODE,
$\ldots$ instruction cycle is applied to instructions in the
executable image.

%7.4.2
\subsection{More than One Object File}
\label{sec:obj_file}
\index{linking!more than one object file} It is very common to form an
executable image from more than one object file. In fact, in the real
world, where most programs invoke libraries provided by the operating
system as well as modules generated by other programmers, it is much
more common to have multiple object files than a single one.

A case in point is our example character count program. The program
counts the number of occurrences of a character in a file. A typical
application could easily have the program as one module and the input
data file as another. If this were the case, then the starting address
of the file, shown as x4000 in line 2E of Figure~7.2, would not be
known when the program was written. If we replace line 2E with
\begin{colorverbatim}
                   PTR  .FILL   STARTofFILE
\end{colorverbatim}
then the program of Figure~7.2 will not assemble because there will
be no symbol table entry for STARTofFILE.  What can we do?

If the LC-3 assembly language, on the other hand, contained the
\hbox{pseudo-op} .EXTERNAL, we could identify STARTofFILE as the symbolic
name of an address that is not known at the time the program of
Figure~7.2 is assembled.  This would be done by the following line
\begin{colorverbatim}
                   .EXTERNAL    STARTofFILE,
\end{colorverbatim}
which would send a message to the LC-3 assembler that the absence of
label STARTofFILE is not an error in the program. Rather, STARTofFILE
is a label in some other module that will be translated independently.
In fact, in our case, it will be the label of the location of the
first character in the file to be examined by our character count
program.

If the LC-3 assembly language had the pseudo-op .EXTERNAL, and if we
had designated STARTofFILE as .EXTERNAL, the LC-3 assembler would be able to
create a symbol table entry for STARTofFILE, and instead of assigning
it an address, it would mark the symbol as belonging to another
module.  At {\em link time,} when all the modules are combined, the
linker (the program that manages the ``combining'' process) would use
the symbol table entry for STARTofFILE in \index{linker} another
module to complete the translation of our revised line 2E.

In this way, the .EXTERNAL pseudo-op allows references by one module
to symbolic locations in another module without a problem.  The proper
translations are resolved by the linker.

\vspace{-2pc}

\begin{exercises}
\item[7.1] An assembly language program contains the following two
  instructions.  The assembler puts the translated version of the LDI
  instruction that follows into location x3025 of the object module.
  After assembly is complete, what is in location x3025?
\medskip
\begin{lstlisting}
     PLACE   .FILL   x45A7
             LDI     R3, PLACE
\end{lstlisting}
\medskip

\item[7.2] An LC-3 assembly language program contains the instruction:
\medskip
\begin{lstlisting}
        ASCII   LD  R1, ASCII
\end{lstlisting}
\medskip
\noindent
The symbol table entry for ASCII is x4F08. If this instruction is
executed during the running of the program, what will be contained in
R1 immediately after the instruction is executed?

\item[7.3] What is the problem with using the string AND as a label?

\item[7.4] Create the symbol table entries generated by the assembler
  when translating the following routine into machine code:
\medskip
\begin{lstlisting}
                .ORIG   x301C
                ST      R3, SAVE3
                ST      R2, SAVE2
                AND     R2, R2, #0
        TEST    IN
                BRz     TEST
                ADD     R1, R0, #-10
                BRn     FINISH
                ADD     R1, R0, #-15
                NOT     R1, R1
                BRn     FINISH
                HALT
        FINISH  ADD     R2, R2, #1
                HALT
        SAVE3   .FILL   X0000
        SAVE2   .FILL   X0000
                .END
\end{lstlisting}

\newpage

\item[7.5]
\begin{enumerate}[a.]
\item[a.]  What does the following program do?
\bigskip
\medskip
\vspace{-2pt}
\begin{colorverbatim}
                .ORIG   x3000
                LD      R2, ZERO
                LD      R0, M0
                LD      R1, M1
        LOOP    BRz     DONE
                ADD     R2, R2, R0
                ADD     R1, R1, -1
                BR      LOOP
        DONE    ST      R2, RESULT
                HALT
        RESULT  .FILL   x0000
        ZERO    .FILL   x0000
        M0      .FILL   x0004
        M1      .FILL   x0803
                .END
\end{colorverbatim}
\bigskip
\medskip
\vspace{-2pt}

\item[b.]  What value will be contained in {\tt RESULT} after
  the program runs to completion?
\end{enumerate}

\item[7.6] Our assembler has crashed and we need your help! Create 
  a symbol table for the program shown below, and assemble the 
  instructions at labels A, B and D.
\bigskip
\medskip
\vspace{-2pt}
\begin{colorverbatim}
                .ORIG    x3000
                AND      R0, R0, #0
        A       LD       R1, E
                AND      R2, R1, #1
                BRp      C
        B       ADD      R1, R1, #-1
        C       ADD      R0, R0, R1
                ADD      R1, R1, #-2
        D       BRp      C
                ST       R0, F
                TRAP     x25
        E       .BLKW    1
        F       .BLKW    1
                .END
\end{colorverbatim}
\bigskip
\medskip
\vspace{-2pt}

\noindent
You may assume another module deposits a positive value into E 
before the module executes. In fifteen words or fewer, what does 
the above program do?

\item[7.7] Write an LC-3 assembly language program that counts the
  number of 1s in the value stored in R0 and stores the result into
  R1. For example, if R0 contains 0001001101110000, then after the
  program executes, the result stored in R1 would be 0000 0000 0000
  0110.

\newpage

\item[7.8] An engineer is in the process of debugging a program she
  has written. She is looking at the following segment of the program,
  and decides to place a breakpoint in memory at location 0xA404.
  Starting with the ${\rm PC}=0{\rm xA}400$, she initializes all the
  registers to zero and runs the program until the breakpoint is
  encountered.

\bigskip

\begin{lstlisting}
Code Segment:
...
0xA400  THIS1  LEA    R0, THIS1
0xA401  THIS2  LD     R1, THIS2
0xA402  THIS3  LDI    R2, THIS5
0xA403  THIS4  LDR    R3, R0, #2
0xA404  THIS5  .FILL  xA400
...
\end{lstlisting}\vspace{10pt}
  Show the contents of the register file (in hexadecimal) when the
  breakpoint is encountered.

\item[7.9] What is the purpose of the {\tt .END} pseudo-op?
  How does it differ from the HALT instruction?

\item[7.10] The following program fragment has an error in it.
  Identify the error and explain how to fix it.
\bigskip
\begin{colorverbatim}
                  ADD     R3, R3, #30
                  ST      R3, A
                  HALT
           A      .FILL   #0
\end{colorverbatim}
\bigskip\vspace{-3pt}

\noindent
  Will this error be detected when this code is assembled or when this
  code is run on the LC-3?

\item[7.11] The LC-3 assembler must be able to convert constants
  represented in ASCII into their appropriate binary values.  For
  instance, x2A translates into 00101010 and \#12 translates into
  00001100. Write an LC-3 assembly language program that reads a
  decimal or hexadecimal constant from the keyboard (i.e., it is
  preceded by a \# character signifying it is a decimal, or x
  signifying it is hex) and prints out the binary representation.
  Assume the constants can be expressed with no more than two decimal
  or hex digits.

\newpage

\item[7.12] What does the following LC-3 program do?\vspace{10pt}

\begin{lstlisting}
                   .ORIG   x3000
                   AND     R5, R5, #0
                   AND     R3, R3, #0
                   ADD     R3, R3, #8
                   LDI     R1, A
                   ADD     R2, R1, #0
           AG      ADD     R2, R2, R2
                   ADD     R3, R3, #-1
                   BRnp    AG
                   LD      R4, B
                   AND     R1, R1, R4
                   NOT     R1, R1
                   ADD     R1, R1, #1
                   ADD     R2, R2, R1
                   BRnp    NO
                   ADD     R5, R5, #1
           NO      HALT
           B       .FILL   xFF00
           A       .FILL   x4000
                   .END
\end{lstlisting}\vspace{4pt}

\item[7.13] The following program adds the values stored in memory
  locations A, B, and C, and stores the result into memory. There are
  two errors in the code. For each, describe the error and indicate
  whether it will be detected at assembly time or at run time.

\medskip

\begin{lstlisting}
Line No.
1                .ORIG  x3000
2        ONE     LD  R0, A
3                ADD R1, R1, R0
4        TWO     LD  R0, B
5                ADD R1, R1, R0
6        THREE   LD  R0, C
7                ADD R1, R1, R0
8                ST  R1, SUM
9                TRAP  x25
10       A       .FILL x0001
11       B       .FILL x0002
12       C       .FILL x0003
13       D       .FILL x0004
14               .END
\end{lstlisting}\newpage

\item[7.14]
\begin{enumerate}[a.]
\item[a.] Assemble the following program:

\begin{lstlisting}
                   .ORIG   x3000
                   STI     R0, LABEL
                   OUT
                   HALT
           LABEL   .STRINGZ "%"
                   .END
\end{lstlisting}

\item[b.]  The programmer intended the program to output a
  {\tt\bfseries \%} to the monitor, and then halt. Unfortunately, the
  programmer got confused about the semantics of each of the opcodes
  (that is, exactly what function is carried out by the LC-3 in
  response to each opcode).  Replace exactly {\bf one} opcode in this
  program with the correct opcode to make the program work as
  intended.

\item[c.]  The original program from part $a$ was executed. However,
  execution exhibited some very strange behavior. The strange behavior
  was in part due to the programming error, and in part due to the
  fact that the value in R0 when the program started executing was
  x3000. Explain what the strange behavior was and why the program
  behaved that way.
\end{enumerate}

\item[7.15] The following is an LC-3 program that performs a function.
  Assume a sequence of integers is stored in consecutive memory
  locations, one integer per memory location, starting at the location
  x4000. The sequence terminates with the value x0000. What does the
  following program do?

\begin{colorverbatim}
                .ORIG   x3000
                LD     R0, NUMBERS
                LD     R2, MASK
        LOOP    LDR    R1, R0, #0
                BRz    DONE
                AND    R5, R1, R2
                BRz    L1
                BRnzp  NEXT
        L1      ADD    R1, R1, R1
                STR    R1, R0, #0
        NEXT    ADD    R0, R0, #1
                BRnzp  LOOP
        DONE    HALT
        NUMBERS .FILL  x4000
        MASK    .FILL  x8000
        .END













\end{colorverbatim}

\item[7.16] Assume a sequence of nonnegative integers is stored in
  consecutive memory locations, one integer per memory location,
  starting at location x4000.  Each integer has a value between 0 and
  30,000 (decimal).  The sequence terminates with the value $-$1
  (i.e., xFFFF).

What does the following program do?

\begin{colorverbatim}
                .ORIG   x3000
                AND     R4, R4, #0
                AND     R3, R3, #0
                LD      R0, NUMBERS
        LOOP    LDR     R1, R0, #0
                NOT     R2, R1
                BRz     DONE
                AND     R2, R1, #1
                BRz     L1
                ADD     R4, R4, #1
                BRnzp   NEXT
        L1      ADD     R3, R3, #1
        NEXT    ADD     R0, R0, #1
                BRnzp   LOOP
        DONE    TRAP    x25
        NUMBERS .FILL   x4000
                .END
\end{colorverbatim}



\item[7.17]\looseness=-1 Suppose you write two separate assembly language modules
  that you expect to be combined by the linker.  Each module uses the
  label AGAIN, and neither module contains the pseudo-op {\tt
    .EXTERNAL AGAIN}.  Is there a problem using the label
  {\tt AGAIN} in both modules? Why or why not?

\item[7.18] The following LC-3 program compares two character strings
  of the same length. The source strings are in the {\tt
    .STRINGZ} form.  The first string starts at memory location x4000,
  and the second string starts at memory location x4100.  If the
  strings are the same, the program terminates with the value 1 in R5.
  Insert instructions at (a), (b), and (c) that will complete the
  program.\enlargethispage{15pt}

\begin{colorverbatim}
                 .ORIG  x3000
                 LD     R1, FIRST
                 LD     R2, SECOND
                 AND    R0, R0, #0
          LOOP   -------------- (a)
                 LDR    R4, R2, #0
                 BRz    NEXT
                 ADD    R1, R1, #1
                 ADD    R2, R2, #1
                 -------------- (b)
                 -------------- (c)
                 ADD    R3, R3, R4
                 BRz    LOOP
                 AND    R5, R5, #0
                 BRnzp  DONE
          NEXT   AND    R5, R5, #0
                 ADD    R5, R5, #1
          DONE   TRAP   x25
          FIRST  .FILL  x4000
          SECOND .FILL  x4100
                 .END
\end{colorverbatim}

\item[7.19] When the following LC-3 program is executed, how many
  times will the instruction at the memory address labeled
  {\tt LOOP} execute?
\medskip
\begin{lstlisting}
                   .ORIG   x3005
                   LEA     R2, DATA
                   LDR     R4, R2, #0
           LOOP    ADD     R4, R4, #-3
                   BRzp    LOOP
                   TRAP    x25
           DATA    .FILL   x000B
                   .END
\end{lstlisting}



\item[7.20] LC-3 assembly language modules (a) and (b) have been
  written by different programmers to store x0015 into memory location
  x4000. What is fundamentally different about their approaches?
\begin{enumerate}[a.]
\item[a.]
\begin{lstlisting}
             .ORIG  x5000
             AND    R0, R0, #0
             ADD    R0, R0, #15
             ADD    R0, R0, #6
             STI    R0, PTR
             HALT
        PTR  .FILL  x4000
             .END
\end{lstlisting}

\bigskip

\item[b.]
\begin{colorverbatim}
             .ORIG  x4000
             .FILL  x0015
             .END
\end{colorverbatim}
\end{enumerate}

\item[7.21] Assemble the following LC-3 assembly language program.

\begin{lstlisting}
               .ORIG   x3000
               AND     R0, R0, #0
               ADD     R2, R0, #10
               LD      R1, MASK
               LD      R3, PTR1
        LOOP   LDR     R4, R3, #0
               AND     R4, R4, R1
               BRz     NEXT
               ADD     R0, R0, #1
        NEXT   ADD     R3, R3, #1
               ADD     R2, R2, #-1
               BRp     LOOP
               STI     R0, PTR2
               HALT
        MASK   .FILL   x8000
        PTR1   .FILL   x4000
        PTR2   .FILL   x5000
               .END
\end{lstlisting}

  What does the program do (in no more than 20 words)?

\item[7.22] The LC-3 assembler must be able to map an instruction's
  mnemonic opcode into its binary opcode.  For instance, given an ADD,
  it must generate the binary pattern 0001.  Write an LC-3 assembly
  language program that prompts the user to type in an LC-3 assembly
  language opcode and then displays its binary opcode.  If the
  assembly language opcode is invalid, it displays an error message.

%\newpage

\item[7.23] The following LC-3 program determines whether a character
  string is a palindrome or not. A palindrome is a string that reads
  the same backwards as forwards. For example, the string ``racecar''
  is a palindrome. Suppose a string starts at memory location x4000,
  and is in the \verb+.STRINGZ+ format. If the string is a palindrome,
  the program terminates with the value 1 in R5. If not, the program
  terminates with the value 0 in R5. Insert instructions at (a)--(e)
  that will complete the program.
\begin{lstlisting}
               .ORIG  x3000
               LD     R0, PTR
               ADD    R1, R0, #0
        AGAIN  LDR    R2, R1, #0
               BRz    CONT
               ADD    R1, R1, #1
               BRnzp  AGAIN
        CONT   --------------(a)
        LOOP   LDR    R3, R0, #0
               --------------(b)
               NOT    R4, R4
               ADD    R4, R4, #1
               ADD    R3, R3, R4
               BRnp   NO
               --------------(c)
               --------------(d)
               NOT    R2, R0
               ADD    R2, R2, #1
               ADD    R2, R1, R2
               BRnz   YES
               --------------(e)
        YES    AND    R5, R5, #0
               ADD    R5, R5, #1
               BRnzp  DONE
        NO     AND    R5, R5, #0
        DONE   HALT
        PTR    .FILL  x4000
               .END
\end{lstlisting}

\item[7.24] We want the following program fragment to shift R3 to the
  left by four bits, but it has an error in it. Identify the error and
  explain how to fix it.
\begin{lstlisting}
              .ORIG  x3000
              AND    R2, R2, #0
              ADD    R2, R2, #4
        LOOP  BRz    DONE
              ADD    R2, R2, #-1
              ADD    R3, R3, R3
              BR     LOOP
        DONE  HALT
              .END
\end{lstlisting}

\item[7.25] What does the pseudo-op \verb+.FILL xFF004+ do?
  Why?

\item[7.26] Recall the assembly language program of problem 7.6.
Consider the following program:
\begin{lstlisting}
                .ORIG    x3000
                AND      R0, R0, #0
        D       LD       R1, A
                AND      R2, R1, #1
                BRp      B
        E       ADD      R1, R1, #-1
        B       ADD      R0, R0, R1
                ADD      R1, R1, #-2
        F       BRp      B
                ST       R0, C
                TRAP     x25
        A       .BLKW    1
        C       .BLKW    1
                .END
\end{lstlisting}
The assembler translates both assembly language programs into machine
language programs. What can you say about the two resulting machine
language programs?

\item[7.27] The following LC-3 assembly language program: 

\begin{alltt}
    
         .ORIG x3000
         AND R2, R2, #0
         AND R6, R6, #0
         ADD R2, R2, #1
TOP      ADD R3, R2, #0
         ADD R4, R1, #0
SEARCH   ADD R3, R3, R3
         ADD R4, R4, #-1
         BRp SEARCH                      
         AND R5, R3, R0
         BRz NEXT                      
         ADD R6, R6, R2
NEXT     ADD R2, R2, R2
         BRzp TOP                      
END      ST R6, RESULT
         HALT
RESULT   .BLKW 1
         .END
  
\end{alltt}
\vspace{.1in}

\noindent  What does it do (in twenty words or fewer)? Please be BRIEF but PRECISE. You can assume that some of the registers will already contain numbers that are relevant to the program.
\\

\vspace{.1in}

\noindent What is the function of R0? 
For what range of input values does the program function as you've described above?
\vspace{.1in}

\noindent What is the function of R1? 
For what range of input values does the program function as you've described above?

\vspace{.1in}

\noindent What is the function of R6? 
For what range of input values does the program function as you've described above?

\item[7.28]STAR Consider the following program: \\

\begin{verbatim}
        .ORIG x3000
        LD  R0, A
        LD  R1, B
        BRz DONE
        --------- (a)
        --------- (b)
        BRnzp AGAIN
 DONE   ST  R0, A
        HALT
 A      .FILL x0--- (c)
\begin{verbatim}
    B   .FILL x0001
        .END
\end{verbatim}

\noindent
The program uses only R0 and R1. Note lines (a) and (b) to indicate two missing instructions. Complete line (c). Note also that one of the instructions in the program must be labeled AGAIN and that label is missing. \\

\noindent
After execution of the program, the contents of A is x1800.  

\vspace{.1in}
\noindent
During execution, we examined the computer during each clock cycle, and
recorded some information for certain clock cycles, producing the table
shown below. The table is ordered by the cycle number in which the
information was collected. Note that each memory access takes 5 clock cycles. \\

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.5]{728_states.eps}
\end{center}
\end{figure}

\noindent
Fill in the missing instructions in the program, and
complete the program by labeling the appropriate instruction AGAIN. Also, fill in
the missing information in the table.\\

\noindent
Given values for A and B, what does the program do?\\

\FloatBarrier

\item[7.29]STAR An LC-3 program is executing on the LC-3 Simulator when a
breakpoint is encountered, and the Simulator stops.  At that point, {\bf the
contents of several registers are as shown in the first row of the table}.
After the run button is subsequently pushed, the next four instructions that
are executed, none of which are an STI or LDI, produce the values shown in the
table, {\bf two rows of the table per instruction executed}.  The first row of
each pair shows the contents after the fetch phase of the corresponding
instruction, and the second row of each pair after that instruction completes.
\\

\noindent
Note that some values are missing, and are presented by letters A, B, C, D, E,
F, G, H, I, and J. \\

\begin{table}[h!]
\begin{center}
\large
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
PC     & MAR   & MDR   & IR    & R0    & R1    & R2    & R3    & R4    & R5    & R6    & R7    \\ \hline \hline
x1800  & x7FFF & x2211 & xBFFE & x31FF & x2233 & x5177 & x3211 & x21FF & x5233 & x3177 & x2211 \\ \hline \hline
A      & x1800 & B     & B     & x31FF & x2233 & x5177 & x3211 & x21FF & x5233 & x3177 & x2211 \\ \hline
A      & x1800 & B     & B     & x31FF & x2233 & x5177 & x3211 & x21FF & C     & x3177 & x2211 \\ \hline \hline
D      & A     & E     & E     & x31FF & x2233 & x5177 & x3211 & x21FF & C     & x3177 & x2211 \\ \hline
D      & F     & G     & E     & x31FF & x2233 & x5177 & x3211 & x21FF & C     & x3177 & x2211 \\ \hline \hline
H      & D     & I     & I     & x31FF & x2233 & x5177 & x3211 & x21FF & C     & x3177 & x2211 \\ \hline
F      & D     & I     & I     & x31FF & x2233 & x5177 & x3211 & x21FF & C     & x3177 & x2211 \\ \hline \hline
A      & F     & J     & J     & x31FF & x2233 & x5177 & x3211 & x21FF & C     & x3177 & x2211 \\ \hline
A      & F     & J     & J     & x31FF & x2233 & x5177 & x3211 & x223A & C     & x3177 & x2211 \\ \hline
\end{tabular}
\end{center}
\end{table}

\noindent
Your job: Determine the values of A, B, C, D, E, F, G, H, I, and J. Note that
some of the values may be identical. \\

\begin{table}[h!]
\begin{center}
\large
\begin{tabular}{|m{2cm}|m{2cm}|m{2cm}|m{2cm}|m{2cm}|m{1mm}}
\cline{1-5}
A     & B     & C     & D     & E     & \\[10pt] \cline{1-5}
      &       &       &       &       & \\[10pt] \cline{1-5}
\end{tabular}
\end{center}
\end{table}

\begin{table}[h!]
\begin{center}
\large
\begin{tabular}{|m{2cm}|m{2cm}|m{2cm}|m{2cm}|m{2cm}|m{1mm}}
\cline{1-5}
F     & G     & H     & I     & J     & \\[8pt] \cline{1-5}
      &       &       & { x \_F\_\_} &       & \\[8pt] \cline{1-5}
\end{tabular}
\end{center}
\end{table}

\item[7.30]STAR There are times when one wants to implement a stack
in memory, but can not provide enough memory to be sure there will
always be plenty of space to push values on the stack.  Furthermore,
there are times (beyond EE 306) when it is okay to lose some of the
oldest values pushed on the stack.  We can save that discussion for
the last class if you like. \\

\noindent In such situations, a reasonable technique is to specify a circular
stack as shown below.  In this case, the stack occupies five locations
x3FFB to x3FFF.  Initially, the stack is empty, with R6 = x4000.  The
figure shows the result of successively pushing the values
1, 2, 3, 4, 5, 6, 7, 8 on the stack.

\begin{figure}[h]
\centering
\includegraphics[width=4cm]{730_stack.eps}
\end{figure}

\noindent That is, the 1 was written into x3FFF, the 2 was written into x3FFE, etc.
When the time came to push the 6, the stack was full, so R6 was set to
x3FFF, and the 6 was written into x3FFF, clobbering the 1 which was originally
pushed. \\

\noindent If we now pop five elements off the stack, we get 8, 7, 6, 5,and 4, AND we have
an empty stack, even though R6 contains x3FFD.  Why?  Because 3,2, and
1 have been lost.  That is, even though we have pushed 8 values, there
can be at most only five values actually available on the stack for
popping.  We keep track of the number of actual values on the stack in
R5. \\

\noindent Note that R5 and R6 are known to the calling routine, so a test for
underflow can be made by the calling program using R5.  Further, the calling
program puts the value to be pushed in R0 before calling PUSH. \\

\noindent Your job: Complete the assembly language code shown below to implement the
PUSH routine of the circular stack by filling in each of the lines:(a), (b), (c), and (d) with a missing instruction. 

\begin{alltt}
     PUSH    ST R1, SAVER
             LD R1, NEGFULL
             ADD R1, R6, R1
             --------------(a)
\end{alltt}

%             BRnp SKIP      
\begin{alltt}
             LD R6, BASE
     SKIP    ADD R6, R6, #-1
             LD R1, MINUS5
             ADD R1, R5, R1
             BRz END
             --------------(b)
\end{alltt}
     %      ADD R5, R5, #1   

\noindent
\begin{alltt} 
     END     --------------(c)
             --------------(d)
\end{alltt}
%END STR R0, R6, #0
      %            LD R1, SAVER

\begin{alltt}  
             RET
     NEGFULL .FILL xC005     ; x-3FFB
     MINUS5  .FILL xFFFB     ; #-5
     BASE    .FILL x4000
     SAVER   .BLKW #1
\end{alltt} 

\item[7.31] Memory locations x5000 to x5FFF contain 2's complement integers.  What does
the following program do? \\

%\begin{center}
\begin{minipage}[t]{0.5\linewidth}
\begin{flushleft}
{
\begin{alltt}
        .ORIG x3000
        LD  R1, ARRAY
        LD  R2, LENGTH
        AND R3, R3, #0
AGAIN   LDR R0, R1, #0
        AND R0, R0, #1
        BRz SKIP
        ADD R3, R3, #1
SKIP    ADD R1, R1, #1
        ADD R2, R2, #-1
        BRp AGAIN
        HALT
ARRAY  .FILL x5000
LENGTH .FILL x1000
       .END
\end{alltt}
}
\end{flushleft}
\end{minipage}
%\end{center}

\vspace{0.4in}

\item[7.32] Consider the following semi-nonsense assembly language program: \\

\vspace{-.1in}
\begin{alltt}
line 1:          .ORIG x8003
line 2:          AND R1,R1,#0
line 3:          ADD R0,R1,#5
line 4:          ST  R1,B
line 5:          LD  R1,A
line 6:          BRz SKIP
\textbf{line 7:          ST  R0,B}
line 8:   SKIP   TRAP x25
line 9:   A      .BLKW #7
\textbf{line 10:  B      .FILL #5}
line 11:  BANNER .STRINGZ "We are done!"
line 12:  C      .FILL x0
line 13:         .END
\end{alltt}

\vspace{0.1in}
\noindent
A separate module will store a value in A before the above program executes. \\
\vspace{0.1in}
\noindent
Construct the symbol table.\\ 
\vspace{0.1in}
\noindent
Show the result of assembly of lines 5 through 7 above.  Note: the
instruction at line 8 has already been assembled for you. \\
\vspace{0.1in}

\includegraphics[scale=0.5]{732_table.eps}

\vspace{0.2in}
\noindent
Note that two different things could cause location B to contain the value 5: the contents of line 7 or the contents of line 10. Explain the difference between line 7 causing the value 5 to be in location B and line 10 causing the value 5 to be in location B. \\

\item[7.33]STAR We have a program with some missing instructions, and we have a table consisting of some information and some missing information associated with five specific clock cycles of the program's execution.  Your job is to complete both! \\

\noindent
Insert the missing instructions in the program and the missing information in the table.  Cycle numbering starts at 1. That is, cycle 1 is the first clock cycle of the processing of LD R0,A. Note that we have not said anything about the number of clock cycles a memory access takes. You do have enough information to figure that out for yourself. Note that we are asking for the value of the registers DURING each clock cycle. 

\begin{Verbatim}[fontsize=\small]
        .ORIG x3000
        LD  R0, A
        LD  R1, B
        NOT R1, R1
        ADD R1, R1, #1
        AND R2, R2, #0
 AGAIN  -------------- (a)
        -------------- (b)  
        BRnzp AGAIN
 DONE   ST  R2, C
        HALT
    A   .FILL #5
    B   .FILL -------- (c)
    C   .BLKW #1
        .END
\end{Verbatim}

\vspace{-.4in}
\noindent
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.4]{733_states.eps}
\end{center}
\end{figure}

\FloatBarrier

\noindent
What is stored in C at the end of execution for the specific operands given in memory locations A and B? \\

\vspace{.2in}
\noindent
Actually, the program was written by a student, so as expected, he did not get it quite right.  Almost, but not quite!  Your final task on this problem is to examine the code, figure out what the student was trying to do, point out where he messed up, and how you would fix it.  It is not necessary to write any code, just explain briefly how you would fix it.\\

\noindent
What was the student trying to do? \\
\vspace{0.1in}

\noindent
How did the student mess up? \\ 
\vspace{0.1in}

\noindent
How would you fix his program? \\
\vspace{0.1in}


\item[7.34] It is often useful to find the midpoint between two values. For this problem, assume A and B are both even numbers, and that A is less than B.  For example, if A=2 and B=8, the midpoint is 5. The following program finds the midpoint of two even numbers A and B by continually incrementing the smaller number and decrementing the larger number. You can assume that A and B have been loaded with values before this program starts execution. \\ 

\noindent
Your job: Insert the missing instructions. \\

\begin{alltt}
        .ORIG  x3000
        LD     R0,A
        LD     R1,B
X       ------------------ (a)
        ------------------ (b)
        ADD    R2,R2,R1
        ------------------ (c)
        ADD    R1,R1,#-1
        ------------------ (d)
        BRnzp  X
DONE    ST     R1,C
        TRAP   x25
A       .BLKW  1
B       .BLKW  1
C       .BLKW  1
        .END
\end{alltt}

\item[7.35]STAR The program stored in memory locations x3000 to x3007 loads a value from memory location x3100, then does some processing, and then stores a result in memory location x3101.  Shown below is an incomplete specification of the program.  Your job: complete the pecification of the program.

\begin{center}
\begin{tabular}{|c|m{5cm}|m{4cm}|}
\hline
Address & Contents & Assembly code\\ \hline

x3000 & 0101 001 001 1 00000 & AND R1, R1, \#0 \\ \hline

x3001 & 0010 000  & LD R0, x3100 \\ \hline

x3002 & 0000 110 000000011 & BRnz x3006 \\ \hline

x3003 & 0001  & ADD  \\ \hline

x3004 &  &  \\ \hline

x3005 & 0000 111  &  \\ \hline

x3006 & 0011 001  & ST R1, x3101 \\ \hline

x3007 & 1111 0000 0010 0101 & HALT \\ \hline

\end{tabular}
\end{center}

\noindent
To help you in this process, we have taken a snapshot of part of the state of the machine before the first instruction executes and at several instruction boundaries thereafter, that is, after a number of instructions executed. Part of the snapshot is shown below. Your job is to complete the snapshot. Note that the program enters the TRAP x25 service routine after executing 17 instructions. Therefore some instructions must execute more than once.\\

\vspace{0.1in}
\noindent
Note that in the table below: some entries are designated xxxx. You do not
have to fill in those entries.  Also, you can ignore snapshots for any
instructions that are not listed in the table.
\begin{center}
\begin{tabular}{|c|c|m{1.5cm}|m{1.5cm}|m{1.5cm}|m{1.5cm}|}
\hline
Instruction \# &PC& MAR& MDR& R0& R1 \\ \hline

Initial &x3000 & xxxx & xxxx & xxxx & xxxx \\ \hline

1 & x3001 & xxxx & xxxx & xxxx & \\ \hline

2 & x3002 & & & & \\ \hline

3 & x3003 & xxxx & xxxx &  & \\ \hline

4 & x3004 &  & x1240 &  &  \\ \hline

5 & x3005 & xxxx & xxxx & x0002 &  \\ \hline

9 & x3005 & xxxx & xxxx & x0001 &  \\ \hline

13 & x3005 &  xxxx & xxxx & x0000 &  \\ \hline

14 & x3002 & xxxx & xxxx &  &  \\ \hline

15 & x3006 &  xxxx & xxxx &   &   \\ \hline

16 & x3007 &  &  &  &  \\ \hline

17 & xxxx & xxxx & xxxx &  &  \\ \hline

\end{tabular}
\end{center}

\item[7.36] The modulo operator (A mod B) is the remainder one gets
when dividing A by B.  For example, 10 mod 5 is 0, 12 mod 7 is 5.
\\
\noindent The program below is supposed to perform A mod B, where A is in x3100
and B is in x3101. The result should be stored at location x3200. However, the
programmer made a serious mistake, so the program does not work. You can assume
that A and B are both positive integers.

\begin{alltt}
    
         .ORIG x3000        ; Line 1
         LD R3, L2          ; 2
         LDR R0, R3, #0     ; 3
         LDR R1, R3, #1     ; 4
         NOT R2, R1         ; 5
         ADD R2, R2, #1     ; 6
L1       ADD R0, R0, R2     ; 7
         BRzp L1            ; 8
         ADD R0, R0, R1     ; 9
         ST R0, L3          ; 10
         HALT               ; 11
L2       .FILL x3100        ; 12
L3       .FILL x3200        ; 13
         .END               ; 14
\end{alltt}

\vspace{.1in}
\noindent 
After the instruction at line 6 has executed, what are the contents of R0,R1,and R2?  NOTE: the correct answer in each case is one of the following: A, -A, B, -B, 0, 1, -1. 

\vspace{.1in} 
\noindent 
There is a bug in the program. What line is it at and what should the correct instruction be? 

\item[7.37]STAR During the processing of an LC-3 program by the data path we have been using in class, the computer stops due to a breakpoint set at x3000.  The contents of certain registers
and memory locations at that time are as follows:
\begin{bf}
\begin{alltt}
    R2 through R7: x0000
         M[x3000]: x1263
         M[x3003]: x0000
\end{alltt}
\end{bf}

\noindent
The LC-3 is restarted and executes exactly four instructions. To accomplish this, a number of clock cycles are required.  In 15 of those clock cycles, the bus must be utilized.  The table
below lists those 15 clock cycles in sequential order, along with the values that are gated onto the LC-3 bus in each.
\begin{table}[h!]
%\begin{center}
\begin{tabular}{l|p{1cm}|}
\cline{2-2} 
         & BUS    \\[6.1pt] \cline{2-2} 
1st:     & x3000  \\[6.1pt] \cline{2-2}
2nd:     & x1263  \\[6.1pt] \cline{2-2}
3rd:     & x009A  \\[6.1pt] \cline{2-2}
4th:     & x3001  \\[6.1pt] \cline{2-2}
5th:     & xA000  \\[6.1pt] \cline{2-2}
6th:     &        \\[6.1pt] \cline{2-2}
7th:     &        \\[6.1pt] \cline{2-2}
8th:     &        \\[6.1pt] \cline{2-2}
9th:     &        \\[6.1pt] \cline{2-2}
10th:    &        \\[6.1pt] \cline{2-2}
11th:    &        \\[6.1pt] \cline{2-2}
12th:    &        \\[6.1pt] \cline{2-2}
13th:    & x3003  \\[6.1pt] \cline{2-2}
14th:    & x1263  \\[6.1pt] \cline{2-2}
15th:    & x009D  \\[6.1pt] \cline{2-2}
\end{tabular}
\end{table}

\vspace{0.1in}
\noindent
Fill in the missing entries above. \\ 

\vspace{0.1in}
\noindent
What are the four instructions that were executed?

\vspace{0.1in}
\noindent
What are the contents of R0 and R1 after the four instructions execute? \\

\end{exercises}
\end{document}
