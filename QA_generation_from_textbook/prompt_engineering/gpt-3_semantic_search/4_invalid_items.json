[
  {
    "textbook-paragraph": "used a three-bit red-green-blue (RGB)  encoding for colors.  The color mapping for such a system is shown to the right.  Imagine that you are charged with creating a counter to drive a light through a sequence of colors.  The light takes an RGB input as just described, and the desired pattern is  {off (black)     yellow     violet     green     blue}  You immediately recognize that you merely need a counter with five states.  How many flip-flops will we need?  At least three, since _2 (5)=3.  Given that we need three flip-flops,  and that the colors we need to produce as   {c|l} RGB& color  000& black 001& blue 010& green 011& cyan 100& red 101& violet 110& yellow 111& white    outputs are all unique bit patterns, we can again choose to use the counter's internal  state directly as our output values.   A fully-specified transition diagram for our color sequencer appears to the right.  The states again form a loop, and are marked with the internal state value S_2S_1S_0  and the output RGB.       As before, we can use the transition diagram to fill in K-maps for the  next-state values S_2^+, S_1^+, and S_0^+, as shown to the right. For each of the three states not included in our transition diagram, we have inserted x's          into the K-maps to indicate ``don't care.''  As you know, we can treat each x as either a 0 or a 1, whichever produces better results (where ``better'' usually means simpler  equations).  The terms that we have chosen for our algebraic  equations are illustrated in the K-maps.  The x's within the ellipses become 1s in the implementation, and the x's outside of the ellipses become 0s.   For our next-state logic, we obtain: {eqnarray*} S_2^+ &=& S_2 S_1 + {{S_1}} {{S_0}}  S_1^+ &=& S_2 S_0 + {{S_1}} {{S_0}}  S_0^+ &=& S_1 {eqnarray*}  Again our equations for S_2^+ and S_1^+ share a common term, which becomes a single AND gate in the implementation shown to the right.      {Identifying an Initial State}  Let's say that you go the lab and build the implementation above,  hook it up to the light, and turn it on.  Does it work?  Sometimes. Sometimes it works perfectly, but sometimes the light glows cyan or red briefly first. At other times, the light is an unchanging white.   What could be going wrong?  Let's try to understand.  We begin by deriving K-maps for the implementation, as shown to the right.  In these K-maps, each of the x's in our design has been replaced by either a 0 or a 1.  These entries are highlighted with green italics.   {file=part3/figs/colS2-bad.eps,width=1.00in}  {file=part3/figs/colS1-bad.eps,width=1.00in}  {file=part3/figs/colS0-bad.eps,width=1.00in}   Now let's imagine what might happen if somehow our FSM got into the S_2S_1S_0=111 state.  In such a state, the light would appear white, since RGB=S_2S_1S_0=111.  What happens in the next cycle?  Plugging into the equations or looking into the K-maps gives (of course) the same answer: the next state is the S_2^+S_1^+S_0^+=111 state. In other words, the light stays white indefinitely!  As an exercise, you should check what happens  if the light is red or cyan.  We can extend the transition diagram that we developed for our design with the extra states possible in the implementation, as shown below. As with the five states in the design, the extra states are named with the color of light that they produce.  {{file=part3/figs/colors-full.eps,width=5.8in}}  Notice that the FSM does not move out of the WHITE state (ever).    You may at this point wonder whether more careful decisions  in selecting our next-state expressions might address this issue. To some extent, yes.  For example, if we replace the  S_2S_1 term in the equation for S_2^+ with S_2{{S_0}},  a decision allowed by the ``don't care'' boxes in the K-map for our design, the resulting transition diagram does not suffer from the problem that we've found.  However, even if we do change our implementation slightly, we need to address another aspect of the problem:  how can the FSM",
    "GPT-3-Semantic-Search-Generations": {
      "question": " How can the FSM ever get into the unexpected states?\\n",
      "answer": "\nOne possibility is that the FSM is not resetting properly, so it does not start from the expected initial state. Another possibility is that there is a race condition in the FSM, so that it can reach an unexpected state if the inputs change too quickly."
    }
  },
  {
    "textbook-paragraph": "systematic technique (or a machine) capable of solving a problem that cannot be solved by a Turing machine.  No one has been able to do so to date.   {The Halting Problem*}  You might reasonably ask whether any problems can be shown to be incomputable.  More common terms for such problems---those known to be insolvable by any computer---are { intractable} or  undecidable.  In the same 1936 paper in which he introduced the universal computing machine, Alan Turing also provided an answer to this question by introducing (and proving) that there are in fact problems that cannot be computed by a universal computing machine. The problem that he proved undecidable, using proof techniques almost identical to those developed for similar problems in the 1880s, is now known as { the halting problem}.    The halting problem is easy to state and easy to prove undecidable. The problem is this: given a Turing machine and an input to the Turing machine, does the Turing machine finish computing in a finite number of steps (a finite amount of time)?  In order to solve the problem, an answer, either yes or no, must be given in a finite amount of time regardless of the machine or input in question.  Clearly some machines never finish.  For example, we can write a Turing machine that counts upwards starting from one.  You may find the proof structure for undecidability of the halting problem easier to understand if you first think about a related problem with which you may already be familiar, the Liar's paradox (which is at least 2,300 years old).  In its stengthened form, it is the following sentence: ``This sentence is not true.''   To see that no Turing machine can solve the halting problem, we begin by assuming that such a machine exists, and then show that its existence is self-contradictory.  We call the machine the ``Halting Machine,'' or HM for short.  HM is a machine that operates on  another      Turing machine and its inputs to produce a yes or no answer in finite time: either the machine in question finishes in finite time (HM returns ``yes''), or it does not (HM returns ``no'').  The figure illustrates HM's operation.   From HM, we construct a second machine that we call the HM Inverter, or HMI.  This machine inverts the sense of the answer given by HM.  In particular, the inputs are fed directly into a copy of HM, and if HM answers ``yes,'' HMI enters an infinite loop.  If HM answers ``no,'' HMI halts.  A diagram appears to the right.  The inconsistency can now be seen by asking HM whether HMI halts when given itself as an input (repeatedly), as      shown below.  Two copies of HM are thus being asked the same question.  One copy is the rightmost in the figure below and the second is embedded in the HMI machine that we are using as the input to the rightmost HM.  As the two copies of HM operate on the same input (HMI operating on HMI), they should return the same answer: a Turing machine either halts on an input, or it does not; they are deterministic.    Let's assume that the rightmost HM tells us that HMI operating on itself halts. Then the copy of HM in HMI (when HMI executes on itself, with itself as an input) must also say ``yes.''  But this answer implies that HMI doesn't halt (see the figure above), so the answer should have been no!  Alternatively, we can assume that the rightmost HM says that HMI operating on itself does not halt.  Again, the copy of HM in HMI must give the same answer.  But in this case HMI halts, again contradicting our assumption.  Since neither answer is consistent, no consistent answer can be given, and the original assumption that HM exists is incorrect.  Thus, no Turing machine can solve the halting problem.      {Programming Concepts and the C Language}  This set of notes introduces the C programming language and explains some basic concepts in computer programming.  Our purpose in showing you a high-level language at this early stage of the course is to give you time to become familiar with the",
    "GPT-3-Semantic-Search-Generations": {
      "question": " What is the value of HOLD when the counter is halted?\\n",
      "answer": "\nThe value of HOLD when the counter is halted is the value of the last input given to the machine."
    }
  }
]