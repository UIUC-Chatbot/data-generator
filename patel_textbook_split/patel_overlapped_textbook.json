{
    "0": "../art/appendix/,../art/designelements/,../art/designelements/UnNumberedArt/ CHAPTER: THE MICROARCHITECTURE OF THE LC-3 We have seen in Chapters 4 and 5 the several stages of the instruction cycle that must occur in order for the computer to process each instruction. If a microarchitecture is to implement an ISA, it must be able to carry out this instruction cycle for every instruction in the ISA. This appendix illustrates one example of a microarchitecture that can do that for the LC-3 ISA. Many of the details of the microarchitecture and the reasons for each design decision are well beyond the scope of an introductory course. However, for those who want to understand how a microarchitecture can carry out the requirements of each instruction of the LC-3 ISA, this appendix is provided. § OVERVIEW Figure C.1 shows the two main components of a microarchitecture: the data path, which contains all the components that actually process the instructions, and the control, which contains all the components that generate the set of control signals that are needed to control the processing at each instant of time. < g r a p h i c s > Microarchitecture of the LC-3, major components We say, “at each instant of time,” but we really",
    "1": "i c s > Microarchitecture of the LC-3, major components We say, “at each instant of time,” but we really mean during each clock cycle. That is, time is divided into clock cycles. The cycle time of a microprocessor is the duration of a clock cycle. A common cycle time for a microprocessor today is 0.33 nanoseconds, which corresponds to 3 billion clock cycles each second. We say that such a microprocessor is operating at a frequency of 3 gigahertz, or 3 GHz. At each instant of time—or, rather, during each clock cycle—the 52 control signals (as shown in Figure C.1) control both the processing in the data path and the generation of the control signals for the next clock cycle. Processing in the data path is controlled by 42 bits, and the generation of the control signals for the next clock cycle is controlled by 10 bits. Note that the hardware that determines which control signals are needed each clock cycle does not operate in a vacuum. On the contrary, the control signals needed in the “next” clock cycle depend on the following: 6pt=3pt * The control signals that are present during the current clock cycle. * The LC-3 instruction",
    "2": "3 billion clock cycles each second. We say that such a microprocessor is operating at a frequency of 3 gigahertz, or 3 GHz. At each instant of time—or, rather, during each clock cycle—the 52 control signals (as shown in Figure C.1) control both the processing in the data path and the generation of the control signals for the next clock cycle. Processing in the data path is controlled by 42 bits, and the generation of the control signals for the next clock cycle is controlled by 10 bits. Note that the hardware that determines which control signals are needed each clock cycle does not operate in a vacuum. On the contrary, the control signals needed in the “next” clock cycle depend on the following: 6pt=3pt * The control signals that are present during the current clock cycle. * The LC-3 instruction that is being executed. * The privilege mode of the program that is executing, and whether the processor has the right to access a particular memory location. * If that LC-3 instruction is a BR, whether the conditions for the branch have been met (i.e., the state of the relevant condition codes). * Whether or not an external device is requesting that the processor be interrupted. * If a memory operation is in progress, whether it is completing during this cycle. Figure C.1 identifies the specific information in our implementation of the LC-3 that corresponds to these six items. They are, respectively: 6pt=3pt * J[5:0], COND[2:0], and IRD—10 bits of control signals provided by the current clock cycle. * inst[15:12], which identifies the opcode, and inst[11:11], which differentiates JSR from JSRR (i.e., the addressing mode for the target of the subroutine call). * PSR[15], bit [15] of the Processor Status Register, which indicates whether the current program is executing with supervisor or user privileges, and ACV, a signal that informs the processor that a process operating in User mode is trying to access a location in privileged memory. ACV stands for Access Control Violation. When asserted, it denies the process access",
    "3": "requesting that the processor be interrupted. * If a memory operation is in progress, whether it is completing during this cycle. Figure C.1 identifies the specific information in our implementation of the LC-3 that corresponds to these six items. They are, respectively: 6pt=3pt * J[5:0], COND[2:0], and IRD—10 bits of control signals provided by the current clock cycle. * inst[15:12], which identifies the opcode, and inst[11:11], which differentiates JSR from JSRR (i.e., the addressing mode for the target of the subroutine call). * PSR[15], bit [15] of the Processor Status Register, which indicates whether the current program is executing with supervisor or user privileges, and ACV, a signal that informs the processor that a process operating in User mode is trying to access a location in privileged memory. ACV stands for Access Control Violation. When asserted, it denies the process access to the privilege memory location. * BEN to indicate whether or not a BR should be taken. * INT to indicate that some external device of higher priority than the executing process requests service. * R to indicate the end of a memory operation. § THE STATE MACHINE The behavior of the LC-3 microarchitecture during a given clock cycle is completely determined by the 52 control signals, combined with ten bits of additional information (inst[15:11], PSR[15], ACV, BEN, INT, and R), as shown in Figure C.1. We have said that during each clock cycle, 42 of these control signals determine the processing of information in the data path and the other 10 control signals combine with the ten bits of additional information to determine which set of control signals will be required in the next clock cycle. We say that these 52 control signals specify the state of the control structure of the LC-3 microarchitecture. We can completely describe the behavior of the LC-3 microarchitecture by means of a directed graph that consists of nodes (one corresponding to each state) and arcs (showing the flow from each state to the one[s] it goes to next). We call such a graph a",
    "4": "completely determined by the 52 control signals, combined with ten bits of additional information (inst[15:11], PSR[15], ACV, BEN, INT, and R), as shown in Figure C.1. We have said that during each clock cycle, 42 of these control signals determine the processing of information in the data path and the other 10 control signals combine with the ten bits of additional information to determine which set of control signals will be required in the next clock cycle. We say that these 52 control signals specify the state of the control structure of the LC-3 microarchitecture. We can completely describe the behavior of the LC-3 microarchitecture by means of a directed graph that consists of nodes (one corresponding to each state) and arcs (showing the flow from each state to the one[s] it goes to next). We call such a graph a state machine. Figure C.2, combined with Figure C.7, is the state machine for our implementation of the LC-3. The state machine describes what happens during each clock cycle in which the computer is running. Each state is active for exactly one clock cycle before control passes to the next state. The state machine shows the step-by-step (clock cycle–by–clock cycle) process that each instruction goes through from the start of its FETCH phase to the end of its instruction cycle, as described in Section 4.2.2. Each node in the state machine corresponds to the activity that the processor carries out during a single clock cycle. The actual processing that is performed in the data path is contained inside the node. The step-by-step flow is conveyed by the arcs that take the processor from one state to the next. 36pc < g r a p h i c s > A state machine for the LC-3 Let's start our study of Figure C.2 by examining the FETCH phase of the instruction cycle. As you know, every instruction goes through the same FETCH phase in its instruction cycle. Recall from Chapter 4 that the FETCH phase starts with a memory access to read the",
    "5": "that each instruction goes through from the start of its FETCH phase to the end of its instruction cycle, as described in Section 4.2.2. Each node in the state machine corresponds to the activity that the processor carries out during a single clock cycle. The actual processing that is performed in the data path is contained inside the node. The step-by-step flow is conveyed by the arcs that take the processor from one state to the next. 36pc < g r a p h i c s > A state machine for the LC-3 Let's start our study of Figure C.2 by examining the FETCH phase of the instruction cycle. As you know, every instruction goes through the same FETCH phase in its instruction cycle. Recall from Chapter 4 that the FETCH phase starts with a memory access to read the instruction at the address specified by the PC. Note that in the state numbered 18, the MAR is loaded with the address contained in PC, and the PC is incremented in preparation for the FETCH of the next LC-3 instruction after the current instruction finishes its instruction cycle. If the contents of MAR specifies privileged memory, and PSR[15]=1, indicating user mode, the access of the instruction will not be allowed. That would be an access control violation so ACV is set. Finally, if there is no interrupt request present (INT =0), the flow passes to the state numbered 33. We will describe in Section C.7 the flow of control if INT =1, that is, if an external device is requesting an interrupt. Before we get into what happens during the clock cycle when the processor is in the state numbered 33, we should explain the numbering system—that is, why are states numbered 18 and 33. Recall, from our discussion of finite state machines in Chapter 3, that each state must be uniquely specified and that this unique specification is accomplished by means of state variables. Our state machine that implements the LC-3 ISA requires 59 distinct states to implement the entire",
    "6": "mode, the access of the instruction will not be allowed. That would be an access control violation so ACV is set. Finally, if there is no interrupt request present (INT =0), the flow passes to the state numbered 33. We will describe in Section C.7 the flow of control if INT =1, that is, if an external device is requesting an interrupt. Before we get into what happens during the clock cycle when the processor is in the state numbered 33, we should explain the numbering system—that is, why are states numbered 18 and 33. Recall, from our discussion of finite state machines in Chapter 3, that each state must be uniquely specified and that this unique specification is accomplished by means of state variables. Our state machine that implements the LC-3 ISA requires 59 distinct states to implement the entire behavior of the LC-3. Figure C.2 shows 31 of them plus pointers to seven others (states 8, 13, 15, 48, 49, 57, and 60). Figure C.7 shows the other 28 states (including the seven that are pointed to in Figure C.2). We will visit all of them as we go through this appendix. Since k logical variables can uniquely identify 2^k items, six state variables are needed to uniquely specify 59 states. The number next to each node in Figure C.2 and Figure C.7 is the decimal equivalent of the values (0 or 1) of the six state variables for the corresponding state. Thus, for example, the state numbered 18 has state variable values 010010. Now, back to what happens after the clock cycle in which the activity of state 18 has finished. As we said, if no external device is requesting an interrupt, the flow passes to state 33 (i.e., 100001). From state 33, control passes to state 60 if the processor is trying to access privileged memory while in user mode, or to state 28, if the memory access is allowed, that is, if there is no ACV violation. We will discuss what happens if there is an ACV",
    "7": "2^k items, six state variables are needed to uniquely specify 59 states. The number next to each node in Figure C.2 and Figure C.7 is the decimal equivalent of the values (0 or 1) of the six state variables for the corresponding state. Thus, for example, the state numbered 18 has state variable values 010010. Now, back to what happens after the clock cycle in which the activity of state 18 has finished. As we said, if no external device is requesting an interrupt, the flow passes to state 33 (i.e., 100001). From state 33, control passes to state 60 if the processor is trying to access privileged memory while in user mode, or to state 28, if the memory access is allowed, that is, if there is no ACV violation. We will discuss what happens if there is an ACV violation in Section C.7. In state 28, since the MAR contains the address of the instruction to be processed, this instruction is read from memory and loaded into the MDR. Since this memory access can take multiple cycles, this state continues to execute until a ready signal from the memory (R) is asserted, indicating that the memory access has completed. Thus the MDR contains the valid contents of the memory location specified by MAR. The state machine then moves on to state 30, where the instruction is loaded into the instruction register (IR), completing the fetch phase of the instruction cycle. The state machine then moves to state 32, where DECODE takes place. Note that there are 13 arcs emanating from state 32, each one corresponding to bits [15:12] of the LC-3 instruction. These are the opcode bits which direct the state machine to one of 16 paths to carry out the instruction cycle of the particular instruction that has just been fetched. Note that the arc from the last state of each instruction cycle (i.e., the state that completes the processing of that LC-3 instruction) takes us to state 18 (to begin the instruction cycle of the next LC-3 instruction).",
    "8": "Thus the MDR contains the valid contents of the memory location specified by MAR. The state machine then moves on to state 30, where the instruction is loaded into the instruction register (IR), completing the fetch phase of the instruction cycle. The state machine then moves to state 32, where DECODE takes place. Note that there are 13 arcs emanating from state 32, each one corresponding to bits [15:12] of the LC-3 instruction. These are the opcode bits which direct the state machine to one of 16 paths to carry out the instruction cycle of the particular instruction that has just been fetched. Note that the arc from the last state of each instruction cycle (i.e., the state that completes the processing of that LC-3 instruction) takes us to state 18 (to begin the instruction cycle of the next LC-3 instruction). C.4 The Control Structure § THE DATA PATH The data path consists of all components that actually process the information during each clock cycle—the functional units that operate on the information, the registers that store information at the end of one cycle so it will be available for further use in subsequent cycles, and the buses and wires that carry information from one point to another in the data path. Figure C.3, an expanded version of what you have already encountered in Figure 5.18, illustrates the data path of our microarchitecture of the LC-3. 36pc < g r a p h i c s > The LC-3 data path Note the control signals that are associated with each component in the data path. For example, ALUK, consisting of two control signals, is associated with the ALU. These control signals determine how that component (the ALU) will be used each cycle. Table C.1 lists the set of 42 control signals that control the elements of the data path and the set of values that each control signal can have. (Actually, for readability, we provide a symbolic name for each value, rather than the binary value.) For example, since ALUK consists of two",
    "9": "information from one point to another in the data path. Figure C.3, an expanded version of what you have already encountered in Figure 5.18, illustrates the data path of our microarchitecture of the LC-3. 36pc < g r a p h i c s > The LC-3 data path Note the control signals that are associated with each component in the data path. For example, ALUK, consisting of two control signals, is associated with the ALU. These control signals determine how that component (the ALU) will be used each cycle. Table C.1 lists the set of 42 control signals that control the elements of the data path and the set of values that each control signal can have. (Actually, for readability, we provide a symbolic name for each value, rather than the binary value.) For example, since ALUK consists of two bits, it can have one of four values. Which value it has during any particular clock cycle depends on whether the ALU is required to ADD, AND, NOT, or simply pass one of its inputs to the output during that clock cycle. PCMUX also consists of two control signals and specifies which input to the MUX is required during a given clock cycle. LD.PC is a single-bit control signal, and is a 0 (NO) or a 1 (YES), depending on whether or not the PC is to be loaded during the given clock cycle. empty Data Path Control Signals 1lSignal Name 2lSignal Values0pt7pt LD.MAR/1:0pt10pt 2lNO, LOAD LD.MDR/1: 2lNO, LOAD LD.IR/1: 2lNO, LOAD LD.BEN/1: 2lNO, LOAD LD.REG/1: 2lNO, LOAD LD.CC/1: 2lNO, LOAD LD.PC/1: 2lNO, LOAD LD.Priv/1: 2lNO, LOAD LD.Priority/1: 2lNO, LOAD LD.SavedSSP/1: 2lNO, LOAD LD.SavedUSP/1: 2lNO, LOAD LD.ACV/1: 2lNO, LOAD LD.Vector/1: 2lNO, LOAD GatePC/1:[0mm]0mm5mm 2lNO, YES GateMDR/1: 2lNO, YES GateALU/1: 2lNO, YES GateMARMUX/1: 2lNO, YES GateVector/1: 2lNO, YES GatePC-1/1: 2lNO, YES GatePSR/1: 2lNO, YES GateSP/1: 2lNO, YES PCMUX/2:[0mm]0mm5mm PC+1 ;select pc+1 BUS ;select value from bus ADDER ;select output of address adder DRMUX/2:[0mm]0mm5mm 11.9 ;destination IR[11:9] R7 ;destination R7 SP ;destination R6 SR1MUX/2:[0mm]0mm5mm 11.9 ;source IR[11:9] 8.6 ;source IR[8:6] SP ;source R6",
    "10": "given clock cycle. LD.PC is a single-bit control signal, and is a 0 (NO) or a 1 (YES), depending on whether or not the PC is to be loaded during the given clock cycle. empty Data Path Control Signals 1lSignal Name 2lSignal Values0pt7pt LD.MAR/1:0pt10pt 2lNO, LOAD LD.MDR/1: 2lNO, LOAD LD.IR/1: 2lNO, LOAD LD.BEN/1: 2lNO, LOAD LD.REG/1: 2lNO, LOAD LD.CC/1: 2lNO, LOAD LD.PC/1: 2lNO, LOAD LD.Priv/1: 2lNO, LOAD LD.Priority/1: 2lNO, LOAD LD.SavedSSP/1: 2lNO, LOAD LD.SavedUSP/1: 2lNO, LOAD LD.ACV/1: 2lNO, LOAD LD.Vector/1: 2lNO, LOAD GatePC/1:[0mm]0mm5mm 2lNO, YES GateMDR/1: 2lNO, YES GateALU/1: 2lNO, YES GateMARMUX/1: 2lNO, YES GateVector/1: 2lNO, YES GatePC-1/1: 2lNO, YES GatePSR/1: 2lNO, YES GateSP/1: 2lNO, YES PCMUX/2:[0mm]0mm5mm PC+1 ;select pc+1 BUS ;select value from bus ADDER ;select output of address adder DRMUX/2:[0mm]0mm5mm 11.9 ;destination IR[11:9] R7 ;destination R7 SP ;destination R6 SR1MUX/2:[0mm]0mm5mm 11.9 ;source IR[11:9] 8.6 ;source IR[8:6] SP ;source R6 ADDR1MUX/1:[0mm]0mm5mm 2lPC, BaseR ADDR2MUX/2:[0mm]0mm5mm ZERO ;select the value zero offset6 ;select SEXT[IR[5:0]] PCoffset9 ;select SEXT[IR[8:0]] PCoffset11 ;select SEXT[IR[10:0]] SPMUX/2:[0mm]0mm5mm SP+1 ;select stack pointer+1 SP-1 ;select stack pointer-1 Saved SSP ;select saved Supervisor Stack Pointer Saved USP ;select saved User Stack Pointer MARMUX/1:[0mm]0mm5mm 7.0 ;select ZEXT[IR[7:0]] ADDER ;select output of address adder TableMUX/1:[0mm]0mm5mm 2lx00, x01 VectorMUX/2:[0mm]0mm5mm INTV Priv.exception Opc.exception ACV.exception PSRMUX/1:[0mm]0mm5mm 2lindividual settings, BUS ALUK/2:[0mm]0mm5mm 2lADD, AND, NOT, PASSA MIO.EN/1:[0mm]0mm5mm 2lNO, YES R.W/1: 2lRD, WR Set.Priv/1:[0mm]0mm5mm 0 ;Supervisor mode 1 ;User mode During each clock cycle, corresponding to the “current state” in the state machine, the 42 bits of control direct the processing of all components in the data path that are required during that clock cycle. As we have said, the processing that takes place in the data path during that clock cycle is specified inside the node representing the state. § THE CONTROL STRUCTURE The control structure of a microarchitecture is specified by its state machine. As described earlier, the state machine (Figure C.2 and Figure C.7) determines which control signals are needed each clock cycle to process information in the data path and which control signals are needed each clock cycle to direct the flow of control from the",
    "11": "2lindividual settings, BUS ALUK/2:[0mm]0mm5mm 2lADD, AND, NOT, PASSA MIO.EN/1:[0mm]0mm5mm 2lNO, YES R.W/1: 2lRD, WR Set.Priv/1:[0mm]0mm5mm 0 ;Supervisor mode 1 ;User mode During each clock cycle, corresponding to the “current state” in the state machine, the 42 bits of control direct the processing of all components in the data path that are required during that clock cycle. As we have said, the processing that takes place in the data path during that clock cycle is specified inside the node representing the state. § THE CONTROL STRUCTURE The control structure of a microarchitecture is specified by its state machine. As described earlier, the state machine (Figure C.2 and Figure C.7) determines which control signals are needed each clock cycle to process information in the data path and which control signals are needed each clock cycle to direct the flow of control from the currently active state to its successor state. Figure C.4 shows a block diagram of the control structure of our implementation of the LC-3. Many implementations are possible, and the design considerations that must be studied to determine which of many possible implementations should be used is the subject of a full course in computer architecture. < g r a p h i c s > The control structure of a microprogrammed implementation, overall block diagram We have chosen here a straightforward microprogrammed implementation. Each state of the control structure requires 42 bits to control the processing in the data path and 10 bits to help determine which state comes next. These 52 bits are collectively known as a microinstruction. Each microinstruction (i.e., each state of the state machine) is stored in one 52-bit location of a special memory called the control store. There are 59 distinct states. Since each state corresponds to one microinstruction in the control store, the control store for our microprogrammed implementation requires six bits to specify the address of each microinstruction. Those six bits correspond to the state number associated with each state in the state machine. For example the microinstruction associated with state 18 is the",
    "12": "h i c s > The control structure of a microprogrammed implementation, overall block diagram We have chosen here a straightforward microprogrammed implementation. Each state of the control structure requires 42 bits to control the processing in the data path and 10 bits to help determine which state comes next. These 52 bits are collectively known as a microinstruction. Each microinstruction (i.e., each state of the state machine) is stored in one 52-bit location of a special memory called the control store. There are 59 distinct states. Since each state corresponds to one microinstruction in the control store, the control store for our microprogrammed implementation requires six bits to specify the address of each microinstruction. Those six bits correspond to the state number associated with each state in the state machine. For example the microinstruction associated with state 18 is the set of 52 control signals stored in address 18 of the control store. Table C.2 lists the function of the 10 bits of control information that help determine which state comes next. Figure C.5 shows the logic of the microsequencer. The purpose of the microsequencer is to determine the address in the control store that corresponds to the next state, that is, the location where the 52 bits of control information for the next state are stored. Microsequencer Control Signals Signal Name0pt7pt 2@lSignal Values J/6:0pt10pt 2l COND/3: COND0 ;Unconditional COND1 ;Memory Ready COND2 ;Branch COND3 ;Addressing Mode COND4 ;Privilege Mode COND5 ;Interrupt test COND6 ;ACV Test IRD/1:[0mm]0mm5mm 2@lNO, YES < g r a p h i c s > The microsequencer of the LC-3 As we said, state 32 of the state machine (Figure C.2) performs the DECODE phase of the instruction cycle. It has 16 “next” states, depending on the LC-3 instruction being executed during the current instruction cycle. If the IRD control signal in the microinstruction corresponding to state 32 is 1, the output MUX of the microsequencer (Figure C.5) will take its source from the six bits formed by 00 concatenated with the four opcode bits IR[15:12]. Since",
    "13": "that is, the location where the 52 bits of control information for the next state are stored. Microsequencer Control Signals Signal Name0pt7pt 2@lSignal Values J/6:0pt10pt 2l COND/3: COND0 ;Unconditional COND1 ;Memory Ready COND2 ;Branch COND3 ;Addressing Mode COND4 ;Privilege Mode COND5 ;Interrupt test COND6 ;ACV Test IRD/1:[0mm]0mm5mm 2@lNO, YES < g r a p h i c s > The microsequencer of the LC-3 As we said, state 32 of the state machine (Figure C.2) performs the DECODE phase of the instruction cycle. It has 16 “next” states, depending on the LC-3 instruction being executed during the current instruction cycle. If the IRD control signal in the microinstruction corresponding to state 32 is 1, the output MUX of the microsequencer (Figure C.5) will take its source from the six bits formed by 00 concatenated with the four opcode bits IR[15:12]. Since IR[15:12] specifies the opcode of the current LC-3 instruction being processed, the next address of the control store will be one of 16 addresses, corresponding to the 15 opcodes plus the one unused opcode, IR[15:12] = 1101. That is, each of the 16 next states after state 32 is the first state to be carried out after the instruction has been decoded in state 32. For example, if the instruction being processed is ADD, the address of the next state is state 1, whose microinstruction is stored at location 000001. Recall that IR[15:12] for ADD is 0001. If, somehow, the instruction inadvertently contained IR[15:12] = 1101, the unused opcode, the microarchitecture would execute a sequence of microinstructions, starting at state 13. These microinstructions would respond to the fact that an instruction with an illegal opcode had been fetched. Section C.7.3 describes what happens in that case. Several signals necessary to control the data path and the microsequencer are not among those listed in Tables C.1 and C.2. They are DR, SR1, BEN, INT, ACV, and R. Figure C.6 shows the additional logic needed to generate DR, SR1, BEN, and ACV. < g r a p h i c s > Additional",
    "14": "been decoded in state 32. For example, if the instruction being processed is ADD, the address of the next state is state 1, whose microinstruction is stored at location 000001. Recall that IR[15:12] for ADD is 0001. If, somehow, the instruction inadvertently contained IR[15:12] = 1101, the unused opcode, the microarchitecture would execute a sequence of microinstructions, starting at state 13. These microinstructions would respond to the fact that an instruction with an illegal opcode had been fetched. Section C.7.3 describes what happens in that case. Several signals necessary to control the data path and the microsequencer are not among those listed in Tables C.1 and C.2. They are DR, SR1, BEN, INT, ACV, and R. Figure C.6 shows the additional logic needed to generate DR, SR1, BEN, and ACV. < g r a p h i c s > Additional logic required to provide control signals The INT signal is supplied by some event external to the normal instruction processing, indicating that normal instruction processing should be interrupted and this external event dealt with. The interrupt mechanism was described in Chapter 9. The corresponding flow of control within the microarchitecture is described in Section C.7. The remaining signal, R, is a signal generated by the memory in order to allow the LC-3 to operate correctly with a memory that takes multiple clock cycles to read or store a value. Suppose it takes memory five cycles to read a value. That is, once MAR contains the address to be read and the microinstruction asserts READ, it will take five cycles before the contents of the specified location in memory are available to be loaded into MDR. (Note that the microinstruction asserts READ by means of two control signals: MIO.EN/YES and R.W/RD; see Figure C.3.) Recall our discussion in Section C.2 of the function of state 28, which accesses an instruction from memory during the FETCH phase of each instruction cycle. If the memory takes five cycles to read a value, for the LC-3 to operate correctly, state 28 must execute five times",
    "15": "a signal generated by the memory in order to allow the LC-3 to operate correctly with a memory that takes multiple clock cycles to read or store a value. Suppose it takes memory five cycles to read a value. That is, once MAR contains the address to be read and the microinstruction asserts READ, it will take five cycles before the contents of the specified location in memory are available to be loaded into MDR. (Note that the microinstruction asserts READ by means of two control signals: MIO.EN/YES and R.W/RD; see Figure C.3.) Recall our discussion in Section C.2 of the function of state 28, which accesses an instruction from memory during the FETCH phase of each instruction cycle. If the memory takes five cycles to read a value, for the LC-3 to operate correctly, state 28 must execute five times before moving on to state 30. That is, until MDR contains valid data from the memory location specified by the contents of MAR, we want state 28 to continue to re-execute. After five clock cycles, the memory has completed the “read,” resulting in valid data in MDR, so the processor can move on to state 30. What if the microarchitecture did not wait for the memory to complete the read operation before moving on to state 30? Since the contents of MDR would still be garbage, the microarchitecture would put garbage into the IR in state 30. The ready signal (R) enables the memory read to execute correctly. Since the memory knows it needs five clock cycles to complete the read, it asserts a ready signal (R) throughout the fifth clock cycle. Figure C.2 shows that the next state is 28 (i.e., 011100) if the memory read will not complete in the current clock cycle and state 30 (i.e., 011110) if it will. As we have seen, it is the job of the microsequencer (Figure C.5) to produce the next state address. The 10 microsequencer control signals for state 28 are: [style=intext] IRD/0 ; NO COND/001 ; Memory Ready J/011100 With",
    "16": "did not wait for the memory to complete the read operation before moving on to state 30? Since the contents of MDR would still be garbage, the microarchitecture would put garbage into the IR in state 30. The ready signal (R) enables the memory read to execute correctly. Since the memory knows it needs five clock cycles to complete the read, it asserts a ready signal (R) throughout the fifth clock cycle. Figure C.2 shows that the next state is 28 (i.e., 011100) if the memory read will not complete in the current clock cycle and state 30 (i.e., 011110) if it will. As we have seen, it is the job of the microsequencer (Figure C.5) to produce the next state address. The 10 microsequencer control signals for state 28 are: [style=intext] IRD/0 ; NO COND/001 ; Memory Ready J/011100 With these control signals, what next state address is generated by the microsequencer? For each of the first four executions of state 28, since R =0, the next state address is 011100. This causes state 28 to be executed again in the next clock cycle. In the fifth clock cycle, since R =1, the next state address is 011110, and the LC-3 moves on to state 30. Note that in order for the ready signal (R) from memory to be part of the next state address, COND had to be set to 001, which allowed R to pass through its four-input AND gate. § THE TRAP INSTRUCTION As we have said, each LC-3 instruction follows its own path from state 32 to its final state in its instruction cycle, after which it returns to state 18 to start processing the next instruction. As an example, we will follow the instruction cycle of the TRAP instruction, shown in Figure C.7. Recall that the TRAP instruction pushes the PSR and PC onto the system stack, loads the PC with the starting address of the trap service routine, and executes the service routine from privileged memory. From state 32, the next state after DECODE is",
    "17": "LC-3 moves on to state 30. Note that in order for the ready signal (R) from memory to be part of the next state address, COND had to be set to 001, which allowed R to pass through its four-input AND gate. § THE TRAP INSTRUCTION As we have said, each LC-3 instruction follows its own path from state 32 to its final state in its instruction cycle, after which it returns to state 18 to start processing the next instruction. As an example, we will follow the instruction cycle of the TRAP instruction, shown in Figure C.7. Recall that the TRAP instruction pushes the PSR and PC onto the system stack, loads the PC with the starting address of the trap service routine, and executes the service routine from privileged memory. From state 32, the next state after DECODE is state 15, consistent with the TRAP instruction opcode 1111. In state 15, the Table register, which will be used to form MAR[15:8] of the trap vector table entry is loaded with x00, the PC is incremented (we will see why momentarily), and the MDR is loaded with the PSR in preparation for pushing it on the system stack. Control passes to state 47. In state 47, the trap vector (IR[7:0]) is loaded into the eight bit register Vector, PSR[15] is set to Supervisor mode since the trap service routine executes in privileged memory, and the state machine branches to state 37 or 45, depending on whether the program that executed the TRAP instruction was in User mode or Supervisor mode. If in User mode, state 45 saves the User Stack Pointer in Saved_USP, loads the stack pointer from Saved_SSP, and continues on to state 37 where the processor starts pushing PSR and PC on the stack. If the program executing the TRAP instruction is already in Privileged mode, state 45 is not necessary. In states 37 and 41, the PSR is pushed onto the system stack. In state 43, 46, and 52, the PC is pushed onto the system stack. Note",
    "18": "to state 47. In state 47, the trap vector (IR[7:0]) is loaded into the eight bit register Vector, PSR[15] is set to Supervisor mode since the trap service routine executes in privileged memory, and the state machine branches to state 37 or 45, depending on whether the program that executed the TRAP instruction was in User mode or Supervisor mode. If in User mode, state 45 saves the User Stack Pointer in Saved_USP, loads the stack pointer from Saved_SSP, and continues on to state 37 where the processor starts pushing PSR and PC on the stack. If the program executing the TRAP instruction is already in Privileged mode, state 45 is not necessary. In states 37 and 41, the PSR is pushed onto the system stack. In state 43, 46, and 52, the PC is pushed onto the system stack. Note that in state 43, the PC is decremented before being pushed onto the stack. This is necessary in the case of dealing with interrupts and exceptions, which will be explained in Section C.7. This is not necessary for processing the TRAP instruction, which is why PC is incremented in state 15. The only thing remaining is to load PC with the starting address of the trap service routine. This is done by loading MAR with the address of the proper entry in the trap vector table, obtained by concatenating Table and Vector (in state 54), loading the starting address from memory into MDR (in state 53), and loading the PC (in state 55). This completes the execution of the TRAP instruction, and controls returns to state 18 to begin processing the next instruction – in this case the first instruction of the trap service routine. The last instruction in every trap service routine is RTI (return from trap or interrupt). From DECODE in state 32, the next state of RTI is state 8, consistent with its eight bit opcode 1000. In states 8, 36, and 38, the PC is popped off the system stack and loaded into PC. In states 39,",
    "19": "the starting address of the trap service routine. This is done by loading MAR with the address of the proper entry in the trap vector table, obtained by concatenating Table and Vector (in state 54), loading the starting address from memory into MDR (in state 53), and loading the PC (in state 55). This completes the execution of the TRAP instruction, and controls returns to state 18 to begin processing the next instruction – in this case the first instruction of the trap service routine. The last instruction in every trap service routine is RTI (return from trap or interrupt). From DECODE in state 32, the next state of RTI is state 8, consistent with its eight bit opcode 1000. In states 8, 36, and 38, the PC is popped off the system stack and loaded into PC. In states 39, 40, 42, and 34, the PSR is popped off the system stack and loaded into PSR. This returns the PC and PSR to the values it had before the trap service routine was executed. Finally, if the program that invoked the TRAP instruction was in User mode, PSR[15] must be returned to 1, the Supervisor stack pointer saved, and the User stack pointer loaded into SP. This is done in state 59, completing the instruction cycle for RTI. § MEMORY-MAPPED I/O As you know from Chapter 8, the LC-3 ISA performs input and output via memory-mapped I/O, that is, with the same data movement instructions that it uses to read from and write to memory. The LC-3 does this by assigning an address to each device register. Input is accomplished by a load instruction whose effective address is the address of an input device register. Output is accomplished by a store instruction whose effective address is the address of an output device register. For example, in state 25 of Figure C.2, if the address in MAR is xFE02, MDR is supplied by the KBDR, and the data input will be the last keyboard character typed. On the other hand, if the",
    "20": "User stack pointer loaded into SP. This is done in state 59, completing the instruction cycle for RTI. § MEMORY-MAPPED I/O As you know from Chapter 8, the LC-3 ISA performs input and output via memory-mapped I/O, that is, with the same data movement instructions that it uses to read from and write to memory. The LC-3 does this by assigning an address to each device register. Input is accomplished by a load instruction whose effective address is the address of an input device register. Output is accomplished by a store instruction whose effective address is the address of an output device register. For example, in state 25 of Figure C.2, if the address in MAR is xFE02, MDR is supplied by the KBDR, and the data input will be the last keyboard character typed. On the other hand, if the address in MAR is a legitimate memory address, MDR is supplied by the memory. The state machine of Figure C.2 does not have to be altered to accommodate memory-mapped I/O. However, something has to determine when memory should be accessed and when I/O device registers should be accessed. This is the job of the address control logic (ADDR.CTL.LOGIC) shown in Figure C.3. Table C.3 is a truth table for the address control logic, showing what control signals are generated, based on (1) the contents of MAR, (2) whether or not memory or I/O is accessed this cycle (MIO.EN/NO, YES), and (3) whether a load (R.W/Read) or store (R.W/Write) is requested. Note that, for a memory-mapped load, data can be supplied to MDR from one of four sources: memory, KBDR, KBSR, or DSR. The address control logic provides the appropriate select signals to the INMUX. For a memory-mapped store, the data supplied by MDR can be written to memory, KBSR, DDR, or DSR. The address control logic supplies the appropriate enable signal to the corresponding structure. Truth Table for Address Control Logic 0pt10ptMAR0pt10pt MIO.EN R.W MEM.EN IN.MUX LD.KBSR LD.DSR LD.DDR 0pt10ptxFE000pt10pt 0 R 0 x 0 0 0 xFE00 0 W 0",
    "21": "Figure C.3. Table C.3 is a truth table for the address control logic, showing what control signals are generated, based on (1) the contents of MAR, (2) whether or not memory or I/O is accessed this cycle (MIO.EN/NO, YES), and (3) whether a load (R.W/Read) or store (R.W/Write) is requested. Note that, for a memory-mapped load, data can be supplied to MDR from one of four sources: memory, KBDR, KBSR, or DSR. The address control logic provides the appropriate select signals to the INMUX. For a memory-mapped store, the data supplied by MDR can be written to memory, KBSR, DDR, or DSR. The address control logic supplies the appropriate enable signal to the corresponding structure. Truth Table for Address Control Logic 0pt10ptMAR0pt10pt MIO.EN R.W MEM.EN IN.MUX LD.KBSR LD.DSR LD.DDR 0pt10ptxFE000pt10pt 0 R 0 x 0 0 0 xFE00 0 W 0 x 0 0 0 xFE00 1 R 0 KBSR 0 0 0 xFE00 1 W 0 x 1 0 0 xFE02 0 R 0 x 0 0 0 xFE02 0 W 0 x 0 0 0 xFE02 1 R 0 KBDR 0 0 0 xFE02 1 W 0 x 0 0 0 xFE04 0 R 0 x 0 0 0 xFE04 0 W 0 x 0 0 0 xFE04 1 R 0 DSR 0 0 0 xFE04 1 W 0 x 0 1 0 xFE06 0 R 0 x 0 0 0 xFE06 0 W 0 x 0 0 0 xFE06 1 R 0 x 0 0 0 xFE06 1 W 0 x 0 0 1 other 0 R 0 x 0 0 0 other 0 W 0 x 0 0 0 other 1 R 1 mem 0 0 0 other 1 W 1 x 0 0 0 § INTERRUPT AND EXCEPTION CONTROL The final piece of the state machine needed to complete the LC-3 story are those states that control the initiation of an interrupt, those states that control the return from an interrupt (the RTI instruction), and those states that control the initiation of one of the three exceptions",
    "22": "xFE04 0 W 0 x 0 0 0 xFE04 1 R 0 DSR 0 0 0 xFE04 1 W 0 x 0 1 0 xFE06 0 R 0 x 0 0 0 xFE06 0 W 0 x 0 0 0 xFE06 1 R 0 x 0 0 0 xFE06 1 W 0 x 0 0 1 other 0 R 0 x 0 0 0 other 0 W 0 x 0 0 0 other 1 R 1 mem 0 0 0 other 1 W 1 x 0 0 0 § INTERRUPT AND EXCEPTION CONTROL The final piece of the state machine needed to complete the LC-3 story are those states that control the initiation of an interrupt, those states that control the return from an interrupt (the RTI instruction), and those states that control the initiation of one of the three exceptions specified by the ISA. Interrupts and exceptions are very similar. Both stop the program that is currently executing. Both push the PSR and PC of the interrupted program onto the System stack, obtain the starting address of the interrupt or exception service routine from the interrupt vector table, and load that starting address into the Program Counter. The main difference between interrupts and exceptions is the nature of the event that causes the program that is executing to stop. Interrupts are events that usually have nothing to do with the program that is executing. Exceptions are events that are the direct result of something going awry in the program that is executing. The LC-3 specifies three exceptions: a privilege mode violation, an illegal opcode, and an ACV exception. Figure C.7 shows the state machine that carries these out. Figure C.8 shows the data path, after adding the additional structures to Figure C.3 that are needed to make interrupt and exception processing work. Section C.7.1 describes the flow of processing required to initiate an interrupt. Section C.7.3 describes the flow of processing required to initiate an exception. 36pc < g r a p h i c s > LC-3 state machine showing",
    "23": "between interrupts and exceptions is the nature of the event that causes the program that is executing to stop. Interrupts are events that usually have nothing to do with the program that is executing. Exceptions are events that are the direct result of something going awry in the program that is executing. The LC-3 specifies three exceptions: a privilege mode violation, an illegal opcode, and an ACV exception. Figure C.7 shows the state machine that carries these out. Figure C.8 shows the data path, after adding the additional structures to Figure C.3 that are needed to make interrupt and exception processing work. Section C.7.1 describes the flow of processing required to initiate an interrupt. Section C.7.3 describes the flow of processing required to initiate an exception. 36pc < g r a p h i c s > LC-3 state machine showing interrupt control 36pc < g r a p h i c s > LC-3 data path, including additional structures for interrupt control §.§ Initiating an Interrupt While a program is executing, an interrupt can be requested by some external event so that the normal processing of instructions can be preempted and the control can turn its attention to processing the interrupt. The external event requests an interrupt by asserting its interrupt request signal. Recall from Chapter 9 that if the priority level of the device asserting its interrupt request signal is higher than both the priority level of the currently executing program and any other external interrupt request asserted at the same time, INT is asserted and INTV is loaded with the interrupt vector corresponding to that external event. The microprocessor responds to INT by initiating the interrupt. That is, the processor puts itself into Supervisor mode if it isn't in Supervisor mode, pushes the PSR and PC of the interrupted process onto the Supervisor stack, and loads the PC with the starting address of the interrupt service routine. The PSR contains the privilege mode PSR[15], priority level PSR[10:8], and condition codes PSR[2:0] of a program. It is important that when",
    "24": "interrupt. The external event requests an interrupt by asserting its interrupt request signal. Recall from Chapter 9 that if the priority level of the device asserting its interrupt request signal is higher than both the priority level of the currently executing program and any other external interrupt request asserted at the same time, INT is asserted and INTV is loaded with the interrupt vector corresponding to that external event. The microprocessor responds to INT by initiating the interrupt. That is, the processor puts itself into Supervisor mode if it isn't in Supervisor mode, pushes the PSR and PC of the interrupted process onto the Supervisor stack, and loads the PC with the starting address of the interrupt service routine. The PSR contains the privilege mode PSR[15], priority level PSR[10:8], and condition codes PSR[2:0] of a program. It is important that when the processor resumes execution of the interrupted program, the privilege mode, priority level, and condition codes are restored to what they were when the interrupt occurred. The microarchitecture of the LC-3 initiates an interrupt as follows: Recall from Figure C.2 that in state 18, while MAR is loaded with the contents of PC and PC is incremented, INT is tested. State 18 is the only state in which the processor checks for interrupts. The reason for only testing in state 18 is straightforward: Once an LC-3 instruction starts processing, it is easier to let it finish its complete instruction cycle (FETCH, DECODE, etc.) than to interrupt it in the middle and have to keep track of how far along it was when the external device requested an interrupt (i.e., asserted INT). If INT is only tested in state 18, the current instruction cycle can be aborted early (even before the instruction has been fetched), and control directed to initiating the interrupt. The test is enabled by the control signals that make up COND5, which are 101 only in state 18, allowing the value of INT to pass through its four-input AND gate, shown in Figure C.5, to contribute to the address",
    "25": "State 18 is the only state in which the processor checks for interrupts. The reason for only testing in state 18 is straightforward: Once an LC-3 instruction starts processing, it is easier to let it finish its complete instruction cycle (FETCH, DECODE, etc.) than to interrupt it in the middle and have to keep track of how far along it was when the external device requested an interrupt (i.e., asserted INT). If INT is only tested in state 18, the current instruction cycle can be aborted early (even before the instruction has been fetched), and control directed to initiating the interrupt. The test is enabled by the control signals that make up COND5, which are 101 only in state 18, allowing the value of INT to pass through its four-input AND gate, shown in Figure C.5, to contribute to the address of the next state. Since the COND signals are not 101 in any other state, INT has no effect in any other state. In state 18, the ten microsequencer control bits are as follows: [style=intext] IRD/0 ; NO COND/101 ; Test for interrupts J/100001 If INT =1, a 1 is produced at the output of the AND gate, which in turn makes the next state address not 100001, corresponding to state 33, but rather 110001, corresponding to state 49. This starts the initiation of the interrupt (see Figure C.7). Several functions are performed in state 49. The PSR, which contains the privilege mode, priority level, and condition codes of the interrupted program, are loaded into MDR, in preparation for pushing it onto the Supervisor Stack. PSR[15] is cleared, reflecting the change to Supervisor mode, since all interrupt service routines execute in Supervisor mode. The 3-bit priority level and 8-bit interrupt vector (INTV) provided by the interrupting device are recorded. PSR[10:8] is loaded with the priority level of the interrupting device. The internal register Vector is loaded with INTV and the eight bit register Table is loaded with x01 in preparation for accessing the interrupt vector table to obtain the starting address",
    "26": "turn makes the next state address not 100001, corresponding to state 33, but rather 110001, corresponding to state 49. This starts the initiation of the interrupt (see Figure C.7). Several functions are performed in state 49. The PSR, which contains the privilege mode, priority level, and condition codes of the interrupted program, are loaded into MDR, in preparation for pushing it onto the Supervisor Stack. PSR[15] is cleared, reflecting the change to Supervisor mode, since all interrupt service routines execute in Supervisor mode. The 3-bit priority level and 8-bit interrupt vector (INTV) provided by the interrupting device are recorded. PSR[10:8] is loaded with the priority level of the interrupting device. The internal register Vector is loaded with INTV and the eight bit register Table is loaded with x01 in preparation for accessing the interrupt vector table to obtain the starting address of the interrupt service routine. Finally, the processor tests the old PSR[15] to determine whether the stack pointers must be adjusted before pushing PSR and PC. If the old PSR[15] = 0, the processor is already operating in Supervisor mode. R6 is the Supervisor Stack Pointer (SSP), so the processor proceeds immediately to states 37 and 41 to push the PSR of the interrupted program onto the Supervisor Stack. If PSR[15] = 1, the interrupted program was in User mode. In that case, the User Stack Pointer (USP) must be saved in Saved_USP and R6 must be loaded with the contents of Saved_SSP before moving to state 37. This is done in state 45. The control flow from state 49 to either 37 or 45 is enabled by the ten microsequencer control bits, as follows: [style=intext] IRD/0 ; NO COND/100 ; Test PSR[15], privilege mode J/100101 If PSR[15] = 0, control goes to state 37 (100101); if PSR[15] = 1, control goes to state 45 (101101). In state 37, R6 (the SSP) is decremented (preparing for the push), and MAR is loaded with the address of the new top of the stack. In state 41, the memory is enabled to WRITE",
    "27": "PSR of the interrupted program onto the Supervisor Stack. If PSR[15] = 1, the interrupted program was in User mode. In that case, the User Stack Pointer (USP) must be saved in Saved_USP and R6 must be loaded with the contents of Saved_SSP before moving to state 37. This is done in state 45. The control flow from state 49 to either 37 or 45 is enabled by the ten microsequencer control bits, as follows: [style=intext] IRD/0 ; NO COND/100 ; Test PSR[15], privilege mode J/100101 If PSR[15] = 0, control goes to state 37 (100101); if PSR[15] = 1, control goes to state 45 (101101). In state 37, R6 (the SSP) is decremented (preparing for the push), and MAR is loaded with the address of the new top of the stack. In state 41, the memory is enabled to WRITE (MIO.EN/YES, R.W/WR). When the write completes, signaled by R =1, PSR has been pushed onto the Supervisor Stack, and the flow moves on to state 43. In state 43, the PC is loaded into MDR. Note that state 43 says MDR is loaded with PC-1. Recall that in state 18, at the beginning of the instruction cycle for the interrupted instruction, PC was incremented. Loading MDR with PC-1 adjusts PC to the correct address of the interrupted program. In states 46 and 52, the same sequence as in states 37 and 41 occurs, only this time the PC of the interrupted program is pushed onto the Supervisor Stack. The final task to complete the initiation of the interrupt is to load the PC with the starting address of the interrupt service routine. This is carried out by states 54, 53, and 55. It is accomplished in a manner similar to the loading of the PC with the starting address of a TRAP service routine. The event causing the INT request supplies the 8-bit interrupt vector INTV associated with the interrupt, similar to the 8-bit trap vector contained in the TRAP instruction. This interrupt vector is stored in the 8-bit register INTV,",
    "28": "instruction, PC was incremented. Loading MDR with PC-1 adjusts PC to the correct address of the interrupted program. In states 46 and 52, the same sequence as in states 37 and 41 occurs, only this time the PC of the interrupted program is pushed onto the Supervisor Stack. The final task to complete the initiation of the interrupt is to load the PC with the starting address of the interrupt service routine. This is carried out by states 54, 53, and 55. It is accomplished in a manner similar to the loading of the PC with the starting address of a TRAP service routine. The event causing the INT request supplies the 8-bit interrupt vector INTV associated with the interrupt, similar to the 8-bit trap vector contained in the TRAP instruction. This interrupt vector is stored in the 8-bit register INTV, shown on the data path in Figure C.8. The interrupt vector table occupies memory locations x0100 to x01FF. In state 54, the interrupt vector that was loaded into Vector in state 49 is combined with the base address of the interrupt vector table (x0100) and loaded into MAR. In state 53, memory is READ. When R =1, the read has completed and MDR contains the starting address of the interrupt service routine. In state 55, the PC is loaded with that starting address, completing the initiation of the interrupt. It is important to emphasize that the LC-3 supports two stacks, one for each privilege mode, and two stack pointers (USP and SSP), one for each stack. R6 is the stack pointer and is loaded from the Saved_SSP when privilege changes from User mode to Supervisor mode, and from Saved_USP when privilege changes from Supervisor mode to User mode. When the Privilege mode changes, the current value in R6 must be stored in the appropriate \"Saved\" stack pointer in order to be available the next time the privilege mode changes back. §.§ Returning from an Interrupt or Trap service routine, RTI Interrupt service routines, like trap service routines already described, end with",
    "29": "completed and MDR contains the starting address of the interrupt service routine. In state 55, the PC is loaded with that starting address, completing the initiation of the interrupt. It is important to emphasize that the LC-3 supports two stacks, one for each privilege mode, and two stack pointers (USP and SSP), one for each stack. R6 is the stack pointer and is loaded from the Saved_SSP when privilege changes from User mode to Supervisor mode, and from Saved_USP when privilege changes from Supervisor mode to User mode. When the Privilege mode changes, the current value in R6 must be stored in the appropriate \"Saved\" stack pointer in order to be available the next time the privilege mode changes back. §.§ Returning from an Interrupt or Trap service routine, RTI Interrupt service routines, like trap service routines already described, end with the execution of the RTI instruction. The job of the RTI instruction is to restore the computer to the state it was in before the interrupt or trap service routine was executed. This means restoring the PSR (i.e., the privilege mode, priority level, and the values of the condition codes N, Z, P) and restoring the PC. These values were pushed onto the stack during the initiation of the interrupt or execution of the TRAP instruction. They must, therefore, be popped off the stack in the reverse order. The first state after DECODE is state 8. Here we load the MAR with the address of the top of the Supervisor Stack, which contains the last thing pushed (that has not been subsequently popped)—the state of the PC when the interrupt was initiated. At the same time, we test PSR[15] since RTI is a privileged instruction and can only execute in Supervisor mode. If PSR[15] = 0, we can continue to carry out the requirements of RTI. States 36 and 38 restore PC to the value it had when the interrupt was initiated. In state 36, the memory is read. When the read is completed, MDR contains the address of the instruction",
    "30": "pushed onto the stack during the initiation of the interrupt or execution of the TRAP instruction. They must, therefore, be popped off the stack in the reverse order. The first state after DECODE is state 8. Here we load the MAR with the address of the top of the Supervisor Stack, which contains the last thing pushed (that has not been subsequently popped)—the state of the PC when the interrupt was initiated. At the same time, we test PSR[15] since RTI is a privileged instruction and can only execute in Supervisor mode. If PSR[15] = 0, we can continue to carry out the requirements of RTI. States 36 and 38 restore PC to the value it had when the interrupt was initiated. In state 36, the memory is read. When the read is completed, MDR contains the address of the instruction that was to be processed next when the interrupt occurred. State 38 loads that address into the PC. States 39, 40, 42, and 34 restore the privilege mode, priority level, and condition codes (N, Z, P) to their original values. In state 39, the Supervisor Stack Pointer is incremented so that it points to the top of the stack after the PC was popped. The MAR is loaded with the address of the new top of the stack. State 40 initiates the memory READ; when the READ is completed, MDR contains the interrupted PSR. State 42 loads the PSR from MDR, and state 34 increments the stack pointer. The only thing left is to check the privilege mode of the interrupted program to see whether the stack pointers have to be switched. In state 34, the microsequencer control bits are as follows: [style=intext] IRD/0 ; NO COND/100 ; Test PSR[15], privilege mode J/110011 If PSR[15] = 0, control flows to state 51 (110011) to do nothing for one cycle. If PSR[15] = 1, control flows to state 59 where R6 is saved in Saved_SSP and R6 is loaded from Saved_USP. In both cases control returns to state 18 to begin processing",
    "31": "the PC was popped. The MAR is loaded with the address of the new top of the stack. State 40 initiates the memory READ; when the READ is completed, MDR contains the interrupted PSR. State 42 loads the PSR from MDR, and state 34 increments the stack pointer. The only thing left is to check the privilege mode of the interrupted program to see whether the stack pointers have to be switched. In state 34, the microsequencer control bits are as follows: [style=intext] IRD/0 ; NO COND/100 ; Test PSR[15], privilege mode J/110011 If PSR[15] = 0, control flows to state 51 (110011) to do nothing for one cycle. If PSR[15] = 1, control flows to state 59 where R6 is saved in Saved_SSP and R6 is loaded from Saved_USP. In both cases control returns to state 18 to begin processing the next instruction. §.§ Initiating an Exception The LC-3 identifies three cases where processing is not allowed to continue normally due to something going awry in the executing program. We refer to these cases as exceptions. They are initiated in the same way interrupts are initiated, by pushing the PSR and PC onto the system stack, obtaining the starting address of the exception service routine from the interrupt vector table, and loading that address into the PC to initiate the exception service routine. The three exceptions identified in the LC-3 are (1) a privileged mode exception caused by the program attempting to execute the RTI instruction while in User mode, (2) the illegal opcode exception caused by the program trying to execute an instruction whose opcode is 1101, and (3) an access control violation (ACV) exception caused by the program trying to access a privileged memory location while in User mode. §.§.§ Privilege Mode Exception If the processor is in User mode (PSR[15] = 1) and is attempting to execute RTI, a privileged mode exception occurs. The processor pushes the PSR and the address of the RTI instruction onto the Supervisor stack and loads the PC with the starting address of",
    "32": "of the exception service routine from the interrupt vector table, and loading that address into the PC to initiate the exception service routine. The three exceptions identified in the LC-3 are (1) a privileged mode exception caused by the program attempting to execute the RTI instruction while in User mode, (2) the illegal opcode exception caused by the program trying to execute an instruction whose opcode is 1101, and (3) an access control violation (ACV) exception caused by the program trying to access a privileged memory location while in User mode. §.§.§ Privilege Mode Exception If the processor is in User mode (PSR[15] = 1) and is attempting to execute RTI, a privileged mode exception occurs. The processor pushes the PSR and the address of the RTI instruction onto the Supervisor stack and loads the PC with the starting address of the service routine that handles privilege mode violations. Figure C.7 shows the flow, starting with a branch from state 8 to state 44 if PSR[15]=1. In state 44, the eight-bit Table register is loaded with x01 indicating the address of an entry in the interrupt vector table, the eight bit Vector register is loaded with x00, indicating the first entry in the interrupt vector table. The contents of x0100 is the starting address of the service routine that handles privilege mode exceptions. The MDR is loaded with the PSR of the program that caused the exception in preparation to pushing it on the System stack. Finally, PSR[15] is set to 0, since the service routine will execute with Supervisor privileges. Then the processor moves to state 45, where it follows the same flow as the initiation of interrupts. The main difference between this flow and that for the initiation of interrupts is in state 54, where MAR is loaded with x01'Vector. In the case of interrupts, Vector is loaded in state 49 with INTV, which is supplied by the interrupting device. In the case of the privilege mode violation, Vector is loaded in state 44 with x00. There are two additional",
    "33": "in the interrupt vector table. The contents of x0100 is the starting address of the service routine that handles privilege mode exceptions. The MDR is loaded with the PSR of the program that caused the exception in preparation to pushing it on the System stack. Finally, PSR[15] is set to 0, since the service routine will execute with Supervisor privileges. Then the processor moves to state 45, where it follows the same flow as the initiation of interrupts. The main difference between this flow and that for the initiation of interrupts is in state 54, where MAR is loaded with x01'Vector. In the case of interrupts, Vector is loaded in state 49 with INTV, which is supplied by the interrupting device. In the case of the privilege mode violation, Vector is loaded in state 44 with x00. There are two additional functions performed in state 49 that are not performed in state 44. First, the priority level is changed, based on the priority of the interrupting device. We do not change the priority in handling a privilege mode violation. The service routine executes at the same priority as the program that caused the violation. Second, a test to determine the privilege mode is performed for an interrupt. This is unnecessary for a privilege mode violation since the processor already knows it is executing in User mode. §.§.§ Illegal Opcode Exception Although it would be a rare situation, it is possible, we suppose, that a programmer writing a program in machine language could mistakenly include an instruction having opcode = 1101. Since there is no such opcode in the LC-3 ISA, the computer can not process that instruction. State 32 performs the DECODE, and the next state is state 13. The action the processor takes is very similar to that of a privilege mode exception. The PSR and PC of the program are pushed onto the Supervisor Stack and the PC is loaded with the starting address of the Illegal Opcode exception service routine. State 13 is very similar to state 44 which",
    "34": "mode is performed for an interrupt. This is unnecessary for a privilege mode violation since the processor already knows it is executing in User mode. §.§.§ Illegal Opcode Exception Although it would be a rare situation, it is possible, we suppose, that a programmer writing a program in machine language could mistakenly include an instruction having opcode = 1101. Since there is no such opcode in the LC-3 ISA, the computer can not process that instruction. State 32 performs the DECODE, and the next state is state 13. The action the processor takes is very similar to that of a privilege mode exception. The PSR and PC of the program are pushed onto the Supervisor Stack and the PC is loaded with the starting address of the Illegal Opcode exception service routine. State 13 is very similar to state 44 which starts the initiation of a privilege mode exception. There are two differences: (1) Vector is loaded with x01, since the starting address of the service routine for the illegal opcode exception is in x0101. (2) In the case of the privilege mode exception, we know the program is in User mode when the processor attempts to execute the RTI instruction. In the case of an illegal opcode, the processor can be in either mode, so from state 13. the processor goes to state 37 or state 45 depending on whether the program is executing in Supervisor mode or User mode when the illegal opcode instruction is encountered. Like state 44, the priority of the running program is not changed, since the urgency of handling the exception is the same as the urgency of executing the program that contains it. Like state 49, state 13 tests the Privilege mode of the program that contains the illegal opcode, since if the currently executing program is in User mode, the stack pointers need to be switched as described in Section C.7.1. Like state 49, the processor then microbranches either to state 37 if the stack pointer is already pointing to the Supervisor stack, or",
    "35": "In the case of an illegal opcode, the processor can be in either mode, so from state 13. the processor goes to state 37 or state 45 depending on whether the program is executing in Supervisor mode or User mode when the illegal opcode instruction is encountered. Like state 44, the priority of the running program is not changed, since the urgency of handling the exception is the same as the urgency of executing the program that contains it. Like state 49, state 13 tests the Privilege mode of the program that contains the illegal opcode, since if the currently executing program is in User mode, the stack pointers need to be switched as described in Section C.7.1. Like state 49, the processor then microbranches either to state 37 if the stack pointer is already pointing to the Supervisor stack, or to state 45 if the stack pointers have to be switched. From there, the initiating sequence continues in states 37, 41, 43, etc., identical to what happens when an interrupt is initiated (Section C.7.1) or a privilege mode exception is initiated (Section C.7.3.1). The PSR and PC are pushed onto the Supervisor Stack and the starting address of the service routine is loaded into the PC, completing the initiation of the exception. §.§.§ Access Control Violation (ACV) Exception An Access Control Violation (ACV) exception occurs if the processor attempts to access privileged memory while operating in User mode. The state machine checks for this in every case where the processor accesses memory, that is, in states 17, 19, 23, 33, and 35. If an ACV violation occurs, the next state is respectively states 56, 61, 48, 60, or 57 (see Figure C.2). In all five states, the processor loads Table with x01, Vector with x02, MDR with the PSR, sets PSR[15] to 0, exactly like state 44, with one exception. Vector is set to x02 since the starting address of the ACV exception service routine is in memory location x0102. Processing continues exactly like in state 44, moving first to state",
    "36": "routine is loaded into the PC, completing the initiation of the exception. §.§.§ Access Control Violation (ACV) Exception An Access Control Violation (ACV) exception occurs if the processor attempts to access privileged memory while operating in User mode. The state machine checks for this in every case where the processor accesses memory, that is, in states 17, 19, 23, 33, and 35. If an ACV violation occurs, the next state is respectively states 56, 61, 48, 60, or 57 (see Figure C.2). In all five states, the processor loads Table with x01, Vector with x02, MDR with the PSR, sets PSR[15] to 0, exactly like state 44, with one exception. Vector is set to x02 since the starting address of the ACV exception service routine is in memory location x0102. Processing continues exactly like in state 44, moving first to state 45 to switch to the System stack, and then pushing PSR and PC onto the stack and loading the PC with the starting address of the service routine. § CONTROL STORE Figure C.9 completes our microprogrammed implementation of the LC-3. It shows the contents of each location of the control store, corresponding to the 52 control signals required by each state of the state machine. We have left the exact entries blank to allow you, the reader, the joy of filling in the required signals yourself. The solution is available from your instructor. 36pc < g r a p h i c s > Specification of the control store ../art/appendix/,../art/designelements/,../art/designelements/UnNumberedArt/ CHAPTER: THE LC-3 ISA § OVERVIEW The Instruction Set Architecture (ISA) of the LC-3 is defined as follows: 18pt Memory address space 16 bits, corresponding to 2^16 locations, each containing one word (16 bits). Addresses are numbered from 0 (i.e, x0000) to 65,535 (i.e., xFFFF). Addresses are used to identify memory locations and memory-mapped I/O device registers. Certain regions of memory are reserved for special uses, as described in Figure A.1. < g r a p h i c s > Memory map of the LC-3 Locations x0000 to x2FFF comprise",
    "37": "state of the state machine. We have left the exact entries blank to allow you, the reader, the joy of filling in the required signals yourself. The solution is available from your instructor. 36pc < g r a p h i c s > Specification of the control store ../art/appendix/,../art/designelements/,../art/designelements/UnNumberedArt/ CHAPTER: THE LC-3 ISA § OVERVIEW The Instruction Set Architecture (ISA) of the LC-3 is defined as follows: 18pt Memory address space 16 bits, corresponding to 2^16 locations, each containing one word (16 bits). Addresses are numbered from 0 (i.e, x0000) to 65,535 (i.e., xFFFF). Addresses are used to identify memory locations and memory-mapped I/O device registers. Certain regions of memory are reserved for special uses, as described in Figure A.1. < g r a p h i c s > Memory map of the LC-3 Locations x0000 to x2FFF comprise privileged memory, and are only accessible if the process is executing in Supervisor mode (PSR[15]=0). Locations x3000 to xFDFF comprise memory available to user code and data. Addresses xFE00 to xFFFF specify input and output device registers and special internal processor registers that are also only accessible if the process is executing in Supervisor mode (PSR[15]=0). For purposes of controlling access to these device registers, their addresses are also considered part of privileged memory. Memory-mapped I/O Input and output are handled by load/store (LD/ST, LDI/STI, LDR/STR) instructions using memory addresses from xFE00 to xFFFF to designate each device register. Table A.1 lists the input and output device registers and internal processor registers that have been specified for the LC-3 thus far, along with their corresponding assigned addresses from the memory address space. Device Register Assignments Address I/O Register Name I/O Register Function xFE00 Keyboard status register (KBSR) The ready bit (bit [15]) indicates if the keyboard has received a new character. xFE02 Keyboard data register (KBDR) Bits [7:0] contain the last character typed on the keyboard. xFE04 Display status register (DSR) The ready bit (bit [15]) indicates if the display device is ready to receive another character to print on the",
    "38": "access to these device registers, their addresses are also considered part of privileged memory. Memory-mapped I/O Input and output are handled by load/store (LD/ST, LDI/STI, LDR/STR) instructions using memory addresses from xFE00 to xFFFF to designate each device register. Table A.1 lists the input and output device registers and internal processor registers that have been specified for the LC-3 thus far, along with their corresponding assigned addresses from the memory address space. Device Register Assignments Address I/O Register Name I/O Register Function xFE00 Keyboard status register (KBSR) The ready bit (bit [15]) indicates if the keyboard has received a new character. xFE02 Keyboard data register (KBDR) Bits [7:0] contain the last character typed on the keyboard. xFE04 Display status register (DSR) The ready bit (bit [15]) indicates if the display device is ready to receive another character to print on the screen. xFE06 Display data register (DDR) A character written in bits [7:0] will be displayed on the screen. xFFFC Processor Status Register (PSR) Contains privilege mode, priority level and condition codes of the currently executing process. xFFFE Machine control register (MCR) Bit [15] is the clock enable bit. When cleared, instruction processing stops. Bit numbering Bits of all quantities are numbered, from right to left, starting with bit 0. The leftmost bit of the contents of a memory location is bit 15. Instructions Instructions are 16 bits wide. Bits [15:12] specify the opcode (operation to be performed), bits [11:0] provide further information that is needed to execute the instruction. The specific operation of each LC-3 instruction is described in Section A.2. Illegal opcode exception Bits [15:12]=1101 has not been specified. If an instruction contains 1101 in bits [15:12], an illegal opcode exception occurs. Section A.3 explains what happens. Program counter A 16-bit register containing the address of the next instruction to be processed. General purpose registers Eight 16-bit registers, numbered from 000 to 111 (R0 to R7). Condition codes Three 1-bit registers: N (negative), Z (zero), and P (positive). Load instructions (LD, LDI, and LDR) and operate instructions (ADD, AND, and",
    "39": "numbered, from right to left, starting with bit 0. The leftmost bit of the contents of a memory location is bit 15. Instructions Instructions are 16 bits wide. Bits [15:12] specify the opcode (operation to be performed), bits [11:0] provide further information that is needed to execute the instruction. The specific operation of each LC-3 instruction is described in Section A.2. Illegal opcode exception Bits [15:12]=1101 has not been specified. If an instruction contains 1101 in bits [15:12], an illegal opcode exception occurs. Section A.3 explains what happens. Program counter A 16-bit register containing the address of the next instruction to be processed. General purpose registers Eight 16-bit registers, numbered from 000 to 111 (R0 to R7). Condition codes Three 1-bit registers: N (negative), Z (zero), and P (positive). Load instructions (LD, LDI, and LDR) and operate instructions (ADD, AND, and NOT) each load a result into one of the eight general purpose registers. The condition codes are set, based on whether that result, taken as a 16-bit 2's complement integer, is negative ( N=1; Z, P=0), zero ( Z=1; N, P=0), or positive ( P=1; N, Z=0). All other LC-3 instructions leave the condition codes unchanged. Interrupt processing I/O devices have the capability of interrupting the processor. Section A.3 describes the mechanism. Priority level The LC-3 supports eight levels of priority. Priority level 7 (PL7) is the highest, PL0 is the lowest. The priority level of the currently executing process is specified in bits PSR[10:8]. Processor status register (PSR) A 16-bit register, containing status information about the currently executing process. Seven bits of the PSR have been defined thus far. PSR[15] specifies the privilege mode of the executing process. PSR[10:8] specifies the priority level of the currently executing process. PSR[2:0] contains the condition codes. PSR[2] is N, PSR[1] is Z, and PSR[0] is P. Supervisor mode The LC-3 specifies two modes of operation, Supervisor mode (privileged) and User mode (unprivileged). Interrupt service routines and trap service routines (i.e., system calls) execute in Supervisor mode. The privilege mode is specified by PSR[15].",
    "40": "have the capability of interrupting the processor. Section A.3 describes the mechanism. Priority level The LC-3 supports eight levels of priority. Priority level 7 (PL7) is the highest, PL0 is the lowest. The priority level of the currently executing process is specified in bits PSR[10:8]. Processor status register (PSR) A 16-bit register, containing status information about the currently executing process. Seven bits of the PSR have been defined thus far. PSR[15] specifies the privilege mode of the executing process. PSR[10:8] specifies the priority level of the currently executing process. PSR[2:0] contains the condition codes. PSR[2] is N, PSR[1] is Z, and PSR[0] is P. Supervisor mode The LC-3 specifies two modes of operation, Supervisor mode (privileged) and User mode (unprivileged). Interrupt service routines and trap service routines (i.e., system calls) execute in Supervisor mode. The privilege mode is specified by PSR[15]. PSR[15]=0 indicates Supervisor mode; PSR[15]=1 indicates User mode. Privilege mode exception The RTI instruction executes in Supervisor mode. If the processor attempts to execute the RTI instruction while in User mode, a privilege mode exception occurs. Section A.3 explains what happens. Access Control Violation (ACV) Exception An ACV exception occurs if a process attempts to access a location in privileged memory (either a location in System Space or a device register having an address from xFE00 to xFFFF) while operating in User mode. Section A.3 explains what happens. Supervisor Stack A region of memory in system space accessible via the Supervisor Stack Pointer (SSP). When PSR[15]=0, the stack pointer (R6) is SSP. When the processor is operating in User mode (PSR[15]=1), the SSP is stored in Saved_SSP. User Stack A region of memory in user space accessible via the User Stack Pointer (USP). When PSR[15]=1, the stack pointer (R6) is USP. When the processor is operating in Supervisor mode (PSR[15]=0), the USP is stored in Saved_USP § THE INSTRUCTION SET The LC-3 supports a rich, but lean, instruction set. Each 16-bit instruction consists of an opcode (bits[15:12]) plus 12 additional bits to specify the other information that is needed to carry",
    "41": "memory (either a location in System Space or a device register having an address from xFE00 to xFFFF) while operating in User mode. Section A.3 explains what happens. Supervisor Stack A region of memory in system space accessible via the Supervisor Stack Pointer (SSP). When PSR[15]=0, the stack pointer (R6) is SSP. When the processor is operating in User mode (PSR[15]=1), the SSP is stored in Saved_SSP. User Stack A region of memory in user space accessible via the User Stack Pointer (USP). When PSR[15]=1, the stack pointer (R6) is USP. When the processor is operating in Supervisor mode (PSR[15]=0), the USP is stored in Saved_USP § THE INSTRUCTION SET The LC-3 supports a rich, but lean, instruction set. Each 16-bit instruction consists of an opcode (bits[15:12]) plus 12 additional bits to specify the other information that is needed to carry out that instruction. Figure A.2 summarizes the 15 different opcodes in the LC-3 and the specification of the remaining bits of each instruction. The 16th 4-bit opcode is not specified, but is reserved for future use. In the following pages, the instructions will be described in greater detail. Table A.2 is provided to help understand those descriptions. For each instruction, we show the assembly language representation, the format of the 16-bit instruction, the operation of the instruction, an English-language description of its operation, and one or more examples of the instruction. Where relevant, additional notes about the instruction are also provided. Notational Conventions Notation Meaning xNumber The number in hexadecimal notation. Example: xF2A1 #Number The number in decimal notation. Example #793 bNumber The number in binary. Example b10011 A[l:r] The field delimited by bit [l] on the left and bit [r] on the right, of the datum A. For example, if PC contains 0011001100111111, then PC[15:9] is 0011001. PC[2:2] is 1. If l and r are the same bit number, we generally write PC[2]. BaseR Base Register; one of R0..R7, specified by bits [8:6] of the instruction, used in conjunction with a six-bit offset to compute Base+offset addresses (LDR and STR),",
    "42": "we show the assembly language representation, the format of the 16-bit instruction, the operation of the instruction, an English-language description of its operation, and one or more examples of the instruction. Where relevant, additional notes about the instruction are also provided. Notational Conventions Notation Meaning xNumber The number in hexadecimal notation. Example: xF2A1 #Number The number in decimal notation. Example #793 bNumber The number in binary. Example b10011 A[l:r] The field delimited by bit [l] on the left and bit [r] on the right, of the datum A. For example, if PC contains 0011001100111111, then PC[15:9] is 0011001. PC[2:2] is 1. If l and r are the same bit number, we generally write PC[2]. BaseR Base Register; one of R0..R7, specified by bits [8:6] of the instruction, used in conjunction with a six-bit offset to compute Base+offset addresses (LDR and STR), or alone to identify the target address of a control instruction (JMP and JSRR). DR Destination Register; one of R0..R7, which specifies the register a result should be written to. imm5 A 5-bit immediate value (bits [4:0] of an instruction), when used as a literal (immediate) value. Taken as a 5-bit, 2's complement integer, it is sign-extended to 16 bits before it is used. Range: -16..15. INTV An 8-bit value, supplied along with an interrupting event; used to determine the starting address of an interrupt service routine. The eight bits form an offset from the starting address of the interrupt vector table. The corresponding location in the interrupt vector table contains the starting address of the corresponding interrupt service routine. Range 0..255. LABEL An assembly language construct that identifies a location symbolically (i.e., by means of a name, rather than its 16-bit address). mem[address] Denotes the contents of memory at the given address. offset6 A 6-bit signed 2's complement integer (bits [5:0] of an instruction), used with the Base+offset addressing mode. Bits [5:0] are sign-extended to 16 bits and then added to the Base Register to form an address. Range: -32..31. PC Program Counter; 16-bit register that contains the memory address",
    "43": "before it is used. Range: -16..15. INTV An 8-bit value, supplied along with an interrupting event; used to determine the starting address of an interrupt service routine. The eight bits form an offset from the starting address of the interrupt vector table. The corresponding location in the interrupt vector table contains the starting address of the corresponding interrupt service routine. Range 0..255. LABEL An assembly language construct that identifies a location symbolically (i.e., by means of a name, rather than its 16-bit address). mem[address] Denotes the contents of memory at the given address. offset6 A 6-bit signed 2's complement integer (bits [5:0] of an instruction), used with the Base+offset addressing mode. Bits [5:0] are sign-extended to 16 bits and then added to the Base Register to form an address. Range: -32..31. PC Program Counter; 16-bit register that contains the memory address of the next instruction to be fetched. For example, if the instruction at address A is not a control instruction, during its execution, the PC contains the address A+1, indicating that the next instruction to be executed is contained in memory location A+1. PCoffset9 A 9-bit signed 2's complement integer (bits [8:0] of an instruction), used with the PC+offset addressing mode. Bits [8:0] are sign-extended to 16 bits and then added to the incremented PC to form an address. Range -256..255. PCoffset11 An 11-bit signed 2's complement integer (bits [10:0] of an instruction), used with the JSR opcode to compute the target address of a subroutine call. Bits [10:0] are sign-extended to 16 bits and then added to the incremented PC to form the target address. Range -1024..1023. PSR Processor Status Register. A 16-bit register that contains status information of the process that is executing. Seven bits of the PSR have been specified. PSR[15]=privilege mode. PSR[10:8] = Priority Level. PSR[2:0] contains the condition codes. PSR[2]= N, PSR[1]= Z, PSR[0]= P. SavedSSP Saved Supervisor Stack Pointer. The processor is executing in either Supervisor mode or User mode. If in User mode, R6, the stack pointer, is the User Stack Pointer (USP). The",
    "44": "mode. Bits [8:0] are sign-extended to 16 bits and then added to the incremented PC to form an address. Range -256..255. PCoffset11 An 11-bit signed 2's complement integer (bits [10:0] of an instruction), used with the JSR opcode to compute the target address of a subroutine call. Bits [10:0] are sign-extended to 16 bits and then added to the incremented PC to form the target address. Range -1024..1023. PSR Processor Status Register. A 16-bit register that contains status information of the process that is executing. Seven bits of the PSR have been specified. PSR[15]=privilege mode. PSR[10:8] = Priority Level. PSR[2:0] contains the condition codes. PSR[2]= N, PSR[1]= Z, PSR[0]= P. SavedSSP Saved Supervisor Stack Pointer. The processor is executing in either Supervisor mode or User mode. If in User mode, R6, the stack pointer, is the User Stack Pointer (USP). The Supervisor Stack Pointer (SSP) is stored in SavedSSP. When the privilege mode changes from User mode to Supervisor mode, SavedUSP is loaded with R6 and R6 is loaded with SavedSSP. SavedUSP Saved User Stack Pointer. The User Stack Pointer is stored in SavedUSP when the processor is executing in Supervisor mode. See SavedSSP. setcc() Indicates that condition codes N, Z, and P are set based on the value of the result written to DR. SEXT(A) Sign-extend A. The most significant bit of A is replicated as many times as necessary to extend A to 16 bits. For example, if A=110000, then SEXT(A)=1111 1111 1111 0000. SP The current stack pointer. R6 is the current stack pointer. There are two stacks, one for each privilege mode. SP is SSP if PSR[15]=0; SP is USP if PSR[15]=1. SR, SR1, SR2 Source Register; one of R0..R7 which specifies the register from which a source operand is obtained. SSP The Supervisor Stack Pointer. trapvect8 An 8-bit value; (bits [7:0] of an instruction), used with the TRAP opcode to determine the starting address of a trap service routine. Bits [7:0] are taken as an unsigned integer and zero-extended to 16 bits. This is the address of",
    "45": "and P are set based on the value of the result written to DR. SEXT(A) Sign-extend A. The most significant bit of A is replicated as many times as necessary to extend A to 16 bits. For example, if A=110000, then SEXT(A)=1111 1111 1111 0000. SP The current stack pointer. R6 is the current stack pointer. There are two stacks, one for each privilege mode. SP is SSP if PSR[15]=0; SP is USP if PSR[15]=1. SR, SR1, SR2 Source Register; one of R0..R7 which specifies the register from which a source operand is obtained. SSP The Supervisor Stack Pointer. trapvect8 An 8-bit value; (bits [7:0] of an instruction), used with the TRAP opcode to determine the starting address of a trap service routine. Bits [7:0] are taken as an unsigned integer and zero-extended to 16 bits. This is the address of the memory location containing the starting address of the corresponding service routine. Range 0..255. USP The User Stack Pointer. ZEXT(A) Zero-extend A. Zeros are appended to the leftmost bit of A to extend it to 16 bits. For example, if A=110000, then ZEXT(A)=0000 0000 0011 0000. < g r a p h i c s > Format of the entire LC-3 instruction set. Note: + indicates instructions that modify condition codes AddAddition Assembler Formats ADD DR, SR1, SR2 ADD DR, SR1, imm5 Encodings < g r a p h i c s > Operation colc̄olc̄olif (bit[5] == 0) DR = SR1 + SR2; else DR = SR1 + SEXT(imm5); setcc(); Description If bit [5] is 0, the second source operand is obtained from SR2. If bit [5] is 1, the second source operand is obtained by sign-extending the imm5 field to 16 bits. In both cases, the second source operand is added to the contents of SR1 and the result stored in DR. The condition codes are set, based on whether the result is negative, zero, or positive. Examples ADD R2, R3, R4 ; R2 ← R3+ R4 ADD R2, R3, #7 ; R2 ← R3+7 And Bit-wise Logical AND Assembler",
    "46": "LC-3 instruction set. Note: + indicates instructions that modify condition codes AddAddition Assembler Formats ADD DR, SR1, SR2 ADD DR, SR1, imm5 Encodings < g r a p h i c s > Operation colc̄olc̄olif (bit[5] == 0) DR = SR1 + SR2; else DR = SR1 + SEXT(imm5); setcc(); Description If bit [5] is 0, the second source operand is obtained from SR2. If bit [5] is 1, the second source operand is obtained by sign-extending the imm5 field to 16 bits. In both cases, the second source operand is added to the contents of SR1 and the result stored in DR. The condition codes are set, based on whether the result is negative, zero, or positive. Examples ADD R2, R3, R4 ; R2 ← R3+ R4 ADD R2, R3, #7 ; R2 ← R3+7 And Bit-wise Logical AND Assembler Formats AND DR, SR1, SR2 AND DR, SR1, imm5 Encodings < g r a p h i c s > Operation colc̄olc̄olif (bit[5] == 0) DR = SR1 AND SR2; else DR = SR1 AND SEXT(imm5); setcc(); Description If bit [5] is 0, the second source operand is obtained from SR2. If bit [5] is 1, the second source operand is obtained by sign-extending the imm5 field to 16 bits. In either case, the second source operand and the contents of SR1 are bit-wise ANDed, and the result stored in DR. The condition codes are set, based on whether the binary value produced, taken as a 2's complement integer, is negative, zero, or positive. Examples AND R2, R3, R4 ;R2 ← R3 AND R4 AND R2, R3, #7 ;R2 ← R3 AND 7 Br Conditional Branch Assembler Formats BRn LABEL BRzp LABEL BRz LABEL BRnp LABEL BRp LABEL BRnz LABEL BR^† LABEL BRnzp LABEL [2]The assembly language opcode BR is interpreted the same as BRnzp; that is, always branch to the target address. Encoding < g r a p h i c s > Operation colc̄olc̄olif ((n AND N) OR (z AND Z) OR (p AND P)) PC = PC^ +",
    "47": "is obtained by sign-extending the imm5 field to 16 bits. In either case, the second source operand and the contents of SR1 are bit-wise ANDed, and the result stored in DR. The condition codes are set, based on whether the binary value produced, taken as a 2's complement integer, is negative, zero, or positive. Examples AND R2, R3, R4 ;R2 ← R3 AND R4 AND R2, R3, #7 ;R2 ← R3 AND 7 Br Conditional Branch Assembler Formats BRn LABEL BRzp LABEL BRz LABEL BRnp LABEL BRp LABEL BRnz LABEL BR^† LABEL BRnzp LABEL [2]The assembly language opcode BR is interpreted the same as BRnzp; that is, always branch to the target address. Encoding < g r a p h i c s > Operation colc̄olc̄olif ((n AND N) OR (z AND Z) OR (p AND P)) PC = PC^ + SEXT(PCoffset9); [3]This is the incremented PC. Description The condition codes specified by bits [11:9] are tested. If bit [11] is 1, N is tested; if bit [11] is 0, N is not tested. If bit [10] is 1, Z is tested, etc. If any of the condition codes tested is 1, the program branches to the memory location specified by adding the sign-extended PCoffset9 field to the incremented PC. Examples BRzp LOOP ; Branch to LOOP if the last result was zero or positive. BR[2] NEXT ; Unconditionally branch to NEXT. Jmp RetJump Return from Subroutine Assembler Formats JMP BaseR RET Encoding < g r a p h i c s > < g r a p h i c s > Operation PC=BaseR; Description The program unconditionally jumps to the location specified by the contents of the base register. Bits [8:6] identify the base register. Examples JMP R2 ; PC← R2 RET ; PC← R7 Note The RET instruction is a special case of the JMP instruction, normally used in the return from a subroutine. The PC is loaded with the contents of R7, which contains the linkage back to the instruction following the subroutine call instruction. Jsr Jsrr Jump",
    "48": "adding the sign-extended PCoffset9 field to the incremented PC. Examples BRzp LOOP ; Branch to LOOP if the last result was zero or positive. BR[2] NEXT ; Unconditionally branch to NEXT. Jmp RetJump Return from Subroutine Assembler Formats JMP BaseR RET Encoding < g r a p h i c s > < g r a p h i c s > Operation PC=BaseR; Description The program unconditionally jumps to the location specified by the contents of the base register. Bits [8:6] identify the base register. Examples JMP R2 ; PC← R2 RET ; PC← R7 Note The RET instruction is a special case of the JMP instruction, normally used in the return from a subroutine. The PC is loaded with the contents of R7, which contains the linkage back to the instruction following the subroutine call instruction. Jsr Jsrr Jump to Subroutine Assembler Formats JSR LABEL JSRR BaseR Encoding < g r a p h i c s > Operation colc̄olc̄olTEMP = PC;^† if (bit[11] == 0) PC=BaseR; else PC = PC[2] + SEXT(PCoffset11); R7 = TEMP; [2]This is the incremented PC. Description First, the incremented PC is saved in a temporary location. Then the PC is loaded with the address of the first instruction of the subroutine, which will cause an unconditional jump to that address after the current instruction completes execution. The address of the subroutine is obtained from the base register (if bit [11] is 0), or the address is computed by sign-extending bits [10:0] and adding this value to the incremented PC (if bit [11] is 1). Finally, R7 is loaded with the value stored in the temporary location. This is the linkage back to the calling routine. Examples JSR QUEUE ; Put the address of the instruction following JSR into R7; ; Jump to QUEUE. JSRR R3 ; Put the address of the instruction following JSRR into R7; ; Jump to the address contained in R3. LdLoad Assembler Format LD DR, LABEL Encoding < g r a p h i c s > Operation colc̄olc̄olif (computed",
    "49": "address of the first instruction of the subroutine, which will cause an unconditional jump to that address after the current instruction completes execution. The address of the subroutine is obtained from the base register (if bit [11] is 0), or the address is computed by sign-extending bits [10:0] and adding this value to the incremented PC (if bit [11] is 1). Finally, R7 is loaded with the value stored in the temporary location. This is the linkage back to the calling routine. Examples JSR QUEUE ; Put the address of the instruction following JSR into R7; ; Jump to QUEUE. JSRR R3 ; Put the address of the instruction following JSRR into R7; ; Jump to the address contained in R3. LdLoad Assembler Format LD DR, LABEL Encoding < g r a p h i c s > Operation colc̄olc̄olif (computed address is in privileged memory AND PSR[15] == 1) Initiate ACV exception; else DR=mem[PC^† + SEXT(PCoffset9)]; setcc(); [2]This is the incremented PC. Description An address is computed by sign-extending bits [8:0] to 16 bits and adding this value to the incremented PC. If the address is to privileged memory and PSR[15]=1, initiate ACV exception. If not, the contents of memory at this address are loaded into DR. The condition codes are set, based on whether the value loaded is negative, zero, or positive. Example LD R4, VALUE ; R4 ←mem[VALUE] Ldi Load Indirect Assembler Format LDI DR, LABEL Encoding < g r a p h i c s > Operation colc̄olc̄olif (either computed address is in privileged memory AND PSR[15] == 1) Initiate ACV exception; else DR=mem[mem[PC^† + SEXT(PCoffset9)]]; setcc(); [2]This is the incremented PC. Description An address is computed by sign-extending bits [8:0] to 16 bits and adding this value to the incremented PC. What is stored in memory at this address is the address of the data to be loaded into DR. If either address is to privileged memory and PSR[15]=1, initiate ACV exception. If not, the data is loaded and the condition codes are set, based on whether",
    "50": "at this address are loaded into DR. The condition codes are set, based on whether the value loaded is negative, zero, or positive. Example LD R4, VALUE ; R4 ←mem[VALUE] Ldi Load Indirect Assembler Format LDI DR, LABEL Encoding < g r a p h i c s > Operation colc̄olc̄olif (either computed address is in privileged memory AND PSR[15] == 1) Initiate ACV exception; else DR=mem[mem[PC^† + SEXT(PCoffset9)]]; setcc(); [2]This is the incremented PC. Description An address is computed by sign-extending bits [8:0] to 16 bits and adding this value to the incremented PC. What is stored in memory at this address is the address of the data to be loaded into DR. If either address is to privileged memory and PSR[15]=1, initiate ACV exception. If not, the data is loaded and the condition codes are set, based on whether the value loaded is negative, zero, or positive. Example LDI R4, ONEMORE ; R4 ←mem[mem[ONEMORE]] Ldr Load Base+offset Assembler Format LDR DR, BaseR, offset6 Encoding < g r a p h i c s > Operation colc̄olc̄olIf (computed address is in privileged memory AND PSR[15] == 1) Initiate ACV exception; else DR=mem[BaseR + SEXT(offset6)]; setcc(); Description An address is computed by sign-extending bits [5:0] to 16 bits and adding this value to the contents of the register specified by bits [8:6]. If the computed address is to privileged memory and PSR[15]=1, initiate ACV exception. If not, the contents of memory at this address are loaded into DR. The condition codes are set, based on whether the value loaded is negative, zero, or positive. Example LDR R4, R2, #-5 ; R4 ←mem[R2-5] Lea Load Effective Address Assembler Format LEA DR, LABEL Encoding < g r a p h i c s > Operation colc̄olc̄olDR=PC^† + SEXT(PCoffset9); [2]This is the incremented PC. Description An address is computed by sign-extending bits [8:0] to 16 bits and adding this value to the incremented PC. This address is loaded into DR.[The LEA instruction computes an address but does NOT read memory. Instead, the address itself is",
    "51": "by sign-extending bits [5:0] to 16 bits and adding this value to the contents of the register specified by bits [8:6]. If the computed address is to privileged memory and PSR[15]=1, initiate ACV exception. If not, the contents of memory at this address are loaded into DR. The condition codes are set, based on whether the value loaded is negative, zero, or positive. Example LDR R4, R2, #-5 ; R4 ←mem[R2-5] Lea Load Effective Address Assembler Format LEA DR, LABEL Encoding < g r a p h i c s > Operation colc̄olc̄olDR=PC^† + SEXT(PCoffset9); [2]This is the incremented PC. Description An address is computed by sign-extending bits [8:0] to 16 bits and adding this value to the incremented PC. This address is loaded into DR.[The LEA instruction computes an address but does NOT read memory. Instead, the address itself is loaded into DR.] Example LEA R4, TARGET ; R4 ←address of TARGET. NotBit-Wise Complement Assembler Format NOT DR, SR Encoding < g r a p h i c s > Operation colc̄olc̄olDR = NOT(SR); setcc(); Description The bit-wise complement of the contents of SR is stored in DR. The condition codes are set, based on whether the binary value produced, taken as a 2's complement integer, is negative, zero, or positive. Example NOT R4, R2 ; R4←NOT(R2) RET[2] Return from Subroutine Assembler Format [2]The RET instruction is a specific encoding of the JMP instruction. See also JMP. * RET Encoding < g r a p h i c s > Operation PC = R7; 12pt Description The PC is loaded with the value in R7. Its normal use is to cause a return from a previous JSR(R) instruction. Example RET ; PC← R7 Rti Return from Trap or Interrupt Assembler Format * RTI Encoding < g r a p h i c s > Operation c̄olc̄olc̄olif (PSR[15] == 1) Initiate a privilege mode exception; else PC = mem[R6]; R6 is the SSP, PC is restored R6 = R6+1; TEMP = mem[R6]; R6 = R6+1; system stack completes POP before saved PSR",
    "52": "taken as a 2's complement integer, is negative, zero, or positive. Example NOT R4, R2 ; R4←NOT(R2) RET[2] Return from Subroutine Assembler Format [2]The RET instruction is a specific encoding of the JMP instruction. See also JMP. * RET Encoding < g r a p h i c s > Operation PC = R7; 12pt Description The PC is loaded with the value in R7. Its normal use is to cause a return from a previous JSR(R) instruction. Example RET ; PC← R7 Rti Return from Trap or Interrupt Assembler Format * RTI Encoding < g r a p h i c s > Operation c̄olc̄olc̄olif (PSR[15] == 1) Initiate a privilege mode exception; else PC = mem[R6]; R6 is the SSP, PC is restored R6 = R6+1; TEMP = mem[R6]; R6 = R6+1; system stack completes POP before saved PSR is restored PSR = TEMP; PSR is restored if (PSR[15] == 1) SavedSSP=R6 and R6=SavedUSP; Description If the processor is running in User mode, a privilege mode exception occurs. If in Supervisor mode, the top two elements on the System Stack are popped and loaded into PC, PSR. After PSR is restored, if the processor is running in User mode, the SSP is saved in Saved_SSP, and R6 is loaded with Saved_USP. Example RTI ; PC, PSR ← top two values popped off stack. Note RTI is the last instruction in both interrupt and trap service routines and returns control to the program that was running. In both cases the relevant service routine is initiated by first pushing the PSR and PC of the program that is running onto the System Stack. Then the starting address of the appropriate service routine is loaded into the PC, and the service routine executes with Supervisor privilege. The last instruction in the service routine is RTI, which returns control to the interrupted program by popping two values off the Supervisor Stack to restore the PC and PSR. In the case of an interrupt, the PC is restored to the address of the instruction that",
    "53": "the SSP is saved in Saved_SSP, and R6 is loaded with Saved_USP. Example RTI ; PC, PSR ← top two values popped off stack. Note RTI is the last instruction in both interrupt and trap service routines and returns control to the program that was running. In both cases the relevant service routine is initiated by first pushing the PSR and PC of the program that is running onto the System Stack. Then the starting address of the appropriate service routine is loaded into the PC, and the service routine executes with Supervisor privilege. The last instruction in the service routine is RTI, which returns control to the interrupted program by popping two values off the Supervisor Stack to restore the PC and PSR. In the case of an interrupt, the PC is restored to the address of the instruction that was about to be processed when the interrupt was initiated. In the case of an exception, the PC is restored to either the address of the instruction that caused the exception or the address of the following instruction, depending on whether the instruction that caused the exception is to be re-executed. In the case of a TRAP service routine, the PC is restored to the instruction following the TRAP instruction in the calling routine. In the case of an interrupt or TRAP, the PSR is restored to the value it had when the interrupt was initiated. In the case of an exception, the PSR is restored to the value it had when the exception occurred or to some modified value, depending on the exception. See also Section A.3. empty St Store Assembler Format ST SR, LABEL Encoding < g r a p h i c s > Operation colc̄olif (computed address is in privileged memory AND PSR[15] == 1) Initiate ACV exception; else mem[PC[This is the incremented PC.] + SEXT(PCoffset9)] = SR; [2]This is the incremented PC. Description If the computed address is to privileged memory and PSR[15]=1, initiate ACV exception. If not, the contents of the register specified by SR",
    "54": "PC is restored to the instruction following the TRAP instruction in the calling routine. In the case of an interrupt or TRAP, the PSR is restored to the value it had when the interrupt was initiated. In the case of an exception, the PSR is restored to the value it had when the exception occurred or to some modified value, depending on the exception. See also Section A.3. empty St Store Assembler Format ST SR, LABEL Encoding < g r a p h i c s > Operation colc̄olif (computed address is in privileged memory AND PSR[15] == 1) Initiate ACV exception; else mem[PC[This is the incremented PC.] + SEXT(PCoffset9)] = SR; [2]This is the incremented PC. Description If the computed address is to privileged memory and PSR[15]=1, initiate ACV exception. If not, the contents of the register specified by SR are stored in the memory location whose address is computed by sign-extending bits [8:0] to 16 bits and adding this value to the incremented PC. Example ST R4, HERE ; mem[HERE] ← R4 StiStore Indirect Assembler Format STI SR, LABEL Encoding < g r a p h i c s > Operation colc̄olif (either computed address is in privileged memory AND PSR[15] == 1) Initiate ACV exception; else mem[mem[PC[2] + SEXT(PCoffset9)]] = SR; [2]This is the incremented PC. Description If either computed address is to privileged memory and PSR[15]=1, initiate ACV exception. If not, the contents of the register specified by SR are stored in the memory location whose address is obtained as follows: Bits [8:0] are sign-extended to 16 bits and added to the incremented PC. What is in memory at this address is the address of the location to which the data in SR is stored. Example STI R4, NOT_HERE ; mem[mem[NOT_HERE]] ← R4 Str Store Base+offset Assembler Format STR SR, BaseR, offset6 Encoding < g r a p h i c s > Operation colc̄olif (computed address is in privileged memory AND PSR[15] == 1) Initiate ACV exception; else mem[BaseR + SEXT(offset6)] = SR; Description If the computed",
    "55": "AND PSR[15] == 1) Initiate ACV exception; else mem[mem[PC[2] + SEXT(PCoffset9)]] = SR; [2]This is the incremented PC. Description If either computed address is to privileged memory and PSR[15]=1, initiate ACV exception. If not, the contents of the register specified by SR are stored in the memory location whose address is obtained as follows: Bits [8:0] are sign-extended to 16 bits and added to the incremented PC. What is in memory at this address is the address of the location to which the data in SR is stored. Example STI R4, NOT_HERE ; mem[mem[NOT_HERE]] ← R4 Str Store Base+offset Assembler Format STR SR, BaseR, offset6 Encoding < g r a p h i c s > Operation colc̄olif (computed address is in privileged memory AND PSR[15] == 1) Initiate ACV exception; else mem[BaseR + SEXT(offset6)] = SR; Description If the computed address is to privileged memory and PSR[15]=1, initiate ACV exception. If not, the contents of the register specified by SR are stored in the memory location whose address is computed by sign-extending bits [5:0] to 16 bits and adding this value to the contents of the register specified by bits [8:6]. Example STR R4, R2, #5 ; mem[R2+5] ← R4 TrapSystem Call Assembler Format TRAP trapvector8 Encoding < g r a p h i c s > Operation colc̄olc̄olTEMP=PSR; if (PSR[15] == 1) Saved_USP=R6 and R6=Saved_SSP; PSR[15]=0; Push TEMP,PC[2] on the system stack PC = mem[ZEXT(trapvect8)]; [2]This is the incremented PC. Description If the the program is executing in User mode, the user stack pointer must be saved and the system stack pointer loaded. Then the PSR and PC are pushed on the system stack. (This enables a return to the instruction physically following the TRAP instruction in the original program after the last instruction in the service routine (RTI) has completed execution.) Then the PC is loaded with the starting address of the system call specified by trapvector8. The starting address is contained in the memory location whose address is obtained by zero-extending trapvector8 to 16 bits. Example TRAP x23",
    "56": "TrapSystem Call Assembler Format TRAP trapvector8 Encoding < g r a p h i c s > Operation colc̄olc̄olTEMP=PSR; if (PSR[15] == 1) Saved_USP=R6 and R6=Saved_SSP; PSR[15]=0; Push TEMP,PC[2] on the system stack PC = mem[ZEXT(trapvect8)]; [2]This is the incremented PC. Description If the the program is executing in User mode, the user stack pointer must be saved and the system stack pointer loaded. Then the PSR and PC are pushed on the system stack. (This enables a return to the instruction physically following the TRAP instruction in the original program after the last instruction in the service routine (RTI) has completed execution.) Then the PC is loaded with the starting address of the system call specified by trapvector8. The starting address is contained in the memory location whose address is obtained by zero-extending trapvector8 to 16 bits. Example TRAP x23 ; Directs the operating system to execute the IN system call. ; The starting address of this system call is contained in ; memory location x0023. Note Memory locations x0000 through x00FF, 256 in all, are available to contain starting addresses for system calls specified by their corresponding trap vectors. This region of memory is called the Trap Vector Table. Table A.3 describes the functions performed by the service routines corresponding to trap vectors x20 to x25. Unused Opcode Assembler Format * none Encoding < g r a p h i c s > Operation Initiate an illegal opcode exception. Description If an illegal opcode is encountered, an illegal opcode exception occurs. Note The opcode 1101 has been reserved for future use. It is currently not defined. If the instruction currently executing has bits [15:12]=1101, an illegal opcode exception occurs. Section A.3 describes what happens. Trap Service Routines Trap Vector Assembler Name Description x20 GETC Read a single character from the keyboard. The character is not echoed onto the console. Its ASCII code is copied into R0. The high eight bits of R0 are cleared. x21 OUT Write a character in R0[7:0] to the console display. x22 PUTS Write a string",
    "57": "Table A.3 describes the functions performed by the service routines corresponding to trap vectors x20 to x25. Unused Opcode Assembler Format * none Encoding < g r a p h i c s > Operation Initiate an illegal opcode exception. Description If an illegal opcode is encountered, an illegal opcode exception occurs. Note The opcode 1101 has been reserved for future use. It is currently not defined. If the instruction currently executing has bits [15:12]=1101, an illegal opcode exception occurs. Section A.3 describes what happens. Trap Service Routines Trap Vector Assembler Name Description x20 GETC Read a single character from the keyboard. The character is not echoed onto the console. Its ASCII code is copied into R0. The high eight bits of R0 are cleared. x21 OUT Write a character in R0[7:0] to the console display. x22 PUTS Write a string of ASCII characters to the console display. The characters are contained in consecutive memory locations, one character per memory location, starting with the address specified in R0. Writing terminates with the occurrence of x0000 in a memory location. x23 IN Print a prompt on the screen and read a single character from the keyboard. The character is echoed onto the console monitor, and its ASCII code is copied into R0. The high eight bits of R0 are cleared. x24 PUTSP Write a string of ASCII characters to the console. The characters are contained in consecutive memory locations, two characters per memory location, starting with the address specified in R0. The ASCII code contained in bits [7:0] of a memory location is written to the console first. Then the ASCII code contained in bits [15:8] of that memory location is written to the console. (A character string consisting of an odd number of characters to be written will have x00 in bits [15:8] of the memory location containing the last character to be written.) Writing terminates with the occurrence of x0000 in a memory location. x25 HALT Halt execution and print a message on the console. § INTERRUPT AND EXCEPTION PROCESSING As",
    "58": "console monitor, and its ASCII code is copied into R0. The high eight bits of R0 are cleared. x24 PUTSP Write a string of ASCII characters to the console. The characters are contained in consecutive memory locations, two characters per memory location, starting with the address specified in R0. The ASCII code contained in bits [7:0] of a memory location is written to the console first. Then the ASCII code contained in bits [15:8] of that memory location is written to the console. (A character string consisting of an odd number of characters to be written will have x00 in bits [15:8] of the memory location containing the last character to be written.) Writing terminates with the occurrence of x0000 in a memory location. x25 HALT Halt execution and print a message on the console. § INTERRUPT AND EXCEPTION PROCESSING As has been discussed in detail in Chapter 9, events external to the program that is running can interrupt the processor. A common example of an external event is interrupt-driven I/O. It is also the case that the processor can be interrupted by exceptional events that occur while the program is running that are caused by the program itself. An example of such an “internal” event is the presence of an unused opcode in the computer program that is running. Associated with each event that can interrupt the processor is an 8-bit vector that provides an entry point into a 256-entry interrupt vector table. The starting address of the interrupt vector table is x0100. That is, the interrupt vector table occupies memory locations x0100 to x01FF. Each entry in the interrupt vector table contains the starting address of the service routine that handles the needs of the corresponding event. These service routines execute in Supervisor mode. Half (128) of these entries, locations x0100 to x017F, provide the starting addresses of routines that service events caused by the running program itself. These routines are called exception service routines because they handle exceptional events, that is, events that prevent the program from executing",
    "59": "of such an “internal” event is the presence of an unused opcode in the computer program that is running. Associated with each event that can interrupt the processor is an 8-bit vector that provides an entry point into a 256-entry interrupt vector table. The starting address of the interrupt vector table is x0100. That is, the interrupt vector table occupies memory locations x0100 to x01FF. Each entry in the interrupt vector table contains the starting address of the service routine that handles the needs of the corresponding event. These service routines execute in Supervisor mode. Half (128) of these entries, locations x0100 to x017F, provide the starting addresses of routines that service events caused by the running program itself. These routines are called exception service routines because they handle exceptional events, that is, events that prevent the program from executing normally. The other half of the entries, locations x0180 to x01FF, provide the starting addresses of routines that service events that are external to the program that is running, such as requests from I/O devices. These routines are called interrupt service routines. §.§ Interrupts At this time, an LC-3 computer system provides only one I/O device that can interrupt the processor. That device is the keyboard. It interrupts at priority level PL4 and supplies the interrupt vector x80. An I/O device can interrupt the processor if it wants service, if its Interrupt Enable (IE) bit is set, and if the priority of its request is greater than the priority of any other event that wants to interrupt and greater than the priority of the program that is running. Assume a program is running at a priority level less than 4, and someone strikes a key on the keyboard. If the IE bit of the KBSR is 1, the currently executing program is interrupted at the end of the current instruction cycle. The interrupt service routine is initiated as follows: 6pt=3pt * The PSR of the interrupted process is saved in TEMP. * The processor sets the privilege mode to Supervisor",
    "60": "processor. That device is the keyboard. It interrupts at priority level PL4 and supplies the interrupt vector x80. An I/O device can interrupt the processor if it wants service, if its Interrupt Enable (IE) bit is set, and if the priority of its request is greater than the priority of any other event that wants to interrupt and greater than the priority of the program that is running. Assume a program is running at a priority level less than 4, and someone strikes a key on the keyboard. If the IE bit of the KBSR is 1, the currently executing program is interrupted at the end of the current instruction cycle. The interrupt service routine is initiated as follows: 6pt=3pt * The PSR of the interrupted process is saved in TEMP. * The processor sets the privilege mode to Supervisor mode (PSR[15]=0). * The processor sets the priority level to PL4, the priority level of the interrupting device (PSR[10:8]=100). * If the interrupted process is in User mode, R6 is saved in Saved_USP and R6 is loaded with the Supervisor Stack Pointer (SSP). * TEMP and the PC of the interrupted process are pushed onto the Supervisor Stack. * The keyboard supplies its 8-bit interrupt vector, in this case x80. * The processor expands that vector to x0180, the corresponding 16-bit address in the interrupt vector table. * The PC is loaded with the contents of memory location x0180, the address of the first instruction in the keyboard interrupt service routine. The processor then begins execution of the interrupt service routine. -1The last instruction executed in an interrupt service routine is RTI. The top two elements of the Supervisor Stack are popped and loaded into the PC and PSR registers. R6 is loaded with the appropriate stack pointer, depending on the new value of PSR[15]. Processing then continues where the interrupted program left off. §.§ Exceptions At this time, the LC-3 ISA specifies three exception conditions: privilege mode violation, illegal opcode, and access control violation (ACV). The privilege mode violation",
    "61": "keyboard supplies its 8-bit interrupt vector, in this case x80. * The processor expands that vector to x0180, the corresponding 16-bit address in the interrupt vector table. * The PC is loaded with the contents of memory location x0180, the address of the first instruction in the keyboard interrupt service routine. The processor then begins execution of the interrupt service routine. -1The last instruction executed in an interrupt service routine is RTI. The top two elements of the Supervisor Stack are popped and loaded into the PC and PSR registers. R6 is loaded with the appropriate stack pointer, depending on the new value of PSR[15]. Processing then continues where the interrupted program left off. §.§ Exceptions At this time, the LC-3 ISA specifies three exception conditions: privilege mode violation, illegal opcode, and access control violation (ACV). The privilege mode violation occurs if the processor attempts to execute the RTI instruction while running in User mode. The illegal opcode exception occurs if the processor attempts to execute an instruction having the unused opcode (Bits [15:12] == 1101). The ACV exception occurs if the processor attempts to access privileged memory (i.e., a memory location in System Space or a device register having an address from xFE00 to xFFFF while running in User mode). Exceptions are handled as soon as they are detected. They are initiated very much like interrupts are initiated, that is: 6pt=3pt * The PSR of the process causing the exception is saved in TEMP. * The processor sets the privilege mode to Supervisor mode (PSR[15]=0). * If the process causing the exception is in User mode, R6 is saved in Saved_USP and R6 is loaded with the Supervisor Stack Pointer (SSP). * TEMP and the PC of the process causing the exception are pushed onto the Supervisor Stack. * The exception supplies its 8-bit vector. In the case of the Privilege mode violation, that vector is x00. In the case of the illegal opcode, that vector is x01. In the case of the ACV exception, that vector is x02.",
    "62": "an address from xFE00 to xFFFF while running in User mode). Exceptions are handled as soon as they are detected. They are initiated very much like interrupts are initiated, that is: 6pt=3pt * The PSR of the process causing the exception is saved in TEMP. * The processor sets the privilege mode to Supervisor mode (PSR[15]=0). * If the process causing the exception is in User mode, R6 is saved in Saved_USP and R6 is loaded with the Supervisor Stack Pointer (SSP). * TEMP and the PC of the process causing the exception are pushed onto the Supervisor Stack. * The exception supplies its 8-bit vector. In the case of the Privilege mode violation, that vector is x00. In the case of the illegal opcode, that vector is x01. In the case of the ACV exception, that vector is x02. * The processor expands that vector to x0100, x0101, or x0102, the corresponding 16-bit address in the interrupt vector table. * The PC is loaded with the contents of memory location x0100, x0101, or x0102, the address of the first instruction in the corresponding exception service routine. The processor then begins execution of the exception service routine. The details of the exception service routine depends on the exception and the way in which the operating system wishes to handle that exception. In many cases, the exception service routine can correct any problem caused by the exceptional event and then continue processing the original program. In those cases the last instruction in the exception service routine is RTI, which pops the top two elements from the Supervisor Stack and loads them into the PC and PSR registers. The program then resumes execution with the problem corrected. In some cases, the cause of the exceptional event is sufficiently catastrophic that the exception service routine removes the program from further processing. Another difference between the handling of interrupts and the handling of exceptions is the priority level of the processor during the execution of the service routine. In the case of exceptions, we",
    "63": "the exception service routine depends on the exception and the way in which the operating system wishes to handle that exception. In many cases, the exception service routine can correct any problem caused by the exceptional event and then continue processing the original program. In those cases the last instruction in the exception service routine is RTI, which pops the top two elements from the Supervisor Stack and loads them into the PC and PSR registers. The program then resumes execution with the problem corrected. In some cases, the cause of the exceptional event is sufficiently catastrophic that the exception service routine removes the program from further processing. Another difference between the handling of interrupts and the handling of exceptions is the priority level of the processor during the execution of the service routine. In the case of exceptions, we normally do not change the priority level when we service the exception. The priority level of a program is the urgency with which it needs to be executed. In the case of the exceptions specified by the LC-3 ISA, the urgency of a program is not changed by the fact that a privilege mode violation occurred or there was an illegal opcode in the program or the program attempted to access privileged memory while it was in User mode. ../art/ch01/,../art/designelements/,../art/designelements/UnNumberedArt/ makechapterhead#1 @ (0,0) (432,-577) < g r a p h i c s > (428,-577)1@9.52667in (381.5,-181) < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > 1212chapter 1212chapter 7212 3032#1 36.4pc4@ CHAPTER: WELCOME ABOARD § WHAT WE WILL TRY TO DO Welcome to From Bits and Gates to C and Beyond. Our intent is to introduce you over the next xxx pages to the world of computing. As we do so, we have one objective above all others: to show",
    "64": "illegal opcode in the program or the program attempted to access privileged memory while it was in User mode. ../art/ch01/,../art/designelements/,../art/designelements/UnNumberedArt/ makechapterhead#1 @ (0,0) (432,-577) < g r a p h i c s > (428,-577)1@9.52667in (381.5,-181) < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > 1212chapter 1212chapter 7212 3032#1 36.4pc4@ CHAPTER: WELCOME ABOARD § WHAT WE WILL TRY TO DO Welcome to From Bits and Gates to C and Beyond. Our intent is to introduce you over the next xxx pages to the world of computing. As we do so, we have one objective above all others: to show you very clearly that there is no magic to computing. The computer is a deterministic system—every time we hit it over the head in the same way and in the same place (provided, of course, it was in the same starting condition), we get the same response. The computer is not an electronic genius; on the contrary, if anything, it is an electronic idiot, doing exactly what we tell it to do. It has no mind of its own. What appears to be a very complex organism is really just a very large, systematically interconnected collection of very simple parts. Our job throughout this book is to introduce you to those very simple parts, and, step-by-step, build the interconnected structure that you know by the name computer. Like a house, we will start at the bottom, construct the foundation first, and then go on to add layer after layer, as we get closer and closer to what most people know as a full-blown computer. Each time we add a layer, we will explain what we are doing, tying the new ideas to the underlying fabric. Our goal is that when we are done, you will be able to write programs",
    "65": "is an electronic idiot, doing exactly what we tell it to do. It has no mind of its own. What appears to be a very complex organism is really just a very large, systematically interconnected collection of very simple parts. Our job throughout this book is to introduce you to those very simple parts, and, step-by-step, build the interconnected structure that you know by the name computer. Like a house, we will start at the bottom, construct the foundation first, and then go on to add layer after layer, as we get closer and closer to what most people know as a full-blown computer. Each time we add a layer, we will explain what we are doing, tying the new ideas to the underlying fabric. Our goal is that when we are done, you will be able to write programs in a computer language such as C, using the sophisticated features of that language, and understand what is going on underneath, inside the computer. § HOW WE WILL GET THERE We will start (in Chapter 2) by first showing that any information processed by the computer is represented by a sequence of 0s and 1s. That is, we will encode all information as sequences of 0s and 1s. For example, one encoding of the letter a that is commonly used is the sequence 01100001. One encoding of the decimal number 35 is the sequence 00100011. We will see how to perform operations on such encoded information. Once we are comfortable with information represented as codes made up of 0s and 1s and operations (addition, for example) being performed on these representations, we will begin the process of showing how a computer works. Starting in Chapter 3, we will note that the computer is a piece of electronic equipment and, as such, consists of electronic parts operated by voltages, and interconnected by wires. Every wire in the computer, at every moment in time, is either at a high voltage or a low voltage. For our representation of 0s and 1s, we",
    "66": "all information as sequences of 0s and 1s. For example, one encoding of the letter a that is commonly used is the sequence 01100001. One encoding of the decimal number 35 is the sequence 00100011. We will see how to perform operations on such encoded information. Once we are comfortable with information represented as codes made up of 0s and 1s and operations (addition, for example) being performed on these representations, we will begin the process of showing how a computer works. Starting in Chapter 3, we will note that the computer is a piece of electronic equipment and, as such, consists of electronic parts operated by voltages, and interconnected by wires. Every wire in the computer, at every moment in time, is either at a high voltage or a low voltage. For our representation of 0s and 1s, we do not specify exactly how high. We only care whether there is or is not a large enough voltage relative to 0 volts to identify it as a 1. That is, the absence or presence of a reasonable voltage relative to 0 volts is what determines whether it represents the value 0 or the value 1. =1 In Chapter 3, we will see how the transistors that make up today's microprocessor (the heart of the modern computer) works. We will further see how those transistors are combined into larger structures that perform operations, such as addition, and into structures that allow us to save information for later use. In Chapter 4, we will combine these larger structures into the Von Neumann machine, a basic model that describes how a computer works. We will also begin to study a simple computer, the LC-3. We will continue our study of the LC-3 in Chapter 5. LC-3 stands for Little Computer 3. We actually started with LC-1 but needed two more shots at it before (we think) we got it right! The LC-3 has all the important characteristics of the microprocessors that you may have already heard of, for example, the Intel 8088,",
    "67": "we will see how the transistors that make up today's microprocessor (the heart of the modern computer) works. We will further see how those transistors are combined into larger structures that perform operations, such as addition, and into structures that allow us to save information for later use. In Chapter 4, we will combine these larger structures into the Von Neumann machine, a basic model that describes how a computer works. We will also begin to study a simple computer, the LC-3. We will continue our study of the LC-3 in Chapter 5. LC-3 stands for Little Computer 3. We actually started with LC-1 but needed two more shots at it before (we think) we got it right! The LC-3 has all the important characteristics of the microprocessors that you may have already heard of, for example, the Intel 8088, which was used in the first IBM PCs back in 1981. Or the Motorola 68000, which was used in the Macintosh, vintage 1984. Or the Pentium IV, one of the high-performance microprocessors of choice for the PC in the year 2003. Or today's laptop and desktop microprocessors, the Intel Core processors – I3, I5 and I7. Or even the ARM microprocessors that are used in most smartphones today. That is, the LC-3 has all the important characteristics of these \"real\" microprocessors without being so complicated that it gets in the way of your understanding. Once we understand how the LC-3 works, the next step is to program it, first in its own language (Chapter 5 and Chapter 6), and then in a language called assembly language that is a little bit easier for humans to work with (Chapter 7). Chapter 8 introduces representations of information more complex than a simple number – stacks, queues, and character strings, and shows how to implement them. Chapter 9 deals with the problem of getting information into (input) and out of (output) the LC-3. Chapter 9 also deals with services provided to a computer user by the operating system. We conclude the first half",
    "68": "microprocessors that are used in most smartphones today. That is, the LC-3 has all the important characteristics of these \"real\" microprocessors without being so complicated that it gets in the way of your understanding. Once we understand how the LC-3 works, the next step is to program it, first in its own language (Chapter 5 and Chapter 6), and then in a language called assembly language that is a little bit easier for humans to work with (Chapter 7). Chapter 8 introduces representations of information more complex than a simple number – stacks, queues, and character strings, and shows how to implement them. Chapter 9 deals with the problem of getting information into (input) and out of (output) the LC-3. Chapter 9 also deals with services provided to a computer user by the operating system. We conclude the first half of the book (Chapter 10) with an extensive example, the simulation of a calculator, an app on most smart phones today. In the second half of the book (Chapters 11–21), we turn our attention to high-level programming concepts, which we introduce via the C and C++ programming languages. High level languages enable programmers to more effectively develop complex software, by abstracting away the details of the underlying hardware. C and C++ in particular offer a rich set of programmer friendly constructs, but are close enough to the hardware so that we can examine how code is tranformed to execute on the layers below. Our goal is to enable you to write short, simple programs using the core parts of these programming languages, all the while being able to comprehend the transformations required for your code to execute on the underlying hardware. We'll start with basic topics in C such as variables and operators (Chapter 12), control structures (Chapter 13), and functions (Chapter 14). We'll see that these are straightforward extensions of concepts introduced in the first half of the textbook. We then move on to programming concepts in Chapters 15–19 that will enable us to create more powerful pieces of",
    "69": "abstracting away the details of the underlying hardware. C and C++ in particular offer a rich set of programmer friendly constructs, but are close enough to the hardware so that we can examine how code is tranformed to execute on the layers below. Our goal is to enable you to write short, simple programs using the core parts of these programming languages, all the while being able to comprehend the transformations required for your code to execute on the underlying hardware. We'll start with basic topics in C such as variables and operators (Chapter 12), control structures (Chapter 13), and functions (Chapter 14). We'll see that these are straightforward extensions of concepts introduced in the first half of the textbook. We then move on to programming concepts in Chapters 15–19 that will enable us to create more powerful pieces of code: Testing and Debugging (Chapter 15), Pointers and Arrays in C (Chapter 16), Recursion (Chapter 17), Input and Output in C (Chapter 18), and Data Structures in C (Chapter 19). Chapters 20 and 21 are devoted to C++, which we present as an evolution of the C programming language. Because the C++ language was intially defined as a superset of C, many of the concepts covered in Chapters 11–19 directly map onto the C++ language. We will introduce some of the core notions in C++ that have helped establish C++ as one of the most popular languages for developing real-world software. Chapter 20 is our Introduction to C++, and Chapter 21 is an introduction to Objects, a powerful programming construct in the C++ language. In almost all cases, we try to tie high-level C and C++ constructs to the underlying LC-3, so that you will understand what you demand of the computer when you use a particular construct in a C or C++ program. § TWO RECURRING THEMES Two themes permeate this book that we as professors previously took for granted, assuming that everyone recognized their value and regularly emphasized them to students of engineering and computer science. However, it",
    "70": "C, many of the concepts covered in Chapters 11–19 directly map onto the C++ language. We will introduce some of the core notions in C++ that have helped establish C++ as one of the most popular languages for developing real-world software. Chapter 20 is our Introduction to C++, and Chapter 21 is an introduction to Objects, a powerful programming construct in the C++ language. In almost all cases, we try to tie high-level C and C++ constructs to the underlying LC-3, so that you will understand what you demand of the computer when you use a particular construct in a C or C++ program. § TWO RECURRING THEMES Two themes permeate this book that we as professors previously took for granted, assuming that everyone recognized their value and regularly emphasized them to students of engineering and computer science. However, it has become clear to us that from the git-go, we need to make these points explicit. So, we state them here up front. The two themes are (a) the notion of abstraction and (b) the importance of not separating in your mind the notions of hardware and software. Their value to your development as an effective engineer or computer scientist goes well beyond your understanding of how a computer works and how to program it. The notion of abstraction is central to all that you will learn and expect to use in practicing your craft, whether it be in mathematics, physics, any aspect of engineering, or business. It is hard to think of any body of knowledge where the notion of abstraction is not critical. The misguided hardware/software separation is directly related to your continuing study of computers and your work with them. We will discuss each in turn. §.§ The Notion of Abstraction The use of abstraction is all around us. When we get in a taxi and tell the driver, “Take me to the airport,” we are using abstraction. If we had to, we could probably direct the driver each step of the way: “Go down this street",
    "71": "goes well beyond your understanding of how a computer works and how to program it. The notion of abstraction is central to all that you will learn and expect to use in practicing your craft, whether it be in mathematics, physics, any aspect of engineering, or business. It is hard to think of any body of knowledge where the notion of abstraction is not critical. The misguided hardware/software separation is directly related to your continuing study of computers and your work with them. We will discuss each in turn. §.§ The Notion of Abstraction The use of abstraction is all around us. When we get in a taxi and tell the driver, “Take me to the airport,” we are using abstraction. If we had to, we could probably direct the driver each step of the way: “Go down this street ten blocks, and make a left turn.” And, when the driver got there, “Now take this street five blocks and make a right turn.” And on and on. You know the details, but it is a lot quicker to just tell the driver to take you to the airport. Even the statement “Go down this street ten blocks …” can be broken down further with instructions on using the accelerator, the steering wheel, watching out for other vehicles, pedestrians, etc. Abstraction is a technique for establishing a simpler way for a person to interact with a system, removing the details that are unnecessary for the person to interact effectively with that system. Our ability to abstract is very much a productivity enhancer. It allows us to deal with a situation at a higher level, focusing on the essential aspects, while keeping the component ideas in the background. It allows us to be more efficient in our use of time and brain activity. It allows us to not get bogged down in the detail when everything about the detail is working just fine. There is an underlying assumption to this, however: when everything about the detail is just fine. What if",
    "72": "be broken down further with instructions on using the accelerator, the steering wheel, watching out for other vehicles, pedestrians, etc. Abstraction is a technique for establishing a simpler way for a person to interact with a system, removing the details that are unnecessary for the person to interact effectively with that system. Our ability to abstract is very much a productivity enhancer. It allows us to deal with a situation at a higher level, focusing on the essential aspects, while keeping the component ideas in the background. It allows us to be more efficient in our use of time and brain activity. It allows us to not get bogged down in the detail when everything about the detail is working just fine. There is an underlying assumption to this, however: when everything about the detail is just fine. What if everything about the detail is not just fine? Then, to be successful, our ability to abstract must be combined with our ability to un-abstract. Some people use the word deconstruct—the ability to go from the abstraction back to its component parts. Two stories come to mind. The first involves a trip through Arizona the first author made a long time ago in the hottest part of the summer. At the time he was living in Palo Alto, California, where the temperature tends to be mild almost always. He knew enough to take the car to a mechanic before making the trip, and tell him to check the cooling system. That was the abstraction: cooling system. What he had not mastered was that the capability of a cooling system for Palo Alto, California is not the same as the capability of a cooling system for the summer deserts of Arizona. The result: two days in Deer Lodge, Arizona (population 3), waiting for a head gasket to be shipped in. The second story (perhaps apocryphal) is supposed to have happened during the infancy of electric power generation. General Electric Co. was having trouble with one of its huge electric power generators and",
    "73": "ago in the hottest part of the summer. At the time he was living in Palo Alto, California, where the temperature tends to be mild almost always. He knew enough to take the car to a mechanic before making the trip, and tell him to check the cooling system. That was the abstraction: cooling system. What he had not mastered was that the capability of a cooling system for Palo Alto, California is not the same as the capability of a cooling system for the summer deserts of Arizona. The result: two days in Deer Lodge, Arizona (population 3), waiting for a head gasket to be shipped in. The second story (perhaps apocryphal) is supposed to have happened during the infancy of electric power generation. General Electric Co. was having trouble with one of its huge electric power generators and did not know what to do. On the front of the generator were lots of dials containing lots of information, and lots of screws that could be rotated clockwise or counterclockwise as the operator wished. Something on the other side of the wall of dials and screws was malfunctioning and no one knew what to do. As the story goes, they called in one of the early giants in the electric power industry. He looked at the dials and listened to the noises for a minute, then took a small screwdriver from his pocket and rotated one screw 35 degrees counterclockwise. The problem immediately went away. He submitted a bill for $1,000 (a lot of money in those days) without any elaboration. The controller found the bill for two minutes' work a little unsettling, and asked for further clarification. Back came the new bill: [fontsize=910] Turning a screw 35 degrees counterclockwise: 0.75 Knowing which screw to turn and by how much: 999.25 In both stories the message is the same. It is more efficient to think of entities as abstractions. One does not want to get bogged down in details unnecessarily. And as long as nothing untoward happens, we are",
    "74": "they called in one of the early giants in the electric power industry. He looked at the dials and listened to the noises for a minute, then took a small screwdriver from his pocket and rotated one screw 35 degrees counterclockwise. The problem immediately went away. He submitted a bill for $1,000 (a lot of money in those days) without any elaboration. The controller found the bill for two minutes' work a little unsettling, and asked for further clarification. Back came the new bill: [fontsize=910] Turning a screw 35 degrees counterclockwise: 0.75 Knowing which screw to turn and by how much: 999.25 In both stories the message is the same. It is more efficient to think of entities as abstractions. One does not want to get bogged down in details unnecessarily. And as long as nothing untoward happens, we are OK. If there had been no trip to Arizona, the abstraction “cooling system” would have been sufficient. If the electric power generator never malfunctioned, there would have been no need for the power engineering guru's deeper understanding. As we will see, modern computers are comprised of transistors. These transistors are combined to form logic \"gates\" – an abstraction that lets us think in terms of 0s and 1s instead of the varying voltages on the transistors. A logic circuit is a further abstraction of a combination of gates. When one designs a logic circuit out of gates, it is much more efficient to not have to think about the internals of each gate. To do so would slow down the process of designing the logic circuit. One wants to think of the gate as a component. But if there is a problem with getting the logic circuit to work, it is often helpful to look at the internal structure of the gate and see if something about its functioning is causing the problem. When one designs a sophisticated computer application program, whether it be a new spreadsheet program, word processing system, or computer game, one wants to think of each",
    "75": "us think in terms of 0s and 1s instead of the varying voltages on the transistors. A logic circuit is a further abstraction of a combination of gates. When one designs a logic circuit out of gates, it is much more efficient to not have to think about the internals of each gate. To do so would slow down the process of designing the logic circuit. One wants to think of the gate as a component. But if there is a problem with getting the logic circuit to work, it is often helpful to look at the internal structure of the gate and see if something about its functioning is causing the problem. When one designs a sophisticated computer application program, whether it be a new spreadsheet program, word processing system, or computer game, one wants to think of each of the components one is using as an abstraction. If one spent time thinking about the details of each component when it was not necessary, the distraction could easily prevent the total job from ever getting finished. But when there is a problem putting the components together, it is often useful to examine carefully the details of each component in order to uncover the problem. The ability to abstract is a most important skill. In our view, one should try to keep the level of abstraction as high as possible, consistent with getting everything to work effectively. Our approach in this book is to continually raise the level of abstraction. We describe logic gates in terms of transistors. Once we understand the abstraction of gates, we no longer think in terms of transistors. Then we build larger structures out of gates. Once we understand these larger abstractions, we no longer think in terms of gates. The Bottom Line Abstractions allow us to be much more efficient in dealing with all kinds of situations. It is also true that one can be effective without understanding what is below the abstraction as long as everything behaves nicely. So, one should not pooh-pooh",
    "76": "order to uncover the problem. The ability to abstract is a most important skill. In our view, one should try to keep the level of abstraction as high as possible, consistent with getting everything to work effectively. Our approach in this book is to continually raise the level of abstraction. We describe logic gates in terms of transistors. Once we understand the abstraction of gates, we no longer think in terms of transistors. Then we build larger structures out of gates. Once we understand these larger abstractions, we no longer think in terms of gates. The Bottom Line Abstractions allow us to be much more efficient in dealing with all kinds of situations. It is also true that one can be effective without understanding what is below the abstraction as long as everything behaves nicely. So, one should not pooh-pooh the notion of abstraction. On the contrary, one should celebrate it since it allows us to be more efficient. In fact, if we never have to combine a component with anything else into a larger system, and if nothing can go wrong with the component, then it is perfectly fine to understand this component only at the level of its abstraction. =1 But if we have to combine multiple components into a larger system, we should be careful not to allow their abstractions to be the deepest level of our understanding. If we don't know the components below the level of their abstractions, then we are at the mercy of them working together without our intervention. If they don't work together, and we are unable to go below the level of abstraction, we are stuck. And that is the state we should take care not to find ourselves in. §.§ Hardware versus Software =-1 Many computer scientists and engineers refer to themselves as hardware people or software people. By hardware, they generally mean the physical computer and all the specifications associated with it. By software, they generally mean the programs, whether operating systems like Android, ChromeOS, Linux or Windows, or",
    "77": "abstraction. =1 But if we have to combine multiple components into a larger system, we should be careful not to allow their abstractions to be the deepest level of our understanding. If we don't know the components below the level of their abstractions, then we are at the mercy of them working together without our intervention. If they don't work together, and we are unable to go below the level of abstraction, we are stuck. And that is the state we should take care not to find ourselves in. §.§ Hardware versus Software =-1 Many computer scientists and engineers refer to themselves as hardware people or software people. By hardware, they generally mean the physical computer and all the specifications associated with it. By software, they generally mean the programs, whether operating systems like Android, ChromeOS, Linux or Windows, or database systems like Access, MongoDB, Oracle or DB-terrific, or application programs like Facebook, Chrome, Excel or Word. The implication is that the person knows a whole lot about one of these two things and precious little about the other. Usually, there is the further implication that it is OK to be an expert at one of these (hardware OR software) and clueless about the other. It is as if there were a big wall between the hardware (the computer and how it actually works) and the software (the programs that direct the computer to do their bidding), and that one should be content to remain on one side of that wall or the other. The power of abstraction allows us to \"usually\" operate at a level where we do not have to think about the underlying layers all the time. This is a good thing. It enables us to be more productive. But if we are clueless about the underlying layers, then we are not able to take advantage of the nuances of those underlying layers when it is very important to be able to. That is not to say that you must work at the lower level of abstraction",
    "78": "and clueless about the other. It is as if there were a big wall between the hardware (the computer and how it actually works) and the software (the programs that direct the computer to do their bidding), and that one should be content to remain on one side of that wall or the other. The power of abstraction allows us to \"usually\" operate at a level where we do not have to think about the underlying layers all the time. This is a good thing. It enables us to be more productive. But if we are clueless about the underlying layers, then we are not able to take advantage of the nuances of those underlying layers when it is very important to be able to. That is not to say that you must work at the lower level of abstraction and not take advantage of the productivity enhancements that abstraction provides. On the contrary, you are encouraged to work at the highest level of abstraction available to you. But in doing so, if you are able to, at the same time, keep in mind the underlying levels, you will find yourself able to do a much better job. As you approach your study and practice of computing, we urge you to take the approach that hardware and software are names for components of two parts of a computing system that work best when they are designed by people who take into account the capabilities and limitations of both. Microprocessor designers who understand the needs of the programs that will execute on the microprocessor they are designing can design much more effective microprocessors than those who don't. For example, Intel, AMD, ARM and other major producers of microprocessors recognized a few years ago that a large fraction of future programs would contain video clips as part of e-mail, video games, and full-length movies. They recognized that it would be important for such programs to execute efficiently. The result: most microprocessors today contain special hardware capability to process those video clips. Intel",
    "79": "approach your study and practice of computing, we urge you to take the approach that hardware and software are names for components of two parts of a computing system that work best when they are designed by people who take into account the capabilities and limitations of both. Microprocessor designers who understand the needs of the programs that will execute on the microprocessor they are designing can design much more effective microprocessors than those who don't. For example, Intel, AMD, ARM and other major producers of microprocessors recognized a few years ago that a large fraction of future programs would contain video clips as part of e-mail, video games, and full-length movies. They recognized that it would be important for such programs to execute efficiently. The result: most microprocessors today contain special hardware capability to process those video clips. Intel defined additional instructions, initially called their MMX instruction set, and developed special hardware for it. Motorola, IBM and Apple did essentially the same thing, resulting in the AltiVec instruction set and special hardware to support it. A similar story can be told about software designers. The designer of a large computer program who understands the capabilities and limitations of the hardware that will carry out the tasks of that program can design the program so it executes more efficiently than the designer who does not understand the nature of the hardware. One important task that almost all large software systems need to carry out is called sorting, where a number of items have to be arranged in some order. The words in a dictionary are arranged in alphabetical order. Students in a class are often graded based on a numerical order, according to their scores on the final exam. There is a large number of fundamentally different programs one can write to arrange a collection of items in order. Donald Knuth, one of the top computer scientists in the world, devoted 391 pages to the task in The Art of Computer Programming, vol. 3. Which sorting program works best is",
    "80": "hardware that will carry out the tasks of that program can design the program so it executes more efficiently than the designer who does not understand the nature of the hardware. One important task that almost all large software systems need to carry out is called sorting, where a number of items have to be arranged in some order. The words in a dictionary are arranged in alphabetical order. Students in a class are often graded based on a numerical order, according to their scores on the final exam. There is a large number of fundamentally different programs one can write to arrange a collection of items in order. Donald Knuth, one of the top computer scientists in the world, devoted 391 pages to the task in The Art of Computer Programming, vol. 3. Which sorting program works best is often very dependent on how much the software designer is aware of the underlying characteristics of the hardware. The Bottom Line We believe that whether your inclinations are in the direction of a computer hardware career or a computer software career, you will be much more capable if you master both. This book is about getting you started on the path to mastering both hardware and software. Although we sometimes ignore making the point explicitly when we are in the trenches of working through a concept, it really is the case that each sheds light on the other. When you study data types, a software concept, in C (Chapter 12), you will understand how the finite word length of the computer, a hardware concept, affects our notion of data types. When you study functions in C (Chapter 14), you will be able to tie the rules of calling a function with the hardware implementation that makes those rules necessary. When you study recursion, a powerful algorithmic device (initially in Chapter 8 and more extensively in Chapter 17), you will be able to tie it to the hardware. If you take the time to do that, you will better understand when",
    "81": "path to mastering both hardware and software. Although we sometimes ignore making the point explicitly when we are in the trenches of working through a concept, it really is the case that each sheds light on the other. When you study data types, a software concept, in C (Chapter 12), you will understand how the finite word length of the computer, a hardware concept, affects our notion of data types. When you study functions in C (Chapter 14), you will be able to tie the rules of calling a function with the hardware implementation that makes those rules necessary. When you study recursion, a powerful algorithmic device (initially in Chapter 8 and more extensively in Chapter 17), you will be able to tie it to the hardware. If you take the time to do that, you will better understand when the additional time to execute a procedure recursively is worth it. When you study pointer variables in C (in Chapter 16), your knowledge of computer memory will provide a deeper understanding of what pointers provide, and very importantly, when they should be used, and when they should be avoided. When you study data structures in C (in Chapter 19), your knowledge of computer memory will help you better understand what must be done to manipulate the actual structures in memory efficiently. We realize that most of the terms in the preceding five short paragraphs may not be familiar to you yet. That is OK; you can reread this page at the end of the semester. What is important to know right now is that there are important topics in the software that are very deeply interwoven with topics in the hardware. Our contention is that mastering either is easier if you pay attention to both. Most importantly, most computing problems yield better solutions when the problem solver has the capability of both at his or her disposal. § A COMPUTER SYSTEM We have used the word computer more than two dozen times in the preceding pages, and although we did",
    "82": "knowledge of computer memory will help you better understand what must be done to manipulate the actual structures in memory efficiently. We realize that most of the terms in the preceding five short paragraphs may not be familiar to you yet. That is OK; you can reread this page at the end of the semester. What is important to know right now is that there are important topics in the software that are very deeply interwoven with topics in the hardware. Our contention is that mastering either is easier if you pay attention to both. Most importantly, most computing problems yield better solutions when the problem solver has the capability of both at his or her disposal. § A COMPUTER SYSTEM We have used the word computer more than two dozen times in the preceding pages, and although we did not say so explicitly, we used it to mean a system consisting of the software (i.e., computer programs) that directs and specifies the processing of information and the hardware that performs the actual processing of information in response to what the software asks the hardware to do. When we say “performing the actual processing,” we mean doing the actual additions, multiplications, and so forth in the hardware that are necessary to get the job done. A more precise term for this hardware is a central processing unit (CPU), or simply a processor or microprocessor. This textbook is primarily about the processor and the programs that are executed by the processor. §.§ A (very) little history for a (lot) better perspective Before we get into the detail of how the processor and the software associated with it work, we should take a moment and note the enormous and unparalleled leaps of performance that the computing industry has made in the relatively short time computers have been around. After all, it wasn't until the 1940s that the first computers showed their faces. One of the first computers was the ENIAC (the Electronic Numerical Integrator and Calculator), a general purpose electronic computer that",
    "83": "multiplications, and so forth in the hardware that are necessary to get the job done. A more precise term for this hardware is a central processing unit (CPU), or simply a processor or microprocessor. This textbook is primarily about the processor and the programs that are executed by the processor. §.§ A (very) little history for a (lot) better perspective Before we get into the detail of how the processor and the software associated with it work, we should take a moment and note the enormous and unparalleled leaps of performance that the computing industry has made in the relatively short time computers have been around. After all, it wasn't until the 1940s that the first computers showed their faces. One of the first computers was the ENIAC (the Electronic Numerical Integrator and Calculator), a general purpose electronic computer that could be reprogrammed for different tasks. It was designed and built in 1943-1945 at the University of Pennsylvania by Presper Eckert and his colleagues. It contained more than 17,000 vacuum tubes. It was approximately 8 feet high, more than 100 feet wide, and about 3 feet deep (about 300 square feet of floor space). It weighed 30 tons, and required 140 KWatts to operate. Figure <ref> shows three operators programming the ENIAC by plugging and unplugging cables and switches. < g r a p h i c s > The ENIAC, designed and built at Unversity of Pennsylvania, 1943-45 About 40 years and many computer companies and computers later, in the early 1980s, the Burroughs A series was born. One of the dozen or so 18 inch boards that comprise that machine is shown in Figure <ref>. Each board contained 50 or more integrated circuit packages. Instead of 300 square feet, it took up around 50-60 square feet, instead of 30 tons, it weighed about 1 ton, and instead of 140 Kwatts, it required approximately 25 Kwatts to operate. < g r a p h i c s > A processor board, vintage 1980s (Courtesy of Emilio Salgueiro, Unisys Corporation.)",
    "84": "140 KWatts to operate. Figure <ref> shows three operators programming the ENIAC by plugging and unplugging cables and switches. < g r a p h i c s > The ENIAC, designed and built at Unversity of Pennsylvania, 1943-45 About 40 years and many computer companies and computers later, in the early 1980s, the Burroughs A series was born. One of the dozen or so 18 inch boards that comprise that machine is shown in Figure <ref>. Each board contained 50 or more integrated circuit packages. Instead of 300 square feet, it took up around 50-60 square feet, instead of 30 tons, it weighed about 1 ton, and instead of 140 Kwatts, it required approximately 25 Kwatts to operate. < g r a p h i c s > A processor board, vintage 1980s (Courtesy of Emilio Salgueiro, Unisys Corporation.) Fast forward another 30 or so years and we find many of today's computers on desk tops (Figure <ref>), laptops (Figure <ref>) and most recently in smartphones (Figure <ref>). Their relative weights and energy requirements have decreased enormously, and the speed at which they process information has increased also enormously. We estimate that the computing power in a smart phone today (that is, how fast we can compute with a smart phone) is more than four million times the computing power of the ENIAC! < g r a p h i c s > A desktop computer. < g r a p h i c s > A laptop. < g r a p h i c s > A smartphone. The integrated circuit packages that comprise modern digital computers have also seen phenomenal improvement. An example of one of today's microprocessors is shown in Figure <ref>. The first microprocessor, the Intel 4004 in 1971, contained 2300 transistors, and operated at 106 KHz. By 1992, those numbers had jumped to 3.1 million transistors at a frequency of 66 MHz on the Intel Pentium microprocessor, an increase in both parameters of a factor of about 1000. Today's microprocessors contain upwards of",
    "85": "today (that is, how fast we can compute with a smart phone) is more than four million times the computing power of the ENIAC! < g r a p h i c s > A desktop computer. < g r a p h i c s > A laptop. < g r a p h i c s > A smartphone. The integrated circuit packages that comprise modern digital computers have also seen phenomenal improvement. An example of one of today's microprocessors is shown in Figure <ref>. The first microprocessor, the Intel 4004 in 1971, contained 2300 transistors, and operated at 106 KHz. By 1992, those numbers had jumped to 3.1 million transistors at a frequency of 66 MHz on the Intel Pentium microprocessor, an increase in both parameters of a factor of about 1000. Today's microprocessors contain upwards of 5 billion transistors and can operate at upwards of 4 GHz, another increase in both parameters of about a factor of 1000. This factor of one million since 1971 in both the number of transistors and the frequency that the microprocessor operates at has had very important implications. The fact that each operation can be performed in one millionth of the time it took in 1971 means the microprocessor can do one million things today in the time it took to do one thing in 1971. The fact that there are more than a million times as many transistors on a chip means we can do a lot more things at the same time today than we could in 1971. The result of all this is we have today computers that seem able to understand the languages people speak – English, Spanish, Chinese, for example. We have computers that seem able to recognize faces. Many see this as the magic of artificial intelligence. We will see as we get into the details of how a computer works that much of what appears to be magic is really due to how blazingly fast very simple mindless operations (many at the same",
    "86": "the time it took in 1971 means the microprocessor can do one million things today in the time it took to do one thing in 1971. The fact that there are more than a million times as many transistors on a chip means we can do a lot more things at the same time today than we could in 1971. The result of all this is we have today computers that seem able to understand the languages people speak – English, Spanish, Chinese, for example. We have computers that seem able to recognize faces. Many see this as the magic of artificial intelligence. We will see as we get into the details of how a computer works that much of what appears to be magic is really due to how blazingly fast very simple mindless operations (many at the same time) can be carried out. < g r a p h i c s > A microprocessor. §.§ The parts of a computer system When most people use the word computer, they usually mean more than just the processor (i.e., CPU) that is in charge of doing what the software directs. They usually mean the collection of parts that in combination form their computer systemcomputer system. Today that computer system is often a laptop (see Figure <ref>), augmented with many additional devices. A computer system generally includes, in addition to the processor, a keyboard for typing commands, a mouse or keypad or joystick for positioning on menu entries, a monitor for displaying information that the computer system has produced, memory for temporarily storing information, disks and USB memory sticks of one sort or another for storing information for a very long time, even after the computer has been turned off, connections to other devices such as a printer for obtaining paper copies of that information, and the collection of programs (the software) that the user wishes to execute. All these items help the computer user do his or her job. Without a printer, for example, the user would have to",
    "87": "combination form their computer systemcomputer system. Today that computer system is often a laptop (see Figure <ref>), augmented with many additional devices. A computer system generally includes, in addition to the processor, a keyboard for typing commands, a mouse or keypad or joystick for positioning on menu entries, a monitor for displaying information that the computer system has produced, memory for temporarily storing information, disks and USB memory sticks of one sort or another for storing information for a very long time, even after the computer has been turned off, connections to other devices such as a printer for obtaining paper copies of that information, and the collection of programs (the software) that the user wishes to execute. All these items help the computer user do his or her job. Without a printer, for example, the user would have to copy by hand what is displayed on the monitor. Without a mouse, keypad, or joystick, the user would have to type each command, rather than simply position the mouse, keypad, or joystick. So, as we begin our journey, which focuses on the CPU which occupies a small fraction of 1 square inch of silicon and the software that makes the CPU do our bidding, we note that the computer systems we use contain a lot of additional components. § TWO VERY IMPORTANT IDEAS Before we leave this first chapter, there are two very important ideas that we would like you to understand, ideas that are at the core of what computing is all about. Idea 1: All computers (the biggest and the smallest, the fastest and the slowest, the most expensive and the cheapest) are capable of computing exactly the same things if they are given enough time and enough memory. That is, anything a fast computer can do, a slow computer can do also. The slow computer just does it more slowly. A more expensive computer cannot figure out something that a cheaper computer is unable to figure out as long as the cheaper computer can access enough memory.",
    "88": "CPU do our bidding, we note that the computer systems we use contain a lot of additional components. § TWO VERY IMPORTANT IDEAS Before we leave this first chapter, there are two very important ideas that we would like you to understand, ideas that are at the core of what computing is all about. Idea 1: All computers (the biggest and the smallest, the fastest and the slowest, the most expensive and the cheapest) are capable of computing exactly the same things if they are given enough time and enough memory. That is, anything a fast computer can do, a slow computer can do also. The slow computer just does it more slowly. A more expensive computer cannot figure out something that a cheaper computer is unable to figure out as long as the cheaper computer can access enough memory. (You may have to go to the store to buy more memory whenever it runs out of memory in order to keep increasing memory.) All computers can do exactly the same things. Some computers can do things faster, but none can do more than any other. Idea 2: We describe our problems in English or some other language spoken by people. Yet the problems are solved by electrons running around inside the computer. It is necessary to transform our problem from the language of humans to the voltages that influence the flow of electrons. This transformation is really a sequence of systematic transformations, developed and improved over the last 70 years, which combine to give the computer the ability to carry out what appears to be some very complicated tasks. In reality, these tasks are simple and straightforward. The rest of this chapter is devoted to discussing these two ideas. § COMPUTERS AS UNIVERSAL COMPUTATIONAL DEVICES It may seem strange that an introductory textbook begins by describing how computers work. After all, mechanical engineering students begin by studying physics, not how car engines work. Chemical engineering students begin by studying chemistry, not oil refineries. Why should computing students begin by",
    "89": "people. Yet the problems are solved by electrons running around inside the computer. It is necessary to transform our problem from the language of humans to the voltages that influence the flow of electrons. This transformation is really a sequence of systematic transformations, developed and improved over the last 70 years, which combine to give the computer the ability to carry out what appears to be some very complicated tasks. In reality, these tasks are simple and straightforward. The rest of this chapter is devoted to discussing these two ideas. § COMPUTERS AS UNIVERSAL COMPUTATIONAL DEVICES It may seem strange that an introductory textbook begins by describing how computers work. After all, mechanical engineering students begin by studying physics, not how car engines work. Chemical engineering students begin by studying chemistry, not oil refineries. Why should computing students begin by studying computers? The answer is that computers are different. To learn the fundamental principles of computing, you must study computers or machines that can do what computers can do. The reason for this has to do with the notion that computers are universal computational devices. Let's see what that means. =-1 Before modern computers, there were many kinds of calculating machines. Some were analog machines—machines that produced an answer by measuring some physical quantity such as distance or voltage. For example, a slide rule is an analog machine that multiplies numbers by sliding one logarithmically graded ruler next to another. The user can read a logarithmic “distance” on the second ruler. Some early analog adding machines worked by dropping weights on a scale. The difficulty with analog machines is that it is very hard to increase their accuracy. =-1 This is why digital machines—machines that perform computations by manipulating a fixed finite set of digits or letters—came to dominate computing. You are familiar with the distinction between analog and digital watches. An analog watch has hour and minute hands, and perhaps a second hand. It gives the time by the positions of its hands, which are really angular measures. Digital",
    "90": "machines. Some were analog machines—machines that produced an answer by measuring some physical quantity such as distance or voltage. For example, a slide rule is an analog machine that multiplies numbers by sliding one logarithmically graded ruler next to another. The user can read a logarithmic “distance” on the second ruler. Some early analog adding machines worked by dropping weights on a scale. The difficulty with analog machines is that it is very hard to increase their accuracy. =-1 This is why digital machines—machines that perform computations by manipulating a fixed finite set of digits or letters—came to dominate computing. You are familiar with the distinction between analog and digital watches. An analog watch has hour and minute hands, and perhaps a second hand. It gives the time by the positions of its hands, which are really angular measures. Digital watches give the time in digits. You can increase accuracy just by adding more digits. For example, if it is important for you to measure time in hundredths of a second, you can buy a watch that gives a reading like 10:35.16 rather than just 10:35. How would you get an analog watch that would give you an accurate reading to one one-hundredth of a second? You could do it, but it would take a mighty long second hand! When we talk about computers in this book, we will always mean digital machines. Before modern digital computers, the most common digital machines in the West were adding machines. In other parts of the world another digital machine, the abacus, was common. Digital adding machines were mechanical or electromechanical devices that could perform a specific kind of computation: adding integers. There were also digital machines that could multiply integers. There were digital machines that could put a stack of cards with punched names in alphabetical order. The main limitation of all these machines is that they could do only one specific kind of computation. If you owned only an adding machine and wanted to multiply two integers, you had some pencil-and-paper",
    "91": "to one one-hundredth of a second? You could do it, but it would take a mighty long second hand! When we talk about computers in this book, we will always mean digital machines. Before modern digital computers, the most common digital machines in the West were adding machines. In other parts of the world another digital machine, the abacus, was common. Digital adding machines were mechanical or electromechanical devices that could perform a specific kind of computation: adding integers. There were also digital machines that could multiply integers. There were digital machines that could put a stack of cards with punched names in alphabetical order. The main limitation of all these machines is that they could do only one specific kind of computation. If you owned only an adding machine and wanted to multiply two integers, you had some pencil-and-paper work to do. This is why computers are different. You can tell a computer how to add numbers. You can tell it how to multiply. You can tell it how to alphabetize a list or perform any computation you like. When you think of a new kind of computation, you do not have to buy or design a new computer. You just give the old computer a new set of instructions (or program) to carry out the new computation. This is why we say the computer is a universal computational device. Computer scientists believe that anything that can be computed, can be computed by a computer provided it has enough time and enough memory. When we study computers, we study the fundamentals of all computing. We learn what computation is and what can be computed. =1 The idea of a universal computational device is due to Alan Turing. Turing, Alan Turing proposed in 1937 that all computations could be carried out by a particular kind of machine, which is now called a Turing machine. He gave a mathematical description of this kind of machine, but did not actually build one. Digital computers were not operating until several years later. Turing",
    "92": "You just give the old computer a new set of instructions (or program) to carry out the new computation. This is why we say the computer is a universal computational device. Computer scientists believe that anything that can be computed, can be computed by a computer provided it has enough time and enough memory. When we study computers, we study the fundamentals of all computing. We learn what computation is and what can be computed. =1 The idea of a universal computational device is due to Alan Turing. Turing, Alan Turing proposed in 1937 that all computations could be carried out by a particular kind of machine, which is now called a Turing machine. He gave a mathematical description of this kind of machine, but did not actually build one. Digital computers were not operating until several years later. Turing was more interested in solving a philosophical problem: defining computation. He began by looking at the kinds of actions that people perform when they compute; these include making marks on paper, writing symbols according to certain rules when other symbols are present, and so on. He abstracted these actions and specified a mechanism that could carry them out. He gave some examples of the kinds of things that these machines could do. One Turing machine could add two integers; another Turing machine could multiply two integers. Figure <ref> shows what we call “black box”black box model models of Turing machines that add and multiply. In each case, the operation to be performed is described in the box. The data on which to operate is shown as inputs to the box. The result of the operation is shown as output from the box. A black box model provides no information as to exactly how the operation is performed, and indeed, there are many ways to add or multiply two numbers. < g r a p h i c s > Black box models of Turing machines Turing proposed that every computation can be performed by some Turing machine. We call this",
    "93": "some examples of the kinds of things that these machines could do. One Turing machine could add two integers; another Turing machine could multiply two integers. Figure <ref> shows what we call “black box”black box model models of Turing machines that add and multiply. In each case, the operation to be performed is described in the box. The data on which to operate is shown as inputs to the box. The result of the operation is shown as output from the box. A black box model provides no information as to exactly how the operation is performed, and indeed, there are many ways to add or multiply two numbers. < g r a p h i c s > Black box models of Turing machines Turing proposed that every computation can be performed by some Turing machine. We call this Turing's thesis. Although Turing's thesis has never been proved, there does exist a lot of evidence to suggest it is true. We know, for example, that various enhancements one can make to Turing machines do not result in machines that can compute more. Perhaps the best argument to support Turing's thesis was provided by Turing himself in his original paper. He said that one way to try to construct a machine more powerful than any particular Turing machine was to make a machineUthat could simulate all Turing machines. You would simply describe toUthe particular Turing machine you wanted it to simulate, say a machine to add two integers, giveUthe input data, andUwould compute the appropriate output, in this case the sum of the inputs. Turing then showed that there was, in fact, a Turing machine that could do this, so even this attempt to find something that could not be computed by Turing machines failed. Figure <ref> further illustrates the point. Suppose you wanted to compute You would simply provide toUdescriptions of the Turing machines to add and to multiply, and the three inputs,e,f, andg.Uwould do the rest. < g r a p h i c s > Black box",
    "94": "He said that one way to try to construct a machine more powerful than any particular Turing machine was to make a machineUthat could simulate all Turing machines. You would simply describe toUthe particular Turing machine you wanted it to simulate, say a machine to add two integers, giveUthe input data, andUwould compute the appropriate output, in this case the sum of the inputs. Turing then showed that there was, in fact, a Turing machine that could do this, so even this attempt to find something that could not be computed by Turing machines failed. Figure <ref> further illustrates the point. Suppose you wanted to compute You would simply provide toUdescriptions of the Turing machines to add and to multiply, and the three inputs,e,f, andg.Uwould do the rest. < g r a p h i c s > Black box model of a universal Turing machine In specifyingU, Turing had provided us with a deep insight: He had given us the first description of what computers do. In fact, both a computer (with as much memory as it wants) and a universal Turing machine can compute exactly universal Turing machine the same things. In both cases you give the machine a description of a computation and the data it needs, and the machine computes the appropriate answer. Computers and universal Turing machines can compute anything that can be computed because they are programmable. This is the reason that a big or expensive computer cannot do more than a small, cheap computer. More money may buy you a faster computer, a monitor with higher resolution, or a nice sound system. But if you have a small, cheap computer, you already have a universal computational device. § HOW DO WE GET THE ELECTRONS TO DO THE WORK? < g r a p h i c s > Levels of transformation Figure <ref> shows the process we must go through to get the electrons (which actually do the work) to do our bidding. We call the steps of this process the “Levels of",
    "95": "a description of a computation and the data it needs, and the machine computes the appropriate answer. Computers and universal Turing machines can compute anything that can be computed because they are programmable. This is the reason that a big or expensive computer cannot do more than a small, cheap computer. More money may buy you a faster computer, a monitor with higher resolution, or a nice sound system. But if you have a small, cheap computer, you already have a universal computational device. § HOW DO WE GET THE ELECTRONS TO DO THE WORK? < g r a p h i c s > Levels of transformation Figure <ref> shows the process we must go through to get the electrons (which actually do the work) to do our bidding. We call the steps of this process the “Levels of Transformation.” As we will see, at levels of transformation each level we have choices. If we ignore any of the levels, our ability to make the best use of our computing system can be very adversely affected. §.§ The Statement of the Problem We describe the problems we wish to solve in a “natural language.” Natural languages are languages that people speak, like English, French, Japanese, Italian, and so on. They have evolved over centuries in accordance with their usage. They are fraught with a lot of things unacceptable for providing instructions to a computer. Most important of these unacceptable attributes is ambiguity. Natural language is filled with ambiguity. To infer the meaning of a sentence, a listener is often helped by the tone of voice of the speaker, or at the very least, the context of the sentence. An example of ambiguity in English is the sentence, “Time flies like an arrow.” At least three interpretations are possible, depending on whether (1) one is noticing how fast time passes, (2) one is at a track meet for insects, or (3) one is writing a letter to the Dear Abby of Insectville. In the first case, a simile; one is",
    "96": "people speak, like English, French, Japanese, Italian, and so on. They have evolved over centuries in accordance with their usage. They are fraught with a lot of things unacceptable for providing instructions to a computer. Most important of these unacceptable attributes is ambiguity. Natural language is filled with ambiguity. To infer the meaning of a sentence, a listener is often helped by the tone of voice of the speaker, or at the very least, the context of the sentence. An example of ambiguity in English is the sentence, “Time flies like an arrow.” At least three interpretations are possible, depending on whether (1) one is noticing how fast time passes, (2) one is at a track meet for insects, or (3) one is writing a letter to the Dear Abby of Insectville. In the first case, a simile; one is comparing the speed of time passing to the speed of an arrow that has been released. In the second case, one is telling the timekeeper to do his/her job much like an arrow would. In the third case, one is relating that a particular group of flies (time flies, as opposed to fruit flies) are all in love with the same arrow. Such ambiguity would be unacceptable in instructions provided to a computer. The computer, electronic idiot that it is, can only do as it is told. To tell it to do something where there are multiple interpretations would cause the computer to not know which interpretation to follow. §.§ The Algorithm The first step in the sequence of transformations is to transform the natural language description of the problem to an algorithm, and in so doing, algorithm get rid of the objectionable characteristics of the natural language. An algorithm is a step-by-step procedure that is guaranteed to terminate, such that each step is precisely stated and can be carried out by the computer. There are terms to describe each of these properties. We use the term definiteness to describe the notion that each step is definiteness precisely stated. A",
    "97": "same arrow. Such ambiguity would be unacceptable in instructions provided to a computer. The computer, electronic idiot that it is, can only do as it is told. To tell it to do something where there are multiple interpretations would cause the computer to not know which interpretation to follow. §.§ The Algorithm The first step in the sequence of transformations is to transform the natural language description of the problem to an algorithm, and in so doing, algorithm get rid of the objectionable characteristics of the natural language. An algorithm is a step-by-step procedure that is guaranteed to terminate, such that each step is precisely stated and can be carried out by the computer. There are terms to describe each of these properties. We use the term definiteness to describe the notion that each step is definiteness precisely stated. A recipe for excellent pancakes that instructs the preparer to “stir until lumpy” lacks definiteness, since the notion of lumpiness is not precise. We use the term effective computability to describe the notion that effective computability each step can be carried out by a computer. A procedure that instructs the computer to “take the largest prime number” lacks effective computability, since there is no largest prime number. We use the term finiteness to describe the notion that the procedure terminates. finiteness For every problem there are usually many different algorithms for solving that problem. One algorithm may require the fewest number of steps. Another algorithm may allow some steps to be performed concurrently. A computer that allows more than one thing to be done at a time can often solve the problem in less time, even though it is likely that the total number of steps to be performed has increased. -1pc §.§ The Program The next step is to transform the algorithm into a computer program in one of the programming languages that are available. Programming languages are “mechanical languages.” That is, unlike natural languages, mechanical languages did not evolve through human discourse. Rather, they were invented for use in",
    "98": "there is no largest prime number. We use the term finiteness to describe the notion that the procedure terminates. finiteness For every problem there are usually many different algorithms for solving that problem. One algorithm may require the fewest number of steps. Another algorithm may allow some steps to be performed concurrently. A computer that allows more than one thing to be done at a time can often solve the problem in less time, even though it is likely that the total number of steps to be performed has increased. -1pc §.§ The Program The next step is to transform the algorithm into a computer program in one of the programming languages that are available. Programming languages are “mechanical languages.” That is, unlike natural languages, mechanical languages did not evolve through human discourse. Rather, they were invented for use in specifying a sequence of instructions to a computer. Therefore, mechanical languages do not suffer from failings such as ambiguity that would make them unacceptable for specifying a computer program. There are more than 1,000 programming languages. Some have been designed for use with particular applications, such as Fortran for solving scientific calculations and COBOL for solving business data-processing problems. In the second half of this book, we will use C and C++, languages that were designed for manipulating low-level hardware structures. Other languages are useful for still other purposes. Prolog is the language of choice for many applications that require the design of an expert system. LISP was for years the language of choice of a substantial number of people working on problems dealing with artificial intelligence. Pascal is a language invented as a vehicle for teaching beginning students how to program. There are two kinds of programming languages, high-level languages and low-level high-level language languages. High-level languages are at a distance (a high level) from the underlying computer. At their best, they are independent of the computer on which the programs will execute. We say the language is “machine independent.” All the languages mentioned thus far are high-level languages.",
    "99": "the second half of this book, we will use C and C++, languages that were designed for manipulating low-level hardware structures. Other languages are useful for still other purposes. Prolog is the language of choice for many applications that require the design of an expert system. LISP was for years the language of choice of a substantial number of people working on problems dealing with artificial intelligence. Pascal is a language invented as a vehicle for teaching beginning students how to program. There are two kinds of programming languages, high-level languages and low-level high-level language languages. High-level languages are at a distance (a high level) from the underlying computer. At their best, they are independent of the computer on which the programs will execute. We say the language is “machine independent.” All the languages mentioned thus far are high-level languages. Low-level languages are tied to the computer on which the programs will execute. There is generally one such low-level language for each computer. That language is called the assembly language for that computer. assembly language §.§ The ISA The next step is to translate the program into the instruction set of the particular computer that will be used to carry out the work of the program. The instruction set architecture (ISA) Instruction Set ArchitectureISA is the complete specification of the interface between programs that have been written and the underlying computer hardware that must carry out the work of those programs. An analogy that may be helpful in understanding the concept of an ISA is provided by the automobile. Corresponding to a computer program, represented as a sequence of 0s and 1s in the case of the computer, is the human sitting in the driver's seat of a car. Corresponding to the microprocessor hardware is the car, itself. The \"ISA\" of the automobile is the specification of everything the human needs to know to tell the automobile what to do, and everything the automobile needs to know to carry out the tasks specified by the human driver. For example, one",
    "100": "out the work of the program. The instruction set architecture (ISA) Instruction Set ArchitectureISA is the complete specification of the interface between programs that have been written and the underlying computer hardware that must carry out the work of those programs. An analogy that may be helpful in understanding the concept of an ISA is provided by the automobile. Corresponding to a computer program, represented as a sequence of 0s and 1s in the case of the computer, is the human sitting in the driver's seat of a car. Corresponding to the microprocessor hardware is the car, itself. The \"ISA\" of the automobile is the specification of everything the human needs to know to tell the automobile what to do, and everything the automobile needs to know to carry out the tasks specified by the human driver. For example, one element of the automobile's \"ISA\" is the pedal on the floor known as the \"brake, and its function. The human knows that if he/she steps on the brake the car will stop. The automobile knows that if it feels pressure from the human on that pedal, the hardware of the automobile must engage those elements necessary to stop the car. The full \"ISA\" of the car includes the specification of the other pedals, the steering wheel, the ignition key, the gears, windshield wipers, etc. For each, the \"ISA\" specifies (a) what the human has to do to tell the automobile what he/she wants done, and (b) correspondingly, what the automobile will interpret those actions to mean so it (the automobile) can carry out the specified task. The ISA of a computer serves the same purpose as the \"ISA\" of an automobile, except instead of the driver and the car, the ISA of a computer specifies the interface between the computer program directing the computer hardware and the hardware carrying out those directions. For example, the set of instructions that the computer can carry out; that is, what operations the computer can perform and where to get the data that is",
    "101": "The full \"ISA\" of the car includes the specification of the other pedals, the steering wheel, the ignition key, the gears, windshield wipers, etc. For each, the \"ISA\" specifies (a) what the human has to do to tell the automobile what he/she wants done, and (b) correspondingly, what the automobile will interpret those actions to mean so it (the automobile) can carry out the specified task. The ISA of a computer serves the same purpose as the \"ISA\" of an automobile, except instead of the driver and the car, the ISA of a computer specifies the interface between the computer program directing the computer hardware and the hardware carrying out those directions. For example, the set of instructions that the computer can carry out; that is, what operations the computer can perform and where to get the data that is needed to perform those operations. The term opcode is used to decribe the operation. The term operand is used to describe individual data values. The ISA specifies the operanddata type acceptable representations for operands. They are called data types. A data type is a representation of an operand such that the computer can perform operations on that representation. The ISA specifies the mechanisms that the computer can use to figure out where the operands are located. These mechanisms are called addressing modes.addressing mode The number of opcodes, data types, and addressing modes specified by an ISA vary among different ISAs. Some ISAs have as few as a half dozen opcodes, whereas others have as many as several hundred. Some ISAs have only one data type, while others have more than a dozen. Some ISAs have one or two addressing modes, whereas others have more than 20. The x86, the ISA used in the PC, has more than 200 opcodes, more than a dozen data types, and more than two dozen addressing modes. The ISA also specifies the number of unique locations that comprise the computer's memory and the number of individual 0s and 1s that are contained in each location.",
    "102": "specifies the mechanisms that the computer can use to figure out where the operands are located. These mechanisms are called addressing modes.addressing mode The number of opcodes, data types, and addressing modes specified by an ISA vary among different ISAs. Some ISAs have as few as a half dozen opcodes, whereas others have as many as several hundred. Some ISAs have only one data type, while others have more than a dozen. Some ISAs have one or two addressing modes, whereas others have more than 20. The x86, the ISA used in the PC, has more than 200 opcodes, more than a dozen data types, and more than two dozen addressing modes. The ISA also specifies the number of unique locations that comprise the computer's memory and the number of individual 0s and 1s that are contained in each location. Many ISAs are in use today. The most widely-known example is the x86, introduced by Intel Corporation in 1979 and currently also manufactured by AMD and other companies. Other ISAs and the companies responsible for them include ARM and THUMB (ARM), POWER and z/Architecture (IBM), and SPARC (Oracle). The translation from a high-level language (such as C) to the ISA of the computer on which the program will execute (such as x86) is usually done by a translating program called a compiler. To translate from a program written in C to the x86 ISA, one would need compiler a C to x86 compiler. For each high-level language and each desired target ISA, one must provide a corresponding compiler. The translation from the unique assembly language of a computer to its ISA is done by an assembler. assembler- §.§ The Microarchitecture The next step is the implementation of the ISA, referred to as its microarchitecture. The automobile analogy that we used in our discussion of the ISA is also useful in showing the relationship between an ISA and a microarchitecture that implements that ISA. The automobile's \"ISA\" describes what the driver needs to know as he/she sits inside the automobile to",
    "103": "of the computer on which the program will execute (such as x86) is usually done by a translating program called a compiler. To translate from a program written in C to the x86 ISA, one would need compiler a C to x86 compiler. For each high-level language and each desired target ISA, one must provide a corresponding compiler. The translation from the unique assembly language of a computer to its ISA is done by an assembler. assembler- §.§ The Microarchitecture The next step is the implementation of the ISA, referred to as its microarchitecture. The automobile analogy that we used in our discussion of the ISA is also useful in showing the relationship between an ISA and a microarchitecture that implements that ISA. The automobile's \"ISA\" describes what the driver needs to know as he/she sits inside the automobile to make the automobile carry out the driver's wishes. All automobiles have the same ISA. If there are three pedals on the floor, it does not matter what manufacturer produced the car, the middle one is always the brake. The one on the right is always the accelerator, and the more it is depressed, the faster the car will move. Because there is only one ISA for automobiles, one does not need one driver's license for Buicks and a different driver's license for Hondas. The microarchitecture (or implementation) of the automobile's ISA, on the other hand, is about what goes on underneath the hood. Here all automobile makes and models can be different, depending on what cost/performance trade-offs the automobile designer made before the car was manufactured. Some automobiles come with disc brakes, others (in the past, at least) with drums. Some automobiles have eight cylinders, others run on six cylinders, and still others have only four. Some are turbocharged, some are not. Some automobiles can travel 60 miles on one gallon of gasoline, others are lucky to travel from gas station to the next without running out of gas. Some automobiles cost 6,000 US dollars, others cost 200,000 US dollars.",
    "104": "there is only one ISA for automobiles, one does not need one driver's license for Buicks and a different driver's license for Hondas. The microarchitecture (or implementation) of the automobile's ISA, on the other hand, is about what goes on underneath the hood. Here all automobile makes and models can be different, depending on what cost/performance trade-offs the automobile designer made before the car was manufactured. Some automobiles come with disc brakes, others (in the past, at least) with drums. Some automobiles have eight cylinders, others run on six cylinders, and still others have only four. Some are turbocharged, some are not. Some automobiles can travel 60 miles on one gallon of gasoline, others are lucky to travel from gas station to the next without running out of gas. Some automobiles cost 6,000 US dollars, others cost 200,000 US dollars. In each case, the “microarchitecture” of the specific automobile is a result of the automobile designers' decisions regarding the tradeoffs of cost and performance. The fact that the \"microarchitecture\" of every model or make is different is a good reason to take one's Honda, when it is malfunctioning, to a Honda repair person, and not to a Buick repair person. In the previous section we identified ISAs of several computer manufacturers, including the x86 (Intel), the PowerPC (IBM and Motorola), and THUMB (ARM). Each has been implemented by many different microarchitectures. miroarchitecture For example, the x86's original implementation in 1979 was the 8086, followed by the 80286, 80386, and 80486 in the 1980s. More recently, in 2001, Intel introduced the Pentium IV microprocessor. Even more recently, in 2015, Intel introduced Skylake. Each of these x86 microprocessors has its own microarchitecture. The story is the same for the PowerPC ISA, with more than a dozen different microprocessors, each having its own microarchitecture. Each microarchitecture is an opportunity for computer designers to make different trade-offs between the cost of the microprocessor, the performance that the microprocessor will provide, and the energy that is required to power the microprocessor. Computer design is always",
    "105": "In the previous section we identified ISAs of several computer manufacturers, including the x86 (Intel), the PowerPC (IBM and Motorola), and THUMB (ARM). Each has been implemented by many different microarchitectures. miroarchitecture For example, the x86's original implementation in 1979 was the 8086, followed by the 80286, 80386, and 80486 in the 1980s. More recently, in 2001, Intel introduced the Pentium IV microprocessor. Even more recently, in 2015, Intel introduced Skylake. Each of these x86 microprocessors has its own microarchitecture. The story is the same for the PowerPC ISA, with more than a dozen different microprocessors, each having its own microarchitecture. Each microarchitecture is an opportunity for computer designers to make different trade-offs between the cost of the microprocessor, the performance that the microprocessor will provide, and the energy that is required to power the microprocessor. Computer design is always an exercise in trade-offs, as the designer opts for higher (or lower) performance, more (or less) energy required, at greater (or lesser) cost. §.§ The Logic Circuit The next step is to implement each element of the microarchitecture out of simple logic circuits. Here, also, there are choices, as the logic designer decides how logic circuit to best make the trade-offs between cost and performance. So, for example, even for an operation as simple as addition, there are several choices of logic circuits to perform the operation at differing speeds and corresponding costs. §.§ The Devices Finally, each basic logic circuit is implemented in accordance with the requirements of the particular device technology used. So, CMOS circuits are different from CMOS NMOS circuits, which are different, in turn, from gallium arsenide circuits. The Bottom Line In summary, from the natural language description of a problem to the electrons that actually solve the problem by moving from one voltage potential to another, many transformations need to be performed. If we could speak electron, or if the electrons could understand English, perhaps we could just walk up to the computer and get the electrons to do our bidding. Since we can't speak",
    "106": "trade-offs between cost and performance. So, for example, even for an operation as simple as addition, there are several choices of logic circuits to perform the operation at differing speeds and corresponding costs. §.§ The Devices Finally, each basic logic circuit is implemented in accordance with the requirements of the particular device technology used. So, CMOS circuits are different from CMOS NMOS circuits, which are different, in turn, from gallium arsenide circuits. The Bottom Line In summary, from the natural language description of a problem to the electrons that actually solve the problem by moving from one voltage potential to another, many transformations need to be performed. If we could speak electron, or if the electrons could understand English, perhaps we could just walk up to the computer and get the electrons to do our bidding. Since we can't speak electron and they can't speak English, the best we can do is this systematic sequence of transformations. At each level of transformation, there are choices as to how to proceed. Our handling of those choices determines the resulting cost and performance of our computer. =1 In this book, we describe each of these transformations. We show how transistors combine to form logic circuits, how logic circuits combine to form the microarchitecture, and how the microarchitecture implements a particular ISA. In our case, the ISA is the LC-3. We complete the process by going from the English-language description of a problem to a C or C++ program that solves the problem, and we show how that C or C++ program is translated (i.e., compiled) to the ISA of the LC-3. We hope you enjoy the ride. 1.1 [1] Explain the first of the two important ideas stated in Section 1.5. 1.2 [1] Can a higher-level programming language instruct a computer to compute more than a lower-level programming language? 1.3 [1] What difficulty with analog computers encourages computer designers to use digital designs? 1.4 [1] Name one characteristic of natural languages that prevents them from being used as programming languages. 1.5 [5]",
    "107": "form logic circuits, how logic circuits combine to form the microarchitecture, and how the microarchitecture implements a particular ISA. In our case, the ISA is the LC-3. We complete the process by going from the English-language description of a problem to a C or C++ program that solves the problem, and we show how that C or C++ program is translated (i.e., compiled) to the ISA of the LC-3. We hope you enjoy the ride. 1.1 [1] Explain the first of the two important ideas stated in Section 1.5. 1.2 [1] Can a higher-level programming language instruct a computer to compute more than a lower-level programming language? 1.3 [1] What difficulty with analog computers encourages computer designers to use digital designs? 1.4 [1] Name one characteristic of natural languages that prevents them from being used as programming languages. 1.5 [5] Say we had a “black box,” which takes two numbers as input and outputs their sum. See Figure 1.7a. Say we had another box capable of multiplying two numbers together. See Figure 1.7b. We can connect these boxes together to calculate p×(m+n). See Figure 1.7c. Assume we have an unlimited number of these boxes. Show how to connect them together to calculate: a.ax+b b. The average of the four input numbers w, x, y, and z c.a^2+2ab+b^2 (Can you do it with one add box and one multiply box?) < g r a p h i c s > “Black boxes” capable of (a) addition, (b) multiplication, and (c) a combination of addition and multiplication 1.6 [1] Write a statement in a natural language and offer two different interpre­tations of that statement. 1.7 [3] The discussion of abstraction in Section 1.3.1 noted that one does not need to understand the makeup of the components as long as “everything about the detail is just fine.” The case was made that when everything is not fine, one must be able to deconstruct the components, or be at the mercy of the abstractions. In the taxi example, suppose you did not understand the",
    "108": "to calculate: a.ax+b b. The average of the four input numbers w, x, y, and z c.a^2+2ab+b^2 (Can you do it with one add box and one multiply box?) < g r a p h i c s > “Black boxes” capable of (a) addition, (b) multiplication, and (c) a combination of addition and multiplication 1.6 [1] Write a statement in a natural language and offer two different interpre­tations of that statement. 1.7 [3] The discussion of abstraction in Section 1.3.1 noted that one does not need to understand the makeup of the components as long as “everything about the detail is just fine.” The case was made that when everything is not fine, one must be able to deconstruct the components, or be at the mercy of the abstractions. In the taxi example, suppose you did not understand the component, that is, you had no clue how to get to the airport. Using the notion of abstraction, you simply tell the driver,“Take me to the airport.” Explain when this is a productivity enhancer, and when it could result in very negative consequences. 1.8 [5] John said, “I saw the man in the park with a telescope.” What did he mean? How many reasonable interpretations can you provide for this statement? List them. What property does this sentence demonstrate that makes it unacceptable as a statement in a program. 1.9 [1] Are natural languages capable of expressing algorithms? 1.10 [1] Name three characteristics of algorithms. Briefly explain each of these three characteristics. 1.11 [4] For each characteristic of an algorithm, give an example of a procedure that does not have the characteristic, and is therefore not an algorithm. 1.12 [5] Are items a through e in the following list algorithms? If not, what qualities required of algorithms do they lack? a. Add the first row of the following matrix to another row whose first column contains a nonzero entry. ( Reminder: Columns run vertically; rows run horizontally.) [ 1 2 0 4 0 3 2 4 2 3 10 22",
    "109": "mean? How many reasonable interpretations can you provide for this statement? List them. What property does this sentence demonstrate that makes it unacceptable as a statement in a program. 1.9 [1] Are natural languages capable of expressing algorithms? 1.10 [1] Name three characteristics of algorithms. Briefly explain each of these three characteristics. 1.11 [4] For each characteristic of an algorithm, give an example of a procedure that does not have the characteristic, and is therefore not an algorithm. 1.12 [5] Are items a through e in the following list algorithms? If not, what qualities required of algorithms do they lack? a. Add the first row of the following matrix to another row whose first column contains a nonzero entry. ( Reminder: Columns run vertically; rows run horizontally.) [ 1 2 0 4 0 3 2 4 2 3 10 22 12 4 3 4 ] b. In order to show that there are as many prime numbers as there are natural numbers, match each prime number with a natural number in the following manner. Create pairs of prime and natural numbers by matching the first prime number with 1 (which is the first natural number) and the second prime number with 2, the third with 3, and so forth. If, in the end, it turns out that each prime number can be paired with each natural number, then it is shown that there are as many prime numbers as natural numbers. c. Suppose you're given two vectors each with 20 elements and asked to perform the following operation. Take the first element of the first vector and multiply it by the first element of the second vector. Do the same to the second elements, and so forth. Add all the individual products together to derive the dot product. d. Lynne and Calvin are trying to decided who will take the dog for a walk. Lynne suggests that they flip a coin and pulls a quarter out of her pocket. Calvin does not trust Lynne and suspects that the quarter may",
    "110": "with 2, the third with 3, and so forth. If, in the end, it turns out that each prime number can be paired with each natural number, then it is shown that there are as many prime numbers as natural numbers. c. Suppose you're given two vectors each with 20 elements and asked to perform the following operation. Take the first element of the first vector and multiply it by the first element of the second vector. Do the same to the second elements, and so forth. Add all the individual products together to derive the dot product. d. Lynne and Calvin are trying to decided who will take the dog for a walk. Lynne suggests that they flip a coin and pulls a quarter out of her pocket. Calvin does not trust Lynne and suspects that the quarter may be weighted (meaning that it might favor a particular outcome when tossed) and suggests the following procedure to fairly determine who will walk the dog. 1. Flip the quarter twice. 2. If the outcome is heads on the first flip and tails on the second, then I will walk the dog. 3. If the outcome is tails on the first flip, and heads on the second, then you will walk the dog. 4. If both outcomes are tails or both outcomes are heads, then we flip twice again. Is Calvin's technique an algorithm? e. Given a number, perform the following steps in order: 1. Multiply it by four 2. Add four 3. Divide by two 4. Subtract two 5. Divide by two 6. Subtract one 7. At this point, add one to a counter to keep track of the fact that you performed steps 1 through 6. Then test the result you got when you subtracted one. If 0, write down the number of times you performed steps 1 through 6 and stop. If not 0, starting with the result of subtracting 1, perform the above 7 steps again. 1.13 [4] Two computers, A and B, are identical except for",
    "111": "flip, and heads on the second, then you will walk the dog. 4. If both outcomes are tails or both outcomes are heads, then we flip twice again. Is Calvin's technique an algorithm? e. Given a number, perform the following steps in order: 1. Multiply it by four 2. Add four 3. Divide by two 4. Subtract two 5. Divide by two 6. Subtract one 7. At this point, add one to a counter to keep track of the fact that you performed steps 1 through 6. Then test the result you got when you subtracted one. If 0, write down the number of times you performed steps 1 through 6 and stop. If not 0, starting with the result of subtracting 1, perform the above 7 steps again. 1.13 [4] Two computers, A and B, are identical except for the fact that A has a subtract instruction and B does not. Both have add instructions. Both have instructions that can take a value and produce the negative of that value. Which computer is able to solve more problems, A or B? Prove your result. 1.14 [4] Suppose we wish to put a set of names in alphabetical order. We call the act of doing so sorting. One algorithm that can accomplish that is called the bubble sort. We could then program our bubble sort algorithm in C, and compile the C program to execute on an x86 ISA. The x86 ISA can be implemented with an Intel Pentium IV microarchitecture. Let us call the sequence “Bubble Sort, C program, x86 ISA, Pentium IV microarchitecture” one transformation process. Assume we have available four sorting algorithms and can program in C, C++, Pascal, Fortran, and COBOL. We have available compilers that can translate from each of these to either x86 or SPARC, and we have available three different microarchitectures for x86 and three different microarchitectures for SPARC. a. How many transformation processes are possible? b. Write three examples of transformation processes. c. How many transformation processes are possible if instead of",
    "112": "call the act of doing so sorting. One algorithm that can accomplish that is called the bubble sort. We could then program our bubble sort algorithm in C, and compile the C program to execute on an x86 ISA. The x86 ISA can be implemented with an Intel Pentium IV microarchitecture. Let us call the sequence “Bubble Sort, C program, x86 ISA, Pentium IV microarchitecture” one transformation process. Assume we have available four sorting algorithms and can program in C, C++, Pascal, Fortran, and COBOL. We have available compilers that can translate from each of these to either x86 or SPARC, and we have available three different microarchitectures for x86 and three different microarchitectures for SPARC. a. How many transformation processes are possible? b. Write three examples of transformation processes. c. How many transformation processes are possible if instead of three different microarchitectures for x86 and three different microarchitectures for SPARC, there were two for x86 and four for SPARC? 1.15 [7] Identify one advantage of programming in a higher-level language compared to a lower-level language. Identify one disadvantage. 1.16 [1] Name at least three things specified by an ISA. 1.17 [1] Briefly describe the difference between an ISA and a microarchitecture. 1.18 [4] How many ISAs are normally implemented by a single microarchitecture? Conversely, how many microarchitectures could exist for a single ISA? 1.19 [1] List the levels of transformation and name an example for each level. 1.20 [4] The levels of transformation in Figure 1.6 are often referred to as levels of abstraction. Is that a reasonable characterization? If yes, give an example. If no, why not? 1.21 [7] Say you go to the store and buy some word processing software. What form is the software actually in? Is it in a high-level programming language? Is it in assembly language? Is it in the ISA of the computer on which you'll run it? Justify your answer. 1.22 [5] Suppose you were given a task at one of the transformation levels shown in Figure 1.6, and required to tranform",
    "113": "a microarchitecture. 1.18 [4] How many ISAs are normally implemented by a single microarchitecture? Conversely, how many microarchitectures could exist for a single ISA? 1.19 [1] List the levels of transformation and name an example for each level. 1.20 [4] The levels of transformation in Figure 1.6 are often referred to as levels of abstraction. Is that a reasonable characterization? If yes, give an example. If no, why not? 1.21 [7] Say you go to the store and buy some word processing software. What form is the software actually in? Is it in a high-level programming language? Is it in assembly language? Is it in the ISA of the computer on which you'll run it? Justify your answer. 1.22 [5] Suppose you were given a task at one of the transformation levels shown in Figure 1.6, and required to tranform it to the level just below. At which level would it be most difficult to perform the transformation to the next lower level? Why? 1.23 [5] Why is an ISA unlikely to change between successive generations of microarchitectures that implement it? For example, why would Intel want to make certain that the ISA implemented by the Pentium III is the same as the one implemented by the Pentium II? Hint: When you upgrade your computer (or buy one with a newer CPU), do you need to throw out all your old software? ../art/ch03/,../art/designelements/,../art/designelements/UnNumberedArt/makechapterhead#1 @ (0,0) (432,-577) < g r a p h i c s > (428,-577)1@9.52667in(381.5,-181) < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > 1212chapter 1212chapter 7212 3032#1 36.4pc4@ CHAPTER: DIGITAL LOGIC STRUCTURES In Chapter 1, we stated that computers were built from very large numbers of very simple structures. For example, Intel's Broadwell-E5 microprocessor, introduced in 2016, contained more than 7 billion transistors. Similarly, IBM's Power9",
    "114": "same as the one implemented by the Pentium II? Hint: When you upgrade your computer (or buy one with a newer CPU), do you need to throw out all your old software? ../art/ch03/,../art/designelements/,../art/designelements/UnNumberedArt/makechapterhead#1 @ (0,0) (432,-577) < g r a p h i c s > (428,-577)1@9.52667in(381.5,-181) < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > 1212chapter 1212chapter 7212 3032#1 36.4pc4@ CHAPTER: DIGITAL LOGIC STRUCTURES In Chapter 1, we stated that computers were built from very large numbers of very simple structures. For example, Intel's Broadwell-E5 microprocessor, introduced in 2016, contained more than 7 billion transistors. Similarly, IBM's Power9 microprocessor, introduced in 2017 contained 8 billion transistors. In this chapter, we will explain how the MOS transistor works (as a logic element), show how these transistors are connected to form logic gates, and then show how logic gates are interconnected to form larger units that are needed to construct a computer. In Chapter 4, we will connect those larger units and form a computer. But first, the transistor. § THE TRANSISTOR Most computers today, or rather most microprocessors (which form the core of the computer) are constructed out of MOS transistors. MOS stands for metal-oxide semiconductor. The electrical properties of Metal Oxide SemiconductorMOS metal-oxide semiconductors are well beyond the scope of what we want to understand in this course. They are below our lowest level of abstraction, which means that if somehow transistors start misbehaving, we are at their mercy. However, it is unlikely in this course that we will have any problems from the transistors. Still, it is useful to know that there are two types of MOS transistors: P-type and N-type. They both operate “logically,” very similar to the way wall switches work. Figure <ref> shows the most basic of electrical circuits. It consists of (1) a",
    "115": "units and form a computer. But first, the transistor. § THE TRANSISTOR Most computers today, or rather most microprocessors (which form the core of the computer) are constructed out of MOS transistors. MOS stands for metal-oxide semiconductor. The electrical properties of Metal Oxide SemiconductorMOS metal-oxide semiconductors are well beyond the scope of what we want to understand in this course. They are below our lowest level of abstraction, which means that if somehow transistors start misbehaving, we are at their mercy. However, it is unlikely in this course that we will have any problems from the transistors. Still, it is useful to know that there are two types of MOS transistors: P-type and N-type. They both operate “logically,” very similar to the way wall switches work. Figure <ref> shows the most basic of electrical circuits. It consists of (1) a power supply (in this case, the 120 volts that come into your house if you live in the United States, or the 220 volts if you live in most of the rest of the world), (2) a wall switch, and (3) a lamp (plugged into an outlet in the wall). In order for the lamp to glow, electrons must flow; in order for electrons to flow, there must be a closed circuit from the power supply to the lamp and back to the power supply. The lamp can be turned on and off by simply manipulating the wall switch to make or break the closed circuit. < g r a p h i c s > A simple electric circuit showing the use of a wall switch Instead of the wall switch, we could use an N-type or a P-type MOS transistor to make or break the closed circuit. Figure 3.2 shows a schematic rendering of an N-type transistor (a) by itself, and (b) in a circuit. Note (Figure 3.2a) that the transistor has three terminals. They are called the gate, the source, and the drain. The reasons for the names source and drain are not of interest to us",
    "116": "in order for electrons to flow, there must be a closed circuit from the power supply to the lamp and back to the power supply. The lamp can be turned on and off by simply manipulating the wall switch to make or break the closed circuit. < g r a p h i c s > A simple electric circuit showing the use of a wall switch Instead of the wall switch, we could use an N-type or a P-type MOS transistor to make or break the closed circuit. Figure 3.2 shows a schematic rendering of an N-type transistor (a) by itself, and (b) in a circuit. Note (Figure 3.2a) that the transistor has three terminals. They are called the gate, the source, and the drain. The reasons for the names source and drain are not of interest to us in this course. What is of interest is the fact that if the gate of the N-type transistor is supplied with 1.2 volts, the connection from source to drain acts like a piece of wire. We say (in the language of electricity) that we have a short circuit short circuit between the source and drain. If the gate of the N-type transistor is supplied with 0 volts, the connection between the source and drain is broken. We say that between the source and drain we have an open circuit. open circuit < g r a p h i c s > The N-type MOS transistor Figure <ref> shows the N-type transistor in N-type transistor a circuit with a battery and a bulb. When the gate is supplied with 1.2 volts, the transistor acts like a piece of wire, completing the circuit and causing the bulb to glow. When the gate is supplied with 0 volts, the transistor acts like an open circuit, breaking the circuit, and causing the bulb to not glow. Figure 3.2c is a shorthand notation for describing the circuit of Figure 3.2b. Rather than always showing the power supply and the complete circuit, electrical engineers usually show",
    "117": "N-type transistor is supplied with 0 volts, the connection between the source and drain is broken. We say that between the source and drain we have an open circuit. open circuit < g r a p h i c s > The N-type MOS transistor Figure <ref> shows the N-type transistor in N-type transistor a circuit with a battery and a bulb. When the gate is supplied with 1.2 volts, the transistor acts like a piece of wire, completing the circuit and causing the bulb to glow. When the gate is supplied with 0 volts, the transistor acts like an open circuit, breaking the circuit, and causing the bulb to not glow. Figure 3.2c is a shorthand notation for describing the circuit of Figure 3.2b. Rather than always showing the power supply and the complete circuit, electrical engineers usually show only the terminals of the power supply. The fact that the power supply itself provides the completion of the completed circuit is well understood, and so is not usually shown. The P-type transistor works in exactly the opposite fashion from the N-typeP-type transistor transistor. Figure 3.3 shows the schematic representation of a P-type transistor. When the gate is supplied with 0 volts, the P-type transistor acts (more or less) like a piece of wire, closing the circuit. When the gate is supplied with 1.2 volts, the P-type transistor acts like an open circuit. Because the P-type and N-type transistors act in this complementary way, we refer to circuits that contain both P-type and N-type transistors as CMOS circuits, for complementary metal-oxide semiconductor. CMOSComplementary Metal-Oxide Semiconductor < g r a p h i c s > A P-type MOS transistor § LOGIC GATES One step up from the transistor is the logic gate. That is, we construct basic logic structures out of individual MOS transistors. In Chapter 2, we studied the behavior of the AND, the OR, and the NOT functions. In this chapter we construct transistor circuits that implement each of these functions. The corresponding circuits are called AND, OR,",
    "118": "0 volts, the P-type transistor acts (more or less) like a piece of wire, closing the circuit. When the gate is supplied with 1.2 volts, the P-type transistor acts like an open circuit. Because the P-type and N-type transistors act in this complementary way, we refer to circuits that contain both P-type and N-type transistors as CMOS circuits, for complementary metal-oxide semiconductor. CMOSComplementary Metal-Oxide Semiconductor < g r a p h i c s > A P-type MOS transistor § LOGIC GATES One step up from the transistor is the logic gate. That is, we construct basic logic structures out of individual MOS transistors. In Chapter 2, we studied the behavior of the AND, the OR, and the NOT functions. In this chapter we construct transistor circuits that implement each of these functions. The corresponding circuits are called AND, OR, and NOT gates. §.§ The NOT Gate (Inverter) inverterNOT gate Figure 3.4 shows the simplest logic structure that exists in a computer. It is constructed from two MOS transistors, one P-type and one N-type. Figure 3.4a is the schematic representation of that circuit. Figure 3.4b shows the behavior of the circuit if the input is supplied with 0 volts. Note that the P-type transistor acts like a short circuit and the N-type transistor acts like an open circuit. The output is, therefore, connected to 1.2 volts. On the other hand, if the input is supplied with 1.2 volts, the P-type transistor acts like an open circuit, but the N-type transistor acts like a short circuit. The output in this case is connected to ground (i.e., 0 volts). The complete behavior of the circuit can be described by means of a table, as shown in Figure 3.4c. If we replace 0 volts by the symbol 0 and 1.2 volts by the symbol 1, we have the truth table (Figure 3.4d) for the complement or NOT function, which we studied in Chapter 2. < g r a p h i c s > A CMOS inverter In other words, we have just",
    "119": "that the P-type transistor acts like a short circuit and the N-type transistor acts like an open circuit. The output is, therefore, connected to 1.2 volts. On the other hand, if the input is supplied with 1.2 volts, the P-type transistor acts like an open circuit, but the N-type transistor acts like a short circuit. The output in this case is connected to ground (i.e., 0 volts). The complete behavior of the circuit can be described by means of a table, as shown in Figure 3.4c. If we replace 0 volts by the symbol 0 and 1.2 volts by the symbol 1, we have the truth table (Figure 3.4d) for the complement or NOT function, which we studied in Chapter 2. < g r a p h i c s > A CMOS inverter In other words, we have just shown how to construct an electronic circuit that implements the NOT logic function discussed in Chapter 2. We call this circuit a NOT gate, or an inverter. §.§ OR and NOR Gates Figure 3.5 illustrates a NOR gate. Figure 3.5a is a schematic of a circuit that implements a NOR gate. It contains two P-type and two N-type transistors. < g r a p h i c s > The NOR gate Figure 3.5b shows the behavior of the circuit if A is supplied with 0 volts and B is supplied with 1.2 volts. In this case, the lower of the two P-type transistors produces an open circuit, and the output C is disconnected from the 1.2-volt power supply. However, the leftmost N-type transistor acts like a piece of wire, connecting the output C to 0 volts. Note that if both A and B are supplied with 0 volts, the two P-type transistors conduct, and the output C is connected to 1.2 volts. Note further that there is no ambiguity here, since both N-type transistors act as open circuits, and so C is disconnected from ground. If either A or B is supplied with 1.2 volts, the corresponding P-type transistor",
    "120": "g r a p h i c s > The NOR gate Figure 3.5b shows the behavior of the circuit if A is supplied with 0 volts and B is supplied with 1.2 volts. In this case, the lower of the two P-type transistors produces an open circuit, and the output C is disconnected from the 1.2-volt power supply. However, the leftmost N-type transistor acts like a piece of wire, connecting the output C to 0 volts. Note that if both A and B are supplied with 0 volts, the two P-type transistors conduct, and the output C is connected to 1.2 volts. Note further that there is no ambiguity here, since both N-type transistors act as open circuits, and so C is disconnected from ground. If either A or B is supplied with 1.2 volts, the corresponding P-type transistor results in an open circuit. That is sufficient to break the connection from C to the 1.2-volt source. However, 1.2 volts supplied to the gate of one of the N-type transistors is sufficient to cause that transistor to conduct, resulting in C being connected to ground (i.e., 0 volts). Figure 3.5c summarizes the complete behavior of the circuit of Figure 3.5a. It shows the behavior of the circuit for each of the four pairs of voltages that can be supplied to A and B. That is, A = 0 volts, B = 0 volts A = 0 volts, B = 1.2 volts A = 1.2 volts, B = 0 volts A = 1.2 volts, B = 1.2 volts If we replace the voltages with their logical equivalents, we have the truth table of Figure 3.5d. Note that the output C is exactly the opposite of the logical OR function that we studied in Chapter 2. In fact, it is the NOT-OR function, more typically abbreviated as NOR. We refer to the circuit that implements the NOR function as a NOR gate. NOR gate If we augment the circuit of Figure 3.5a by adding an inverter at its output, as shown",
    "121": "3.5a. It shows the behavior of the circuit for each of the four pairs of voltages that can be supplied to A and B. That is, A = 0 volts, B = 0 volts A = 0 volts, B = 1.2 volts A = 1.2 volts, B = 0 volts A = 1.2 volts, B = 1.2 volts If we replace the voltages with their logical equivalents, we have the truth table of Figure 3.5d. Note that the output C is exactly the opposite of the logical OR function that we studied in Chapter 2. In fact, it is the NOT-OR function, more typically abbreviated as NOR. We refer to the circuit that implements the NOR function as a NOR gate. NOR gate If we augment the circuit of Figure 3.5a by adding an inverter at its output, as shown in Figure 3.6a, we have at the output D the logical function OR. Figure 3.6a is the circuit for an OR gate. Figure 3.6b describes the behavior of this circuit if the input variable A is set to 0 and the input variable B is set to 1. Figure 3.6c shows the circuit's truth table. OR gate 36pc < g r a p h i c s > The OR gate §.§ Why we can't simply connect P-type to ground Some bright students have looked at our implementation of the OR gate (a NOR-gate followed by an inverter) and asked the question, why can't we simply connect the transistors as shown in Figure <ref>a. Logically, it looks very tempting. Four transistors instead of six. Unfortunately, the electrical properties of transistors makes this problematic. When we connect a P-type transistor to 1.2 volts or an N-type transistor to ground, there is no voltage across the transistor, resulting in outputs as shown in Figure <ref>, for example, of 0 volts or 1.2 volts, depending on the input voltages to A and B. However, when we connect a P-type transistor to ground or an N-type transistor to 1.2 volts, because of the electrical",
    "122": "r a p h i c s > The OR gate §.§ Why we can't simply connect P-type to ground Some bright students have looked at our implementation of the OR gate (a NOR-gate followed by an inverter) and asked the question, why can't we simply connect the transistors as shown in Figure <ref>a. Logically, it looks very tempting. Four transistors instead of six. Unfortunately, the electrical properties of transistors makes this problematic. When we connect a P-type transistor to 1.2 volts or an N-type transistor to ground, there is no voltage across the transistor, resulting in outputs as shown in Figure <ref>, for example, of 0 volts or 1.2 volts, depending on the input voltages to A and B. However, when we connect a P-type transistor to ground or an N-type transistor to 1.2 volts, because of the electrical requirements of the transisors, we get what is usually referred to as a transmission voltage of approximately 0.5 volts across the transistor. This results in the output of the transistor circuit of Figure <ref> being 0.5 volts + 0.5 volts, or 1.0 volt if A and B are both 0, and 0.7 volts (1.2 volts minus 0.5 volts) otherwise. Figure <ref>b shows the actual voltages in the resulting truth table, rather than 0s and 1s. That is, even though the transistor circuit looks like it would work, the transmission voltages across the transistors would yield an output voltage of 1 volt for a logical 0 and 0.7 volts for a logical 1. Not what we would like for an OR gate! < g r a p h i c s > An OR gate (not really!) §.§ AND and NAND Gates Figure <ref> shows an AND gate. Note that if either A or B is supplied with 0 volts, there is a direct connection from C to the 1.2-volt power supply. The fact that C is at 1.2 volts means the N-type transistor whose gate is connected to C provides a path from D to ground. Therefore, if either A",
    "123": "<ref>b shows the actual voltages in the resulting truth table, rather than 0s and 1s. That is, even though the transistor circuit looks like it would work, the transmission voltages across the transistors would yield an output voltage of 1 volt for a logical 0 and 0.7 volts for a logical 1. Not what we would like for an OR gate! < g r a p h i c s > An OR gate (not really!) §.§ AND and NAND Gates Figure <ref> shows an AND gate. Note that if either A or B is supplied with 0 volts, there is a direct connection from C to the 1.2-volt power supply. The fact that C is at 1.2 volts means the N-type transistor whose gate is connected to C provides a path from D to ground. Therefore, if either A or B is supplied with 0 volts, the output D of the circuit of Figure <ref> is 0 volts. < g r a p h i c s > The AND gate -2 Again, we note that there is no ambiguity. The fact that at least one of the two inputs A or B is supplied with 0 volts means that at least one of the two N-type transistors whose gates are connected to A or B is open, and that consequently, C is disconnected from ground. Furthermore, the fact that C is at 1.2 volts means the P-type transistor whose gate is connected to C is open-circuited. Therefore, D is not connected to 1.2 volts. On the other hand, if both A and B are supplied with 1.2 volts, then both of their corresponding P-type transistors are open. However, their corresponding N-type transistors act like pieces of wire, providing a direct connection from C to ground. Because C is at ground, the rightmost P-type transistor acts like a closed circuit, forcing D to 1.2 volts. Figure <ref>b is a truth table that summarizes the behavior of the circuit of Figure <ref>a. Note that the circuit is an AND gate.",
    "124": "that at least one of the two N-type transistors whose gates are connected to A or B is open, and that consequently, C is disconnected from ground. Furthermore, the fact that C is at 1.2 volts means the P-type transistor whose gate is connected to C is open-circuited. Therefore, D is not connected to 1.2 volts. On the other hand, if both A and B are supplied with 1.2 volts, then both of their corresponding P-type transistors are open. However, their corresponding N-type transistors act like pieces of wire, providing a direct connection from C to ground. Because C is at ground, the rightmost P-type transistor acts like a closed circuit, forcing D to 1.2 volts. Figure <ref>b is a truth table that summarizes the behavior of the circuit of Figure <ref>a. Note that the circuit is an AND gate. The circuit shown within the dashed lines (i.e., having output C) is a NOT-AND gate, which we generally abbreviate as NAND. NAND gate-2 The gates just discussed are very common in digital logic circuits and in digital computers. There are billions of inverters (NOT gates) in Intel's Skylake microprocessor. As a convenience, we can represent each of these gates by standard symbols, as shown in Figure <ref>. The bubble shown in the inverter, NAND, and NOR gates signifies the complement (i.e., NOT) function. AND gate From now on, we will not draw circuits showing the individual transistors. Instead, we will raise our level of abstraction and use the symbols shown in Figure <ref>. < g r a p h i c s > Basic logic gates §.§ Gates with more than two inputs Before we leave the topic of logic gates, we should note that the notion of AND, OR, NAND, and NOR gates extends to larger numbers of inputs. One could build a three-input AND gate or a four-input OR gate, for example. An n-input AND gate has an output value of 1 only if ALL n input variables have values of 1. If any of the n inputs",
    "125": "standard symbols, as shown in Figure <ref>. The bubble shown in the inverter, NAND, and NOR gates signifies the complement (i.e., NOT) function. AND gate From now on, we will not draw circuits showing the individual transistors. Instead, we will raise our level of abstraction and use the symbols shown in Figure <ref>. < g r a p h i c s > Basic logic gates §.§ Gates with more than two inputs Before we leave the topic of logic gates, we should note that the notion of AND, OR, NAND, and NOR gates extends to larger numbers of inputs. One could build a three-input AND gate or a four-input OR gate, for example. An n-input AND gate has an output value of 1 only if ALL n input variables have values of 1. If any of the n inputs has a value of 0, the output of the n-input AND gate is 0. An n-input OR gate has an output value of 1 if ANY of the n input variables has a value of 1. That is, an n-input OR gate has an output value of 0 only if ALL n input variables have values of 0. Figure <ref> illustrates a three-input AND gate. Figure 3.10a shows its truth table. Figure 3.10b shows the symbol for a three-input AND gate. < g r a p h i c s > A three-input AND gate Question: Can you draw a transistor-level circuit for a three-input AND gate? How about a four-input AND gate? How about a four-input OR gate? § COMBINATIONAL LOGIC CIRCUITS Now that we understand the workings of the basic logic gates, the next step is to build some of the logic structures that are important components of the microarchitecture of a computer. There are fundamentally two kinds of logic structures, those that include the storage of information and those that do not. In Sections 3.4, 3.5, and 3.6, we will deal with structures that store information. In this section, we will deal with structures that do not",
    "126": "illustrates a three-input AND gate. Figure 3.10a shows its truth table. Figure 3.10b shows the symbol for a three-input AND gate. < g r a p h i c s > A three-input AND gate Question: Can you draw a transistor-level circuit for a three-input AND gate? How about a four-input AND gate? How about a four-input OR gate? § COMBINATIONAL LOGIC CIRCUITS Now that we understand the workings of the basic logic gates, the next step is to build some of the logic structures that are important components of the microarchitecture of a computer. There are fundamentally two kinds of logic structures, those that include the storage of information and those that do not. In Sections 3.4, 3.5, and 3.6, we will deal with structures that store information. In this section, we will deal with structures that do not store information. These structures are sometimes referred to as decision elements. Usually, they are referred to as combinational logic structures, because their outputs are strictly dependent on the combination of input values that are being applied to the structure right now. Their outputs are not at all dependent on any past history of information that is stored internally, since no information can be stored internally in a combinational logic circuit. combinational logic We will next examine three useful combinational logic circuits: a decoder, a mux, and a one-bit adder. §.§ Decoder =1 Figure 3.11 shows a logic gate implementation of a two-input decoder. A decoder has the property that exactly one of its outputs is 1 and all the rest are 0s. The one output that is logically 1 is the output corresponding to the input pattern that it is expected to detect. In general, decoders have n inputs and 2^n outputs. We say the output line that detects the input pattern is asserted. That is, that output asserted line has the value 1, rather than 0 as is the case for all the other output lines. In Figure 3.11, note that for each of the four possible combinations of",
    "127": "information can be stored internally in a combinational logic circuit. combinational logic We will next examine three useful combinational logic circuits: a decoder, a mux, and a one-bit adder. §.§ Decoder =1 Figure 3.11 shows a logic gate implementation of a two-input decoder. A decoder has the property that exactly one of its outputs is 1 and all the rest are 0s. The one output that is logically 1 is the output corresponding to the input pattern that it is expected to detect. In general, decoders have n inputs and 2^n outputs. We say the output line that detects the input pattern is asserted. That is, that output asserted line has the value 1, rather than 0 as is the case for all the other output lines. In Figure 3.11, note that for each of the four possible combinations of inputs A and B, exactly one output has the value 1 at any one time. In Figure 3.11b, the input to the decoder is 10, resulting in the third output line being asserted.decoder < g r a p h i c s > A two-input decoder The decoder is useful in determining how to interpret a bit pattern. We will see in Chapter 5 that the work to be carried out by each instruction in the LC-3 computer is determined by a four-bit pattern that is the part of the instruction called the opcode, A 4-to-16 decoder is a simple combinational logic structure for identifying what work is to be performed by each instruction. §.§ Mux Figure 3.12a shows a logic gate implementation of a two-input multiplexer, more commonly referred to as a mux. The function of a mux is to select one of the inputs (A or B) and connect it to the output. The select signal (S in Figure 3.12) determines which input is connected to the output. MUXmultiplexer The mux of Figure 3.12 works as follows: Suppose S=0, as shown in Figure 3.12b. Since the output of an AND gate is 0 unless all inputs are 1,",
    "128": "see in Chapter 5 that the work to be carried out by each instruction in the LC-3 computer is determined by a four-bit pattern that is the part of the instruction called the opcode, A 4-to-16 decoder is a simple combinational logic structure for identifying what work is to be performed by each instruction. §.§ Mux Figure 3.12a shows a logic gate implementation of a two-input multiplexer, more commonly referred to as a mux. The function of a mux is to select one of the inputs (A or B) and connect it to the output. The select signal (S in Figure 3.12) determines which input is connected to the output. MUXmultiplexer The mux of Figure 3.12 works as follows: Suppose S=0, as shown in Figure 3.12b. Since the output of an AND gate is 0 unless all inputs are 1, the output of the rightmost AND gate is 0. Also, the output of the leftmost AND gate is whatever the input A is. That is, if A=0, then the output of the leftmost AND gate is 0, and if A=1, then the output of the leftmost AND gate is 1. Since the output of the rightmost AND gate is 0, it has no effect on the OR gate. Consequently, the output at C is exactly the same as the output of the leftmost AND gate. The net result of all this is that if S=0, the output C is identical to the input A. < g r a p h i c s > A 2-to-1 mux On the other hand, if S=1, it is B that is ANDed with 1, resulting in the output of the OR gate having the value of B. In summary, the output C is always connected to either the input A or the input B—which one depends on the value of the select line S. We say S selects the source of the mux (either A or B) to be routed through to the output C. Figure 3.12c shows the standard representation for a",
    "129": "it has no effect on the OR gate. Consequently, the output at C is exactly the same as the output of the leftmost AND gate. The net result of all this is that if S=0, the output C is identical to the input A. < g r a p h i c s > A 2-to-1 mux On the other hand, if S=1, it is B that is ANDed with 1, resulting in the output of the OR gate having the value of B. In summary, the output C is always connected to either the input A or the input B—which one depends on the value of the select line S. We say S selects the source of the mux (either A or B) to be routed through to the output C. Figure 3.12c shows the standard representation for a mux. In general, a mux consists of 2^n inputs and n select lines. Figure 3.13a shows a gate-level description of a four-input mux. It requires two select lines. Figure 3.13b shows the standard representation for a four-input mux. < g r a p h i c s > A four-input mux Question: Can you construct the gate-level representation for an eight-input mux? How many select lines must you have? §.§ A One-bit Adder (aka a Full Adder) Recall in Chapter 2, we discussed binary addition. A simple algorithm for binary addition is to proceed as you have always done in the case of decimal addition, from right to left, one column at a time, adding the two digits from the two values plus the carry in, and generating a sum digit and a carry to the next column. The only difference here (with binary addition) is you get a carry after 1, rather than after 9. Figure <ref> is a truth table that describes the result of binary addition on one column of bits within two n-bit operands. At each column, there are three values that must be added: one bit from each of the two operands A and B",
    "130": "eight-input mux? How many select lines must you have? §.§ A One-bit Adder (aka a Full Adder) Recall in Chapter 2, we discussed binary addition. A simple algorithm for binary addition is to proceed as you have always done in the case of decimal addition, from right to left, one column at a time, adding the two digits from the two values plus the carry in, and generating a sum digit and a carry to the next column. The only difference here (with binary addition) is you get a carry after 1, rather than after 9. Figure <ref> is a truth table that describes the result of binary addition on one column of bits within two n-bit operands. At each column, there are three values that must be added: one bit from each of the two operands A and B and the carry from the previous column. We designate these three bits as A_i, B_i, and C_i. There are two results, the sum bit (S_i) and the carry over to the next column, C_i+1. Note that if only one of the three bits equals 1, we get a sum of 1, and no carry (i.e., C_i+1 = 0). If two of the three bits equal 1, we get a sum of 0, and a carry of 1. If all three bits equal 1, the sum is 3, which in binary corresponds to a sum of 1 and a carry of 1. < g r a p h i c s > The truth table for a one-bit adder Figure <ref> shows a logic gate implementation of a one-bit adder. Note that each AND gate in Figure 3.15 produces an output 1 for exactly one of the eight input combinations of A_i, B_i, and C_i. The output of the OR gate for C_i+1 must be 1 in exactly those cases where the corresponding input combinations in Figure <ref> produce an output 1. Therefore the inputs to the OR gate that generates C_i+1 are the outputs of the AND gates corresponding to",
    "131": "of the three bits equal 1, we get a sum of 0, and a carry of 1. If all three bits equal 1, the sum is 3, which in binary corresponds to a sum of 1 and a carry of 1. < g r a p h i c s > The truth table for a one-bit adder Figure <ref> shows a logic gate implementation of a one-bit adder. Note that each AND gate in Figure 3.15 produces an output 1 for exactly one of the eight input combinations of A_i, B_i, and C_i. The output of the OR gate for C_i+1 must be 1 in exactly those cases where the corresponding input combinations in Figure <ref> produce an output 1. Therefore the inputs to the OR gate that generates C_i+1 are the outputs of the AND gates corresponding to those input combinations. Similarly, the inputs to the OR gate that generates S_i are the outputs of the AND gates corresponding to the input combinations that require an output 1 for S_i in the truth table of Figure <ref>. -1 < g r a p h i c s > Gate-level description of a one-bit adder Note that since the input combination 000 does not result in an output 1 for either C_i+1 or S_i, its corresponding AND gate is not an input to either of the two OR gates. Figure <ref> shows a circuit for adding two 4-bit binary numbers, using four of the one-bit adder circuits of Figure 3.15. Note that the carry out of column i is an input to the addition performed in column i+1. < g r a p h i c s > A circuit for adding two 4-bit binary numbers If we wish to implement a logic circuit that adds two 16-bit numbers, we could do so with a circuit of 16 one-bit adders. We should point out that historically the logic circuit of Figure <ref> that provides three inputs (A_i, B_i, and C_i) and two outputs (the sum bit S_i and the",
    "132": "input combination 000 does not result in an output 1 for either C_i+1 or S_i, its corresponding AND gate is not an input to either of the two OR gates. Figure <ref> shows a circuit for adding two 4-bit binary numbers, using four of the one-bit adder circuits of Figure 3.15. Note that the carry out of column i is an input to the addition performed in column i+1. < g r a p h i c s > A circuit for adding two 4-bit binary numbers If we wish to implement a logic circuit that adds two 16-bit numbers, we could do so with a circuit of 16 one-bit adders. We should point out that historically the logic circuit of Figure <ref> that provides three inputs (A_i, B_i, and C_i) and two outputs (the sum bit S_i and the carry over to the next column C_i+1) has generally been referred to as a full adderfull adder to differentiate it from another structure which is called a half adder. The distinction between the two is the carry bit. Note that the carry into the right-most column in Figure <ref> is 0. That is, in the right-most circuit, S_0 and C_1 depend only on two inputs, A_0 and B_0. Since that circuit depends on only two inputs, it has been referred to as a half adder. Since the other circuits depend on all three inputs, they are referred to as full adders. We prefer the term one-bit adder as a simpler term for describing what is happening in each column. §.§ The Programmable Logic Array (PLA) =1 Figure <ref> illustrates a very common building block for implementing any collection of logic functions one wishes to implement. The building block is called a programmable logic array (PLA). It consists of an array of AND gates (called an AND array) followed by an array of OR gates (called an OR array). The number of AND gates corresponds to the number of input combinations (rows) in the truth table. For n-input logic functions, we",
    "133": "depend only on two inputs, A_0 and B_0. Since that circuit depends on only two inputs, it has been referred to as a half adder. Since the other circuits depend on all three inputs, they are referred to as full adders. We prefer the term one-bit adder as a simpler term for describing what is happening in each column. §.§ The Programmable Logic Array (PLA) =1 Figure <ref> illustrates a very common building block for implementing any collection of logic functions one wishes to implement. The building block is called a programmable logic array (PLA). It consists of an array of AND gates (called an AND array) followed by an array of OR gates (called an OR array). The number of AND gates corresponds to the number of input combinations (rows) in the truth table. For n-input logic functions, we need a PLA with 2^nn-input AND gates. In Figure <ref>, we have 2^3 3-input AND gates, corresponding to three logical input variables. The number of OR gates corresponds to the number of logic functions we wish to implement, i.e., the number of output columns in the truth table. The implementation algorithm is simply to connect the output of an AND gate to the input of an OR gate if the corresponding row of the truth table produces an output 1 for that output column. Hence the notion of programmable. That is, we say we program the connections from AND gate outputs to OR gate inputs to implement our desired logic functions. < g r a p h i c s > A programmable logic array Figure <ref> shows seven AND gates connected to two OR gates since our requirement was to implement two functions (sum and carry) of three input variables. Figure <ref> shows a PLA that can implement any four functions of three variables by appropriately connecting AND gate outputs to OR gate inputs. That is, any function of three variables can be implemented by connecting the outputs of all AND gates corresponding to input combinations for which the",
    "134": "gate to the input of an OR gate if the corresponding row of the truth table produces an output 1 for that output column. Hence the notion of programmable. That is, we say we program the connections from AND gate outputs to OR gate inputs to implement our desired logic functions. < g r a p h i c s > A programmable logic array Figure <ref> shows seven AND gates connected to two OR gates since our requirement was to implement two functions (sum and carry) of three input variables. Figure <ref> shows a PLA that can implement any four functions of three variables by appropriately connecting AND gate outputs to OR gate inputs. That is, any function of three variables can be implemented by connecting the outputs of all AND gates corresponding to input combinations for which the output is 1 to inputs of one of the OR gates. Thus, we could implement the one-bit adder by programming the two OR gates in Figure <ref> whose outputs are W and X by connecting or not connecting the outputs of the AND gates to the inputs of those two Or gates as specified by the two output columns of Figure <ref>. §.§ Logical Completeness Before we leave the topic of combinational logic circuits, it is worth noting an important property of building blocks for logic circuits: logical completeness. We showed in Section 3.3.4 that any logic function we wished to implement could be accomplished with a PLA. We saw that the PLA consists of only AND gates, OR gates, and inverters. That means that any logic function can be implemented, provided that enough AND, OR, and NOT gates are available. We say that the set of gates {AND, OR, NOT} is logically completelogical completeness because we can build a circuit to carry out the specification of any truth table we wish without using any other kind of gate. That is, the set of gates {AND, OR, and NOT} is logically complete because a barrel of AND gates, a barrel",
    "135": "Figure <ref>. §.§ Logical Completeness Before we leave the topic of combinational logic circuits, it is worth noting an important property of building blocks for logic circuits: logical completeness. We showed in Section 3.3.4 that any logic function we wished to implement could be accomplished with a PLA. We saw that the PLA consists of only AND gates, OR gates, and inverters. That means that any logic function can be implemented, provided that enough AND, OR, and NOT gates are available. We say that the set of gates {AND, OR, NOT} is logically completelogical completeness because we can build a circuit to carry out the specification of any truth table we wish without using any other kind of gate. That is, the set of gates {AND, OR, and NOT} is logically complete because a barrel of AND gates, a barrel of OR gates, and a barrel of NOT gates are sufficient to build a logic circuit that carries out the specification of any desired truth table. The barrels may have to be big, but the point is, we do not need any other kind of gate to do the job. Question: Is there any single two-input logic gate that is logically complete? For example, is the NAND gate logically complete? Hint: Can I implement a NOT gate with a NAND gate? If yes, can I then implement an AND gate using a NAND gate followed by a NOT gate? If yes, can I implement an OR gate using just AND gates and NOT gates? If all of the above is true, then the NAND gate is logically complete, and I can implement any desired logic function as described by its truth table with a barrel of NAND gates. § BASIC STORAGE ELEMENTS Recall our statement at the beginning of Section 3.3 that there are two kinds of logic structures, those that involve the storage of information and those that do not. We have discussed three examples of those that do not: the decoder, the mux, and the full adder. Now",
    "136": "logically complete? For example, is the NAND gate logically complete? Hint: Can I implement a NOT gate with a NAND gate? If yes, can I then implement an AND gate using a NAND gate followed by a NOT gate? If yes, can I implement an OR gate using just AND gates and NOT gates? If all of the above is true, then the NAND gate is logically complete, and I can implement any desired logic function as described by its truth table with a barrel of NAND gates. § BASIC STORAGE ELEMENTS Recall our statement at the beginning of Section 3.3 that there are two kinds of logic structures, those that involve the storage of information and those that do not. We have discussed three examples of those that do not: the decoder, the mux, and the full adder. Now we are ready to discuss logic structures that do include the storage of information. §.§ The R-S Latch A simple example of a storage element is the R-S latch. It can store one bit of information, a 0 or a 1. The R-S latch can be implemented in many ways, the simplest being the one shown in Figure <ref>. Two 2-input NAND gates are connected such that the output of each is connected to one of the inputs of the other. The remaining inputs S and R are normally held at a logic level 1. The R-S latch gets its name from the old designations for setting the latch to store a 1 and setting the latch to store a 0. Setting the latch to store a 1 was referred to as setting the latch, and setting the latch to store a 0 was referred to as reseting the latch. Ergo, R-S. < g r a p h i c s > An R-S latch The quiescent state We describe the quiescent (or quiet) state of a latch as the state when the latch is storing a value, either 0 or 1, and nothing is trying to change that value.",
    "137": "2-input NAND gates are connected such that the output of each is connected to one of the inputs of the other. The remaining inputs S and R are normally held at a logic level 1. The R-S latch gets its name from the old designations for setting the latch to store a 1 and setting the latch to store a 0. Setting the latch to store a 1 was referred to as setting the latch, and setting the latch to store a 0 was referred to as reseting the latch. Ergo, R-S. < g r a p h i c s > An R-S latch The quiescent state We describe the quiescent (or quiet) state of a latch as the state when the latch is storing a value, either 0 or 1, and nothing is trying to change that value. This is the case when inputs S and R both have the logic value 1. In Figure <ref> the letter a designates the value that is currently stored in the latch, which we also refer to as the output of the latch. Consider first the case where the value stored and therefore the output a is 1. Since that means the value A is 1 (and since we know the input R is 1 because we are in the quiescent state), the NAND gate's output b must be 0. That, in turn, means B must be 0, which results in the output a equal to 1. As long as the inputs S and R remain 1, the state of the circuit will not change. That is, the R-S latch will continue to store the value 1 (the value of the output a).latch!R-S If, on the other hand, we assume the output a is 0, then A must be 0, and the output b must be 1. That, in turn, results in B equal to 1, and combined with the input S equal to 1 (again due to quiescence), results in the output a equal to 0. Again, as long as",
    "138": "the value A is 1 (and since we know the input R is 1 because we are in the quiescent state), the NAND gate's output b must be 0. That, in turn, means B must be 0, which results in the output a equal to 1. As long as the inputs S and R remain 1, the state of the circuit will not change. That is, the R-S latch will continue to store the value 1 (the value of the output a).latch!R-S If, on the other hand, we assume the output a is 0, then A must be 0, and the output b must be 1. That, in turn, results in B equal to 1, and combined with the input S equal to 1 (again due to quiescence), results in the output a equal to 0. Again, as long as the inputs S and R remain 1, the state of the circuit will not change. In this case, we say the R-S latch stores the value 0. Setting the latch to a 1 or a 0 The latch can be set to 1 by momentarily setting S to 0, provided we [-18pt] keep the value of R at 1. Similarly, the latch can be set to 0 by momentarily setting R to 0, provided we keep the value of S at 1. In order for the R-S latch to work properly, both S and R must never be allowed to be set to 0 at the same time. We use the term set to denote setting a variable to 0 or 1, as setting a bit in “set to 0” or “set to 1.” In addition, we often use the term clear to denote the act of setting a variable to 0. clearing a bit If we set S to 0 for a very brief period of time, this causes a to equal 1, which in turn causes A to equal 1. Since R is also 1, the output at b must be 0. This causes B to be 0,",
    "139": "the latch can be set to 0 by momentarily setting R to 0, provided we keep the value of S at 1. In order for the R-S latch to work properly, both S and R must never be allowed to be set to 0 at the same time. We use the term set to denote setting a variable to 0 or 1, as setting a bit in “set to 0” or “set to 1.” In addition, we often use the term clear to denote the act of setting a variable to 0. clearing a bit If we set S to 0 for a very brief period of time, this causes a to equal 1, which in turn causes A to equal 1. Since R is also 1, the output at b must be 0. This causes B to be 0, which in turn makes a equal to 1. If, after that very brief period of time, we now return S to 1, it does not affect a. Why? Answer: Since B is also 0, and since only one input 0 to a NAND gate is enough to guarantee that the output of the NAND gate is 1, the latch will continue to store a 1 long after S returns to 1. In the same way, we can clear the latch (set the latch to 0) by setting R to 0 for a very short period of time. We should point out that if both S and R were allowed to be set to 0 at the same time, the outputs a and b would both be 1, and the final state of the latch would depend on the electrical properties of the transistors making up the gates and not on the logic being performed. How the electrical properties of the transistors would determine the final state in this case is a subject we will have to leave for a later semester. :-( Finally, we should note that when a digital circuit is powered on, the latch can be in either",
    "140": "continue to store a 1 long after S returns to 1. In the same way, we can clear the latch (set the latch to 0) by setting R to 0 for a very short period of time. We should point out that if both S and R were allowed to be set to 0 at the same time, the outputs a and b would both be 1, and the final state of the latch would depend on the electrical properties of the transistors making up the gates and not on the logic being performed. How the electrical properties of the transistors would determine the final state in this case is a subject we will have to leave for a later semester. :-( Finally, we should note that when a digital circuit is powered on, the latch can be in either of its two states, 0 or 1. It does not matter which state since we never use that information until after we have set it to 1 or 0. §.§ The Gated D Latch To be useful, it is necessary to control when a latch is set and when it is cleared. A simple way to accomplish this is with the gated latch. Figure <ref> shows a logic circuit that implements a gated D latch. It consists of the R-S latch of Figure 3.18, plus two additional NAND gates that allow the latch to be set to the value of D, but only when WE is asserted (i.e., when WE equals 1). WE stands for write enable. When WE is not asserted (i.e., when WE equals 0), the outputs S and R are both equal to 1. Since S and R are inputs to the R-S latch, if they are kept at 1, the value stored in the latch remains unchanged, as we explained in Section 3.4.1. latch!gated D When WE is momentarily set to 1, exactly one of the outputs S or R is set to 0, depending on the value of D. If D equals 1, then S",
    "141": "the gated latch. Figure <ref> shows a logic circuit that implements a gated D latch. It consists of the R-S latch of Figure 3.18, plus two additional NAND gates that allow the latch to be set to the value of D, but only when WE is asserted (i.e., when WE equals 1). WE stands for write enable. When WE is not asserted (i.e., when WE equals 0), the outputs S and R are both equal to 1. Since S and R are inputs to the R-S latch, if they are kept at 1, the value stored in the latch remains unchanged, as we explained in Section 3.4.1. latch!gated D When WE is momentarily set to 1, exactly one of the outputs S or R is set to 0, depending on the value of D. If D equals 1, then S is set to 0. If D equals 0, then both inputs to the lower NAND gate are 1, resulting in R being set to 0. As we saw earlier, if S is set to 0, the R-S latch is set to 1. If R is set to 0, the R-S latch is set to 0. Thus, the R-S latch is set to 1 or 0 according to whether D is 1 or 0. When WE returns to 0, S and R return to 1, and the value stored in the R-S latch persists. < g r a p h i c s > A gated D latch § THE CONCEPT OF MEMORY We now have all the tools we need to describe one of the most important structures in the electronic digital computer, its memory. We will see in Chapter 4 how memory fits into the memory basic scheme of computer processing, and you will see throughout the rest of the book and indeed the rest of your work with computers how important the concept of memory is to computing. Memory is made up of a (usually large) number of locations, each uniquely identifiable and each having the ability to",
    "142": "set to 1 or 0 according to whether D is 1 or 0. When WE returns to 0, S and R return to 1, and the value stored in the R-S latch persists. < g r a p h i c s > A gated D latch § THE CONCEPT OF MEMORY We now have all the tools we need to describe one of the most important structures in the electronic digital computer, its memory. We will see in Chapter 4 how memory fits into the memory basic scheme of computer processing, and you will see throughout the rest of the book and indeed the rest of your work with computers how important the concept of memory is to computing. Memory is made up of a (usually large) number of locations, each uniquely identifiable and each having the ability to store a value. We refer to the unique identifier associated with each memory location as its address. address We refer to the number of bits [-18pt] of information stored in each location as its addressability. addressability For example, an advertisement for a laptop computer might say, “This computer comes with 2 gigabytes of memory.” Actually, most ads generally use the abbreviation 2 GB (or, often: 2 Gig). This statement means, as we will explain momentarily, that the laptop includes 2 billion memory locations, each containing 1 byte of information. §.§ Address Space We refer to the total number of uniquely identifiable locations as the memory's address space. A 2 GB memory, for example, refers address space to a memory that consists of 2 billion uniquely identifiable memory locations. Actually, the number 2 billion is only an approximation, due to the way we specify memory locations. Since everything else in the computer is represented by sequences of 0s and 1s, it should not be surprising that memory locations are identified by binary addresses as well. With n bits of address, we can uniquely identify 2^n locations. Ten bits provide 1,024 locations, which is approximately 1,000. If we have 20 bits to",
    "143": "abbreviation 2 GB (or, often: 2 Gig). This statement means, as we will explain momentarily, that the laptop includes 2 billion memory locations, each containing 1 byte of information. §.§ Address Space We refer to the total number of uniquely identifiable locations as the memory's address space. A 2 GB memory, for example, refers address space to a memory that consists of 2 billion uniquely identifiable memory locations. Actually, the number 2 billion is only an approximation, due to the way we specify memory locations. Since everything else in the computer is represented by sequences of 0s and 1s, it should not be surprising that memory locations are identified by binary addresses as well. With n bits of address, we can uniquely identify 2^n locations. Ten bits provide 1,024 locations, which is approximately 1,000. If we have 20 bits to represent each address, we have 2^20 uniquely identifiable locations, which is approximately 1 million. With 30 bits, we have 2^30 locations, which is approximately 1 billion. In the same way we use the prefix \"kilo\" to represent 2^10 (approximately 1,000, and \"mega\" to represent 2^20 (approximately one million), we use the prefix \"giga\" to represent 2^30 (approximately one billion). Thus 2 giga really corresponds to the number of uniquely identifiable locations that can be specified with 31 address bits. We say the address space is 2^31, which is exactly 2,147,483,648 locations, rather than 2,000,000,000, although we colloquially refer to it as 2 billion. §.§ Addressability =-1 The number of bits stored in each memory location is the memory's addressability. A 2 gigabyte memory (written 2GB) is a memory consisting of 2,147,483,648 memory locations, each containing 1 byte (i.e., 8 bits) of storage. Most memories are byte-addressable. The reason is historical; most computers got their start processing data, and one character stroke on the keyboard corresponds to one 8-bit ASCII code, as we learned in Chapter 2. If the memory is byte-addressable, then each ASCII character occupies one location in memory. Uniquely identifying each byte of memory allows individual bytes of",
    "144": "2 giga really corresponds to the number of uniquely identifiable locations that can be specified with 31 address bits. We say the address space is 2^31, which is exactly 2,147,483,648 locations, rather than 2,000,000,000, although we colloquially refer to it as 2 billion. §.§ Addressability =-1 The number of bits stored in each memory location is the memory's addressability. A 2 gigabyte memory (written 2GB) is a memory consisting of 2,147,483,648 memory locations, each containing 1 byte (i.e., 8 bits) of storage. Most memories are byte-addressable. The reason is historical; most computers got their start processing data, and one character stroke on the keyboard corresponds to one 8-bit ASCII code, as we learned in Chapter 2. If the memory is byte-addressable, then each ASCII character occupies one location in memory. Uniquely identifying each byte of memory allows individual bytes of stored information to be changed easily. Many computers that have been designed specifically to perform large scientific calculations are 64-bit addressable. This is due to the fact that numbers used in scientific calculations are often represented as 64-bit floating point quantities. Recall that we discussed the floating point data type in Chapter 2. Since scientific calculations are likely to use numbers that require 64 bits to represent them, it is reasonable to design a memory for such a computer that stores one such number in each uniquely identifiable memory location. §.§ A 2^2-by-3-Bit Memory < g r a p h i c s > A 2^ 2-by-3-bit memory Figure <ref> illustrates a memory of size 2^2 by 3 bits. That is, the memory has an address space of four locations, and an addressability of 3 bits. A memory of size 2^2 requires 2 bits to specify the address. We describe the 2-bit address as A[1:0]. A memory of addressability 3 stores 3 bits of information in each memory location. We describe the 3 bits of data as D[2:0]. In both cases, our notation A[high:low] and D[high:low] reflects the fact that we have numbered the bits of address and data from",
    "145": "numbers that require 64 bits to represent them, it is reasonable to design a memory for such a computer that stores one such number in each uniquely identifiable memory location. §.§ A 2^2-by-3-Bit Memory < g r a p h i c s > A 2^ 2-by-3-bit memory Figure <ref> illustrates a memory of size 2^2 by 3 bits. That is, the memory has an address space of four locations, and an addressability of 3 bits. A memory of size 2^2 requires 2 bits to specify the address. We describe the 2-bit address as A[1:0]. A memory of addressability 3 stores 3 bits of information in each memory location. We describe the 3 bits of data as D[2:0]. In both cases, our notation A[high:low] and D[high:low] reflects the fact that we have numbered the bits of address and data from right to left, in order, starting with the right-most bit which is numbered 0. The notation [high:low] means a sequence of high - low + 1 bits such that \"high\" is the bit number of the leftmost (or high) bit number in the sequence and \"low\" is the bit number of the rightmost (or low) bit number in the sequence. Accesses of memory require decoding the address bits. Note that the address decoder takes as input the address bits A[1:0] and asserts exactly one of its four outputs, corresponding to the word line being addressed. In Figure 3.20, each row of the memory corresponds to a unique three-bit word; thus the term word line. Memory can be read by applying the address A[1:0], which asserts the word line to be read. Note that each bit of the memory is ANDed with its word line and then ORed with the corresponding bits of the other words. Since only one word line can be asserted at a time, this is effectively a mux with the output of the decoder providing the select function to each bit line. Thus, the appropriate word is read at D[2:0]. Figure <ref> shows the process of reading",
    "146": "Accesses of memory require decoding the address bits. Note that the address decoder takes as input the address bits A[1:0] and asserts exactly one of its four outputs, corresponding to the word line being addressed. In Figure 3.20, each row of the memory corresponds to a unique three-bit word; thus the term word line. Memory can be read by applying the address A[1:0], which asserts the word line to be read. Note that each bit of the memory is ANDed with its word line and then ORed with the corresponding bits of the other words. Since only one word line can be asserted at a time, this is effectively a mux with the output of the decoder providing the select function to each bit line. Thus, the appropriate word is read at D[2:0]. Figure <ref> shows the process of reading location 3. The code for 3 is 11. The address A[1:0]=11 is decoded, and the bottom word line is asserted. Note that the three other decoder outputs are not asserted. That is, they have the value 0. The value stored in location 3 is 101. These three bits are each ANDed with their word line producing the bits 101, which are supplied to the three output OR gates. Note that all other inputs to the OR gates are 0, since they have been produced by ANDing with their unasserted word lines. The result is that D[2:0] = 101. That is, the value stored in location 3 is output by the OR gates. Memory can be written in a similar fashion. The address specified by A[1:0] is presented to the address decoder, resulting in the correct word line being asserted. With write enable (WE) also asserted, the three bits D[2:0] can be written into the three gated latches corresponding to that word line. < g r a p h i c s > Reading location 3 in our 2^ 2-by-3-bit memory § SEQUENTIAL LOGIC CIRCUITS In Section 3.3, we discussed digital logic structures that process information (decision structures, we call them)",
    "147": "are supplied to the three output OR gates. Note that all other inputs to the OR gates are 0, since they have been produced by ANDing with their unasserted word lines. The result is that D[2:0] = 101. That is, the value stored in location 3 is output by the OR gates. Memory can be written in a similar fashion. The address specified by A[1:0] is presented to the address decoder, resulting in the correct word line being asserted. With write enable (WE) also asserted, the three bits D[2:0] can be written into the three gated latches corresponding to that word line. < g r a p h i c s > Reading location 3 in our 2^ 2-by-3-bit memory § SEQUENTIAL LOGIC CIRCUITS In Section 3.3, we discussed digital logic structures that process information (decision structures, we call them) wherein the outputs depend solely on the values that are present on the inputs now. Examples are muxes, decoders, and full adders. We call these structures combinational logic circuits. In these circuits there is no sense of the past. Indeed, there is no capability for storing any information about anything that happened before the present time. In Sections 3.4 and 3.5, we described structures that do store information—in Section 3.4, some basic storage elements, and in Section 3.5, a simple 2^2-by-3-bit memory. In this section, we discuss digital logic structures that can both process information (i.e., make decisions) and store information. [-18pt] That is, these structures base their decisions not only on the input values now present, but also (and this is very important) on what has happened before. These structures are usually called sequential logic circuits. They are distinguishable from combinational logic circuits because, unlike combinational logic circuits, they contain storage elements that allow them to keep track of prior history information. Figure <ref> shows a block diagram of a sequential logic circuit. Note the storage elements. Note, also, that the output can be dependent on both the inputs now and the values stored in the storage elements. The",
    "148": "3.5, we described structures that do store information—in Section 3.4, some basic storage elements, and in Section 3.5, a simple 2^2-by-3-bit memory. In this section, we discuss digital logic structures that can both process information (i.e., make decisions) and store information. [-18pt] That is, these structures base their decisions not only on the input values now present, but also (and this is very important) on what has happened before. These structures are usually called sequential logic circuits. They are distinguishable from combinational logic circuits because, unlike combinational logic circuits, they contain storage elements that allow them to keep track of prior history information. Figure <ref> shows a block diagram of a sequential logic circuit. Note the storage elements. Note, also, that the output can be dependent on both the inputs now and the values stored in the storage elements. The values stored in the storage elements reflect the history of what has happened before. < g r a p h i c s > Sequential logic circuit block diagram Sequential logic circuits are used to implement a very important class of mechanisms called finite state machines. We use finite state machines in essentially all branches of engineering. For example, they are used as controllers of electrical systems, mechanical systems, and aeronautical systems. A traffic light controller that sets the traffic light to red, yellow, or green depends on the light that is currently on (history information) and input information from sensors such as trip wires on the road, a timer keeping track of how long the current light has been on, and perhaps optical devices that are monitoring traffic. We will see in Chapter 4 when we introduce the von Neumann model of a computer that a finite state machine is at the heart of the computer. It controls the processing of information by the computer. §.§ A Simple Example: The Combination Lock A simple example shows the difference between combinational logic structures and sequential logic structures. Suppose one wishes to secure a bicycle with a lock, but does not",
    "149": "are used as controllers of electrical systems, mechanical systems, and aeronautical systems. A traffic light controller that sets the traffic light to red, yellow, or green depends on the light that is currently on (history information) and input information from sensors such as trip wires on the road, a timer keeping track of how long the current light has been on, and perhaps optical devices that are monitoring traffic. We will see in Chapter 4 when we introduce the von Neumann model of a computer that a finite state machine is at the heart of the computer. It controls the processing of information by the computer. §.§ A Simple Example: The Combination Lock A simple example shows the difference between combinational logic structures and sequential logic structures. Suppose one wishes to secure a bicycle with a lock, but does not want to carry a key. A common solution is the combination lock. The person memorizes a “combination” and uses it to open the lock. Two common types of locks are shown in Figure <ref>. < g r a p h i c s > Combination locks In Figure <ref>a, the lock consists of a dial, with the numbers from 0 to 30 equally spaced around its circumference. To open the lock, one needs to know the “combination.” One such combination could be: R13-L22-R3. If this were the case, one would open the lock by turning the dial two complete turns to the right (clockwise), and then continuing until the dial points to 13, followed by one complete turn to the left (counterclockwise), and then continuing until the dial points to 22, followed by turning the dial again to the right (clockwise) until it points to 3. At that point, the lock opens. What is important here is the sequence of the turns. The lock will not open, for example if one performed two turns to the right, and then stopped on 22 (instead of 13), followed by one complete turn to the left, ending on 13, followed by one turn",
    "150": "to 30 equally spaced around its circumference. To open the lock, one needs to know the “combination.” One such combination could be: R13-L22-R3. If this were the case, one would open the lock by turning the dial two complete turns to the right (clockwise), and then continuing until the dial points to 13, followed by one complete turn to the left (counterclockwise), and then continuing until the dial points to 22, followed by turning the dial again to the right (clockwise) until it points to 3. At that point, the lock opens. What is important here is the sequence of the turns. The lock will not open, for example if one performed two turns to the right, and then stopped on 22 (instead of 13), followed by one complete turn to the left, ending on 13, followed by one turn to the right, ending on 3. That is, even though the final position of the dial is 3, and even though R22-L13-R3 uses the same three numbers as the combination R13-L22-R3, the lock would not open. Why? Because the lock stores the previous rotations and makes its decision (open or don't open) on the basis of the the history of the past operations, that is, on the correct sequence being performed. Another type of lock is shown in Figure <ref>b. The mechanism consists of (usually) four wheels, each containing the digits 0 through 9. When the digits are lined up properly, the lock will open. In this case, the combination is the set of four digits. Whether or not this lock opens is totally independent of the past rotations of the four wheels. The lock does not care at all about past rotations. The only thing important is the current value of each of the four wheels. This is a simple example of a combinational structure. It is curious that in our everyday speech, both mechanisms are referred to as “combination locks.” In fact, only the lock of Figure <ref>b is a combinational lock. The lock of Figure <ref>a would",
    "151": "the past operations, that is, on the correct sequence being performed. Another type of lock is shown in Figure <ref>b. The mechanism consists of (usually) four wheels, each containing the digits 0 through 9. When the digits are lined up properly, the lock will open. In this case, the combination is the set of four digits. Whether or not this lock opens is totally independent of the past rotations of the four wheels. The lock does not care at all about past rotations. The only thing important is the current value of each of the four wheels. This is a simple example of a combinational structure. It is curious that in our everyday speech, both mechanisms are referred to as “combination locks.” In fact, only the lock of Figure <ref>b is a combinational lock. The lock of Figure <ref>a would be better called a sequential lock! §.§ The Concept of State For the mechanism of Figure <ref>a to work properly, it has to keep track of the sequence of rotations leading up to the opening of the lock. In particular, it has to differentiate the correct sequence R13-L22-R3 from all other sequences. For example, R22-L13-R3 must not be allowed to open the lock. Likewise, R10-L22-R3 must also not be allowed to open the lock. For the lock of Figure <ref>a to work, it must identify several relevant situations, as follows: 1. #1 to #1 9101.75pc A. The lock is not open, and NO relevant operations have been performed. B. The lock is not open, but the user has just completed the R13 operation. C. The lock is not open, but the user has just completed R13, followed by L22. D. The lock is open, since the user has just completed R13, followed by L22, followed by R3. We have labeled these four situations A, B, C, and D. We refer to each of these situations as the state of the lock. The notion of state is a very important concept in computer [-5pt] engineering, and actually, in just about all",
    "152": "open the lock. Likewise, R10-L22-R3 must also not be allowed to open the lock. For the lock of Figure <ref>a to work, it must identify several relevant situations, as follows: 1. #1 to #1 9101.75pc A. The lock is not open, and NO relevant operations have been performed. B. The lock is not open, but the user has just completed the R13 operation. C. The lock is not open, but the user has just completed R13, followed by L22. D. The lock is open, since the user has just completed R13, followed by L22, followed by R3. We have labeled these four situations A, B, C, and D. We refer to each of these situations as the state of the lock. The notion of state is a very important concept in computer [-5pt] engineering, and actually, in just about all branches of engineering. The state of a mechanism—more generally, the state of a system—is a snapshot of that system in which all relevant items are explicitly expressed. That is: The state of a system is a snapshot of all the relevant elements of the system at the moment the snapshot is taken. In the case of the lock of Figure <ref>a, there are four states A, B, C, and D. Either the lock is open (State D), or if it is not open, we have already performed either zero (State A), one (State B), or two (State C) correct operations. This is the sum total of all possible states that can exist. Question: Why are there exactly four states needed to describe the combination lock of Figure <ref>a? Can you think of a snapshot of the combination lock after an operation (Rn or Ln) that requires a fifth state because it is not covered by one of the four states A,B,C or D? There are many examples of systems that you are familiar with that can be easily described by means of states. The state of a game of basketball can be described by the scoreboard in the basketball arena.",
    "153": "<ref>a, there are four states A, B, C, and D. Either the lock is open (State D), or if it is not open, we have already performed either zero (State A), one (State B), or two (State C) correct operations. This is the sum total of all possible states that can exist. Question: Why are there exactly four states needed to describe the combination lock of Figure <ref>a? Can you think of a snapshot of the combination lock after an operation (Rn or Ln) that requires a fifth state because it is not covered by one of the four states A,B,C or D? There are many examples of systems that you are familiar with that can be easily described by means of states. The state of a game of basketball can be described by the scoreboard in the basketball arena. Figure <ref> shows the state of the basketball game as Texas 73, Oklahoma 68, 7 minutes and 38 seconds left in the second half, 14 seconds left on the shot clock, Texas with the ball, and Texas and Oklahoma each with four team fouls. This is a snapshot of the basketball game. It describes the state of the basketball game at one point in time. If, 12 seconds later, a Texas player were to score a two-point shot, the new state would be described by the updated scoreboard. That is, the score would then be Texas 75, Oklahoma 68, the time remaining in the game would be 7 minutes and 26 seconds, the shot clock would be back to 25 seconds, and Oklahoma would have the ball. < g r a p h i c s > An example of a state The game of tic-tac-toe can also be described in accordance with the notion of state. Recall that the game is played by two people (or, in our case, a person and the computer). The state is a snapshot of the game in progress each time the computer asks the person to make a move. The game is played",
    "154": "at one point in time. If, 12 seconds later, a Texas player were to score a two-point shot, the new state would be described by the updated scoreboard. That is, the score would then be Texas 75, Oklahoma 68, the time remaining in the game would be 7 minutes and 26 seconds, the shot clock would be back to 25 seconds, and Oklahoma would have the ball. < g r a p h i c s > An example of a state The game of tic-tac-toe can also be described in accordance with the notion of state. Recall that the game is played by two people (or, in our case, a person and the computer). The state is a snapshot of the game in progress each time the computer asks the person to make a move. The game is played as follows: There are nine locations on the diagram. The person and then the computer take turns placing an X (the person) and an O (the computer) in an empty location. The person goes first. The winner is the first to place three symbols (three Xs for the person, three Os for the computer) in a straight line, either vertically, horizontally, or diagonally. The initial state, before either the person or computer has had a turn, is shown in Figure <ref>a. Figure <ref>b shows a possible state of the game when the person is prompted for a second move, if he/she put an X in the upper left corner as his/her first move, and the computer followed with a O in the middle square as its first move. Figure <ref>c shows a possible state of the game when the person is prompted for a third move if he/she put an X in the upper right corner on the second move, and the computer followed by putting its second O in the upper middle location. < g r a p h i c s > Three states in a tic-tac-toe machine One final example: a very old soft drink machine, when",
    "155": "horizontally, or diagonally. The initial state, before either the person or computer has had a turn, is shown in Figure <ref>a. Figure <ref>b shows a possible state of the game when the person is prompted for a second move, if he/she put an X in the upper left corner as his/her first move, and the computer followed with a O in the middle square as its first move. Figure <ref>c shows a possible state of the game when the person is prompted for a third move if he/she put an X in the upper right corner on the second move, and the computer followed by putting its second O in the upper middle location. < g r a p h i c s > Three states in a tic-tac-toe machine One final example: a very old soft drink machine, when drinks sold for 15 cents, and the machine would only take nickels (5 cents) and dimes (10 cents) and not be able to give change. The state of the machine can be described as the amount of money inserted, and whether the machine is open (so one can remove a bottle). There are only three possible states: 1. #1 to #1 9101.75pc A. The lock is open, so a bottle can be (or has been!) removed. B. The lock is not open, but 5 cents has been inserted. C. The lock is not open, but 10 cents has been inserted. §.§ The Finite State Machine and its State Diagram We have seen that a state is a snapshot of all relevant parts of a system at a particular point in time. At other times, that system can be in other states. We have described four systems: a combination lock, a basketball game, a tic-tac-toe machine, and a very old soft drink machine when a bottle of cola cost only 15 cents. The behavior of each of these systems can be specified by a finite state machine, and represented as a state diagram. A finite state machine consists of five elements:",
    "156": "#1 9101.75pc A. The lock is open, so a bottle can be (or has been!) removed. B. The lock is not open, but 5 cents has been inserted. C. The lock is not open, but 10 cents has been inserted. §.§ The Finite State Machine and its State Diagram We have seen that a state is a snapshot of all relevant parts of a system at a particular point in time. At other times, that system can be in other states. We have described four systems: a combination lock, a basketball game, a tic-tac-toe machine, and a very old soft drink machine when a bottle of cola cost only 15 cents. The behavior of each of these systems can be specified by a finite state machine, and represented as a state diagram. A finite state machine consists of five elements: 1. #1 to #1 9101.4pc 1. a finite number of states 2. a finite number of external inputs 3. a finite number of external outputs 4. an explicit specification of all state transitions 5. an explicit specification of what determines each external output value. The set of states represents all possible situations (or snapshots) that the system can be in. Each state transition describes what it takes to get from one state to another. Let's examine the finite state machines for these four systems. The combination lock A state diagram is a convenient representation of a finite state machine. Figure <ref> is a state diagram for the combination lock. < g r a p h i c s > State diagram of the combination lock of Figure 3.23a Recall, we identified four states A,B,C, and D. Which state we are in depends on the progress we have made in getting from a random initial state to the lock being open. In the state diagram of Figure <ref>, each circle corresponds to one of the four states, A,B,C, or D. The external inputs are R13, L22, R3, and R-other-than-13, L-other-than-22, and R-other-than-3. The external output is either the lock is open",
    "157": "Each state transition describes what it takes to get from one state to another. Let's examine the finite state machines for these four systems. The combination lock A state diagram is a convenient representation of a finite state machine. Figure <ref> is a state diagram for the combination lock. < g r a p h i c s > State diagram of the combination lock of Figure 3.23a Recall, we identified four states A,B,C, and D. Which state we are in depends on the progress we have made in getting from a random initial state to the lock being open. In the state diagram of Figure <ref>, each circle corresponds to one of the four states, A,B,C, or D. The external inputs are R13, L22, R3, and R-other-than-13, L-other-than-22, and R-other-than-3. The external output is either the lock is open or the lock is not open. (One logical variable will suffice to describe that!) As shown in the state diagram, in states A,B, and C, the combination lock is locked. In state D, the combination lock is open. The explicit specifications of all state transistions are shown by the arrows in the state diagram. The more sophisticated term for “arrow” is arc. The arrowhead on each arc specifies which state the system is coming from, and which state it is going to. We refer to the state the system is coming from as the current state, and the state it is going to as the next state. The combination lock has eight state transitions. Associated with each transition is the input that causes the transition from the current state to the next state. For example, R13 causes the transition from state A to state B. A couple of things are worth noting. First, it is usually the case that from a current state there are multiple transitions to next states. The state transition that occurs depends on both the current state and the value of the external input. For example, if the combination lock is in state B, and the",
    "158": "is arc. The arrowhead on each arc specifies which state the system is coming from, and which state it is going to. We refer to the state the system is coming from as the current state, and the state it is going to as the next state. The combination lock has eight state transitions. Associated with each transition is the input that causes the transition from the current state to the next state. For example, R13 causes the transition from state A to state B. A couple of things are worth noting. First, it is usually the case that from a current state there are multiple transitions to next states. The state transition that occurs depends on both the current state and the value of the external input. For example, if the combination lock is in state B, and the input is L22, the next state is state C. If the current state is state B and the input is anything other than L22, the next state is state A. In short, the next state is determined by the combination of the current state and the current external input. The output values of a system can be determined also by the combination of the current state and the value of the current external input. However, as is the case for the combination lock, where states A,B, and C specify the lock is \"locked,\" and state D specifies the lock is \"unlocked,\" the output can also be determined solely by the current state of the system. In all the systems we will study in this book, the output values will be specified solely by the current state of the system. A very old soft drink machine Figure <ref> is the state diagram for the soft drink machine. < g r a p h i c s > State diagram of the soft drink machine The soft drink machine has only three states: 5 cents has been inserted, 10 cents has been inserted, and at least 15 cents has been inserted. Transitions",
    "159": "the combination of the current state and the value of the current external input. However, as is the case for the combination lock, where states A,B, and C specify the lock is \"locked,\" and state D specifies the lock is \"unlocked,\" the output can also be determined solely by the current state of the system. In all the systems we will study in this book, the output values will be specified solely by the current state of the system. A very old soft drink machine Figure <ref> is the state diagram for the soft drink machine. < g r a p h i c s > State diagram of the soft drink machine The soft drink machine has only three states: 5 cents has been inserted, 10 cents has been inserted, and at least 15 cents has been inserted. Transitions are caused by the insertion (the input) of a nickel or a dime. The output is associated only with the states. In states B and C, the machine is locked. Not enough money has been inserted! In state A, the machine is open so a soft drink can be removed because at least 15 cents has been inserted. A basketball game We could similarly draw a state diagram for the basketball game we described earlier, where each state would be one possible configuration of the scoreboard. A transition would occur if either the referee blew a whistle or the other team got the ball. We showed earlier the transition that would be caused by Texas scoring a two-point shot. Clearly, the number of states in the finite state machine describing a basketball game would be huge. Also clearly, the number of legitimate transitions from one state to another is small, compared to the number of arcs one could draw connecting arbitrary pairs of states. For example, there is no arc from a score of Texas 68, Oklahoma 67 to Texas 75, Oklahoma 91, since no single input can cause that transition. The input is the activity that occurred on the",
    "160": "game We could similarly draw a state diagram for the basketball game we described earlier, where each state would be one possible configuration of the scoreboard. A transition would occur if either the referee blew a whistle or the other team got the ball. We showed earlier the transition that would be caused by Texas scoring a two-point shot. Clearly, the number of states in the finite state machine describing a basketball game would be huge. Also clearly, the number of legitimate transitions from one state to another is small, compared to the number of arcs one could draw connecting arbitrary pairs of states. For example, there is no arc from a score of Texas 68, Oklahoma 67 to Texas 75, Oklahoma 91, since no single input can cause that transition. The input is the activity that occurred on the basketball court since the last transition. Some input values are: Texas scored two points, Oklahoma scored three points, Texas stole the ball, Oklahoma successfully rebounded a Texas shot, and so forth. The output is the final result of the game. The output has three values: Game still in progress, Texas wins, Oklahoma wins. Question: Can one have an arc from a state where the score is Texas 30, Oklahoma 28 to a state where the score is tied, Texas 30, Oklahoma 30? Is it possible to have two states, one where Texas is ahead 30-28 and the other where the score is tied 30-30, but no arc between the two? A tic-tac-toe machine We could also draw a state diagram for a tic-tac-toe machine, in our case when a person is playing against a computer. Each state is a representation of the position of the game when the person is asked to put an X into one of the empty cells. Figure <ref> shows three states. The transition from the state of Figure <ref>a to the state of Figure <ref>b is caused by the person putting an X in the top left cell, followed by the computer putting an O",
    "161": "a state where the score is Texas 30, Oklahoma 28 to a state where the score is tied, Texas 30, Oklahoma 30? Is it possible to have two states, one where Texas is ahead 30-28 and the other where the score is tied 30-30, but no arc between the two? A tic-tac-toe machine We could also draw a state diagram for a tic-tac-toe machine, in our case when a person is playing against a computer. Each state is a representation of the position of the game when the person is asked to put an X into one of the empty cells. Figure <ref> shows three states. The transition from the state of Figure <ref>a to the state of Figure <ref>b is caused by the person putting an X in the top left cell, followed by the computer putting an O in the center cell. The transition from the state of Figure <ref>b to the state of Figure <ref>c is caused by the person putting an X in the top right cell, followed by the computer putting an O in the top middle cell. Since there are nine cells, and each state has an X, an O, or nothing in each cell, there must be fewer than 3^9 states in the tic-tac-toe machine. Clearly there are far fewer than that, due to various constraints of the game. There are nine inputs, corresponding to the nine cells a person can put an X in. There are three outputs: (a) game still in progress, (b) person wins, and (c) computer wins. §.§ The Synchronous Finite State Machine Up to now a transition from a current state to a next state in our finite state machine happened when it happened. For example, a person could insert a nickel into the soft drink machine and then wait 10 seconds or 10 minutes before inserting the next coin into the machine. And the soft drink machine would not complain. It would not dispense the soft drink until 15 cents was inserted, but it would wait patiently",
    "162": "cell, there must be fewer than 3^9 states in the tic-tac-toe machine. Clearly there are far fewer than that, due to various constraints of the game. There are nine inputs, corresponding to the nine cells a person can put an X in. There are three outputs: (a) game still in progress, (b) person wins, and (c) computer wins. §.§ The Synchronous Finite State Machine Up to now a transition from a current state to a next state in our finite state machine happened when it happened. For example, a person could insert a nickel into the soft drink machine and then wait 10 seconds or 10 minutes before inserting the next coin into the machine. And the soft drink machine would not complain. It would not dispense the soft drink until 15 cents was inserted, but it would wait patiently as long as necessary for the 15 cents to be inserted. That is, there is no fixed amount of time between successive [-18pt] inputs to the finite state machine. This is true in the case of all four of the systems we discussed above. We say these systems are asynchronous because there is nothing synchronizing when each state transition must occur. However, almost no computers work that way. On the contrary, we say that computers are synchronous because the state transitions take place, one after the other, at identical fixed units of time. They are controlled by a synchronous finite state machine. We will save for Chapter 4 and beyond the state transitions that occur at identical, fixed units of time that control a computer. In this chapter, we will take on a simpler task, the design of a traffic controller, an admittedly simpler structure, but one that is also controlled by a synchronous finite state machine. It is worth pointing out that both the four asynchronous finite state machines discussed above and the synchronous finite state machine that controls a digital computer share an important characteristic: they carry out work, one state transition at a time, moving closer to",
    "163": "occur. However, almost no computers work that way. On the contrary, we say that computers are synchronous because the state transitions take place, one after the other, at identical fixed units of time. They are controlled by a synchronous finite state machine. We will save for Chapter 4 and beyond the state transitions that occur at identical, fixed units of time that control a computer. In this chapter, we will take on a simpler task, the design of a traffic controller, an admittedly simpler structure, but one that is also controlled by a synchronous finite state machine. It is worth pointing out that both the four asynchronous finite state machines discussed above and the synchronous finite state machine that controls a digital computer share an important characteristic: they carry out work, one state transition at a time, moving closer to a goal. In the case of the combination lock, as long as you make the correct moves, each state transition takes us closer to the lock opening. In the case of the soft drink machine, each state transition takes us closer to enjoying the taste of the soft drink. In the case of a computer, each state transition takes us closer to solving a problem by processing a computer program that someone has written. §.§ The Clock A synchronous finite state machine transitions from its current state to its next state after an identical fixed interval of time. Control of that synchronous behavior is in part the responsibility of the clock circuit. A clock circuit produces a signal, commonly referred to as THE clock, whose value alternates between 0 volts and some specified fixed voltage. In digital logic terms, the clock is a signal whose value alternates between 0 and 1. Figure <ref> shows the value of the clock signal as a function of time. Each of the repeated sequence of identical intervals is referred to as a clock cycle. A clock cycle starts when the clock signal transitions from 0 to 1, and ends the next time the clock",
    "164": "closer to solving a problem by processing a computer program that someone has written. §.§ The Clock A synchronous finite state machine transitions from its current state to its next state after an identical fixed interval of time. Control of that synchronous behavior is in part the responsibility of the clock circuit. A clock circuit produces a signal, commonly referred to as THE clock, whose value alternates between 0 volts and some specified fixed voltage. In digital logic terms, the clock is a signal whose value alternates between 0 and 1. Figure <ref> shows the value of the clock signal as a function of time. Each of the repeated sequence of identical intervals is referred to as a clock cycle. A clock cycle starts when the clock signal transitions from 0 to 1, and ends the next time the clock signal transitions from 0 to 1. We will see in Chapter 5 and beyond that in each clock cycle, a computer can perform a piece of useful work. When people say their laptop computers run at a frequency of 2 gigahertz, they are saying their laptop computers perform 2 billion pieces of work each second since 2 gigahertz means 2 billion clock cycles each second, each clock cycle lasting for just one half of a nanosecond. The synchronous finite state machine makes one state transition each clock cycle. We will show by means of a traffic signal controller how the clock signal controls the transition, fixed clock cycle after fixed clock cycle, from one state to the next. In electronic circuit implementations of a synchronous finite state machine, the transition from one state to the next occurs at the start of each clock cycle. 36pc < g r a p h i c s > A clock signal §.§ Example: A danger sign Many electrical, mechanical, and aeronautical,systems are controlled by a synchronous finite state machine. In this section we will design the complete logic needed for a synchronous finite state machine to control a traffic danger sign. Figure <ref>",
    "165": "billion clock cycles each second, each clock cycle lasting for just one half of a nanosecond. The synchronous finite state machine makes one state transition each clock cycle. We will show by means of a traffic signal controller how the clock signal controls the transition, fixed clock cycle after fixed clock cycle, from one state to the next. In electronic circuit implementations of a synchronous finite state machine, the transition from one state to the next occurs at the start of each clock cycle. 36pc < g r a p h i c s > A clock signal §.§ Example: A danger sign Many electrical, mechanical, and aeronautical,systems are controlled by a synchronous finite state machine. In this section we will design the complete logic needed for a synchronous finite state machine to control a traffic danger sign. Figure <ref> shows the danger sign as it will be placed on the highway. Note the sign says, “Danger, Move Right.” The sign contains five lights (labeled 1 through 5 in the figure). < g r a p h i c s > A traffic danger sign The purpose of our synchronous finite state machine (aka a controller) is to direct the behavior of our system. In our case, the system is the set of lights on the traffic danger sign. The controller's job is to have the five lights flash on and off to warn automobile drivers to move to the right. The controller is equipped with a switch. When the switch is in the ON position, the controller directs the lights as follows: During one unit of time, all lights will be off. In the next unit of time, lights 1 and 2 will be on. The next unit of time, lights 1, 2, 3, and 4 will be on. Then all five lights will be on. Then the sequence repeats: no lights on, followed by 1 and 2 on, followed by 1, 2, 3, and 4 on, and so forth. Each unit of time lasts one second. To an",
    "166": "behavior of our system. In our case, the system is the set of lights on the traffic danger sign. The controller's job is to have the five lights flash on and off to warn automobile drivers to move to the right. The controller is equipped with a switch. When the switch is in the ON position, the controller directs the lights as follows: During one unit of time, all lights will be off. In the next unit of time, lights 1 and 2 will be on. The next unit of time, lights 1, 2, 3, and 4 will be on. Then all five lights will be on. Then the sequence repeats: no lights on, followed by 1 and 2 on, followed by 1, 2, 3, and 4 on, and so forth. Each unit of time lasts one second. To an automobile driver approaching the sign, the five lights clearly direct the driver to move to the right. The lights continue to sequence through these four states as long as the switch is on. If the switch is turned off, all the lights are turned off and remain off. The State Diagram for the Danger Sign Controller Figure <ref> is a state diagram for the synchronous finite state machine that controls the lights. There are four states, one for each of the four conditions corresponding to which lights are on. Note that the outputs (whether each light is on or off) is determined by the current state of the system. If the switch is on (input= 1), the transition from each state to the next state happens at one second intervals, causing the lights to flash in the sequence described. If the switch is turned off (input= 0), the state always transitions to state A, the “all off” state. < g r a p h i c s > State diagram for the Danger Sign Controller The Sequential Logic Circuit for the Danger Sign Controller Recall that Figure <ref> shows a generic block diagram for a sequential logic circuit. Figure <ref>",
    "167": "state diagram for the synchronous finite state machine that controls the lights. There are four states, one for each of the four conditions corresponding to which lights are on. Note that the outputs (whether each light is on or off) is determined by the current state of the system. If the switch is on (input= 1), the transition from each state to the next state happens at one second intervals, causing the lights to flash in the sequence described. If the switch is turned off (input= 0), the state always transitions to state A, the “all off” state. < g r a p h i c s > State diagram for the Danger Sign Controller The Sequential Logic Circuit for the Danger Sign Controller Recall that Figure <ref> shows a generic block diagram for a sequential logic circuit. Figure <ref> is a block diagram of the specific sequential logic circuit we need to control the lights. Several things are important to note in this figure. < g r a p h i c s > Sequential Logic Circuit for the danger sign controller First, the two external inputs: the switch and the clock. The switch determines whether the finite state machine will transition through the four states or whether it will transition to state A, where all lights are off. The other input (the clock) controls the transition from state A to B, B to C, C to D, and D to A by controlling the state of the storage elements. We will see how, momentarily. Second, there are two storage elements for storing state information. Since there are four states, and since each storage element can store one bit of information, the four states are identified by the contents of the two storage elements: A (00), B (01), C (10), and D (11). Storage element 2 contains the high bit; storage element 1 contains the low bit. For example, the danger sign controller is in state B when storage element 2 is 0 and storage element 1 is 1.",
    "168": "machine will transition through the four states or whether it will transition to state A, where all lights are off. The other input (the clock) controls the transition from state A to B, B to C, C to D, and D to A by controlling the state of the storage elements. We will see how, momentarily. Second, there are two storage elements for storing state information. Since there are four states, and since each storage element can store one bit of information, the four states are identified by the contents of the two storage elements: A (00), B (01), C (10), and D (11). Storage element 2 contains the high bit; storage element 1 contains the low bit. For example, the danger sign controller is in state B when storage element 2 is 0 and storage element 1 is 1. Third, combinational logic circuit 1 shows that the on/off behavior of the lights are controlled by the storage elements. That is, the input to the combinational logic circuit is from the two storage elements, i.e., the current state of the finite state machine. Finally, combinational logic circuit 2 shows that the transition from the current state to the next state depends on the two storage elements and the switch. If the switch is on, the output of combinational logic circuit 2 depends on the state of the two storage elements. The Combinational Logic Figure <ref> shows the logic that implements combinational logic circuits 1 and 2. Two sets of outputs are required for the controller to work properly: a set of external outputs for the lights and a set of internal outputs for the inputs to the two storage elements that keep track of the state. First, let us look at the outputs that control the lights. As we have said, there are only three outputs necessary to control the lights. Light 5 is controlled by the output of the AND gate labeled V, since the only time light 5 is on is when the controller is in state 11.",
    "169": "depends on the two storage elements and the switch. If the switch is on, the output of combinational logic circuit 2 depends on the state of the two storage elements. The Combinational Logic Figure <ref> shows the logic that implements combinational logic circuits 1 and 2. Two sets of outputs are required for the controller to work properly: a set of external outputs for the lights and a set of internal outputs for the inputs to the two storage elements that keep track of the state. First, let us look at the outputs that control the lights. As we have said, there are only three outputs necessary to control the lights. Light 5 is controlled by the output of the AND gate labeled V, since the only time light 5 is on is when the controller is in state 11. Lights 3 and 4 are controlled by the output of the OR gate labeled X, since there are two states in which those lights are on, those labeled 10 and 11. Why are lights 1 and 2 controlled by the output of the OR gate labeled W? See Exercise 3.42. Next, let us look at the internal outputs that control the storage elements, which specify the next state of the controller. Storage element 2 should be set to 1 for the next clock cycle if the next state is 10 or 11. This is true only if the switch is on and the current state is either 01 or 10. Therefore the output signal that will make storage element 2 be 1 in the next clock cycle is the output of the OR gate labeled Y. Why is the next state of storage element 1 controlled by the output of the OR gate labeled Z? See Exercise 3.42. < g r a p h i c s > Combinational logic circuits 1 and 2 The two storage elements In order for the danger sign controller to work, the state transitions must occur once per second when the switch is on.",
    "170": "the storage elements, which specify the next state of the controller. Storage element 2 should be set to 1 for the next clock cycle if the next state is 10 or 11. This is true only if the switch is on and the current state is either 01 or 10. Therefore the output signal that will make storage element 2 be 1 in the next clock cycle is the output of the OR gate labeled Y. Why is the next state of storage element 1 controlled by the output of the OR gate labeled Z? See Exercise 3.42. < g r a p h i c s > Combinational logic circuits 1 and 2 The two storage elements In order for the danger sign controller to work, the state transitions must occur once per second when the switch is on. A problem with gated latches as storage elements What would happen if the storage elements were gated D latches? If the two storage elements are gated D latches, when the write enable signal (the clock) is 1, the output of OR gates Y and Z would immediately change the bits stored in the two gated D latches. This would produce new input values to the three AND gates that are input to OR gates Y and Z, producing new outputs which would be applied to the inputs of the gated latches, which would in turn change the bits stored in the gated latches, which would in turn mean new inputs to the three AND gates and new outputs of OR gates Y and Z. This would happen again and again, continually changing the bits stored in the two storage elements as long as the Write Enable signal to the gated D latches is asserted. The result: We have no idea what the state of the finite state machine would be for the next clock cycle. And, even in the current clock cycle, the state of the storage elements would change so fast that the five lights would behave erratically. The",
    "171": "new input values to the three AND gates that are input to OR gates Y and Z, producing new outputs which would be applied to the inputs of the gated latches, which would in turn change the bits stored in the gated latches, which would in turn mean new inputs to the three AND gates and new outputs of OR gates Y and Z. This would happen again and again, continually changing the bits stored in the two storage elements as long as the Write Enable signal to the gated D latches is asserted. The result: We have no idea what the state of the finite state machine would be for the next clock cycle. And, even in the current clock cycle, the state of the storage elements would change so fast that the five lights would behave erratically. The problem is the gated D latch. We want the output of OR gates Y and Z to transition to the next state at the end of the current clock cycle, and allow the current state to remain unchanged until then. That is, we do not want the input to the storage elements to take effect until the end of the current clock cycle. Since the output of a gated D latch changes immediately in response to its input if the Write Enable signal is asserted, it can not be the storage element for our synchronous finite state machine. We need storage elements that allow us to read the current state throughout the current clock cycle, and not write the next state values into the storage elements until the beginning of the next clock cycle. The Flip-flop to the Rescue It is worth repeating: To prevent the above from happening, we need storage elements that allow us to read the current state throughout the current clock cycle, and not write the next state values into the storage elements until the beginning of the next clock cycle. That is, the function to be performed during a single clock cycle involves reading and",
    "172": "current clock cycle. Since the output of a gated D latch changes immediately in response to its input if the Write Enable signal is asserted, it can not be the storage element for our synchronous finite state machine. We need storage elements that allow us to read the current state throughout the current clock cycle, and not write the next state values into the storage elements until the beginning of the next clock cycle. The Flip-flop to the Rescue It is worth repeating: To prevent the above from happening, we need storage elements that allow us to read the current state throughout the current clock cycle, and not write the next state values into the storage elements until the beginning of the next clock cycle. That is, the function to be performed during a single clock cycle involves reading and writing a particular variable. [-18pt] Reading must be allowed throughout the clock cycle, and writing must occur at the end of the clock cycle. A flip-flop can accomplish that. One example of a flip-flop is the master/slave flip-flop shown in Figure <ref>. The master/slave flip-flop can be constructed out of two gated D latches, one referred to as the master, the other referred to as the slave. Note that the write enable signal of the master is 1 when the clock is 0, and the write enable signal of the slave is 1 when the clock is 1. < g r a p h i c s > A master/slave flip-flop Figure <ref> is a timing diagram for the master/slave flip-flop, which shows how and why the master/slave flip-flop solves the problem. A timing diagram shows time passing from left to right. Note that clock cycle n starts at the time labeled 1, and ends at the time labeled 4. Clock cycle n+1 starts at the time labeled 4. Consider clock cycle n, which we will discuss in terms of its first half A, its second half B, and the four time points labeled 1, 2, 3, and 4. At",
    "173": "the other referred to as the slave. Note that the write enable signal of the master is 1 when the clock is 0, and the write enable signal of the slave is 1 when the clock is 1. < g r a p h i c s > A master/slave flip-flop Figure <ref> is a timing diagram for the master/slave flip-flop, which shows how and why the master/slave flip-flop solves the problem. A timing diagram shows time passing from left to right. Note that clock cycle n starts at the time labeled 1, and ends at the time labeled 4. Clock cycle n+1 starts at the time labeled 4. Consider clock cycle n, which we will discuss in terms of its first half A, its second half B, and the four time points labeled 1, 2, 3, and 4. At the start of each clock cycle, the output of the storage elements are the outputs of the two slave latches. These outputs (starting at time 1) are input to the AND gates, resulting in OR gates Y and Z producing the next state values for the storage elements (at time 2). The timing diagram shows the propagation delay of the combinational logic; that is, the time it takes for the combinational logic to produce outputs of OR gates Y and Z. Although OR gates Y and Z produce the Next State value sometime during half-cycle A, the write enable signal to the master latches is 0 so the the next state can not be written into the master latches. At the start of half-cycle B (at time 3), the clock signal is 0, which means the write enable signal to the master latches is 1, and the master latches can be written. However, during the half-cycle B, the write enable to the slave latches is 0, so the slave latches can not write the new information now stored in the master latches. At the start of clock cycle n+1 (at time 4), the write enable signal to the slave latches",
    "174": "combinational logic; that is, the time it takes for the combinational logic to produce outputs of OR gates Y and Z. Although OR gates Y and Z produce the Next State value sometime during half-cycle A, the write enable signal to the master latches is 0 so the the next state can not be written into the master latches. At the start of half-cycle B (at time 3), the clock signal is 0, which means the write enable signal to the master latches is 1, and the master latches can be written. However, during the half-cycle B, the write enable to the slave latches is 0, so the slave latches can not write the new information now stored in the master latches. At the start of clock cycle n+1 (at time 4), the write enable signal to the slave latches is 1 so the slave latches can store the next state value which was created by the combinational logic during clock cycle n. This becomes the current state for clock cycle n+1. Since the write enable signal to the master latches is now 0, the state of the master latches can not change. Thus, although the write enable signal to the slave latches is 1, those latches do not change because the master latches can not change. In short, the output of the slave latches contain the current state of the system for the duration of the clock cycle, and produce the inputs to the six AND gates in the combinational logic circuits. Their state changes at the start of the clock cycle by storing the next state information created by the combinational logic during the previous cycle but do not change again during the clock cycle. The reason they do not change again during the clock cycle is as follows: during half-cycle A, the master latches can not change so the slave latches continue to see the state information that is the current state for the new clock cycle. During half-cycle B, the slave latches can not change because",
    "175": "the slave latches is 1, those latches do not change because the master latches can not change. In short, the output of the slave latches contain the current state of the system for the duration of the clock cycle, and produce the inputs to the six AND gates in the combinational logic circuits. Their state changes at the start of the clock cycle by storing the next state information created by the combinational logic during the previous cycle but do not change again during the clock cycle. The reason they do not change again during the clock cycle is as follows: during half-cycle A, the master latches can not change so the slave latches continue to see the state information that is the current state for the new clock cycle. During half-cycle B, the slave latches can not change because the clock signal is 0. Meanwhile, during half-cycle B, the master latches can store the next state information produced by the combinational logic, but they can not write it into the slave latches until the start of the next clock cycle, when it becomes the state information for the next clock cycle. < g r a p h i c s > Timing diagram for a master/slave flip-flop § PREVIEW OF COMING ATTRACTIONS: THE DATA PATH OF THE LC-3 In Chapter 5, we will specify a computer, which we call the LC-3, and you will have the opportunity to write computer programs to execute on it. We close out Chapter 3 with a discussion of Figure <ref>, the data path of the LC-3 computer. 36pc < g r a p h i c s > The data path of the LC-3 computer The data path LC-3!data path consists of all the logic structures that combine to process information in the core of the computer. Right now, Figure <ref> is undoubtedly more than a little intimidating, but you should not be concerned by that. You are not ready to analyze it yet. That will come in Chapter 5. We have included",
    "176": "s > Timing diagram for a master/slave flip-flop § PREVIEW OF COMING ATTRACTIONS: THE DATA PATH OF THE LC-3 In Chapter 5, we will specify a computer, which we call the LC-3, and you will have the opportunity to write computer programs to execute on it. We close out Chapter 3 with a discussion of Figure <ref>, the data path of the LC-3 computer. 36pc < g r a p h i c s > The data path of the LC-3 computer The data path LC-3!data path consists of all the logic structures that combine to process information in the core of the computer. Right now, Figure <ref> is undoubtedly more than a little intimidating, but you should not be concerned by that. You are not ready to analyze it yet. That will come in Chapter 5. We have included it here, however, to show you that you are already familiar with many of the basic structures that make up a computer. For example, you see five MUXes in the data path, and you already know how they work. Also, an adder (shown as the ALU symbol with a + sign inside) and an ALU. You know how those elements are constructed from gates. One element that we have not identified explicitly yet is a register. A register is simply a set of n flip-flops which collectively are used to store one n-bit value. In Figure <ref>, PC, IR, MAR, and MDR are all 16-bit registers that store 16 bits of information each. The block labeled REG FILE consists of eight registers that each store 16 bits of information. As you know, one bit of information can be stored in one flip-flop. Therefore, each of these registers consist of 16 flip-flops. The data path also shows three one-bit registers, N, Z, and P. Those registers require only one flip-flop each. In fact, a register can be any size that we need. The size depends only on the number of bits we need to represent the value we wish to store.",
    "177": "are constructed from gates. One element that we have not identified explicitly yet is a register. A register is simply a set of n flip-flops which collectively are used to store one n-bit value. In Figure <ref>, PC, IR, MAR, and MDR are all 16-bit registers that store 16 bits of information each. The block labeled REG FILE consists of eight registers that each store 16 bits of information. As you know, one bit of information can be stored in one flip-flop. Therefore, each of these registers consist of 16 flip-flops. The data path also shows three one-bit registers, N, Z, and P. Those registers require only one flip-flop each. In fact, a register can be any size that we need. The size depends only on the number of bits we need to represent the value we wish to store. One way to implement registers is with master/slave flip-flops. Figure <ref> shows a four-bit register made up of four master/slave flip-flops. We usually need flip-flops, rather than latches, because it is usually important to be able to both read the contents of a register throughout a clock cycle and also store a new value in the register at the end of that same clock cycle. As shown in Figure <ref>, the four-bit value stored in the register during a clock cycle is Q_3, Q_2, Q_1, Q_0. At the end of that clock cycle. the value D_3, D_2, D_1, D_0 is written into the register. < g r a p h i c s > A four-bit register The arrows in Figure <ref> represent wires that transmit values from one structure to another. Most of the arrows include a cross-hatch with a number next to it. The number represents the number of wires, corresponding to the number of bits being transmitted. Thus, for example, the arrow from the register labeled PC to one of the inputs of the MUX labeled ADDR1MUX indicates that 16 bits are transmitted from PC to an input of ADDR1MUX. In Chapter 5, we will see why",
    "178": "of that same clock cycle. As shown in Figure <ref>, the four-bit value stored in the register during a clock cycle is Q_3, Q_2, Q_1, Q_0. At the end of that clock cycle. the value D_3, D_2, D_1, D_0 is written into the register. < g r a p h i c s > A four-bit register The arrows in Figure <ref> represent wires that transmit values from one structure to another. Most of the arrows include a cross-hatch with a number next to it. The number represents the number of wires, corresponding to the number of bits being transmitted. Thus, for example, the arrow from the register labeled PC to one of the inputs of the MUX labeled ADDR1MUX indicates that 16 bits are transmitted from PC to an input of ADDR1MUX. In Chapter 5, we will see why these elements must be connected as shown in order to execute programs written for the LC-3 computer. For now, just enjoy the fact that the components look familiar. In Chapters 4 and 5, we will raise the level of abstraction again and put these components together into a working computer. 3.1 In the following table, write whether each type of transistor will act as an open circuit or a closed circuit. 0pt10pt N-type P-type Gate=1 Gate=0 3.2 Replace the missing parts in the circuit below with either a wire or no wire to give the output OUT a logical value of 0 when the input IN is a logical 1. < g r a p h i c s > 3.3 A two-input AND and a two-input OR are both examples of two-input logic functions. How many different two-input logic functions are possible? 3.4 Replace the missing parts in the circuit below with either a wire or no wire to give the output C a logical value of 1. Describe a set of inputs that give the output C a logical value of 0. Replace the missing parts with wires or no wires corresponding to that set of inputs. <",
    "179": "transistor will act as an open circuit or a closed circuit. 0pt10pt N-type P-type Gate=1 Gate=0 3.2 Replace the missing parts in the circuit below with either a wire or no wire to give the output OUT a logical value of 0 when the input IN is a logical 1. < g r a p h i c s > 3.3 A two-input AND and a two-input OR are both examples of two-input logic functions. How many different two-input logic functions are possible? 3.4 Replace the missing parts in the circuit below with either a wire or no wire to give the output C a logical value of 1. Describe a set of inputs that give the output C a logical value of 0. Replace the missing parts with wires or no wires corresponding to that set of inputs. < g r a p h i c s > 3.5 Complete a truth table for the transistor-level circuit in Figure 3.34. < g r a p h i c s > Diagram for Exercise 3.5 3.6 For the transistor-level circuit in Figure 3.35, fill in the truth table. What is Z in terms of A and B? 0pt10ptA0pt10pt B C D Z 0pt10pt < g r a p h i c s > Diagram for Exercise 3.6 3.7 The circuit below has a major flaw. Can you identify it? Hint: Evaluate the circuit for all sets of inputs. < g r a p h i c s > 3.8 The transistor-level circuit below implements the logic equation given below. Label the inputs to all the transistors. < g r a p h i c s > 3.9 What does the following transistor circuit do? < g r a p h i c s > 3.10 For what values of A,B,C,D,E, and F will the output of the 6-input AND gate be 1. < g r a p h i c s > 3.11 A student knew that an inverter contained one P-type transistor and one N-type transistor, but he wired",
    "180": "D Z 0pt10pt < g r a p h i c s > Diagram for Exercise 3.6 3.7 The circuit below has a major flaw. Can you identify it? Hint: Evaluate the circuit for all sets of inputs. < g r a p h i c s > 3.8 The transistor-level circuit below implements the logic equation given below. Label the inputs to all the transistors. < g r a p h i c s > 3.9 What does the following transistor circuit do? < g r a p h i c s > 3.10 For what values of A,B,C,D,E, and F will the output of the 6-input AND gate be 1. < g r a p h i c s > 3.11 A student knew that an inverter contained one P-type transistor and one N-type transistor, but he wired them up wrong, as shown below. < g r a p h i c s > 1.8ex[0pt]What is the value of Out when A=0? 1.8ex[0pt]What is the value of Out when A=1? 3.12 A function is described by the truth table shown on the left below. Your job: Complete the logic implementation shown on the right by adding the appropriate connections. < g r a p h i c s > 3.13 The logic diagram below produces the logical value OUT. < g r a p h i c s > What do the values 0 or 1 for OUT signify? 3.14 The following logic circuits consists of two exclusive-OR gates. Construct the output truth table. #1 0=`height #1 @axhline [c].3 < g r a p h i c s > [c].3 A B C output 2pt 0 0 0 0 0 1 0 1 0 0 1 1 1 0 0 1 0 1 1 1 0 1 1 1 3.15 Fill in the truth table for the logical expression NOT(NOT(A) OR NOT(B)). What single logic gate has the same truth table? =12pt A0pt10.1pt B NOT(NOT(A) OR NOT(B)) 0pt10.1pt00pt10.1pt 0 0 1 1 0 1 1 3.16 Fill in",
    "181": "connections. < g r a p h i c s > 3.13 The logic diagram below produces the logical value OUT. < g r a p h i c s > What do the values 0 or 1 for OUT signify? 3.14 The following logic circuits consists of two exclusive-OR gates. Construct the output truth table. #1 0=`height #1 @axhline [c].3 < g r a p h i c s > [c].3 A B C output 2pt 0 0 0 0 0 1 0 1 0 0 1 1 1 0 0 1 0 1 1 1 0 1 1 1 3.15 Fill in the truth table for the logical expression NOT(NOT(A) OR NOT(B)). What single logic gate has the same truth table? =12pt A0pt10.1pt B NOT(NOT(A) OR NOT(B)) 0pt10.1pt00pt10.1pt 0 0 1 1 0 1 1 3.16 Fill in the truth table for a two-input NOR gate. =12pt A B 0pt10ptA NOR B0pt10.1pt 0pt10.1pt0 0 0 1 1 0 1 1 3.17 a. Draw a transistor-level diagram for a three-input AND gate and a three-input OR gate. Do this by extending the designs from Figures 3.6a and 3.7a. b. Replace the transistors in your diagrams from part a with either a wire or no wire to reflect the circuit's operation when the following inputs are applied. (1)A = 1, B = 0, C = 0 (2)A = 0, B = 0, C = 0 (3)A = 1, B = 1, C = 1 3.18 Following the example of Figure 3.11a, draw the gate-level schematic of a three-input decoder. For each output of this decoder, write the input conditions under which that output will be 1. 3.19 How many output lines will a five-input decoder have? 3.20 How many output lines will a 16-input multiplexer have? How many select lines will this multiplexer have? 3.21 If A and B are four-bit unsigned binary numbers, 0111 and 1011, complete the table obtained when using a two-bit full adder from Figure 3.15 to calculate each bit of the sum, S, of A",
    "182": "either a wire or no wire to reflect the circuit's operation when the following inputs are applied. (1)A = 1, B = 0, C = 0 (2)A = 0, B = 0, C = 0 (3)A = 1, B = 1, C = 1 3.18 Following the example of Figure 3.11a, draw the gate-level schematic of a three-input decoder. For each output of this decoder, write the input conditions under which that output will be 1. 3.19 How many output lines will a five-input decoder have? 3.20 How many output lines will a 16-input multiplexer have? How many select lines will this multiplexer have? 3.21 If A and B are four-bit unsigned binary numbers, 0111 and 1011, complete the table obtained when using a two-bit full adder from Figure 3.15 to calculate each bit of the sum, S, of A and B. Check your answer by adding the decimal value of A and B and comparing the sum with S. Are the answers the same? Why or why not? =12pt C_in 0pt10pt 0 A0pt10pt 0 1 1 1 B 1 0 1 1 S C_ out 3.22 Given the following truth table, generate the gate-level logic circuit, using the implementation algorithm referred to in Section 3.3.4. =12pt A B C 0pt10pt Z0pt10pt 0 0 0 1 0 0 1 0 0 1 0 0 0 1 1 1 1 0 0 0 1 0 1 1 1 1 0 1 1 1 1 0 3.23 a. Given four inputs, A, B, C, and D and one output, Z, create a truth table for a circuit with at least seven input combinations generating 1s at the output. (How many rows will this truth table have?) b. Now that you have a truth table, generate the gate-level logic circuit that implements this truth table. Use the implementation algorithm referred to in Section 3.3.4. 3.24 Implement the following functions using AND, OR, and NOT logic gates. The inputs are A, B, and the output is F. a.F has the value 1 only if",
    "183": "algorithm referred to in Section 3.3.4. =12pt A B C 0pt10pt Z0pt10pt 0 0 0 1 0 0 1 0 0 1 0 0 0 1 1 1 1 0 0 0 1 0 1 1 1 1 0 1 1 1 1 0 3.23 a. Given four inputs, A, B, C, and D and one output, Z, create a truth table for a circuit with at least seven input combinations generating 1s at the output. (How many rows will this truth table have?) b. Now that you have a truth table, generate the gate-level logic circuit that implements this truth table. Use the implementation algorithm referred to in Section 3.3.4. 3.24 Implement the following functions using AND, OR, and NOT logic gates. The inputs are A, B, and the output is F. a.F has the value 1 only if A has the value 0 and B has the value 1. b.F has the value 1 only if A has the value 1 and B has the value 0. c. Use your answers from (a) and (b) to implement a 1-bit adder. The truth table for the 1-bit adder is given below. =12pt A B 0pt10ptSum0pt10pt 0pt1pt 0 0 0 0 1 1 1 0 1 1 1 0 d. Is it possible to create a 4-bit adder (a circuit that will correctly add two 4-bit quantities) using only four copies of the logic diagram from (c)? If not, what information is missing? Hint: When A=1 and B=1, a sum of 0 is produced. What information is lost? 3.25 Logic circuit 1 in Figure 3.36 has inputs A, B, C. Logic circuit 2 in Figure 3.37 has inputs A and B. Both logic circuits have an output D. There is a fundamental difference between the behavioral characteristics of these two circuits. What is it? Hint: What happens when the voltage at input A goes from 0 to 1 in both circuits? < g r a p h i c s > Logic circuit 1 for Exercise 3.19 < g r",
    "184": "0 1 1 1 0 1 1 1 0 d. Is it possible to create a 4-bit adder (a circuit that will correctly add two 4-bit quantities) using only four copies of the logic diagram from (c)? If not, what information is missing? Hint: When A=1 and B=1, a sum of 0 is produced. What information is lost? 3.25 Logic circuit 1 in Figure 3.36 has inputs A, B, C. Logic circuit 2 in Figure 3.37 has inputs A and B. Both logic circuits have an output D. There is a fundamental difference between the behavioral characteristics of these two circuits. What is it? Hint: What happens when the voltage at input A goes from 0 to 1 in both circuits? < g r a p h i c s > Logic circuit 1 for Exercise 3.19 < g r a p h i c s > Logic circuit 2 for Exercise 3.19 3.26 Generate the gate-level logic that implements the following truth table. From the gate-level structure, generate a transistor diagram that implements the logic structure. Verify that the transistor diagram implements the truth table. =12pt 0pt10ptin_00pt10pt in_1 f(in_0, in_1) 0pt10pt00pt10pt 0 1 0 1 0 1 0 1 1 1 1 3.27 You know a byte is 8 bits. We call a 4-bit quantity a nibble. If a byte-addressable memory has a 14-bit address, how many nibbles of storage are in this memory? 3.28 Implement a 4-to-1 mux using only 2-to-1 muxes making sure to properly connect all of the terminals. Remember that you will have 4 inputs, 2 control signals, and 1 output. Write out the truth table for this circuit. 3.29 Given the logic circuit in Figure 3.38, fill in the truth table for the output value Z. =12pt A B C Z0pt10pt 0pt1pt 0 0 0 0 0 1 0 1 0 0 1 1 1 0 0 1 0 1 1 1 0 1 1 1 < g r a p h i c s > Diagram for Exercise 3.23 < g r a",
    "185": "1 1 1 3.27 You know a byte is 8 bits. We call a 4-bit quantity a nibble. If a byte-addressable memory has a 14-bit address, how many nibbles of storage are in this memory? 3.28 Implement a 4-to-1 mux using only 2-to-1 muxes making sure to properly connect all of the terminals. Remember that you will have 4 inputs, 2 control signals, and 1 output. Write out the truth table for this circuit. 3.29 Given the logic circuit in Figure 3.38, fill in the truth table for the output value Z. =12pt A B C Z0pt10pt 0pt1pt 0 0 0 0 0 1 0 1 0 0 1 1 1 0 0 1 0 1 1 1 0 1 1 1 < g r a p h i c s > Diagram for Exercise 3.23 < g r a p h i c s > Diagram for Exercise 3.24 3.30 a. Figure 3.39 shows a logic circuit that appears in many of today's processors. Each of the boxes is a full-adder circuit. What does the value on the wire X do? That is, what is the difference in the output of this circuit if X=0 versus if X=1? b. Construct a logic diagram that implements an adder/subtracter. That is, the logic circuit will compute A+B or A-B depending on the value of X. Hint: Use the logic diagram of Figure 3.39 as a building block. 3.31 Say the speed of a logic structure depends on the largest number of logic gates through which any of the inputs must propagate to reach an output. Assume that a NOT, an AND, and an OR gate all count as one gate delay. For example, the propagation delay for a two-input decoder shown in Figure 3.11 is 2 because some inputs propagate through two gates. a. What is the propagation delay for the two-input mux shown in Figure 3.12? b. What is the propagation delay for the 1-bit full adder in Figure 3.15? c. What is the propagation delay for the 4-bit adder",
    "186": "Construct a logic diagram that implements an adder/subtracter. That is, the logic circuit will compute A+B or A-B depending on the value of X. Hint: Use the logic diagram of Figure 3.39 as a building block. 3.31 Say the speed of a logic structure depends on the largest number of logic gates through which any of the inputs must propagate to reach an output. Assume that a NOT, an AND, and an OR gate all count as one gate delay. For example, the propagation delay for a two-input decoder shown in Figure 3.11 is 2 because some inputs propagate through two gates. a. What is the propagation delay for the two-input mux shown in Figure 3.12? b. What is the propagation delay for the 1-bit full adder in Figure 3.15? c. What is the propagation delay for the 4-bit adder shown in Figure 3.16? d. What if the 4-bit adder were extended to 32 bits? 3.32 Recall that the adder was built with individual “ slices” that produced a sum bit and carryout bit based on the two operand bits A and B and the carryin bit. We called such an element a full adder. Suppose we have a 3-to-8 decoder and two six-input OR gates, as shown below. Can we connect them so that we have a full adder? If so, please do. ( Hint: If an input to an OR gate is not needed, we can simply put an input 0 on it and it will have no effect on anything. For example, see the figure below.) < g r a p h i c s > 3.33 For this question, refer to the figure below. < g r a p h i c s > a. Describe the output of this logic circuit when the select line S is a logical 0. That is, what is the output Z for each value of A? b. If the select line S is switched from a logical 0 to 1, what will the output be? c. Is this logic",
    "187": "decoder and two six-input OR gates, as shown below. Can we connect them so that we have a full adder? If so, please do. ( Hint: If an input to an OR gate is not needed, we can simply put an input 0 on it and it will have no effect on anything. For example, see the figure below.) < g r a p h i c s > 3.33 For this question, refer to the figure below. < g r a p h i c s > a. Describe the output of this logic circuit when the select line S is a logical 0. That is, what is the output Z for each value of A? b. If the select line S is switched from a logical 0 to 1, what will the output be? c. Is this logic circuit a storage element? 3.34 Having designed a binary adder, you are now ready to design a 2-bit by 2-bit unsigned binary multiplier. The multiplier takes two 2-bit inputs A[1:0] and B[1:0] and produces an output Y which is the product of A[1:0] and B[1:0]. The standard notation for this is: Y= A[1:0] · B[1:0] a. What is the maximum value that can be represented in 2 bits for A(A[1:0])? b. What is the maximum value that can be represented in 2 bits for B(B[1:0])? c. What is the maximum possible value of Y? d. What is the number of required bits to represent the maximum value of Y? e. Write a truth table for the multiplier described above. You will have a four-input truth table with the inputs being A[1], A[0], B[1], and B[0]. f. Implement the third bit of output, Y[2] from the truth table using only AND, OR, and NOT gates. 3.35 A 16-bit register contains a value. The value x75A2 is written into it. Can the original value be recovered? 3.36 A comparator circuit has two 1-bit inputs A and B and three 1-bit outputs G (greater), E (Equal), and L (less than). Refer to Figures",
    "188": "value that can be represented in 2 bits for A(A[1:0])? b. What is the maximum value that can be represented in 2 bits for B(B[1:0])? c. What is the maximum possible value of Y? d. What is the number of required bits to represent the maximum value of Y? e. Write a truth table for the multiplier described above. You will have a four-input truth table with the inputs being A[1], A[0], B[1], and B[0]. f. Implement the third bit of output, Y[2] from the truth table using only AND, OR, and NOT gates. 3.35 A 16-bit register contains a value. The value x75A2 is written into it. Can the original value be recovered? 3.36 A comparator circuit has two 1-bit inputs A and B and three 1-bit outputs G (greater), E (Equal), and L (less than). Refer to Figures 3.40 and 3.41 for this problem. G is 1 if A>B E is 1 if A=B L is 1 if A<B 0 otherwise 0 otherwise 0 otherwise < g r a p h i c s > Diagram for Exercise 3.30 < g r a p h i c s > Diagram for Exercise 3.30 a. Draw the truth table for a 1-bit comparator. =6pt 0pt10pt A B G E L 0 0 0 1 1 0 1 1 b. Implement G, E, and L using AND, OR, and NOT gates. c. Using the 1-bit comparator as a basic building block, construct a four-bit equality checker, such that output EQUAL is 1 if A[3:0]= B[3:0], 0 otherwise. 3.37 If a computer has eight-byte addressability and needs three bits to access a location in memory, what is the total size of memory in bytes? 3.38 Distinguish between a memory address and the memory's addressability. 3.39 Using Figure 3.21, the diagram of the 4-entry, 2^2-by-3-bit memory. a. To read from the fourth memory location, what must the values of A[1:0] and WE be? b. To change the number of entries in the memory from 4 to 60, how many address lines would",
    "189": "for a 1-bit comparator. =6pt 0pt10pt A B G E L 0 0 0 1 1 0 1 1 b. Implement G, E, and L using AND, OR, and NOT gates. c. Using the 1-bit comparator as a basic building block, construct a four-bit equality checker, such that output EQUAL is 1 if A[3:0]= B[3:0], 0 otherwise. 3.37 If a computer has eight-byte addressability and needs three bits to access a location in memory, what is the total size of memory in bytes? 3.38 Distinguish between a memory address and the memory's addressability. 3.39 Using Figure 3.21, the diagram of the 4-entry, 2^2-by-3-bit memory. a. To read from the fourth memory location, what must the values of A[1:0] and WE be? b. To change the number of entries in the memory from 4 to 60, how many address lines would be needed? What would the addressability of the memory be after this change was made? c. Suppose the minimum width (in bits) of the program counter (the program counter is a special register within a CPU, and we will discuss it in detail in the next chapter) is the minimum number of bits needed to address all 60 locations in our memory from part (b). How many additional memory locations could be added to this memory without having to alter the width of the program counter? 3.40 For the memory shown in Figure 3.42: a. What is the address space? b. What is the addressability? c. What is the data at address 2? 36pc < g r a p h i c s > Diagram for Exercise 3.34 3.41 Given a memory that is addressed by 22 bits and is 3-bit addressable, how many bits of storage does the memory contain? 3.42 A combinational logic circuit has two inputs. The values of those two inputs during the past ten cycles were 01, 10, 11, 01, 10, 11, 01, 10, 11, and 01. The values of these two inputs during the current cycle are 10. Explain the effect on the current",
    "190": "our memory from part (b). How many additional memory locations could be added to this memory without having to alter the width of the program counter? 3.40 For the memory shown in Figure 3.42: a. What is the address space? b. What is the addressability? c. What is the data at address 2? 36pc < g r a p h i c s > Diagram for Exercise 3.34 3.41 Given a memory that is addressed by 22 bits and is 3-bit addressable, how many bits of storage does the memory contain? 3.42 A combinational logic circuit has two inputs. The values of those two inputs during the past ten cycles were 01, 10, 11, 01, 10, 11, 01, 10, 11, and 01. The values of these two inputs during the current cycle are 10. Explain the effect on the current output due to the values of the inputs during the previous ten cycles. 3.43 In the case of the lock of Figure 3.24a, there are four states A, B, C, and D, as described in Section 3.6.2. Either the lock is open (State D), or if it is not open, we have already performed either zero (State A), one (State B), or two (State C) correct operations. This is the sum total of all possible states that can exist. Exercise: Why is that the case? That is, what would be the snapshot of a fifth state that describes a possible situation for the combination lock? 3.44 Recall Section 3.6.2. Can one have an arc from a state where the score is Texas 30, Oklahoma 28 to a state where the score is tied, Texas 30, Oklahoma 30? Draw an example of the scoreboards (like the one in Figure 3.25) for the two states. 3.45 Recall again Section 3.6.2. Is it possible to have two states, one where Texas is ahead 30-28 and the other where the score is tied 30-30, but no arc between the two? Draw an example of two scoreboards, one where the score is 30-28 and the",
    "191": "B), or two (State C) correct operations. This is the sum total of all possible states that can exist. Exercise: Why is that the case? That is, what would be the snapshot of a fifth state that describes a possible situation for the combination lock? 3.44 Recall Section 3.6.2. Can one have an arc from a state where the score is Texas 30, Oklahoma 28 to a state where the score is tied, Texas 30, Oklahoma 30? Draw an example of the scoreboards (like the one in Figure 3.25) for the two states. 3.45 Recall again Section 3.6.2. Is it possible to have two states, one where Texas is ahead 30-28 and the other where the score is tied 30-30, but no arc between the two? Draw an example of two scoreboards, one where the score is 30-28 and the other where the score is 30-30, but there can be no arc between the two. For each of the three output values, game in progress, Texas wins, Oklahoma wins, draw an example of a scoreboard that corresponds to a state that would produce that output. 3.46 Refer to Section 3.6.2. Draw a partial finite state machine for the game of tic-tac-toe. 3.47 The IEEE campus society office sells sodas for 35 cents. Suppose they install a soda controller that only takes the following three inputs: nickel, dime, and quarter. After you put in each coin, you push a pushbutton to register the coin. If at least 35 cents has been put in the controller, it will output a soda and proper change (if applicable). Draw a finite state machine that describes the behavior of the soda controller. Each state will represent how much money has been put in ( Hint: There will be seven of these states). Once enough money has been put in, the controller will go to a final state where the person will receive a soda and proper change ( Hint: There are five such final states). From the final state, the next coin that is put",
    "192": "tic-tac-toe. 3.47 The IEEE campus society office sells sodas for 35 cents. Suppose they install a soda controller that only takes the following three inputs: nickel, dime, and quarter. After you put in each coin, you push a pushbutton to register the coin. If at least 35 cents has been put in the controller, it will output a soda and proper change (if applicable). Draw a finite state machine that describes the behavior of the soda controller. Each state will represent how much money has been put in ( Hint: There will be seven of these states). Once enough money has been put in, the controller will go to a final state where the person will receive a soda and proper change ( Hint: There are five such final states). From the final state, the next coin that is put in will start the process again. 3.48 Refer to Figure 3.32b. Why are lights 1 and 2 controlled by the output of the OR gate labeled Z? Why is the next state of storage element 2 controlled by the output of the OR gate labeled U? 3.49 Shown in Figure 3.43 is an implementation of a finite state machine with an input X and output Z. a. Complete the rest of the following table. S1, S0 specifies the present state. D1, D0 specifies the next state. < g r a p h i c s > Diagram for Exercise 3.43 0pt10ptS10pt10pt S0 X D1 D0 Z 0 0 0 0 0 1 0 1 0 0 1 1 1 0 1 1 0 0 1 0 1 1 1 0 1 1 1 b. Draw the state diagram for the truth table from part a. 3.50 Prove that the NAND gate, by itself, is logically complete (see Section 3.3.5) by constructing a logic circuit that performs the AND function, a logic circuit that performs the NOT function, and a logic circuit that performs the OR function. Use only NAND gates in these three logic circuits. 3.51 We have learned that",
    "193": "an input X and output Z. a. Complete the rest of the following table. S1, S0 specifies the present state. D1, D0 specifies the next state. < g r a p h i c s > Diagram for Exercise 3.43 0pt10ptS10pt10pt S0 X D1 D0 Z 0 0 0 0 0 1 0 1 0 0 1 1 1 0 1 1 0 0 1 0 1 1 1 0 1 1 1 b. Draw the state diagram for the truth table from part a. 3.50 Prove that the NAND gate, by itself, is logically complete (see Section 3.3.5) by constructing a logic circuit that performs the AND function, a logic circuit that performs the NOT function, and a logic circuit that performs the OR function. Use only NAND gates in these three logic circuits. 3.51 We have learned that we can write one bit of information with a logic circuit called a transparent latch, and that the bit written is available to be read almost immediately after being written. Sometimes it is useful to be able to store a bit, but not be able to read the value of that bit until the next cycle. An example of a logic circuit that has this property is a . 3.52 A student decided to design a latch as shown below. For what values of A and B will the latch remain in the quiescent state (i.e., its output will not change)? < g r a p h i c s > 3.53STAR The Master-Slave flip-flop we introduced in the chapter is shown below. Note that the input value is visible at the output after the clock transitions from 0 to 1. < g r a p h i c s > Shown below is a circuit constructed with three of these flip-flops. < g r a p h i c s > Fill in the entries for D2, D1, D0 for each of clock cycles shown < g r a p h i c s > In 10 words or",
    "194": "logic circuit that has this property is a . 3.52 A student decided to design a latch as shown below. For what values of A and B will the latch remain in the quiescent state (i.e., its output will not change)? < g r a p h i c s > 3.53STAR The Master-Slave flip-flop we introduced in the chapter is shown below. Note that the input value is visible at the output after the clock transitions from 0 to 1. < g r a p h i c s > Shown below is a circuit constructed with three of these flip-flops. < g r a p h i c s > Fill in the entries for D2, D1, D0 for each of clock cycles shown < g r a p h i c s > In 10 words or less, what is this circuit doing? 3.54STAR An 8-to-1 mux (shown below) outputs one of the eight sources, A, B, C, D, E, F, G, H depending on S[2:0], as shown. Note the value of S[2:0] corresponding to each source is shown just below the input to the mux. For example, when S[2:0] = 001, B is provided to the output. < g r a p h i c s > We can implement an 8-to-1 mux with a logic circuit of 2-to-1 muxes, as shown below. In this case, the 0 and 1 below the two inputs to each mux correspond to the value of the select line that will cause that input to be provided to the output of that mux. Note that only two of the sources are shown. Note also that none of the select bits are labeled. Your task: finish the job. Part a Label the select line of each mux, according to whether it is S[2], S[1], or S[0]. Part b Label the remaining six sources to the 2-to-1 mux circuit, so the circuit behaves exactly like the 8-to-1 mux shown above. < g r a p h i c s > 3.55STAR We",
    "195": "output. < g r a p h i c s > We can implement an 8-to-1 mux with a logic circuit of 2-to-1 muxes, as shown below. In this case, the 0 and 1 below the two inputs to each mux correspond to the value of the select line that will cause that input to be provided to the output of that mux. Note that only two of the sources are shown. Note also that none of the select bits are labeled. Your task: finish the job. Part a Label the select line of each mux, according to whether it is S[2], S[1], or S[0]. Part b Label the remaining six sources to the 2-to-1 mux circuit, so the circuit behaves exactly like the 8-to-1 mux shown above. < g r a p h i c s > 3.55STAR We wish to implement two logic functions Y(a,b,c) and Z(a,b). Y is 1 in exactly those cases where an odd number of a, b, and c equal 1. Z is the exclusive-OR of a and b. Part a Construct the truth tables for Y and Z. a b c Y Z 0 0 0 0 0 1 0 1 0 0 1 1 1 0 0 1 0 1 1 1 0 1 1 1 Part b : Implement the two logic functions Y and Z described above using ONLY the logic circuits provided below: a 3-to-8 decoder and two OR gates. That is, draw the wires from the outputs of the decoder to the inputs of the OR gates as necessary to do the job. You can assume you have as many inputs to each OR gate as you find necessary. < g r a p h i c s > 3.56STAR Shown below is the partially completed state diagram of a finite state machine that takes an input string of H (heads) and T (tails) and produces an output of 1 every time the string HTHH occurs. < g r a p h i c s > For example,",
    "196": "1 1 1 0 0 1 0 1 1 1 0 1 1 1 Part b : Implement the two logic functions Y and Z described above using ONLY the logic circuits provided below: a 3-to-8 decoder and two OR gates. That is, draw the wires from the outputs of the decoder to the inputs of the OR gates as necessary to do the job. You can assume you have as many inputs to each OR gate as you find necessary. < g r a p h i c s > 3.56STAR Shown below is the partially completed state diagram of a finite state machine that takes an input string of H (heads) and T (tails) and produces an output of 1 every time the string HTHH occurs. < g r a p h i c s > For example, if the input string is: H H H H H T H H T H H H H H T H H T, the output would be: 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1 0. Note that the 8^th coin toss (H) is part of two HTHH sequences. Part a: Complete the state diagram of the finite state machine that will do this for any input sequence of any length. Part b: If we decide to implement this finite state machine with a sequential logic circuit (similar to the danger sign we designed in class), how many state variables would we need? 3.57STAR Shown below is a state diagram for a 4 state machine, and the truth table showing the behavior of this state machine. Some of the entries in both are missing. Note that the states are labeled 00, 01, 10, and 11 and the output of each state Z (0 or 1) is shown in each state. The input is shown as X. Your job, complete both the truth table and the state machine. S[1] S[0] X S'[1] S'[0] Z 0 0 0 0 0 1 1 1",
    "197": "Complete the state diagram of the finite state machine that will do this for any input sequence of any length. Part b: If we decide to implement this finite state machine with a sequential logic circuit (similar to the danger sign we designed in class), how many state variables would we need? 3.57STAR Shown below is a state diagram for a 4 state machine, and the truth table showing the behavior of this state machine. Some of the entries in both are missing. Note that the states are labeled 00, 01, 10, and 11 and the output of each state Z (0 or 1) is shown in each state. The input is shown as X. Your job, complete both the truth table and the state machine. S[1] S[0] X S'[1] S'[0] Z 0 0 0 0 0 1 1 1 0 1 0 0 1 1 1 1 0 0 0 1 0 1 0 1 1 1 0 0 0 1 1 1 < g r a p h i c s > 3.58STAR The transistor circuit shown below produces the accompanying truth table. The inputs to some of the gates of the transistors are not specified. Also, the outputs for some of the input combinations of the truth table are not specified. Your job: Complete both specifications. i.e., all transistors will have their gates properly labeled with either A, B, or C, and all rows of the truth table will have a 0 or 1 specified as the output. Note that this is not a problematic circuit. For every input combination, either the output is connected to ground (i.e., OUT=0) or to the positive end of the battery (i.e., OUT=1). < g r a p h i c s > A B C OUT 0 0 0 0 0 1 0 1 0 0 1 1 1 1 0 0 1 1 0 1 0 1 1 0 1 1 1 3.59STAR Most word processors will correct simple errors in spelling and grammar. Your job is to specify",
    "198": "outputs for some of the input combinations of the truth table are not specified. Your job: Complete both specifications. i.e., all transistors will have their gates properly labeled with either A, B, or C, and all rows of the truth table will have a 0 or 1 specified as the output. Note that this is not a problematic circuit. For every input combination, either the output is connected to ground (i.e., OUT=0) or to the positive end of the battery (i.e., OUT=1). < g r a p h i c s > A B C OUT 0 0 0 0 0 1 0 1 0 0 1 1 1 1 0 0 1 1 0 1 0 1 1 0 1 1 1 3.59STAR Most word processors will correct simple errors in spelling and grammar. Your job is to specify a finite state machine that will capitalize the personal pronoun I in certain instances if it is entered as a lower case i. For example, i think i'm in love will be corrected to I think I'm in love. Input to your finite state machine will be any sequence of characters from a standard keyboard. Your job is to replace the i with an I if the i is the first character input or is preceded by a *space*, and the i is followed by a *space* or by an *apostrophe*. Shown below is a finite state machine with some of the inputs and some of the outputs unspecified. Your job is to complete the specification. Inputs are from the set {i, A, S, O}, where A represents an apostrophe, S represents a space, O represents any character other than i, apostrophe, or *space*. The output Z corresponding to each state is 0 or 1, where 0 means “do nothing,\" 1 means “change the most recent i to an I.\" Note: this exercise in developing a finite state machine word processor is only a first step since a lot of “i to I\" will not fix the problem. For example,",
    "199": "the i with an I if the i is the first character input or is preceded by a *space*, and the i is followed by a *space* or by an *apostrophe*. Shown below is a finite state machine with some of the inputs and some of the outputs unspecified. Your job is to complete the specification. Inputs are from the set {i, A, S, O}, where A represents an apostrophe, S represents a space, O represents any character other than i, apostrophe, or *space*. The output Z corresponding to each state is 0 or 1, where 0 means “do nothing,\" 1 means “change the most recent i to an I.\" Note: this exercise in developing a finite state machine word processor is only a first step since a lot of “i to I\" will not fix the problem. For example, i' am —> I' am, i'abcd —> I'abcd, and i'i —> I'i are all bad! But it is a first step! < g r a p h i c s > 3.60STAR A finite state machine is connected to a 2^3 by 2 bit memory as shown below: < g r a p h i c s > The contents of the memory are shown below to the left. The next state transition table is shown below to the right. t]c||c Address Content A[2:0] D[1:0] 000 11 001 10 010 01 011 10 100 01 101 00 110 00 111 01 t]c||c|c|c|c Current State 4cNext State S[2:0] D[1:0] D[1:0] D[1:0] D[1:0] 00 01 10 11 000 001 010 110 100 001 100 000 011 110 010 010 100 111 010 011 001 100 100 010 100 110 011 011 111 101 100 010 100 110 110 001 110 100 010 111 000 101 111 101 The output Z0, Z1, Z2 is the current state of the finite state machine. That is, Z0=S0, Z1=S1, Z2=S2. The cycle time of the finite state machine is long enough so that during a single cycle, the following happens: the output of the finite state",
    "200": "of the memory are shown below to the left. The next state transition table is shown below to the right. t]c||c Address Content A[2:0] D[1:0] 000 11 001 10 010 01 011 10 100 01 101 00 110 00 111 01 t]c||c|c|c|c Current State 4cNext State S[2:0] D[1:0] D[1:0] D[1:0] D[1:0] 00 01 10 11 000 001 010 110 100 001 100 000 011 110 010 010 100 111 010 011 001 100 100 010 100 110 011 011 111 101 100 010 100 110 110 001 110 100 010 111 000 101 111 101 The output Z0, Z1, Z2 is the current state of the finite state machine. That is, Z0=S0, Z1=S1, Z2=S2. The cycle time of the finite state machine is long enough so that during a single cycle, the following happens: the output of the finite state machine accesses the memory and the data supplied by the memory is input to the combinational logic which determines the next state of the machine. [b]0.5 Part a: Complete the table below. t]c|@c@|@c@ Cycles State Data Cycle 0 000 11 Cycle 1 Cycle 2 Cycle 3 Part b: What will the state of the FSM be just before the end of cycle 100? Why? 3.61STAR The logic diagram shown below is a finite state machine. < g r a p h i c s > a. Construct the truth table for the combinational logic: S1 S0 X Z S1' S0' 0 0 0 0 0 1 0 1 0 0 1 1 1 0 0 1 0 1 1 1 0 1 1 1 b. Complete the state machine (We have provided nine states. You will not need all of them. Use only as many as you need): < g r a p h i c s > 3.62STAR You are taking three courses, one each in computing (C), engineering (E), and math (M). In each course, you periodically receive assignments. You never receive more than one assignment at a time. You also never receive another assignment in a course",
    "201": "of cycle 100? Why? 3.61STAR The logic diagram shown below is a finite state machine. < g r a p h i c s > a. Construct the truth table for the combinational logic: S1 S0 X Z S1' S0' 0 0 0 0 0 1 0 1 0 0 1 1 1 0 0 1 0 1 1 1 0 1 1 1 b. Complete the state machine (We have provided nine states. You will not need all of them. Use only as many as you need): < g r a p h i c s > 3.62STAR You are taking three courses, one each in computing (C), engineering (E), and math (M). In each course, you periodically receive assignments. You never receive more than one assignment at a time. You also never receive another assignment in a course if you currently have an assignment in that course that has not been completed. You must procrastinate (i.e., do nothing) unless you have unfinished assignments in both computing and engineering. Design a finite state machine to describe the state of the work you have to do and whether you are working or procrastinating. Part a Label each state with the unfinished assignments (with letters C,E,M) for when you are in that state. There are far more states provided than you actually need. Use only what you need. Part b There are six inputs: c, e, m, c, e, m. c, e, m refer to you receiving an assignment. c, e, m refer to you completing an assignment. Draw the transition arc for each state/input pair. For example, if you had previously only had an unfinished assignment in Math and you received an assignment in computing, you would transistion from state M to state CM, as shown below. Part c The output of each state is your behavior, 1 if you are working on an assignment, 0 if you are procrastinating. Label the outputs of each state. < g r a p h i c s > ..//art/ch02/,..//art/designelements/,..//art/designelements/UnNumberedArt/makechapterhead#1 @ (0,0) (432,-577)",
    "202": "unfinished assignments (with letters C,E,M) for when you are in that state. There are far more states provided than you actually need. Use only what you need. Part b There are six inputs: c, e, m, c, e, m. c, e, m refer to you receiving an assignment. c, e, m refer to you completing an assignment. Draw the transition arc for each state/input pair. For example, if you had previously only had an unfinished assignment in Math and you received an assignment in computing, you would transistion from state M to state CM, as shown below. Part c The output of each state is your behavior, 1 if you are working on an assignment, 0 if you are procrastinating. Label the outputs of each state. < g r a p h i c s > ..//art/ch02/,..//art/designelements/,..//art/designelements/UnNumberedArt/makechapterhead#1 @ (0,0) (432,-577) < g r a p h i c s > (428,-577)1@9.52667in(381.5,-181) < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > 1212chapter 1212chapter 7212 3032#1 36.4pc4@ CHAPTER: BITS, DATA TYPES, AND OPERATIONS § BITS AND DATA TYPES §.§ The Bit as the Unit of Information We noted in Chapter 1 that the computer was organized as a system with several levels of transformation. A problem stated in a natural language such as English is actually solved by the electrons moving around inside the components of the computer. Inside the computer, millions of very tiny, very fast devices control the movement of those electrons. These devices react to the presence or absence of voltages in electronic circuits. They could react to the actual values of the voltages, rather than simply to the presence or absence of voltages. However, this would make the control and detection circuits more complex than they need to be. It is much easier to detect simply whether",
    "203": "> 1212chapter 1212chapter 7212 3032#1 36.4pc4@ CHAPTER: BITS, DATA TYPES, AND OPERATIONS § BITS AND DATA TYPES §.§ The Bit as the Unit of Information We noted in Chapter 1 that the computer was organized as a system with several levels of transformation. A problem stated in a natural language such as English is actually solved by the electrons moving around inside the components of the computer. Inside the computer, millions of very tiny, very fast devices control the movement of those electrons. These devices react to the presence or absence of voltages in electronic circuits. They could react to the actual values of the voltages, rather than simply to the presence or absence of voltages. However, this would make the control and detection circuits more complex than they need to be. It is much easier to detect simply whether or not a voltage exists at a point in a circuit than it is to measure exactly what that voltage is. To understand this, consider any wall outlet in your home. You could measure the exact voltage it is carrying, whether 120 volts or 115 volts, or 118.6 volts, for example. However, the detection circuitry to determine only whether there is a voltage or whether there is no voltage is much simpler. Your finger casually inserted into the wall socket, for example, will suffice. We symbolically represent the presence of a voltage as “1” and the absence of a voltage as “0.” We refer to each 0 and each 1 as a “bit,” which is a shortenedbitbinary digit form of binary digit. Recall the digits you have been using since you were a child—0,1,2,3,…,9. There are 10 of them, and they are referred to as decimal digits. In the case of binary digits, there are two of them, 0 and 1. To be perfectly precise, it is not really the case that the computer differentiates the absolute absence of a voltage (that is, 0) from the absolute presence of a voltage (that is, 1). Actually, the electronic circuits in the",
    "204": "is a voltage or whether there is no voltage is much simpler. Your finger casually inserted into the wall socket, for example, will suffice. We symbolically represent the presence of a voltage as “1” and the absence of a voltage as “0.” We refer to each 0 and each 1 as a “bit,” which is a shortenedbitbinary digit form of binary digit. Recall the digits you have been using since you were a child—0,1,2,3,…,9. There are 10 of them, and they are referred to as decimal digits. In the case of binary digits, there are two of them, 0 and 1. To be perfectly precise, it is not really the case that the computer differentiates the absolute absence of a voltage (that is, 0) from the absolute presence of a voltage (that is, 1). Actually, the electronic circuits in the computer differentiate voltages close to 0 from voltages far from 0. So, for example, if the computer expects either a voltage of 1.2 volts or a voltage of 0 volts (1.2 volts signifying 1 and 0 volts signifying 0), then a voltage of 1.0 volts will be taken as a 1 and 0.2 volts will be taken as a 0. With one wire, one can differentiate only two things. One of them can be assigned the value 0, the other can be assigned the value 1. But to get useful work done by the computer, it is necessary to be able to diffentiate a large number of distinct values, and to assign each of them a unique representation. We can accomplish this by combining many wires, i.e., many bits. [-18pt] For example, if we use eight bits (corresponding to the voltage present on each of eight wires), we can represent one particular value as 01001110, and another value as 11100111. In fact, if we are limited to eight bits, we can differentiate at most only 256 (that is, 2^8) different things. In general, with k bits, we can distinguish at most 2^k distinct items. Each pattern of these k bits",
    "205": "With one wire, one can differentiate only two things. One of them can be assigned the value 0, the other can be assigned the value 1. But to get useful work done by the computer, it is necessary to be able to diffentiate a large number of distinct values, and to assign each of them a unique representation. We can accomplish this by combining many wires, i.e., many bits. [-18pt] For example, if we use eight bits (corresponding to the voltage present on each of eight wires), we can represent one particular value as 01001110, and another value as 11100111. In fact, if we are limited to eight bits, we can differentiate at most only 256 (that is, 2^8) different things. In general, with k bits, we can distinguish at most 2^k distinct items. Each pattern of these k bits is a codecode; that is, it corresponds to a particular item (or value). §.§ Data Types =1 There are many ways to represent the same value. For example, the number five can be written as a 5. This is the standard decimal notation that you are used to. The value five can also be represented by someone holding up one hand, with all fingers and thumb extended. The person is saying, “The number I wish to communicate can be determined by counting the number of fingers I am showing.” A written version of that scheme would be the value 11111. This notation has a name also—unary. The Romans had yet another notation for five—the character V. We will see momentarily that a fourth notation for five is the binary representation 00000101. It is not enough simply to represent values; we must be able to operate on those values. We say a particular representation is a data typedata type if there are operations in the computer that can operate on information that is encoded in that representation. Each instruction set architecture (ISA) has its own set of data types and its own set of instructions that can operate on those data",
    "206": "hand, with all fingers and thumb extended. The person is saying, “The number I wish to communicate can be determined by counting the number of fingers I am showing.” A written version of that scheme would be the value 11111. This notation has a name also—unary. The Romans had yet another notation for five—the character V. We will see momentarily that a fourth notation for five is the binary representation 00000101. It is not enough simply to represent values; we must be able to operate on those values. We say a particular representation is a data typedata type if there are operations in the computer that can operate on information that is encoded in that representation. Each instruction set architecture (ISA) has its own set of data types and its own set of instructions that can operate on those data types. In this book, we will mainly use two data types: 2's complement integers for [-23pt] representing positive and negative integers that we wish to perform arithmetic on, and ASCII codes for representing characters that we wish to input to a computer via the keyboard or output from the computer via a monitor. Both data types will be explained shortly. =1 There are other representations of information that could be used, and indeed that are present in most computers. Recall the “scientific notation” from high school chemistry where you were admonished to represent the decimal number 621 as 6.21· 10^2. There are computers that represent numbers in that form, and they provide operations that can operate on numbers so represented. That data type is usually called floating point. We will examine its representation in Section 2.7.1. § INTEGER DATA TYPES §.§ Unsigned Integers The first representation of information, or data type, that we shall look at is the unsigned integer. As its name suggests, an unsigned integer has no sign (plus or minus) associated with it. An unsigned integer just has a magnitude. Unsigned integers have many uses in a computer. If we wishunsigned integer to perform a task some",
    "207": "=1 There are other representations of information that could be used, and indeed that are present in most computers. Recall the “scientific notation” from high school chemistry where you were admonished to represent the decimal number 621 as 6.21· 10^2. There are computers that represent numbers in that form, and they provide operations that can operate on numbers so represented. That data type is usually called floating point. We will examine its representation in Section 2.7.1. § INTEGER DATA TYPES §.§ Unsigned Integers The first representation of information, or data type, that we shall look at is the unsigned integer. As its name suggests, an unsigned integer has no sign (plus or minus) associated with it. An unsigned integer just has a magnitude. Unsigned integers have many uses in a computer. If we wishunsigned integer to perform a task some specific number of times, unsigned integers enable us to keep track of this number easily by simply counting how many times we have performed the task. Unsigned integers also provide a means for identifying different memory locations in the computer in the same way that house numbers differentiate 129 Main Street from 131 Main Street. I don't recall ever seeing a house number with a minus sign in front of it. We can represent unsigned integers as strings of binary digits. To do this, we use a positional notation much like the decimal system that you have been using since you were three years old. You are familiar with the decimal number 329, which also uses positional notation. The 3 is worth much more than the 9, even though the absolute value of 3 standing alone is only worth 1/3 the value of 9 standing alone. This is because, as you know, the 3 stands for 300 (3· 10^2) due to its position in the decimal string 329, while the 9 stands for 9· 10^0. Instead of using decimal digits we can represent unsigned integers using just the the binary digits 0 and 1. Here the base is 2, rather",
    "208": "a house number with a minus sign in front of it. We can represent unsigned integers as strings of binary digits. To do this, we use a positional notation much like the decimal system that you have been using since you were three years old. You are familiar with the decimal number 329, which also uses positional notation. The 3 is worth much more than the 9, even though the absolute value of 3 standing alone is only worth 1/3 the value of 9 standing alone. This is because, as you know, the 3 stands for 300 (3· 10^2) due to its position in the decimal string 329, while the 9 stands for 9· 10^0. Instead of using decimal digits we can represent unsigned integers using just the the binary digits 0 and 1. Here the base is 2, rather than 10. So, for example, if we have five bits (binary digits) available to represent our values, the number 5, which we menioned earlier, is represented as 00101, corresponding to 0· 2^4+0 · 2^3+1· 2^2+0· 2^1+1· 2^0 With k bits, we can represent in this positional notation exactly 2^k integers, ranging from 0 to 2^k-1. Figure <ref> shows the five-bit representations for the integers from 0 to 31. Representation Value Represented 5@l@ 0pt10pt Unsigned Signed Magnitude 1's Complement 2's Complement 00000 0 0 0 0 00001 1 1 1 1 00010 2 2 2 2 00011 3 3 3 3 00100 4 4 4 4 00101 5 5 5 5 00110 6 6 6 6 00111 7 7 7 7 01000 8 8 8 8 01001 9 9 9 9 01010 10 10 10 10 01011 11 11 11 11 01100 12 12 12 12 01101 13 13 13 13 01110 14 14 14 14 01111 15 15 15 15 10000 16 -0 -15 -16 10001 17 -1 -14 -15 10010 18 -2 -13 -14 10011 19 -3 -12 -13 10100 20 -4 -11 -12 10101 21 -5 -10 -11 10110 22 -6 -9 -10 10111 23 -7 -8 -9",
    "209": "representations for the integers from 0 to 31. Representation Value Represented 5@l@ 0pt10pt Unsigned Signed Magnitude 1's Complement 2's Complement 00000 0 0 0 0 00001 1 1 1 1 00010 2 2 2 2 00011 3 3 3 3 00100 4 4 4 4 00101 5 5 5 5 00110 6 6 6 6 00111 7 7 7 7 01000 8 8 8 8 01001 9 9 9 9 01010 10 10 10 10 01011 11 11 11 11 01100 12 12 12 12 01101 13 13 13 13 01110 14 14 14 14 01111 15 15 15 15 10000 16 -0 -15 -16 10001 17 -1 -14 -15 10010 18 -2 -13 -14 10011 19 -3 -12 -13 10100 20 -4 -11 -12 10101 21 -5 -10 -11 10110 22 -6 -9 -10 10111 23 -7 -8 -9 11000 24 -8 -7 -8 11001 25 -9 -6 -7 11010 26 -10 -5 -6 11011 27 -11 -4 -5 11100 28 -12 -3 -4 11101 29 -13 -2 -3 11110 30 -14 -1 -2 11111 31 -15 -0 -1 Four representations of integers §.§ Signed Integers To do useful arithmetic, however, it is often (although not always) necessary to signed integers be able to deal with negative quantities as well as positive. We could take our 2^k distinct patterns of k bits and separate them in half, half for positive integers, and half for negative integers. In this way, with five-bit codes, instead of representing integers from 0 to +31, we could choose to represent positive integers from +1 to +15 and negative integers from -1 to -15. There are 30 such integers. Since 2^5 is 32, we still have two 5-bit codes unassigned. One of them, 00000, we would presumably assign to the value 0, giving us the full range of integer values from -15 to +15. That leaves one five-bit code left over, and there are different ways to assign this code, as we will see momentarily. We are still left with the problem of determining what",
    "210": "signed integers be able to deal with negative quantities as well as positive. We could take our 2^k distinct patterns of k bits and separate them in half, half for positive integers, and half for negative integers. In this way, with five-bit codes, instead of representing integers from 0 to +31, we could choose to represent positive integers from +1 to +15 and negative integers from -1 to -15. There are 30 such integers. Since 2^5 is 32, we still have two 5-bit codes unassigned. One of them, 00000, we would presumably assign to the value 0, giving us the full range of integer values from -15 to +15. That leaves one five-bit code left over, and there are different ways to assign this code, as we will see momentarily. We are still left with the problem of determining what codes to assign to what values. That is, we have 32 codes, but which value should go with which code? Positive integers are represented in the straightforward positional scheme. Since there are k bits, and we wish to use exactly half of the 2^k codes to represent the integers from 0 to 2^k-1-1, all positive integers will have a leading 0 in their representation. In our example of Figure <ref>, (with k=5), the largest positive integer +15 is represented as 01111. Note that in all three signed data types shown in Figure <ref> , the representation for 0 and all the positive integers start with a leading 0. What about the representations for the negative integers (in our five-bit example, -1 to -15)? The first thought that usually comes to mind is: If a leading 0 signifies a positive-2 integer, how about letting a leading 1 signify a negative integer? The result is the signed-magnitude data type shown in Figure <ref>. A second thought (which was actuallydata type!signed-magnitude used on some early computers such as the Control Data Corporation 6600) was the following: Let a negative number be represented by taking the representation of the positive number having the same",
    "211": "0 in their representation. In our example of Figure <ref>, (with k=5), the largest positive integer +15 is represented as 01111. Note that in all three signed data types shown in Figure <ref> , the representation for 0 and all the positive integers start with a leading 0. What about the representations for the negative integers (in our five-bit example, -1 to -15)? The first thought that usually comes to mind is: If a leading 0 signifies a positive-2 integer, how about letting a leading 1 signify a negative integer? The result is the signed-magnitude data type shown in Figure <ref>. A second thought (which was actuallydata type!signed-magnitude used on some early computers such as the Control Data Corporation 6600) was the following: Let a negative number be represented by taking the representation of the positive number having the same magnitude, and “flipping” all the bits. That is, if the original representation had a 0, replace it with a 1; if it originally had a 1, replace it with a 0. For example, since +5 is represented as 00101, we designate -5 as 11010. This data type is referred to in the computer engineering community as 1's complement, data type!1's complement and is also shown in Figure <ref>. At this point, you might think that a computer designer could assign any bit pattern to represent any integer he or she wants. And you would be right! Unfortunately, that could complicate matters when we try to build an electronic circuit to add two integers. In fact, the signed-magnitude and 1's complement data types both require unnecessarily cumbersome hardware to do addition. Because computer designers knew what it would take to design a circuit to add two integers, they chose representations that simplified the circuit. The result is the 2's complement data type, also shown in Figure <ref>. data type!2's complement It is used on just about every computer manufactured today. -2 § 2'S COMPLEMENT INTEGERS We see in Figure <ref> the representations of the integers from -16 to +15 for the",
    "212": "complement and is also shown in Figure <ref>. At this point, you might think that a computer designer could assign any bit pattern to represent any integer he or she wants. And you would be right! Unfortunately, that could complicate matters when we try to build an electronic circuit to add two integers. In fact, the signed-magnitude and 1's complement data types both require unnecessarily cumbersome hardware to do addition. Because computer designers knew what it would take to design a circuit to add two integers, they chose representations that simplified the circuit. The result is the 2's complement data type, also shown in Figure <ref>. data type!2's complement It is used on just about every computer manufactured today. -2 § 2'S COMPLEMENT INTEGERS We see in Figure <ref> the representations of the integers from -16 to +15 for the 2's complement data type. Why were those representations chosen? The positive integers, we saw, are represented in the straightforward positional scheme. With five bits, we use exactly half of the 2^5 codes to represent 0 and the positive integers from 1 to 2^4-1. The choice of representations for the negative integers was based, as we said previously, on the wish to keep the logic circuits as simple as possible. Almost all computers use the same basic mechanism to perform addition. It is called an arithmetic and logic unit, usually known by its acronym ALU. We will get into the actual structure of the ALU in Chapters 3 and 4. What is relevant right now is that an ALU has two inputs and one output. It performs addition by adding the binary bit patterns at its inputs, producing a bit pattern at its output that is the sum of the two input bit patterns. For example, if the ALU processed five-bit input patterns, and the two inputs were 00110 and 00101, the result (output of the ALU) would be 01011. The addition is as follows: 00110 00101 01011 The addition of two binary strings is performed in the same way addition",
    "213": "to keep the logic circuits as simple as possible. Almost all computers use the same basic mechanism to perform addition. It is called an arithmetic and logic unit, usually known by its acronym ALU. We will get into the actual structure of the ALU in Chapters 3 and 4. What is relevant right now is that an ALU has two inputs and one output. It performs addition by adding the binary bit patterns at its inputs, producing a bit pattern at its output that is the sum of the two input bit patterns. For example, if the ALU processed five-bit input patterns, and the two inputs were 00110 and 00101, the result (output of the ALU) would be 01011. The addition is as follows: 00110 00101 01011 The addition of two binary strings is performed in the same way addition of two decimal strings is performed, from right to left, column by column. If the addition in a column generates a carry, the carry is added to the column immediately to its left. What is particularly relevant is that the binary ALU does not know (and does not care) what the two patterns it is adding represent. It simply adds the two binary patterns. Since the binary ALU only ADDs and does not CARE, it would be nice if our assignment of codes to the integers resulted in the ALU producing correct results when it added two integers. For starters, it would be nice if, when the ALU adds the representation for an arbitrary integer to the representation of the integer having the same magnitude but opposite sign, the sum would be 0. That is, if the inputs to the ALU are the representations of non-zero integers A and -A, the output of the ALU should be 00000. To accomplish that, the 2's complement data type specifies the representation for each negative integer so that when the ALU adds it to the representation of the positive integer of the same magnitude, the result will be the representation for 0. For",
    "214": "the two binary patterns. Since the binary ALU only ADDs and does not CARE, it would be nice if our assignment of codes to the integers resulted in the ALU producing correct results when it added two integers. For starters, it would be nice if, when the ALU adds the representation for an arbitrary integer to the representation of the integer having the same magnitude but opposite sign, the sum would be 0. That is, if the inputs to the ALU are the representations of non-zero integers A and -A, the output of the ALU should be 00000. To accomplish that, the 2's complement data type specifies the representation for each negative integer so that when the ALU adds it to the representation of the positive integer of the same magnitude, the result will be the representation for 0. For example, since 00101 is the representation of +5, 11011 is chosen as the representation for -5. Moreover, and actually more importantly, as we sequence through representations of -15 to +15, the ALU is adding 00001 to each successive representation. We can express this mathematically as: REPRESENTATION(value+1)= REPRESENTATION(value) + REPRESENTATION(1). This is sufficient to guarantee (as long as we do not get a result larger than +15 or smaller than -15) that the binary ALU will perform addition correctly. Note in particular the representations for -1 and 0, that is, 11111 and 00000. When we add 00001 to the representation for -1, we do get 00000, but we also generate a carry. That carry, however, does not influence the result. That is, the correct result of adding 00001 to the representation for -1 is 0, not 100000. Therefore, the carry is ignored. In fact, because the carry obtained by adding 00001 to 11111 is ignored, the carry can always be ignored when dealing with 2's complement arithmetic. Note: If we know the representation for A, a shortcut for figuring out the representation for -A(A0), is as follows: Flip all the bits of A (the official term for “flip” is complement), and",
    "215": "get a result larger than +15 or smaller than -15) that the binary ALU will perform addition correctly. Note in particular the representations for -1 and 0, that is, 11111 and 00000. When we add 00001 to the representation for -1, we do get 00000, but we also generate a carry. That carry, however, does not influence the result. That is, the correct result of adding 00001 to the representation for -1 is 0, not 100000. Therefore, the carry is ignored. In fact, because the carry obtained by adding 00001 to 11111 is ignored, the carry can always be ignored when dealing with 2's complement arithmetic. Note: If we know the representation for A, a shortcut for figuring out the representation for -A(A0), is as follows: Flip all the bits of A (the official term for “flip” is complement), and add 1 to the complement of A. The sum of A and the complement of A is 11111. If we then add 00001 to 11111, the final result is 00000. Thus, the representation for -A can be easily obtained by adding 1 to the complement of A. What is the 2's complement representation for -13? * Let A be +13. Then the representation for A is 01101 since 13 = 8+4+1. * The complement of A is 10010. * Adding 1 to 10010 gives us 10011, the 2's complement representation for -13. We can verify our result by adding the representations for A and -A, 01101 10011 00000 - You may have noticed that the addition of 01101 and 10011, in addition to producing 00000, also produces a carry out of the five-bit ALU. That is, the binary addition of 01101 and 10011 is really 100000. However, as we saw previously, this carry out can be ignored in the case of the 2's complement data type. At this point, we have identified in our five-bit scheme 15 positive integers. We have constructed 15 negative integers. We also have a representation for 0. With k=5, we can uniquely identify 32 distinct",
    "216": "Then the representation for A is 01101 since 13 = 8+4+1. * The complement of A is 10010. * Adding 1 to 10010 gives us 10011, the 2's complement representation for -13. We can verify our result by adding the representations for A and -A, 01101 10011 00000 - You may have noticed that the addition of 01101 and 10011, in addition to producing 00000, also produces a carry out of the five-bit ALU. That is, the binary addition of 01101 and 10011 is really 100000. However, as we saw previously, this carry out can be ignored in the case of the 2's complement data type. At this point, we have identified in our five-bit scheme 15 positive integers. We have constructed 15 negative integers. We also have a representation for 0. With k=5, we can uniquely identify 32 distinct quantities, and we have accounted for only 31 (15+15+1). The remaining representation is 10000. What value shall we assign to it? We note that -1 is 11111, -2 is 11110, -3 is 11101, and so on. If we continue this, we note that -15 is 10001. Note that, as in the case of the positive representations, as we sequence backwards from representations of -1 to -15, the ALU is subtracting 00001 from each successive representation. Thus, it is convenient to assign to 10000 the value -16; that is the value one gets by subtracting 00001 from 10001 (the representation for -15). In Chapter 5 we will specify a computer that we affectionately have named the LC-3 (for Little Computer 3). The LC-3 operates on 16-bit values. Therefore, the 2's complement integers that can be represented in the LC-3 are the integers from -32,768 to +32,767. - § CONVERSION BETWEEN BINARY AND DECIMAL It is often useful to convert numbers between the 2's complement data type the computer likes and the decimal representation that you have used all your life. §.§ Binary to Decimal Conversion We convert a 2's complement representation of an integer binary to decimal conversion to a decimal",
    "217": "from representations of -1 to -15, the ALU is subtracting 00001 from each successive representation. Thus, it is convenient to assign to 10000 the value -16; that is the value one gets by subtracting 00001 from 10001 (the representation for -15). In Chapter 5 we will specify a computer that we affectionately have named the LC-3 (for Little Computer 3). The LC-3 operates on 16-bit values. Therefore, the 2's complement integers that can be represented in the LC-3 are the integers from -32,768 to +32,767. - § CONVERSION BETWEEN BINARY AND DECIMAL It is often useful to convert numbers between the 2's complement data type the computer likes and the decimal representation that you have used all your life. §.§ Binary to Decimal Conversion We convert a 2's complement representation of an integer binary to decimal conversion to a decimal representation as follows: For purposes of illustration, we will assume our number can be represented in eight bits, corresponding to decimal integer values from -128 to +127. Recall that an eight-bit 2's complement integer takes the form b_7 b_6 b_5 b_4 b_3 b_2 b_1 b_0 where each of the bits b_i is either 0 or 1. * Examine the leading bit b_7. If it is a 0, the integer is positive, and we can begin evaluating its magnitude. If it is a 1, the integer is negative. In that case, we need to first obtain the 2's complement representation of the positive number having the same magnitude. We do this by flipping all the bits and adding 1. * The magnitude is simply b_6· 2^6+b_5· 2^5+b_4· 2^4+b_3· 2^3+b_2· 2^2+b_1· 2^1+b_0· 2^0 In either case, we obtain the decimal magnitude by simply adding the powers of 2 that have coefficients of 1. * Finally, if the original number is negative, we affix a minus sign in front. Done! Convert the 2's complement integer 11000111 to a decimal integer value. * Since the leading binary digit is a 1, the number is negative. We must first find the 2's complement representation of",
    "218": "bit b_7. If it is a 0, the integer is positive, and we can begin evaluating its magnitude. If it is a 1, the integer is negative. In that case, we need to first obtain the 2's complement representation of the positive number having the same magnitude. We do this by flipping all the bits and adding 1. * The magnitude is simply b_6· 2^6+b_5· 2^5+b_4· 2^4+b_3· 2^3+b_2· 2^2+b_1· 2^1+b_0· 2^0 In either case, we obtain the decimal magnitude by simply adding the powers of 2 that have coefficients of 1. * Finally, if the original number is negative, we affix a minus sign in front. Done! Convert the 2's complement integer 11000111 to a decimal integer value. * Since the leading binary digit is a 1, the number is negative. We must first find the 2's complement representation of the positive number of the same magnitude. This is 00111001. * The magnitude can be represented as 0· 2^6+1· 2^5+1· 2^4+1· 2^3+0· 2^2+0· 2^1+1· 2^0 or, 32+16+8+1. * The decimal integer value corresponding to 11000111 is -57. §.§ Decimal to Binary Conversion Converting from decimal to 2's complement is a little more complicated. The crux of the decimal to binary conversion method is to note that a positive binary number is odd if the rightmost digit is 1 and even if the rightmost digit is 0. Consider again our generic eight-bit representation: b_7· 2^7+b_6· 2^6+b_5· 2^5+b_4· 2^4+b_3· 2^3+b_2· 2^2+b_1· 2^1+b_0· 2^0 We can illustrate the conversion best by first working through an example. Suppose we wish to convert the value +105 to a 2's complement binary code. We note that +105 is positive. We first find values for b_i, representing the magnitude 105. Since the value is positive, we will then obtain the 2's complement result by simply appending b_7, which we know is 0. Our first step is to find values for b_i that satisfy the following: 105=b_6· 2^6+b_5· 2^5+b_4· 2^4+b_3· 2^3+b_2· 2^2+b_1· 2^1+b_0· 2^0 Since 105 is odd, we know that b_0 is 1. We subtract 1 from",
    "219": "conversion method is to note that a positive binary number is odd if the rightmost digit is 1 and even if the rightmost digit is 0. Consider again our generic eight-bit representation: b_7· 2^7+b_6· 2^6+b_5· 2^5+b_4· 2^4+b_3· 2^3+b_2· 2^2+b_1· 2^1+b_0· 2^0 We can illustrate the conversion best by first working through an example. Suppose we wish to convert the value +105 to a 2's complement binary code. We note that +105 is positive. We first find values for b_i, representing the magnitude 105. Since the value is positive, we will then obtain the 2's complement result by simply appending b_7, which we know is 0. Our first step is to find values for b_i that satisfy the following: 105=b_6· 2^6+b_5· 2^5+b_4· 2^4+b_3· 2^3+b_2· 2^2+b_1· 2^1+b_0· 2^0 Since 105 is odd, we know that b_0 is 1. We subtract 1 from both sides of the equation, yielding 104=b_6· 2^6+b_5· 2^5+b_4· 2^4+b_3· 2^3+b_2· 2^2+b_1· 2^1 We next divide both sides of the equation by 2, yielding 52=b_6· 2^5+b_5· 2^4+b_4· 2^3+b_3· 2^2+b_2· 2^1+b_1· 2^0 Since 52 is even, b_1, the only coefficient not multiplied by a power of 2, must be equal to 0. We iterate this process, each time subtracting the rightmost digit from both sides of the equation, then dividing both sides by 2, and finally noting whether the new decimal number on the left side is odd or even. Continuing where we left off, with 52 =b_6· 2^5+j_5· 2^4+b_4· 2^3+b_3· 2^2+b_2· 2^1 the process produces, in turn: 26 =b_6· 2^4+b_5· 2^3+b_4· 2^2+b_3· 2^1+b_2· 2^0 Therefore, b_2=0. 13 =b_6· 2^3+b_5· 2^2+b_4· 2^1+b_3· 2^0 Therefore, b_3=1. 6 =b_6· 2^2+b_5· 2^1+b_4· 2^0 Therefore, b_4=0. 3 =b_6· 2^1+b_5· 2^0 Therefore, b_5=1. 1 =b_6· 2^0 Therefore, b_6=1, and we are done. The binary representation is 01101001. Let's summarize the process. If we are given a decimal integer value N, we construct the 2's complement representation as follows: * We first obtain the binary representation of the magnitude of N by forming the equation N=b_6· 2^6+b_5· 2^5+b_4· 2^4+b_3· 2^3+b_2· 2^2+b_1· 2^1+b_0· 2^0 and repeating the following,",
    "220": "digit from both sides of the equation, then dividing both sides by 2, and finally noting whether the new decimal number on the left side is odd or even. Continuing where we left off, with 52 =b_6· 2^5+j_5· 2^4+b_4· 2^3+b_3· 2^2+b_2· 2^1 the process produces, in turn: 26 =b_6· 2^4+b_5· 2^3+b_4· 2^2+b_3· 2^1+b_2· 2^0 Therefore, b_2=0. 13 =b_6· 2^3+b_5· 2^2+b_4· 2^1+b_3· 2^0 Therefore, b_3=1. 6 =b_6· 2^2+b_5· 2^1+b_4· 2^0 Therefore, b_4=0. 3 =b_6· 2^1+b_5· 2^0 Therefore, b_5=1. 1 =b_6· 2^0 Therefore, b_6=1, and we are done. The binary representation is 01101001. Let's summarize the process. If we are given a decimal integer value N, we construct the 2's complement representation as follows: * We first obtain the binary representation of the magnitude of N by forming the equation N=b_6· 2^6+b_5· 2^5+b_4· 2^4+b_3· 2^3+b_2· 2^2+b_1· 2^1+b_0· 2^0 and repeating the following, until the left side of the equation is 0: a. If N is odd, the rightmost bit is 1. If N is even, the rightmost bit is 0. b. Subtract 1 or 0 (according to whether N is odd or even) from N, remove the least significant term from the right side, and divide both sides of the equation by 2. Each iteration produces the value of one coefficient b_i. * If the original decimal number is positive, append a leading 0 sign bit, and you are done. * If the original decimal number is negative, append a leading 0 and then form the negative of this 2's complement representation, and then you are done. §.§ Extending conversion to numbers with fractional parts What if the number we wish to convert is not an integer, but instead has a fractional part. How do we handle that wrinkle? binary to decimal The binary to decimal case is straightforward. In a positional notation system, the number 0.b_-1b_-2b_-3b_-4 shows four bits to the right of the binary point, representing (when the corresponding b_i = 1) the values 0.5, 0.25, 0.125, and 0.0625. To complete the conversion to decimal, we simply add those values",
    "221": "2. Each iteration produces the value of one coefficient b_i. * If the original decimal number is positive, append a leading 0 sign bit, and you are done. * If the original decimal number is negative, append a leading 0 and then form the negative of this 2's complement representation, and then you are done. §.§ Extending conversion to numbers with fractional parts What if the number we wish to convert is not an integer, but instead has a fractional part. How do we handle that wrinkle? binary to decimal The binary to decimal case is straightforward. In a positional notation system, the number 0.b_-1b_-2b_-3b_-4 shows four bits to the right of the binary point, representing (when the corresponding b_i = 1) the values 0.5, 0.25, 0.125, and 0.0625. To complete the conversion to decimal, we simply add those values where the corresponding b_i = 1. For example, if the fractional part of the binary representation is . 1 0 1 1 we would add 0.5 plus 0.125 plus 0.0625, or 0.6875. decimal to binary The decimal to binary case requires a little more work. Suppose we wanted to convert 0.421 to binary. As we did for integer conversion, we first form the equation 0.421 = b_-1× 2^-1 + b_-2× 2^-2 + b_-3× 2^-3 + b_-4× 2^-4 + ... In the case of converting a decimal integer value to binary, we divided by 2 and assigned a 1 or 0 to the coefficient of 2^0 depending on whether the number on the left of the equal sign is odd or even. Here (i.e., in the case of converting a decimal fraction to binary), we multiply both sides of the equation by 2 and assign a 1 or a 0 to the coefficient of 2^0 depending on whether the left side of the equation is greater than or equal to 1 or whether the left side is less than 1. Do you see why? Since 0.842 = b_-1× 2^0 + b_-2× 2^-1 + b_-3× 2^-2 + b_-4× 2^-3 + ..., we",
    "222": "first form the equation 0.421 = b_-1× 2^-1 + b_-2× 2^-2 + b_-3× 2^-3 + b_-4× 2^-4 + ... In the case of converting a decimal integer value to binary, we divided by 2 and assigned a 1 or 0 to the coefficient of 2^0 depending on whether the number on the left of the equal sign is odd or even. Here (i.e., in the case of converting a decimal fraction to binary), we multiply both sides of the equation by 2 and assign a 1 or a 0 to the coefficient of 2^0 depending on whether the left side of the equation is greater than or equal to 1 or whether the left side is less than 1. Do you see why? Since 0.842 = b_-1× 2^0 + b_-2× 2^-1 + b_-3× 2^-2 + b_-4× 2^-3 + ..., we assign b_-1 = 0. Continuing, 1.684 = b_-2× 2^0 + b_-3× 2^-1 + b_-4× 2^-2 + ..., so we assign b_-2 = 1, and subtract 1 from both sides of the equation, yielding 0.684 = b_-3× 2^-1 + b_-4× 2^-2 + ..., Multiplying by 2, we get 1.368 = b_-3× 2^0 + b_-4× 2^-1 + ..., so we assign b_-3 = 1, and subtract 1 from both sides of the equation, yielding 0.368 = b_-4× 2^0 + ..., which assigns 0 to b_-4. We can continue this process indefinitely, until we are simply too tired to go on, or until the left side = 0, in which case all bits to the right of where we stop are all 0s. In our case, stopping with four bits, we have converted 0.421 decimal to 0.0110 in binary. § OPERATIONS ON BITS—PART I: ARITHMETIC §.§ Addition and Subtraction Arithmetic on 2's complement numbers is very much like the arithmetic on decimal numbers that you have been doing for a long time. Addition still proceeds from right to left, one digit at a time. At each point, we generate a sum digit and a carry. Instead of generating a carry after 9 (since",
    "223": "= 1, and subtract 1 from both sides of the equation, yielding 0.368 = b_-4× 2^0 + ..., which assigns 0 to b_-4. We can continue this process indefinitely, until we are simply too tired to go on, or until the left side = 0, in which case all bits to the right of where we stop are all 0s. In our case, stopping with four bits, we have converted 0.421 decimal to 0.0110 in binary. § OPERATIONS ON BITS—PART I: ARITHMETIC §.§ Addition and Subtraction Arithmetic on 2's complement numbers is very much like the arithmetic on decimal numbers that you have been doing for a long time. Addition still proceeds from right to left, one digit at a time. At each point, we generate a sum digit and a carry. Instead of generating a carry after 9 (since 9 is the largest decimal digit), we generate a carry after 1 (since 1 is the largest binary digit). Using our five-bit notation, what is 11+3? 27.5pc [fontsize=914] The decimal value 11 is represented as 01011 The decimal value 3 is represented as 00011 The sum, which is the value 14, is 01110 Subtraction is simply addition, preceded by determining the negative of the number to be subtracted. That is, A-B is simply A+(-B). What is 14-9? 27.5pc [fontsize=914] The decimal value 14 is represented as 01110 The decimal value 9 is represented as 01001 First we form the negative, that is, -9: 10111 Adding 14 to -9, we get 01110 10111 which results in the value 5. 00101 Note again that the carry out is ignored. What happens when we add a number to itself (e.g., x+x)? Let's assume for this example eight-bit codes, which would allow us to representleft shift integers from -128 to 127. Consider a value for x, the integer 59, represented as 00111011. If we add 59 to itself, we get the code 01110110. Note that the bits have all shifted to the left by one position. Is that a curiosity, or will that happen",
    "224": "the negative of the number to be subtracted. That is, A-B is simply A+(-B). What is 14-9? 27.5pc [fontsize=914] The decimal value 14 is represented as 01110 The decimal value 9 is represented as 01001 First we form the negative, that is, -9: 10111 Adding 14 to -9, we get 01110 10111 which results in the value 5. 00101 Note again that the carry out is ignored. What happens when we add a number to itself (e.g., x+x)? Let's assume for this example eight-bit codes, which would allow us to representleft shift integers from -128 to 127. Consider a value for x, the integer 59, represented as 00111011. If we add 59 to itself, we get the code 01110110. Note that the bits have all shifted to the left by one position. Is that a curiosity, or will that happen all the time as long as the sum x+x is not too large to represent with the available number of bits? Using our positional notation, the number 59 is 0· 2^6+1· 2^5+1· 2^4+1· 2^3+0· 2^2+1· 2^1+1· 2^0 The sum 59+59 is 2·59, which, in our representation, is 2·(0· 2^6+1· 2^5+1· 2^4+1·2^3+0·2^2+1· 2^1+1· 2^0) But that is nothing more than 0· 2^7+1· 2^6+1· 2^5+1· 2^4+0· 2^3+1· 2^2+1· 2^1 which shifts each digit one position to the left. Thus, adding a number to itself (provided there are enough bits to represent the result) is equivalent to shifting the representation one bit position to the left. §.§ Sign-Extension It is often useful to represent a small number with fewer bits. For example, rather thansign-extension represent the value 5 as 0000000000000101, there are times when it makes more sense to use only six bits to represent the value 5: 000101. There is little confusion, since we are all used to adding leading zeros without affecting the value of a number. A check for $456.78 and a check for $0000456.78 are checks having the same value. =-1 What about negative representations? We obtained the negative representation from its positive counterpart by complementing the positive representation",
    "225": "2^7+1· 2^6+1· 2^5+1· 2^4+0· 2^3+1· 2^2+1· 2^1 which shifts each digit one position to the left. Thus, adding a number to itself (provided there are enough bits to represent the result) is equivalent to shifting the representation one bit position to the left. §.§ Sign-Extension It is often useful to represent a small number with fewer bits. For example, rather thansign-extension represent the value 5 as 0000000000000101, there are times when it makes more sense to use only six bits to represent the value 5: 000101. There is little confusion, since we are all used to adding leading zeros without affecting the value of a number. A check for $456.78 and a check for $0000456.78 are checks having the same value. =-1 What about negative representations? We obtained the negative representation from its positive counterpart by complementing the positive representation and adding 1. Thus, the representation [-18pt] for -5, given that 5 is represented as 000101, is 111011. If 5 is represented as 0000000000000101, then the representation for -5 is 1111111111111011. In the same way that leading 0s do not affect the value of a positive number, leading 1s do not affect the value of a negative number. In order to add representations of different lengths, it is first necessary to represent them with the same number of bits. For example, suppose we wish to add the number 13 to -5, where 13 is represented as 0000000000001101 and -5 is represented as 111011. If we do not represent the two values with the same number of bits, we have 0000000000001101 + 111011 1@c@+ When we attempt to perform the addition, what shall we do with the missing bits in the representation for -5? If we take the absence of a bit to be a 0, then we are no longer adding -5 to 13. On the contrary, if we take the absence of bits to be 0s, we have changed the -5 to the number represented as 0000000000111011, that is +59. Not surprisingly, then, our result turns out to be",
    "226": "to add representations of different lengths, it is first necessary to represent them with the same number of bits. For example, suppose we wish to add the number 13 to -5, where 13 is represented as 0000000000001101 and -5 is represented as 111011. If we do not represent the two values with the same number of bits, we have 0000000000001101 + 111011 1@c@+ When we attempt to perform the addition, what shall we do with the missing bits in the representation for -5? If we take the absence of a bit to be a 0, then we are no longer adding -5 to 13. On the contrary, if we take the absence of bits to be 0s, we have changed the -5 to the number represented as 0000000000111011, that is +59. Not surprisingly, then, our result turns out to be the representation for 72. However, if we understand that a six-bit -5 and a 16-bit -5 differ only in the number of meaningless leading 1s, then we first extend the value of -5 to 16 bits before we perform the addition. Thus, we have 0000000000001101 + 1111111111111011 1@c@+ 0000000000001000 and the result is +8, as we should expect. The value of a positive number does not change if we extend the sign bit 0 as many bit positions to the left as desired. Similarly, the value of a negative number does not change by extending the sign bit 1 as many bit positions to the left as desired. [-24pt] Since in both cases, it is the sign bit that is extended, we refer to the operation as Sign-EXTension, often abbreviated SEXT. Sign-extension is performed in order to be able to operate on representations of different lengths. It does not affect the values of the numbers being represented. §.§ Overflow Up to now, we have always insisted that the sum of two integers be small enoughoverflow to be represented by the available bits. What happens if such is not the case? You are undoubtedly familiar with the odometer on the front",
    "227": "of a positive number does not change if we extend the sign bit 0 as many bit positions to the left as desired. Similarly, the value of a negative number does not change by extending the sign bit 1 as many bit positions to the left as desired. [-24pt] Since in both cases, it is the sign bit that is extended, we refer to the operation as Sign-EXTension, often abbreviated SEXT. Sign-extension is performed in order to be able to operate on representations of different lengths. It does not affect the values of the numbers being represented. §.§ Overflow Up to now, we have always insisted that the sum of two integers be small enoughoverflow to be represented by the available bits. What happens if such is not the case? You are undoubtedly familiar with the odometer on the front dashboard of your automobile. It keeps track of how many miles your car has been driven—but only up to a point. In the old days, when the odometer registered 99992 and you drove it 100 miles, its new reading became 00092. A brand new car! The problem, as you know, is that the largest value the odometer could store was 99999, so the value 100092 showed up as 00092. The carryout of the ten-thousands digit was lost. (Of course, if you grew up in Boston, the carryout was not lost at all—it was in full display in the rusted chrome all over the car.) We say the odometer overflowed. Representing 100092 as 00092 is unacceptable. As more and more cars lasted more than 100,000 miles, car makers felt the pressure to add a digit to the odometer. Today, practically all cars overflow at 1,000,000 miles, rather than 100,000 miles. The odometer provides an example of unsigned arithmetic. The miles you add are always positive miles. The odometer reads 000129 and you drive 50 miles. The odometer now reads 000179. Overflow is a carry out of the leading digit. In the case of signed arithmetic, or more particularly, 2's complement arithmetic,",
    "228": "99999, so the value 100092 showed up as 00092. The carryout of the ten-thousands digit was lost. (Of course, if you grew up in Boston, the carryout was not lost at all—it was in full display in the rusted chrome all over the car.) We say the odometer overflowed. Representing 100092 as 00092 is unacceptable. As more and more cars lasted more than 100,000 miles, car makers felt the pressure to add a digit to the odometer. Today, practically all cars overflow at 1,000,000 miles, rather than 100,000 miles. The odometer provides an example of unsigned arithmetic. The miles you add are always positive miles. The odometer reads 000129 and you drive 50 miles. The odometer now reads 000179. Overflow is a carry out of the leading digit. In the case of signed arithmetic, or more particularly, 2's complement arithmetic, overflow is a little more subtle. Let's return to our five-bit 2's complement data type, which allowed us to represent integers from -16 to +15. Suppose we wish to add +9 and +11. Our arithmetic takes the following form: 01001 01011 10100 Note that the sum is larger than +15, and therefore too large to represent with our 2's complement scheme. The fact that the number is too large means that the number is larger than 01111, the largest positive number we can represent with a five-bit 2's complement data type. Note that because our positive result was larger than +15, it generated a carry into the leading bit position. But this bit position is used to indicate the sign of a value. Thus detecting that the result is too large is an easy matter. Since we are adding two positive numbers, the result must be positive. Since the ALU has produced a negative result, something must be wrong. The thing that is wrong is that the sum of the two positive numbers is too large to be represented with the available bits. We say that the result has overflowed the capacity of the representation. Suppose instead, we had started",
    "229": "scheme. The fact that the number is too large means that the number is larger than 01111, the largest positive number we can represent with a five-bit 2's complement data type. Note that because our positive result was larger than +15, it generated a carry into the leading bit position. But this bit position is used to indicate the sign of a value. Thus detecting that the result is too large is an easy matter. Since we are adding two positive numbers, the result must be positive. Since the ALU has produced a negative result, something must be wrong. The thing that is wrong is that the sum of the two positive numbers is too large to be represented with the available bits. We say that the result has overflowed the capacity of the representation. Suppose instead, we had started with negative numbers, for example, -12 and -6. In this case our arithmetic takes the following form: 10100 11010 01110 -2 Here, too, the result has overflowed the capacity of the machine, since -12+-6 equals -18, which is “more negative” than -16, the negative number with the largest allowable magnitude. The ALU obliges by producing a positive result. Again, this is easy to detect since the sum of two negative numbers cannot be positive. Note that the sum of a negative number and a positive number never presents a problem. Why is that? See Exercise 2.25. § OPERATIONS ON BITS—PART II: LOGICAL OPERATIONS We have seen that it is possible to perform arithmetic (e.g., add, subtract) on values represented as binary patterns. Another class of operations useful to perform on binary patterns is the set of logical operations. §.§ A logical variable Logical operations operate on logical variables. A logical variable can have one of two values, 0 or 1. The name logical is a historical one; it comes from the fact that the two values 0 and 1 can represent the two logical values false and true, but the use of logical operations has traveled far from this original",
    "230": "is easy to detect since the sum of two negative numbers cannot be positive. Note that the sum of a negative number and a positive number never presents a problem. Why is that? See Exercise 2.25. § OPERATIONS ON BITS—PART II: LOGICAL OPERATIONS We have seen that it is possible to perform arithmetic (e.g., add, subtract) on values represented as binary patterns. Another class of operations useful to perform on binary patterns is the set of logical operations. §.§ A logical variable Logical operations operate on logical variables. A logical variable can have one of two values, 0 or 1. The name logical is a historical one; it comes from the fact that the two values 0 and 1 can represent the two logical values false and true, but the use of logical operations has traveled far from this original meaning. There are several basic logic functions, and most ALUs perform all of them. §.§ The AND Function AND is a binary logical function. This means it requires two pieces of input data. AND function Said another way, AND requires two source operands. Each source is a logical variable, taking the value 0 or 1. The output of AND is 1 only if both sourceslogical variable have the value 1. Otherwise, the output is 0. We can think of the AND operation as the ALL operation; that is, the output is 1 only if ALL two inputs are 1. Otherwise, the output is 0. A convenient mechanism for representing the behavior of a logical operation is the truth table. A truth table consists of n+1 columns and 2^n rows. The first truth tablen columns correspond to the n source operands. Since each source operand is a logical variable and can have one of two values, there are 2^n unique values that these source operands can have. Each such set of values (sometimes called an input combination) is represented as one row of the truth table. The final column ininput combination the truth table shows the output for each input combination.",
    "231": "1 only if both sourceslogical variable have the value 1. Otherwise, the output is 0. We can think of the AND operation as the ALL operation; that is, the output is 1 only if ALL two inputs are 1. Otherwise, the output is 0. A convenient mechanism for representing the behavior of a logical operation is the truth table. A truth table consists of n+1 columns and 2^n rows. The first truth tablen columns correspond to the n source operands. Since each source operand is a logical variable and can have one of two values, there are 2^n unique values that these source operands can have. Each such set of values (sometimes called an input combination) is represented as one row of the truth table. The final column ininput combination the truth table shows the output for each input combination. In the case of a two-input AND function, the truth table has two columns for source operands, and four (2^2) rows for unique input combinations. @cc|c@ A B AND 0 0 0 0 1 0 1 0 0 1 1 1 We can apply the logical operation AND to two bit patterns of m bits each. This involves applying the operation individually and independently to each pair of bits in the two source operands. For example, if a and b in Example 2.6 are 16-bit patterns, then c is the AND of a and b. This operation is often called a bit-wise AND because the operation is applied to each pair of bits individually and independently. If c is the AND of a and b, where a=0011101001101001 and b=0101100100100001, what is c? We form the AND of a and b by bit-wise ANDing the two values. That means individually ANDing each pair of bits a_i and b_i to form c_i. For example, since a_0=1 and b_0=1, c_0 is the AND of a_0 and b_0, which is 1. Since a_6=1 and b_6=0, c_6 is the AND of a_6 and b_6, which is 0. 7.5pc The complete solution for c is a:",
    "232": "operation individually and independently to each pair of bits in the two source operands. For example, if a and b in Example 2.6 are 16-bit patterns, then c is the AND of a and b. This operation is often called a bit-wise AND because the operation is applied to each pair of bits individually and independently. If c is the AND of a and b, where a=0011101001101001 and b=0101100100100001, what is c? We form the AND of a and b by bit-wise ANDing the two values. That means individually ANDing each pair of bits a_i and b_i to form c_i. For example, since a_0=1 and b_0=1, c_0 is the AND of a_0 and b_0, which is 1. Since a_6=1 and b_6=0, c_6 is the AND of a_6 and b_6, which is 0. 7.5pc The complete solution for c is a: 0011101001101001 b: 0101100100100001 1@c@a: c: 0001100000100001 Suppose we have an eight-bit pattern, let's call it A, in which the rightmost two bits have particular significance. The computer could be asked to do one of four tasks depending on the value stored in the two rightmost bits of A. Can we isolate those two bits? Yes, we can, using a bit mask. A bit mask is a binary pattern that enables the bits of A to be separated into two parts—generally the part you care about and the part you wish to ignore. In this case, the bit mask 00000011 ANDed with A produces 0 in bit positions 7 through 2, and the original values of bits 1 and 0 of A in bit positions 1 and 0. The bit mask is said to mask out the values in bit positions 7 through 2. If A is 01010110, the AND of A and the bit mask 00000011 is 00000010. If A is 11111100, the AND of A and the bit mask 00000011 is 00000000. That is, the result of ANDing any eight-bit pattern with the mask 00000011 is one of the four patterns 00000000, 00000001, 00000010, or 00000011. The result of",
    "233": "mask. A bit mask is a binary pattern that enables the bits of A to be separated into two parts—generally the part you care about and the part you wish to ignore. In this case, the bit mask 00000011 ANDed with A produces 0 in bit positions 7 through 2, and the original values of bits 1 and 0 of A in bit positions 1 and 0. The bit mask is said to mask out the values in bit positions 7 through 2. If A is 01010110, the AND of A and the bit mask 00000011 is 00000010. If A is 11111100, the AND of A and the bit mask 00000011 is 00000000. That is, the result of ANDing any eight-bit pattern with the mask 00000011 is one of the four patterns 00000000, 00000001, 00000010, or 00000011. The result of ANDing with the mask is to highlight the two bits that are relevant. [-120pt] §.§ The OR Function OR is also a binary logical function. It requires two source operands, both of which are OR function logical variables. The output of OR is 1 if any source has the value 1. Only if both sources are 0 is the output 0. We can think of the OR operation as the ANY operation; that is, the output is 1 if ANY of the two inputs are 1. The truth table for a two-input OR function is @ll|c@ A B OR 0 0 0 0 1 1 1 0 1 1 1 1 In the same way that we applied the logical operation AND to two m-bit patterns, we can apply the OR operation bit-wise to two m-bit patterns. example example mathmargin@ to 13@ to 7pc1012 Example 9.5117.5pc by 3@ 1.5pcafterheadingafterindentfalse If c is the OR of a and b, where a=0011101001101001 and b=0101100100100001, as before, what is c? We form the OR of a and b by bit-wise ORing the two values. That means individually ORing each pair of bits a_i and b_i to form c_i. For example, since a_0=1 and",
    "234": "0. We can think of the OR operation as the ANY operation; that is, the output is 1 if ANY of the two inputs are 1. The truth table for a two-input OR function is @ll|c@ A B OR 0 0 0 0 1 1 1 0 1 1 1 1 In the same way that we applied the logical operation AND to two m-bit patterns, we can apply the OR operation bit-wise to two m-bit patterns. example example mathmargin@ to 13@ to 7pc1012 Example 9.5117.5pc by 3@ 1.5pcafterheadingafterindentfalse If c is the OR of a and b, where a=0011101001101001 and b=0101100100100001, as before, what is c? We form the OR of a and b by bit-wise ORing the two values. That means individually ORing each pair of bits a_i and b_i to form c_i. For example, since a_0=1 and b_0=1, c_0 is the OR of a_0 and b_0, which is 1. Since a_6=1 and b_6=0, c_6 is the OR of a_6 and b_6, which is also 1. The complete solution for c is a: 0011101001101001 b: 0101100100100001 1@c@a: c: 0111101101101001 Sometimes this OR operation is referred to as the inclusive-OR in order to distinguish it from the exclusive-OR function, which we will discuss momentarily. §.§ The NOT Function NOT is a unary logical function. This means it operates on only one source operand. NOT function It is also known as the complement operation. The output is formed by complementing the input. We sometimes say the output is formed by inverting the input. A 1 input results in a 0 output. A 0 input results in a 1 output. The truth table for the NOT function is @c|c@ A NOT 0 1 1 0 In the same way that we applied the logical operation AND and OR to two m-bit patterns, we can apply the NOT operation bit-wise to one m-bit pattern. If a is as before, then c is the NOT of a. a: 0011101001101001 1@c@a: c: 1100010110010110 -3 §.§ The Exclusive-OR Function Exclusive-OR, often abbreviated XOR, is a",
    "235": "which we will discuss momentarily. §.§ The NOT Function NOT is a unary logical function. This means it operates on only one source operand. NOT function It is also known as the complement operation. The output is formed by complementing the input. We sometimes say the output is formed by inverting the input. A 1 input results in a 0 output. A 0 input results in a 1 output. The truth table for the NOT function is @c|c@ A NOT 0 1 1 0 In the same way that we applied the logical operation AND and OR to two m-bit patterns, we can apply the NOT operation bit-wise to one m-bit pattern. If a is as before, then c is the NOT of a. a: 0011101001101001 1@c@a: c: 1100010110010110 -3 §.§ The Exclusive-OR Function Exclusive-OR, often abbreviated XOR, is a binary logical function. It, too, requires two exclusive-ORXOR source operands, both of which are logical variables. The output of XOR is 1 if one (but not both) of the two sources is 1. The output of XOR is 0 if both sources are 1 or if neither source is 1. In other words, the output of XOR is 1 if the two sources are different. The output is 0 if the two sources are the same. The truth table for the XOR function is @cc|c A B XOR 0 0 0 0 1 1 1 0 1 1 1 0 In the same way that we applied the logical operation AND to two m-bit patterns, we can apply the XOR operation bit-wise to two m-bit patterns. If a and b are 16-bit patterns as before, then c (shown here) is the XOR of a and b. a: 0011101001101001 b: 0101100100100001 1@c@a: c: 0110001101001000 Note the distinction between the truth table for XOR shown here and the truth table for OR inclusive-OR shown earlier. In the case of exclusive-OR, if both source operands are 1, the output is 0. That is, the output is 1 if the first operand is 1",
    "236": "the two sources are different. The output is 0 if the two sources are the same. The truth table for the XOR function is @cc|c A B XOR 0 0 0 0 1 1 1 0 1 1 1 0 In the same way that we applied the logical operation AND to two m-bit patterns, we can apply the XOR operation bit-wise to two m-bit patterns. If a and b are 16-bit patterns as before, then c (shown here) is the XOR of a and b. a: 0011101001101001 b: 0101100100100001 1@c@a: c: 0110001101001000 Note the distinction between the truth table for XOR shown here and the truth table for OR inclusive-OR shown earlier. In the case of exclusive-OR, if both source operands are 1, the output is 0. That is, the output is 1 if the first operand is 1 but the second operand is not 1 or if the second operand is 1 but the first operand is not 1. The term exclusive is used because the output is 1 if only one of the two sources is 1. The OR function, on the other hand, produces an output 1 if only one of the two sources is 1, or if both sources are 1. Ergo, the name inclusive-OR. Suppose we wish to know if two patterns are identical. Since the XOR function produces a 0 only if the corresponding pair of bits is identical, two patterns are identical if the output of the XOR is all zeros. §.§ DeMorgan's Laws There are two well-known relationships between AND functions and OR functions, known as DeMorgan's Laws. One of them is illustrated in Figure <ref>. In Figure <ref>a we complement each of the two inputs A and B before using them as inputs to the AND function, and also complement the result produced by the AND function. Figure <ref>b shows the output of these functions if A=0 and B=1. Figure <ref>c summarizes by means of a truth table the behavior of the logic functions for all four input combinations of",
    "237": "or if both sources are 1. Ergo, the name inclusive-OR. Suppose we wish to know if two patterns are identical. Since the XOR function produces a 0 only if the corresponding pair of bits is identical, two patterns are identical if the output of the XOR is all zeros. §.§ DeMorgan's Laws There are two well-known relationships between AND functions and OR functions, known as DeMorgan's Laws. One of them is illustrated in Figure <ref>. In Figure <ref>a we complement each of the two inputs A and B before using them as inputs to the AND function, and also complement the result produced by the AND function. Figure <ref>b shows the output of these functions if A=0 and B=1. Figure <ref>c summarizes by means of a truth table the behavior of the logic functions for all four input combinations of A and B. Note that the NOT of A is represented as A̅. DeMorgan's Law < g r a p h i c s > DeMorgan's law We can describe the behavior of these functions algebraically: AB=A B We can also state this behavior in English: “It is not the case that both A and B are false” is equivalent to saying “At least one of A and B is true.” This equivalence is known as one of two DeMorgan's Laws. Question: Is there a similar result if one inverts both inputs to an OR function, and then inverts the output? §.§ The Bit Vector We have discussed above the AND, OR, and NOT functions performed on m-bit patterns, where each of the m bits is a logical value (0 or 1) and the operations are performed bit-wise (i.e., individually and independently). We have also discussed the use of an m-bit bit mask, where our choice of 0 or 1 for each bit allows us to isolate the bits we are interested in focusing on from the bits that don't matter. An m-bit pattern, where each bit has a logical value (0 or 1) independent of the other bits is",
    "238": "to saying “At least one of A and B is true.” This equivalence is known as one of two DeMorgan's Laws. Question: Is there a similar result if one inverts both inputs to an OR function, and then inverts the output? §.§ The Bit Vector We have discussed above the AND, OR, and NOT functions performed on m-bit patterns, where each of the m bits is a logical value (0 or 1) and the operations are performed bit-wise (i.e., individually and independently). We have also discussed the use of an m-bit bit mask, where our choice of 0 or 1 for each bit allows us to isolate the bits we are interested in focusing on from the bits that don't matter. An m-bit pattern, where each bit has a logical value (0 or 1) independent of the other bits is called a bit vector. It is a convenient mechanism for identifying a property such that some of the bits identify the presence of the property and other bits identify the absence of the property. There are many uses for bit vectors. The most common use is a bit mask, as we saw in Example 2.7. In that example, we had an 8 bit value, and we wanted to focus on bit 1 and bit 0 of that value. We did not care about the other bits. Performing the AND of that value with the bit mask 00000011 caused bit 7 through bit 2 to be ignored, resulting in the AND function producing 00000000, 00000001, 00000010, or 00000011, depending on the values of bit 1 and bit 0. The bit mask is a bit vector, where the property of each of the bits is whether or not we care about that bit. In Example 2.7, we only cared about bit 1 and bit 0. Another use of a bit mask could involve a 16-bit 2's complement integer. Suppose the only thing we cared about was whether the integer was odd or even and whether it was positive or negative. The bit",
    "239": "an 8 bit value, and we wanted to focus on bit 1 and bit 0 of that value. We did not care about the other bits. Performing the AND of that value with the bit mask 00000011 caused bit 7 through bit 2 to be ignored, resulting in the AND function producing 00000000, 00000001, 00000010, or 00000011, depending on the values of bit 1 and bit 0. The bit mask is a bit vector, where the property of each of the bits is whether or not we care about that bit. In Example 2.7, we only cared about bit 1 and bit 0. Another use of a bit mask could involve a 16-bit 2's complement integer. Suppose the only thing we cared about was whether the integer was odd or even and whether it was positive or negative. The bit vector 1000000000000001 has a 1 in bit 15 which is used to identify a number as positive or negative, and a 1 in bit 0 which is used to identify if the integer is odd or even. If we perform the AND of this bit vector with a 16-bit 2's complement integer, we would get one of four results, depending on whether the integer was positive or negative and odd or even: 0000000000000000 0000000000000001 1000000000000000 1000000000000001 Another common use of bit vectors involves managing a complex system made up of several units, each of which is individually and independently either busy or available. The system could be a manufacturing plant where each unit is a particular machine. Or the system could be a taxicab network where each unit is a particular taxicab. In both cases, it is important to identify which units are busy and which are available, so that work can be properly assigned. Say we have m such units. We can keep track of these m units with an m-bit binary pattern we call a bit vector, where a bit is 1 if the unit is free and 0 if the unit is busy. example example mathmargin@ to",
    "240": "on whether the integer was positive or negative and odd or even: 0000000000000000 0000000000000001 1000000000000000 1000000000000001 Another common use of bit vectors involves managing a complex system made up of several units, each of which is individually and independently either busy or available. The system could be a manufacturing plant where each unit is a particular machine. Or the system could be a taxicab network where each unit is a particular taxicab. In both cases, it is important to identify which units are busy and which are available, so that work can be properly assigned. Say we have m such units. We can keep track of these m units with an m-bit binary pattern we call a bit vector, where a bit is 1 if the unit is free and 0 if the unit is busy. example example mathmargin@ to 13@ to 7pc1012 Example 9.5117.5pc by 3@ 1.5pcafterheadingafterindentfalse Suppose we have eight machines that we want to monitor with respect to their availability. We can keep track of them with an eight-bit BUSYNESS bit vector, where a bit is 1 if the unit is free and 0 if the unit is busy. The bits are labeled, from right to left, from 0 to 7. The BUSYNESS bit vector 11000010 corresponds to the situation where only units 7, 6, and 1 are free, and therefore available for work assignment. Suppose work is assigned to unit 7. We update our BUSYNESS bit vector by performing the logical AND, where our two sources are the current bit vector 11000010 and the bit mask 01111111. The purpose of the bit mask is to clear bit 7 of the BUSYNESS bit vector, while leaving alone the values corresponding to all the other units. The result is the bit vector 01000010, indicating that unit 7 is now busy. Suppose unit 5 finishes its task and becomes idle. We can update the BUSYNESS bit vector by performing the logical OR of it with the bit mask 00100000. The result is 01100010, indicating that unit 5 is now",
    "241": "from 0 to 7. The BUSYNESS bit vector 11000010 corresponds to the situation where only units 7, 6, and 1 are free, and therefore available for work assignment. Suppose work is assigned to unit 7. We update our BUSYNESS bit vector by performing the logical AND, where our two sources are the current bit vector 11000010 and the bit mask 01111111. The purpose of the bit mask is to clear bit 7 of the BUSYNESS bit vector, while leaving alone the values corresponding to all the other units. The result is the bit vector 01000010, indicating that unit 7 is now busy. Suppose unit 5 finishes its task and becomes idle. We can update the BUSYNESS bit vector by performing the logical OR of it with the bit mask 00100000. The result is 01100010, indicating that unit 5 is now available. § OTHER REPRESENTATIONS There are many other representations of information that are used in computers. Two that are among the most useful are the floating point data type and ASCII codes. We will describe both in this section. We will also describe a notation called hexadecimal which, although not a data type, is convenient for humans to use when dealing with long strings of 0s and 1s. §.§ Floating Point Data Type (greater range, less precision) Most of the arithmetic in this book uses integer values. The LC-3 computer, which you will start studying in Chapter 4, uses the 16-bit, 2's complement integer data type. That data type provides one bit to identify whether the number is positive or negative and 15 bits to represent the magnitude of the value. With 16 bits used in this way, we can express integer values between -32,768 and +32,767, that is, between -2^15 and +2^15-1. We say the precision of our value is 15 bits, and the range is 2^16. As you learned in high school chemistry class, sometimes we need to express much larger numbers, but we do not require so many digits of precision. In fact, recall the value ,",
    "242": "dealing with long strings of 0s and 1s. §.§ Floating Point Data Type (greater range, less precision) Most of the arithmetic in this book uses integer values. The LC-3 computer, which you will start studying in Chapter 4, uses the 16-bit, 2's complement integer data type. That data type provides one bit to identify whether the number is positive or negative and 15 bits to represent the magnitude of the value. With 16 bits used in this way, we can express integer values between -32,768 and +32,767, that is, between -2^15 and +2^15-1. We say the precision of our value is 15 bits, and the range is 2^16. As you learned in high school chemistry class, sometimes we need to express much larger numbers, but we do not require so many digits of precision. In fact, recall the value , which you may have been required to memorize back then. The range needed to express the value 10^23 is far greater than the largest value 2^15 -1 that is available with 16-bit 2's complement integers. On the other hand, the 15 bits of precision available with 16-bit 2's complement integers is overkill. We need only enough bits to express four significant decimal digits (6022). So we have a problem. We have more bits than we need for precision. But we don't have enough bits to represent the range. The floating pointdata type!floating point data type solves the problem. Instead of using all the bits to represent the precision of a value, the floating point data type allocates some of the bits to the range of values (i.e., how big or how small) that can be expressed. The rest of the bits (except for the sign bit) are used for precision. Most ISAs today specify more than one floating point data type. One of them, usually called float, consists of 32 bits, allocated as follows: [fontsize=914] 1 bit for the sign (positive or negative) 8 bits for the range (the exponent field) 23 bits for precision (the fraction field) In most",
    "243": "significant decimal digits (6022). So we have a problem. We have more bits than we need for precision. But we don't have enough bits to represent the range. The floating pointdata type!floating point data type solves the problem. Instead of using all the bits to represent the precision of a value, the floating point data type allocates some of the bits to the range of values (i.e., how big or how small) that can be expressed. The rest of the bits (except for the sign bit) are used for precision. Most ISAs today specify more than one floating point data type. One of them, usually called float, consists of 32 bits, allocated as follows: [fontsize=914] 1 bit for the sign (positive or negative) 8 bits for the range (the exponent field) 23 bits for precision (the fraction field) In most computers manufactured today, the format of the 32 bit floating point data type is as shown in Figure <ref>. < g r a p h i c s > The 32 bit floating point data type §.§.§ Normalized form Like Avogadro's Number that you learned years ago, the floating point data type represents numbers expressed in Scientific Notation, and mostly in normalized form: N = (-1)^S × 1.fraction × 2 ^ exponent - 127 , 1 ≤ exponent ≤ 254 where S, fraction, and exponent are the binary numbers in the fields of Figure <ref>. We say mostly in normalized form because (as noted in the above equation) the data type represents a floating point number in normalized form only if the 8 bit exponent is restricted to the 254 unsigned integer values, 1 (00000001) through 254 (11111110). As you know, with 8 bits, one can represent 256 values uniquely. For the other two integer values 0 (00000000) and 255 (11111111), the floating point data type does not represent normalized numbers. We will explain what it does represent in Section <ref> and Section <ref> below. Recall again Avogadro's Number: (a) an implied + sign (often left out when the value",
    "244": "in normalized form: N = (-1)^S × 1.fraction × 2 ^ exponent - 127 , 1 ≤ exponent ≤ 254 where S, fraction, and exponent are the binary numbers in the fields of Figure <ref>. We say mostly in normalized form because (as noted in the above equation) the data type represents a floating point number in normalized form only if the 8 bit exponent is restricted to the 254 unsigned integer values, 1 (00000001) through 254 (11111110). As you know, with 8 bits, one can represent 256 values uniquely. For the other two integer values 0 (00000000) and 255 (11111111), the floating point data type does not represent normalized numbers. We will explain what it does represent in Section <ref> and Section <ref> below. Recall again Avogadro's Number: (a) an implied + sign (often left out when the value is positive), (b) four decimal digits 6.022 in normalized form (one non-zero decimal digit 6 before the decimal point) times (c) the radix 10 raised to the power 23. The computer's 32-bit floating point data type, on the other hand, consists of (a) a sign bit (positive or negative), (b) 24 binary digits in normalized form (one non-zero binary digit to the left of the binary point) times (c) the radix 2 raised to an exponent expressed in 8 bits. -2 We determine the value of the 32-bit floating point representation shown in Figure <ref> by examining its three parts. The sign bit S is just a single binary digit, 0 for positive numbers, 1 for negative numbers. The formula contains the factor -1^S, which evaluates to +1 if S=0, and -1 if S=1. The 23 fraction bits form the 24 bit quantity 1.fraction, where normalized form demands exactly one non-zero binary digit to the left of the binary point. Since there exists only one non-zero binary digit (i.e., the value 1), it is unnecessary to explicitly store that bit in our 32-bit floating point format. In fact that is how we get 24 bits of precision, the 1 to",
    "245": "to the left of the binary point) times (c) the radix 2 raised to an exponent expressed in 8 bits. -2 We determine the value of the 32-bit floating point representation shown in Figure <ref> by examining its three parts. The sign bit S is just a single binary digit, 0 for positive numbers, 1 for negative numbers. The formula contains the factor -1^S, which evaluates to +1 if S=0, and -1 if S=1. The 23 fraction bits form the 24 bit quantity 1.fraction, where normalized form demands exactly one non-zero binary digit to the left of the binary point. Since there exists only one non-zero binary digit (i.e., the value 1), it is unnecessary to explicitly store that bit in our 32-bit floating point format. In fact that is how we get 24 bits of precision, the 1 to the left of the binary point which is always present in normalized numbers and so is unnecessary to store, and the 23 bits of fraction that are actually part of the 32-bit data type. The 8 exponent bits are encoded in what we call an excess code, named for the notion that one can get the *real* exponent by treating the code as an unsigned integer and subracting the excess (sometimes called the bias. In the case of the IEEE Floating Point that almost everyone uses, that excess (or bias) is 127 for 32-bit floating point numbers. Thus, an exponent field containing 10000110 corresponds to the exponent +7 (since 10000110 represents the unsigned integer 134, from which we subtract 127, yielding +7). An exponent field containing 00000111 corresponds to the exponent -120 (since 00000111 represents the unsigned integer 7, from which we subtract 127, yielding -120. The exponent field gives us numbers as large as 2^+127 for an exponent field containing 254 (11111110) and as small as 2^-126 for an exponent field containing 1 (00000001). -3example example mathmargin@ to 13@ to 7pc1012 Example 9.5117.5pc by 3@ 1.5pcafterheadingafterindentfalse by 4pt by 4pt What does the floating point data type represent? The",
    "246": "the code as an unsigned integer and subracting the excess (sometimes called the bias. In the case of the IEEE Floating Point that almost everyone uses, that excess (or bias) is 127 for 32-bit floating point numbers. Thus, an exponent field containing 10000110 corresponds to the exponent +7 (since 10000110 represents the unsigned integer 134, from which we subtract 127, yielding +7). An exponent field containing 00000111 corresponds to the exponent -120 (since 00000111 represents the unsigned integer 7, from which we subtract 127, yielding -120. The exponent field gives us numbers as large as 2^+127 for an exponent field containing 254 (11111110) and as small as 2^-126 for an exponent field containing 1 (00000001). -3example example mathmargin@ to 13@ to 7pc1012 Example 9.5117.5pc by 3@ 1.5pcafterheadingafterindentfalse by 4pt by 4pt What does the floating point data type represent? The leading bit is a 0. This signifies a positive number. The next eight bits represent the unsigned number 123. If we subtract 127, we get the actual exponent -4. The last 23 bits are all 0. Therefore the number being represented is +1.000000000000000000000000· 2^-4, which is 116. by 4pt by 4pt How is the number -658 represented in the floating point data type? First, we express -658 as a binary number: -110.101. -(1· 2^2+1· 2^1+0· 2^0 +1· 2^-1+0· 2^-2+1· 2^-3) Then we normalize the value, yielding -1.10101 · 2^2. The sign bit is 1, reflecting the fact that -658 is a negative number. The exponent field contains 10000001, the unsigned number 129, reflecting the fact that the real exponent is +2 (129 - 127 = +2). The fraction is the 23 bits of precision, after removing the leading 1. That is, the fraction is 10101000000000000000000. The result is the number -658, expressed as a floating point number: The following three examples provide further illustrations of the interpretation of the 32-bit floating point data type according to the rules of the IEEE standard. is 1.00101· 2^4=18.5 The exponent field contains the unsigned number 131. Since 131 - 127 is 4, the",
    "247": "point data type? First, we express -658 as a binary number: -110.101. -(1· 2^2+1· 2^1+0· 2^0 +1· 2^-1+0· 2^-2+1· 2^-3) Then we normalize the value, yielding -1.10101 · 2^2. The sign bit is 1, reflecting the fact that -658 is a negative number. The exponent field contains 10000001, the unsigned number 129, reflecting the fact that the real exponent is +2 (129 - 127 = +2). The fraction is the 23 bits of precision, after removing the leading 1. That is, the fraction is 10101000000000000000000. The result is the number -658, expressed as a floating point number: The following three examples provide further illustrations of the interpretation of the 32-bit floating point data type according to the rules of the IEEE standard. is 1.00101· 2^4=18.5 The exponent field contains the unsigned number 131. Since 131 - 127 is 4, the exponent is +4. Combining a 1 to the left of the binary point with the fraction field to the right of the binary point yields 1.00101. If we move the binary point four positions to the right, we get 10010.1, which is 18.5. is -1 · 1.00101 · 2^3 = -9.25 The sign bit is 1, signifying a negative number. The exponent is 130, signifying an exponent of 130 - 127, or +3. Combining a 1 to the left of the binary point with the fraction field to the right of the binary point yields 1.00101. Moving the binary point three positions to the right, we get 1001.01, which is -9.25. is ∼2^128 The sign is +. The exponent is 254 -127, or +127. Combining a 1 to the left of the binary point with the fraction field to the right of the binary point yields 1.11111111…1, which is approximately 2. Therefore, the result is approximately 2^128. §.§.§ Infinities We noted above that the floating point data type represented numbers expressed in Scientific Notation in normalized form provided the exponent field does not contain 00000000 or 11111111. If the exponent field contains 11111111, we use the floating point data type",
    "248": "The exponent is 130, signifying an exponent of 130 - 127, or +3. Combining a 1 to the left of the binary point with the fraction field to the right of the binary point yields 1.00101. Moving the binary point three positions to the right, we get 1001.01, which is -9.25. is ∼2^128 The sign is +. The exponent is 254 -127, or +127. Combining a 1 to the left of the binary point with the fraction field to the right of the binary point yields 1.11111111…1, which is approximately 2. Therefore, the result is approximately 2^128. §.§.§ Infinities We noted above that the floating point data type represented numbers expressed in Scientific Notation in normalized form provided the exponent field does not contain 00000000 or 11111111. If the exponent field contains 11111111, we use the floating point data type to represent various things, among them the notion of infinity. Infinity is represented by the exponent field containing all 1s and the fraction field containing all 0s. We represent positive infinity if the sign bit is 0, and negative infinity if the sign bit is 1. §.§.§ Subnormal numbers The smallest number that can be represented in normalized form is N = 1.00000000000000000000000 × 2 ^- 126 What about numbers smaller than 2 ^-126 but larger than 0? We call such numbers subnormal numbers because they can not be represented in normalized form. The largest subnormal number is N = 0.11111111111111111111111 × 2 ^- 126 The smallest subnormal number is N = 0.00000000000000000000001 × 2 ^- 126, i.e., 2^-23× 2^-126 which is 2^-149. Note that the largest subnormal number is 2^-126 minus 2^-149. Do you see why that is the case? Subnormal numbers are numbers of the form: N = (-1)^S × 0.fraction × 2 ^ - 126 We represent them with an exponent field of 00000000. The fraction field is represented in the same way as with normalized numbers. That is, if the exponent field contains 00000000, the exponent is -126, and the significant digits are obtained by starting",
    "249": "N = 1.00000000000000000000000 × 2 ^- 126 What about numbers smaller than 2 ^-126 but larger than 0? We call such numbers subnormal numbers because they can not be represented in normalized form. The largest subnormal number is N = 0.11111111111111111111111 × 2 ^- 126 The smallest subnormal number is N = 0.00000000000000000000001 × 2 ^- 126, i.e., 2^-23× 2^-126 which is 2^-149. Note that the largest subnormal number is 2^-126 minus 2^-149. Do you see why that is the case? Subnormal numbers are numbers of the form: N = (-1)^S × 0.fraction × 2 ^ - 126 We represent them with an exponent field of 00000000. The fraction field is represented in the same way as with normalized numbers. That is, if the exponent field contains 00000000, the exponent is -126, and the significant digits are obtained by starting with a leading 0, followed by a binary point, followed by the 23 bits of the fraction field. What number corresponds to the following floating point representation? Answer: The leading 0 means the number is positive. The next eight bits, a zero exponent, means the exponent is -126, and the bit to the left of the binary point is 0. The last 23 bits form the number 0.00001000000000000000000, which equals 2^-5. Thus, the number represented is 2^-5· 2^-126, which is 2^-131. Including subnormal numbers allows very, very tiny numbers to be represented. A detailed understanding of IEEE Floating Point Arithmetic is well beyond what should be expected in this first course. Our purpose in including this section in the textbook is to at least let you know that there is, in addition to 2's complement integers, another very important data type available in almost all ISAs. This data type is called floating point; it allows very large and very tiny numbers to be expressed at the cost of reducing the number of binary digits of precision. -2 §.§ ASCII Codes Another representation of information is the standard code that almost all ASCII codes computer equipment manufacturers have agreed to use",
    "250": "The last 23 bits form the number 0.00001000000000000000000, which equals 2^-5. Thus, the number represented is 2^-5· 2^-126, which is 2^-131. Including subnormal numbers allows very, very tiny numbers to be represented. A detailed understanding of IEEE Floating Point Arithmetic is well beyond what should be expected in this first course. Our purpose in including this section in the textbook is to at least let you know that there is, in addition to 2's complement integers, another very important data type available in almost all ISAs. This data type is called floating point; it allows very large and very tiny numbers to be expressed at the cost of reducing the number of binary digits of precision. -2 §.§ ASCII Codes Another representation of information is the standard code that almost all ASCII codes computer equipment manufacturers have agreed to use for transferring characters between the main computer processing unit and the input and output devices. That code is an eight-bit code referred to as ASCII. ASCII stands for American Standard Code for Information Interchange. It (ASCII) greatly simplifies the interface between a keyboard manufactured by one company, a computer made by another company, and a monitor made by a third company. Each key on the keyboard is identified by its unique ASCII code. So, for example, the digit 3 is represented as 00110011, the digit 2 is 00110010, the lowercase e is 01100101, and the ENTER key is 00001101. The entire set of eight-bit ASCII codes is listed in Figure E.2 of Appendix E. When you type a key on the keyboard, the corresponding eight-bit code is stored and made available to the computer. Where it is stored and how it gets into the computer is discussed in Chapter 9. Most keys are associated with more than one code. For example, the ASCII code for the letter E is 01000101, and the ASCII code for the letter e is 01100101. Both are associated with the same key, although in one case the Shift key is also depressed while in the",
    "251": "company. Each key on the keyboard is identified by its unique ASCII code. So, for example, the digit 3 is represented as 00110011, the digit 2 is 00110010, the lowercase e is 01100101, and the ENTER key is 00001101. The entire set of eight-bit ASCII codes is listed in Figure E.2 of Appendix E. When you type a key on the keyboard, the corresponding eight-bit code is stored and made available to the computer. Where it is stored and how it gets into the computer is discussed in Chapter 9. Most keys are associated with more than one code. For example, the ASCII code for the letter E is 01000101, and the ASCII code for the letter e is 01100101. Both are associated with the same key, although in one case the Shift key is also depressed while in the other case, it is not. In order to display a particular character on the monitor, the computer must transfer the ASCII code for that character to the electronics associated with the monitor. That, too, is discussed in Chapter 9. §.§ Hexadecimal Notation We have seen that information can be represented as 2's complement integers, as bit vectors, in hexadecimal notation floating point format, or as an ASCII code. There are other representations also, but we will leave them for another book. However, before we leave this topic, we would like to introduce you to a representation that is used more as a convenience for humans than as a data type to support operations being performed by the computer. This is the hexadecimal notation. As we will see, it evolves nicely from the positional binary notation and is useful for dealing with long strings of binary digits without making errors. It will be particularly useful in dealing with the LC-3 where 16-bit binary strings will be encountered often. An example of such a binary string is 0011110101101110 =1 Let's try an experiment. Cover the preceding 16-bit binary string of 0s and 1s with one hand, and try to write it down",
    "252": "floating point format, or as an ASCII code. There are other representations also, but we will leave them for another book. However, before we leave this topic, we would like to introduce you to a representation that is used more as a convenience for humans than as a data type to support operations being performed by the computer. This is the hexadecimal notation. As we will see, it evolves nicely from the positional binary notation and is useful for dealing with long strings of binary digits without making errors. It will be particularly useful in dealing with the LC-3 where 16-bit binary strings will be encountered often. An example of such a binary string is 0011110101101110 =1 Let's try an experiment. Cover the preceding 16-bit binary string of 0s and 1s with one hand, and try to write it down from memory. How did you do? Hexadecimal notation is about being able to do this without making mistakes. We shall see how. In general, a 16-bit binary string takes the form a_15 a_14 a_13 a_12 a_11 a_10 a_9 a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a_0 where each of the bits a_i is either 0 or 1. If we think of this binary string as an unsigned integer, its value can be computed as a_15· 2^15+a_14· 2^14+a_13· 2^13+ a_12· 2^12+a_11· 2^11+a_10· 2^10 + a_9· 2^9+a_8· 2^8+a_7· 2^7+a_6· 2^6+a_5· 2^5+a_4· 2^4+a_3· 2^3 + a_2· 2^2+a_1· 2^1+a_0· 2^0 We can factor 2^12 from the first four terms, 2^8 from the second four terms, 2^4 from the third set of four terms, and 2^0 from the last four terms, yielding 2^12(a_15· 2^3+a_14· 2^2+a_13· 2^1+a_12· 2^0) + 2^8(a_11· 2^3+a_10· 2^2 + a_9· 2^1+a_8· 2^0) + 2^4(a_7· 2^3+a_6· 2^2+ a_5· 2^1+a_4· 2^0) + 2^0(a_3· 2^3+a_2· 2^2+a_1· 2^1+a_0· 2^0) Note that the largest value inside a set of parentheses is 15, which would be the case if each of the four bits is 1. If we replace what is inside each square bracket by a symbol representing its value (from 0 to 15), and we",
    "253": "think of this binary string as an unsigned integer, its value can be computed as a_15· 2^15+a_14· 2^14+a_13· 2^13+ a_12· 2^12+a_11· 2^11+a_10· 2^10 + a_9· 2^9+a_8· 2^8+a_7· 2^7+a_6· 2^6+a_5· 2^5+a_4· 2^4+a_3· 2^3 + a_2· 2^2+a_1· 2^1+a_0· 2^0 We can factor 2^12 from the first four terms, 2^8 from the second four terms, 2^4 from the third set of four terms, and 2^0 from the last four terms, yielding 2^12(a_15· 2^3+a_14· 2^2+a_13· 2^1+a_12· 2^0) + 2^8(a_11· 2^3+a_10· 2^2 + a_9· 2^1+a_8· 2^0) + 2^4(a_7· 2^3+a_6· 2^2+ a_5· 2^1+a_4· 2^0) + 2^0(a_3· 2^3+a_2· 2^2+a_1· 2^1+a_0· 2^0) Note that the largest value inside a set of parentheses is 15, which would be the case if each of the four bits is 1. If we replace what is inside each square bracket by a symbol representing its value (from 0 to 15), and we replace 2^12 by its equivalent 16^3, 2^8 by 16^2, 2^4 by 16^1, and 2^0 by 16^0, we have h_3· 16^3+h_2· 16^2+h_1· 16^1+h_0· 16^0 where h_3, for example, is a symbol representing a_15· 2^3+a_14· 2^2+a_13· 2^1+a_12· 2^0 Since the symbols must represent values from 0 to 15, we assign symbols to these values as follows: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. That is, we represent 0000 with the symbol 0, 0001 with the symbol 1,… 1001 with 9, 1010 with A, 1011 with B, … 1111 with F. The resulting notation is called hexadecimal, or base 16. So, for example, if the hex digits E92F represent a 16-bit 2's complement integer, is the value of that integer positive or negative? How do you know? Now, then, what is this hexadecimal representation good for, anyway? It seems like just another way to represent a number without adding any benefit. Let's return to the exercise where you tried to write from memory the string 0011110101101110 If we had first broken the string at four-bit boundaries 0011 1101 0110 1110 and then converted each four-bit string to its equivalent hex digit 3 D 6",
    "254": "6, 7, 8, 9, A, B, C, D, E, F. That is, we represent 0000 with the symbol 0, 0001 with the symbol 1,… 1001 with 9, 1010 with A, 1011 with B, … 1111 with F. The resulting notation is called hexadecimal, or base 16. So, for example, if the hex digits E92F represent a 16-bit 2's complement integer, is the value of that integer positive or negative? How do you know? Now, then, what is this hexadecimal representation good for, anyway? It seems like just another way to represent a number without adding any benefit. Let's return to the exercise where you tried to write from memory the string 0011110101101110 If we had first broken the string at four-bit boundaries 0011 1101 0110 1110 and then converted each four-bit string to its equivalent hex digit 3 D 6 E it would have been no problem to jot down (with the string covered) 3D6E. -4 In summary, although hexadecimal notation can be used to perform base-16 arithmetic, it is mainly used as a convenience for humans. It can be used to represent binary strings that are integers or floating point numbers or sequences of ASCII codes, or bit vectors. It simply reduces the number of digits by a factor of 4, where each digit is in hex (0,1,2,… F) instead of binary (0,1). The usual result is far fewer copying errors due to too many 0s and 1s. 2.1 Given n bits, how many distinct combinations of the n bits exist? 2.2 There are 26 characters in the alphabet we use for writing English. What is the least number of bits needed to give each character a unique bit pattern? How many bits would we need to distinguish between upper- and lowercase versions of all 26 characters? 2.3 a. Assume that there are about 400 students in your class. If every student is to be assigned a unique bit pattern, what is the minimum number of bits required to do this? b. How many more students can be admitted",
    "255": "It simply reduces the number of digits by a factor of 4, where each digit is in hex (0,1,2,… F) instead of binary (0,1). The usual result is far fewer copying errors due to too many 0s and 1s. 2.1 Given n bits, how many distinct combinations of the n bits exist? 2.2 There are 26 characters in the alphabet we use for writing English. What is the least number of bits needed to give each character a unique bit pattern? How many bits would we need to distinguish between upper- and lowercase versions of all 26 characters? 2.3 a. Assume that there are about 400 students in your class. If every student is to be assigned a unique bit pattern, what is the minimum number of bits required to do this? b. How many more students can be admitted to the class without requiring additional bits for each student's unique bit pattern? 2.4 Given n bits, how many unsigned integers can be represented with the n bits? What is the range of these integers? 2.5 Using 5 bits to represent each number, write the representations of 7 and -7 in 1's complement, signed magnitude, and 2's complement integers. 2.6 Write the 6-bit 2's complement representation of -32. 2.7 Create a table showing the decimal values of all 4-bit 2's complement numbers. 2.8 a. What is the largest positive number one can represent in an 8-bit 2's complement code? Write your result in binary and decimal. b. What is the greatest magnitude negative number one can represent in an 8-bit 2's complement code? Write your result in binary and decimal. c. What is the largest positive number one can represent in n-bit 2's complement code? d. What is the greatest magnitude negative number one can represent in n-bit 2's complement code? 2.9 How many bits are needed to represent Avogadro's number (6.02· 10^23) in 2's complement binary representation? 2.10 Convert the following 2's complement binary numbers to decimal. a. 1010 b. 01011010 c. 11111110 d. 0011100111010011 2.11 Convert these decimal",
    "256": "Write the 6-bit 2's complement representation of -32. 2.7 Create a table showing the decimal values of all 4-bit 2's complement numbers. 2.8 a. What is the largest positive number one can represent in an 8-bit 2's complement code? Write your result in binary and decimal. b. What is the greatest magnitude negative number one can represent in an 8-bit 2's complement code? Write your result in binary and decimal. c. What is the largest positive number one can represent in n-bit 2's complement code? d. What is the greatest magnitude negative number one can represent in n-bit 2's complement code? 2.9 How many bits are needed to represent Avogadro's number (6.02· 10^23) in 2's complement binary representation? 2.10 Convert the following 2's complement binary numbers to decimal. a. 1010 b. 01011010 c. 11111110 d. 0011100111010011 2.11 Convert these decimal numbers to 8-bit 2's complement binary numbers. a. 102 b. 64 c. 33 d.-128 e. 127 2.12 If the last digit of a 2's complement binary number is 0, then the number is even. If the last two digits of a 2's complement binary number are 00 (e.g., the binary number 01100), what does that tell you about the number? 2.13 Without changing their values, convert the following 2's complement binary numbers into 8-bit 2's complement numbers. a. 1010 c. 1111111000 b. 011001 d. 01 2.14 Add the following bit patterns. Leave your results in binary form. a. 1011 + 0001 b. 0000 + 1010 c. 1100 + 0011 d. 0101 + 0110 e. 1111 + 0001 2.15 It was demonstrated in Example 2.5 that shifting a binary number one bit to the left is equivalent to multiplying the number by 2. What operation is performed when a binary number is shifted one bit to the right? 2.16 Write the results of the following additions as both 8-bit binary and decimal numbers. For each part, use standard binary addition as described in Section 2.5.1. a. Add the 1's complement representation of 7 to the 1's complement representation of -7. b.",
    "257": "2.13 Without changing their values, convert the following 2's complement binary numbers into 8-bit 2's complement numbers. a. 1010 c. 1111111000 b. 011001 d. 01 2.14 Add the following bit patterns. Leave your results in binary form. a. 1011 + 0001 b. 0000 + 1010 c. 1100 + 0011 d. 0101 + 0110 e. 1111 + 0001 2.15 It was demonstrated in Example 2.5 that shifting a binary number one bit to the left is equivalent to multiplying the number by 2. What operation is performed when a binary number is shifted one bit to the right? 2.16 Write the results of the following additions as both 8-bit binary and decimal numbers. For each part, use standard binary addition as described in Section 2.5.1. a. Add the 1's complement representation of 7 to the 1's complement representation of -7. b. Add the signed magnitude representation of 7 to the signed magnitude representation of -7. c. Add the 2's complement representation of 7 to the 2's complement representation of -7. 2.17 Add the following 2's complement binary numbers. Also express the answer in decimal. a. 01 + 1011 b. 11 + 01010101 c. 0101 + 110 d. 01 + 10 2.18 Add the following unsigned binary numbers. Also, express the answer in decimal. a. 01 + 1011 b. 11 + 01010101 c. 0101 + 110 d. 01 + 10 2.19 Express the negative value -27 as a 2's complement integer, using eight bits. Repeat, using 16 bits. Repeat, using 32 bits. What does this illustrate with respect to the properties of sign extension as they pertain to 2's complement representation? 2.20 The following binary numbers are 4-bit 2's complement binary numbers. Which of the following operations generate overflow? Justify your answer by translating the operands and results into decimal. a. 1100 + 0011 d. 1000 - 0001 b. 1100 + 0100 e. 0111 + 1001 c. 0111 + 0001 2.21 Describe what conditions indicate overflow has occurred when two 2's complement numbers are added. 2.22 Create two 16-bit 2's complement integers",
    "258": "Add the following unsigned binary numbers. Also, express the answer in decimal. a. 01 + 1011 b. 11 + 01010101 c. 0101 + 110 d. 01 + 10 2.19 Express the negative value -27 as a 2's complement integer, using eight bits. Repeat, using 16 bits. Repeat, using 32 bits. What does this illustrate with respect to the properties of sign extension as they pertain to 2's complement representation? 2.20 The following binary numbers are 4-bit 2's complement binary numbers. Which of the following operations generate overflow? Justify your answer by translating the operands and results into decimal. a. 1100 + 0011 d. 1000 - 0001 b. 1100 + 0100 e. 0111 + 1001 c. 0111 + 0001 2.21 Describe what conditions indicate overflow has occurred when two 2's complement numbers are added. 2.22 Create two 16-bit 2's complement integers such that their sum causes an overflow. 2.23 Describe what conditions indicate overflow has occurred when two unsigned numbers are added. 2.24 Create two 16-bit unsigned integers such that their sum causes an overflow. 2.25 Why does the sum of a negative 2's complement number and a positive 2's complement number never generate an overflow? 2.26 You wish to express -64 as a 2's complement number. a. How many bits do you need (the minimum number)? b. With this number of bits, what is the largest positive number you can represent? (Please give answer in both decimal and binary). c. With this number of bits, what is the largest unsigned number you can represent? (Please give answer in both decimal and binary). 2.27 The LC-3, a 16-bit machine adds the two 2's complement numbers 0101010101010101 and 0011100111001111, producing 1000111100100100. Is there a problem here? If yes, what is the problem? If no, why not? 2.28 When is the output of an AND operation equal to 1? 2.29 Fill in the following truth table for a one-bit AND operation. 913pt 0pt10ptX0pt10pt Y X AND Y 0pt10pt00pt10pt 0 0 1 1 0 1 1 2.30 Compute the following. Write your results in",
    "259": "-64 as a 2's complement number. a. How many bits do you need (the minimum number)? b. With this number of bits, what is the largest positive number you can represent? (Please give answer in both decimal and binary). c. With this number of bits, what is the largest unsigned number you can represent? (Please give answer in both decimal and binary). 2.27 The LC-3, a 16-bit machine adds the two 2's complement numbers 0101010101010101 and 0011100111001111, producing 1000111100100100. Is there a problem here? If yes, what is the problem? If no, why not? 2.28 When is the output of an AND operation equal to 1? 2.29 Fill in the following truth table for a one-bit AND operation. 913pt 0pt10ptX0pt10pt Y X AND Y 0pt10pt00pt10pt 0 0 1 1 0 1 1 2.30 Compute the following. Write your results in binary. a. 01010111 AND 11010111 b. 101 AND 110 c. 11100000 AND 10110100 d. 00011111 AND 10110100 e. (0011 AND 0110) AND 1101 f. 0011 AND (0110 AND 1101) 2.31 When is the output of an OR operation equal to 1? 2.32 Fill in the following truth table for a one-bit OR operation. 913pt 0pt10ptX0pt10pt Y X OR Y 0pt10pt00pt10pt 0 0 1 1 0 1 1 2.33 Compute the following: a. 01010111 OR 11010111 b. 101 OR 110 c. 11100000 OR 10110100 d. 00011111 OR 10110100 e. (0101 OR 1100) OR 1101 f. 0101 OR (1100 OR 1101) 2.34 Compute the following: a. NOT(1011) OR NOT(1100) b. NOT(1000 AND (1100 OR 0101)) c. NOT(NOT(1101)) d. (0110 OR 0000) AND 1111 2.35 In Example 2.11, what are the masks used for? 2.36 Refer to Example 2.11 for the following questions. a. What mask value and what operation would one use to indicate that machine 2 is busy? b. What mask value and what operation would one use to indicate that machines 2 and 6 are no longer busy? (Note: This can be done with only one operation.) c. What mask value and what operation would one use to indicate that",
    "260": "0 0 1 1 0 1 1 2.33 Compute the following: a. 01010111 OR 11010111 b. 101 OR 110 c. 11100000 OR 10110100 d. 00011111 OR 10110100 e. (0101 OR 1100) OR 1101 f. 0101 OR (1100 OR 1101) 2.34 Compute the following: a. NOT(1011) OR NOT(1100) b. NOT(1000 AND (1100 OR 0101)) c. NOT(NOT(1101)) d. (0110 OR 0000) AND 1111 2.35 In Example 2.11, what are the masks used for? 2.36 Refer to Example 2.11 for the following questions. a. What mask value and what operation would one use to indicate that machine 2 is busy? b. What mask value and what operation would one use to indicate that machines 2 and 6 are no longer busy? (Note: This can be done with only one operation.) c. What mask value and what operation would one use to indicate that all machines are busy? d. What mask value and what operation would one use to indicate that all machines are idle? e. Using the operations discussed in this chapter, develop a procedure to isolate the status bit of machine 2 as the sign bit. For example, if the BUSYNESS pattern is 01011100, then the output of this procedure is 10000000. If the BUSYNESS pattern is 01110011, then the output is 00000000. In general, if the BUSYNESS pattern is: 0pt10ptb70pt10pt b6 b5 b4 b3 b2 b1 b0 the output is: 0pt10ptb20pt10pt 0 0 0 0 0 0 0 . Hint: What happens when you ADD a bit pattern to itself? 2.37 If n and m are both 4-bit 2's complement numbers, and s is the 4-bit result of adding them together, how can we determine, using only the logical operations described in Section 2.6, if an overflow occurred during the addition? Develop a “procedure” for doing so. The inputs to the procedure are n, m, and s, and the output will be a bit pattern of all zeros (0000) if no overflow occurred and 1000 if an overflow did occur. 2.38 If n and m are both 4-bit unsigned numbers, and",
    "261": "If the BUSYNESS pattern is 01110011, then the output is 00000000. In general, if the BUSYNESS pattern is: 0pt10ptb70pt10pt b6 b5 b4 b3 b2 b1 b0 the output is: 0pt10ptb20pt10pt 0 0 0 0 0 0 0 . Hint: What happens when you ADD a bit pattern to itself? 2.37 If n and m are both 4-bit 2's complement numbers, and s is the 4-bit result of adding them together, how can we determine, using only the logical operations described in Section 2.6, if an overflow occurred during the addition? Develop a “procedure” for doing so. The inputs to the procedure are n, m, and s, and the output will be a bit pattern of all zeros (0000) if no overflow occurred and 1000 if an overflow did occur. 2.38 If n and m are both 4-bit unsigned numbers, and s is the 4-bit result of adding them together, how can we determine, using only the logical operations described in Section 2.6, if an overflow occurred during the addition? Develop a “procedure” for doing so. The inputs to the procedure are n, m, and s, and the output will be a bit pattern of all zeros (0000) if no overflow occurred and 1000 if an overflow did occur. 2.39 Write IEEE floating point representation of the following decimal numbers. a.3.75 b.-55 23/64 c.3.1415927 d.64,000 2.40 Write the decimal equivalents for these IEEE floating point numbers. a. 0 10000000 00000000000000000000000 b. 1 10000011 00010000000000000000000 c. 0 11111111 00000000000000000000000 d. 1 10000000 10010000000000000000000 2.41 a. What is the largest exponent the IEEE standard allows for a 32-bit floating point number? b. What is the smallest exponent the IEEE standard allows for a 32-bit floating point number? 2.42 A computer programmer wrote a program that adds two numbers. The programmer ran the program and observed that when 5 is added to 8, the result is the character m. Explain why this program is behaving erroneously. 2.43 Translate the following ASCII codes into strings of characters by interpreting each group of eight bits as",
    "262": "occurred and 1000 if an overflow did occur. 2.39 Write IEEE floating point representation of the following decimal numbers. a.3.75 b.-55 23/64 c.3.1415927 d.64,000 2.40 Write the decimal equivalents for these IEEE floating point numbers. a. 0 10000000 00000000000000000000000 b. 1 10000011 00010000000000000000000 c. 0 11111111 00000000000000000000000 d. 1 10000000 10010000000000000000000 2.41 a. What is the largest exponent the IEEE standard allows for a 32-bit floating point number? b. What is the smallest exponent the IEEE standard allows for a 32-bit floating point number? 2.42 A computer programmer wrote a program that adds two numbers. The programmer ran the program and observed that when 5 is added to 8, the result is the character m. Explain why this program is behaving erroneously. 2.43 Translate the following ASCII codes into strings of characters by interpreting each group of eight bits as an ASCII character. a. x48656c6c6f21 b. x68454c4c4f21 c. x436f6d70757465727321 d. x4c432d32 2.44 What operation(s) can be used to convert the binary representation for 3 (i.e., 0000 0011) into the ASCII representation for 3 (i.e., 0011 0011)? What about the binary 4 into the ASCII 4? What about any digit? 2.45 Convert the following unsigned binary numbers to hexadecimal. a. 1101 0001 1010 1111 b. 001 1111 c. 1 d. 1110 1101 1011 0010 2.46 Convert the following hexadecimal numbers to binary. a. x10 b. x801 c. xF731 d. x0F1E2D e. xBCAD 2.47 Convert the following hexadecimal representations of 2's complement binary numbers to decimal numbers. a. xF0 b. x7FF c. x16 d. x8000 2.48 Convert the following decimal numbers to hexadecimal representations of 2's complement numbers. a. 256 b. 111 c. 123,456,789 d.-44 2.49 Perform the following additions. The corresponding 16-bit binary numbers are in 2's complement notation. Provide your answers in hexadecimal. a. x025B + x26DE b. x7D96 + xF0A0 c. xA397 + xA35D d. x7D96 + x7412 e. What else can you say about the answers to parts c and d? 2.50 Perform the following logical operations. Express your answers in hexadecimal notation. a. x5478 AND xFDEA b.",
    "263": "0001 1010 1111 b. 001 1111 c. 1 d. 1110 1101 1011 0010 2.46 Convert the following hexadecimal numbers to binary. a. x10 b. x801 c. xF731 d. x0F1E2D e. xBCAD 2.47 Convert the following hexadecimal representations of 2's complement binary numbers to decimal numbers. a. xF0 b. x7FF c. x16 d. x8000 2.48 Convert the following decimal numbers to hexadecimal representations of 2's complement numbers. a. 256 b. 111 c. 123,456,789 d.-44 2.49 Perform the following additions. The corresponding 16-bit binary numbers are in 2's complement notation. Provide your answers in hexadecimal. a. x025B + x26DE b. x7D96 + xF0A0 c. xA397 + xA35D d. x7D96 + x7412 e. What else can you say about the answers to parts c and d? 2.50 Perform the following logical operations. Express your answers in hexadecimal notation. a. x5478 AND xFDEA b. xABCD OR x1234 c. NOT((NOT(xDEFA)) AND (NOT(xFFFF))) d. x00FF XOR x325C 2.51 What is the hexadecimal representation of the following numbers? a. 25,675 b. 675.625 (that is, 67558), in the IEEE 754 floating point standard c. The ASCII string: Hello 2.52 Consider two hexadecimal numbers: x434F4D50 and x55544552. What values do they represent for each of the five data types shown? 0pt10pt x434F4D50 x55544552 Unsigned binary 0pt10pt 1's complement 0pt10pt 2's complement 0pt10pt IEEE 754 floating point 0pt10pt ASCII string 0pt10pt 2.53 Fill in the truth table for the equations given. The first line is done as an example. Q_1 = NOT(A AND B) Q_2 = NOT(NOT(A) AND NOT(B)) 9130pt10ptA0pt10pt B Q_1 Q_2 0pt10pt00pt10pt 0 1 0 Express Q_2 another way. 2.54 Fill in the truth table for the equations given. The first line is done as an example. Q_1 =NOT(NOT(X) OR (X AND Y AND Z)) Q_2 =NOT((Y OR Z) AND (X AND Y AND Z)) 9130pt10ptX0pt10pt Y Z Q_1 Q_2 0pt10pt00pt10pt 0 0 0 1 2.55 We have represented numbers in base-2 (binary) and in base-16 (hex). We are now ready for unsigned base-4, which we will call quad numbers. A quad digit can be 0, 1, 2,",
    "264": "shown? 0pt10pt x434F4D50 x55544552 Unsigned binary 0pt10pt 1's complement 0pt10pt 2's complement 0pt10pt IEEE 754 floating point 0pt10pt ASCII string 0pt10pt 2.53 Fill in the truth table for the equations given. The first line is done as an example. Q_1 = NOT(A AND B) Q_2 = NOT(NOT(A) AND NOT(B)) 9130pt10ptA0pt10pt B Q_1 Q_2 0pt10pt00pt10pt 0 1 0 Express Q_2 another way. 2.54 Fill in the truth table for the equations given. The first line is done as an example. Q_1 =NOT(NOT(X) OR (X AND Y AND Z)) Q_2 =NOT((Y OR Z) AND (X AND Y AND Z)) 9130pt10ptX0pt10pt Y Z Q_1 Q_2 0pt10pt00pt10pt 0 0 0 1 2.55 We have represented numbers in base-2 (binary) and in base-16 (hex). We are now ready for unsigned base-4, which we will call quad numbers. A quad digit can be 0, 1, 2, or 3. a. What is the maximum unsigned decimal value that one can represent with 3 quad digits? b. What is the maximum unsigned decimal value that one can represent with n quad digits (Hint: your answer should be a function of n)? c. Add the two unsigned quad numbers: 023 and 221. d. What is the quad representation of the decimal number 42? e. What is the binary representation of the unsigned quad number 123.3? f. Express the unsigned quad number 123.3 in IEEE floating point format. g. Given a black box which takes m quad digits as input and produces one quad digit for output, what is the maximum number of unique functions this black box can implement? 2.56 Define a new 8-bit floating point format with 1 sign bit, 4 bits of exponent, using an excess-7 code (that is, the bias is 7), and 3 bits of fraction. If xE5 is the bit pattern for a number in this 8-bit floating point format, what value does it have? (Express as a decimal number.) ../art/ch06/,../art/designelements/,../art/designelements/UnNumberedArt/makechapterhead#1 @ (0,0) (432,-577) < g r a p h i c s > (428,-577)1@9.52667in(381.5,-181) < g r a p h i c s",
    "265": "the decimal number 42? e. What is the binary representation of the unsigned quad number 123.3? f. Express the unsigned quad number 123.3 in IEEE floating point format. g. Given a black box which takes m quad digits as input and produces one quad digit for output, what is the maximum number of unique functions this black box can implement? 2.56 Define a new 8-bit floating point format with 1 sign bit, 4 bits of exponent, using an excess-7 code (that is, the bias is 7), and 3 bits of fraction. If xE5 is the bit pattern for a number in this 8-bit floating point format, what value does it have? (Express as a decimal number.) ../art/ch06/,../art/designelements/,../art/designelements/UnNumberedArt/makechapterhead#1 @ (0,0) (432,-577) < g r a p h i c s > (428,-577)1@9.52667in(381.5,-181) < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > 1212chapter 1212chapter 7212 3032#1 36.4pc4@ CHAPTER: PROGRAMMING We are now ready to develop programs to solve problems with the computer. In this chapter we attempt to do two things: first, we develop a methodology for constructing programs to solve problems (Section 6.1, Problem Solving), and second, we develop a methodology for fixing those programs (Section 6.2, Debugging) under the likely condition that we did not get everything right the first time. There is a long tradition that the errors present in programs are referred to as bugs, and the process of removing those errors is called debugging. The opportunities for introducing bugs into a complicated program are so great that it usually takes much more time to get the program to work correctly (debugging) than it does to create the program in the first place. - § PROBLEM SOLVING §.§ Systematic Decomposition =1 Recall from Chapter 1 that in order for electrons to solve a problem, we need to",
    "266": "computer. In this chapter we attempt to do two things: first, we develop a methodology for constructing programs to solve problems (Section 6.1, Problem Solving), and second, we develop a methodology for fixing those programs (Section 6.2, Debugging) under the likely condition that we did not get everything right the first time. There is a long tradition that the errors present in programs are referred to as bugs, and the process of removing those errors is called debugging. The opportunities for introducing bugs into a complicated program are so great that it usually takes much more time to get the program to work correctly (debugging) than it does to create the program in the first place. - § PROBLEM SOLVING §.§ Systematic Decomposition =1 Recall from Chapter 1 that in order for electrons to solve a problem, we need to go through several levels of transformation to get from a natural language description of the problem (in our case English, although many of you might prefer Italian, Mandarin, Hindi, or something else) to something electrons can deal with. Once we have a natural language description of the problem, the next step is to transform the problem statement into an algorithm. That is, the next step is to transform the problem statement into a step-by-step procedure that has the properties of definiteness (each step is precisely stated), effective computability (each step can be carried out by a computer), and finiteness (the procedure terminates). In the late 1960s, the concept of structured programming emerged as a way to dramatically improve the ability of average programmers to take a complex description of a problem and systematically decompose it into smaller and smaller manageable units so that they could ultimately write a program that executed correctly. The methodology has also been called systematic decompositionsystematic decomposition because the larger tasks are systematically broken down into smaller ones. We will find the systematic decomposition model a useful technique for designing computer programs to carry out complex tasks. §.§ The Three Constructs: Sequential, Conditional, Iterative < g",
    "267": "That is, the next step is to transform the problem statement into a step-by-step procedure that has the properties of definiteness (each step is precisely stated), effective computability (each step can be carried out by a computer), and finiteness (the procedure terminates). In the late 1960s, the concept of structured programming emerged as a way to dramatically improve the ability of average programmers to take a complex description of a problem and systematically decompose it into smaller and smaller manageable units so that they could ultimately write a program that executed correctly. The methodology has also been called systematic decompositionsystematic decomposition because the larger tasks are systematically broken down into smaller ones. We will find the systematic decomposition model a useful technique for designing computer programs to carry out complex tasks. §.§ The Three Constructs: Sequential, Conditional, Iterative < g r a p h i c s > The basic constructs of structured programming Systematic decomposition is the process of taking a task, that is, a unit of work (see Figure 6.1a), and breaking it into smaller units of work such that the collection of smaller units carries out the same task as the one larger unit. The idea is that if one starts with a large, complex task and applies this process again and again, one will end up with very small units of work, and consequently, be able to easily write a program to carry out each of these small units of work. The process is also referred to as stepwise refinement,step-wise refinement because the process is applied one step at a time, and each step refines one of the tasks that is still too complex into a collection of simpler subtasks. The idea is to replace each larger unit of work with a construct that correctly decomposes it. There are basically three constructs for doing this: sequential, conditional, and iterative. The sequential construct (Figure 6.1b) is the one to use if the designated task can be sequential construct broken down into two subtasks, one following the other.",
    "268": "that if one starts with a large, complex task and applies this process again and again, one will end up with very small units of work, and consequently, be able to easily write a program to carry out each of these small units of work. The process is also referred to as stepwise refinement,step-wise refinement because the process is applied one step at a time, and each step refines one of the tasks that is still too complex into a collection of simpler subtasks. The idea is to replace each larger unit of work with a construct that correctly decomposes it. There are basically three constructs for doing this: sequential, conditional, and iterative. The sequential construct (Figure 6.1b) is the one to use if the designated task can be sequential construct broken down into two subtasks, one following the other. That is, the computer is to carry out the first subtask completely, then go on and carry out the second subtask completely— never going back to the first subtask after starting the second subtask. The conditional construct (Figure 6.1c) is the one to use if the task consists of conditional construct doing one of two subtasks but not both, depending on some condition. If the condition is true, the computer is to carry out one subtask. If the condition is not true, the computer is to carry out a different subtask. Either subtask may be vacuous, that is, it may do nothing. Regardless, after the correct subtask is completed, the program moves onward. The program never goes back and retests the condition. The iterative construct (Figure 6.1d) is the one to use if the task consists of iterative construct doing a subtask a number of times, but only as long as some condition is true. If the condition is true, do the subtask. After the subtask is finished, go back and test the condition again. As long as the result of the condition tested is true, the program continues to carry out the same subtask again and again. The first",
    "269": "on some condition. If the condition is true, the computer is to carry out one subtask. If the condition is not true, the computer is to carry out a different subtask. Either subtask may be vacuous, that is, it may do nothing. Regardless, after the correct subtask is completed, the program moves onward. The program never goes back and retests the condition. The iterative construct (Figure 6.1d) is the one to use if the task consists of iterative construct doing a subtask a number of times, but only as long as some condition is true. If the condition is true, do the subtask. After the subtask is finished, go back and test the condition again. As long as the result of the condition tested is true, the program continues to carry out the same subtask again and again. The first time the test is not true, the program proceeds onward. Note in Figure 6.1 that whatever the task of Figure 6.1a, work starts with the arrow into the top of the “box” representing the task and finishes with the arrow out of the bottom of the box. There is no mention of what goes on inside the box. In each of the three possible decompositions of Figure 6.1a (i.e., Figures 6.1b, 1c, and 1d), there is exactly one entrance into the construct and exactly one exit out of the construct. Thus, it is easy to replace any task of the form of Figure 6.1a with whichever of its three decompositions apply. We will see how with several examples. §.§ LC-3 Control Instructions to Implement the Three Constructs Before we move on to an example, we illustrate in Figure 6.2 the use of LC-3 control instructions to direct the program counter to carry out each of the three decomposition constructs. That is, Figures 6.2b, 6.2c, and 6.2d correspond respectively to the three constructs shown in Figures 6.1b, 6.1c, and 6.1d. < g r a p h i c s > Use of LC-3 control instructions to implement structured programming We use",
    "270": "of the three possible decompositions of Figure 6.1a (i.e., Figures 6.1b, 1c, and 1d), there is exactly one entrance into the construct and exactly one exit out of the construct. Thus, it is easy to replace any task of the form of Figure 6.1a with whichever of its three decompositions apply. We will see how with several examples. §.§ LC-3 Control Instructions to Implement the Three Constructs Before we move on to an example, we illustrate in Figure 6.2 the use of LC-3 control instructions to direct the program counter to carry out each of the three decomposition constructs. That is, Figures 6.2b, 6.2c, and 6.2d correspond respectively to the three constructs shown in Figures 6.1b, 6.1c, and 6.1d. < g r a p h i c s > Use of LC-3 control instructions to implement structured programming We use the letters A, B, C, and D to represent addresses in memory containing LC-3 instructions. The letter A, for example, represents the address of the first LC-3 instruction to be executed in all three cases, since it is the starting address of the task to be decomposed (shown in Figure 6.2a). Figure 6.2b illustrates the control flow of the sequential decomposition. Note that no control instructions are needed since the PC is incremented from Address B_1 to Address B_1+1. The program continues to execute instructions through address D_1. It does not return to the first subtask. Figure 6.2c illustrates the control flow of the conditional decomposition. First, a condition is generated, resulting in the setting of one of the condition codes. This condition is tested by the conditional branch instruction at Address B_2. If the condition is true, the PC is set to Address C_2+1, and subtask 1 is executed. (Note: x equals 1 + the number of instructions in subtask 2.) If the condition is false, the PC (which had been incremented during the FETCH phase of the branch instruction) fetches the instruction at Address B_2+1, and subtask 2 is executed. Subtask 2 terminates in a branch instruction that",
    "271": "decomposition. Note that no control instructions are needed since the PC is incremented from Address B_1 to Address B_1+1. The program continues to execute instructions through address D_1. It does not return to the first subtask. Figure 6.2c illustrates the control flow of the conditional decomposition. First, a condition is generated, resulting in the setting of one of the condition codes. This condition is tested by the conditional branch instruction at Address B_2. If the condition is true, the PC is set to Address C_2+1, and subtask 1 is executed. (Note: x equals 1 + the number of instructions in subtask 2.) If the condition is false, the PC (which had been incremented during the FETCH phase of the branch instruction) fetches the instruction at Address B_2+1, and subtask 2 is executed. Subtask 2 terminates in a branch instruction that at Address C_2 unconditionally branches to D_2+1. (Note: y equals the number of instructions in subtask 1.) Figure 6.2d illustrates the control flow of the iterative decomposition. As in the case of the conditional construct, first a condition is generated, a condition code is set, and a conditional branch instruction is executed. In this case, the condition bits of the instruction at address B_3 are set to cause a conditional branch if the condition generated is false. If the condition is false, the PC is set to address D_3+1. (Note: z equals 1 + the number of instructions in the subtask in Figure 6.2d.) On the other hand, as long as the condition is true, the PC will be incremented to B_3+1, and the subtask will be executed. The subtask terminates in an unconditional branch instruction at address D_3, which sets the PC to A to again generate and test the condition. (Note: w equals the total number of instructions in the decomposition shown as Figure 6.2d.) Now, we are ready to move on to an example. §.§ The Character Count Example from Chapter 5, Revisited Recall the example of Section 5.5. The statement of the problem is as follows:",
    "272": "instruction at address B_3 are set to cause a conditional branch if the condition generated is false. If the condition is false, the PC is set to address D_3+1. (Note: z equals 1 + the number of instructions in the subtask in Figure 6.2d.) On the other hand, as long as the condition is true, the PC will be incremented to B_3+1, and the subtask will be executed. The subtask terminates in an unconditional branch instruction at address D_3, which sets the PC to A to again generate and test the condition. (Note: w equals the total number of instructions in the decomposition shown as Figure 6.2d.) Now, we are ready to move on to an example. §.§ The Character Count Example from Chapter 5, Revisited Recall the example of Section 5.5. The statement of the problem is as follows: \"We wish to input a character from the keyboard, count the number of occurrences of that character in a file, and display that count on the monitor.\" The systematic decomposition of this English language statement of the problem to the final LC-3 implementation is shown in Figure 6.3. Figure 6.3a is a brief statement of the problem. < g r a p h i c s > Stepwise refinement of the character count program < g r a p h i c s > Stepwise refinement of the character count program ( continued) < g r a p h i c s > Stepwise refinement of the character count program ( continued) In order to solve the problem, it is always a good idea first to examine exactly what is being asked for, and what is available to help solve the problem. In this case, the statement of the problem says that we will get the character of interest from the keyboard, and that we must examine all the characters in a file and determine how many are identical to the character obtained from the keyboard. Finally, we must output the result. To do this, we will need to examine",
    "273": "a p h i c s > Stepwise refinement of the character count program < g r a p h i c s > Stepwise refinement of the character count program ( continued) < g r a p h i c s > Stepwise refinement of the character count program ( continued) In order to solve the problem, it is always a good idea first to examine exactly what is being asked for, and what is available to help solve the problem. In this case, the statement of the problem says that we will get the character of interest from the keyboard, and that we must examine all the characters in a file and determine how many are identical to the character obtained from the keyboard. Finally, we must output the result. To do this, we will need to examine in turn all the characters in a file, we will need to compare each to the character we input from the keyboard, and we will need a counter to increment each time we get a match. We will need registers to hold all these pieces of information: 1. The character input from the keyboard. 2. Where we are (a pointer) in our scan of the file. 3. The character in the file that is currently being examined. 4. The count of the number of occurrences. We will also need to know when we have reached the end of the file. The problem decomposes naturally (using the sequential construct) into three parts as shown in Figure 6.3b: (A) initialization, which includes keyboard input of the character to be “counted,” (B) the process of determining how many occurrences of the character are present in the file, and (C) displaying the count on the monitor. We have seen the importance of proper initialization in several examples already. Before a computer program can get to the crux of the problem, it must have the correct initial values. These initial values do not just show up in the GPRs by magic. They get there as",
    "274": "in our scan of the file. 3. The character in the file that is currently being examined. 4. The count of the number of occurrences. We will also need to know when we have reached the end of the file. The problem decomposes naturally (using the sequential construct) into three parts as shown in Figure 6.3b: (A) initialization, which includes keyboard input of the character to be “counted,” (B) the process of determining how many occurrences of the character are present in the file, and (C) displaying the count on the monitor. We have seen the importance of proper initialization in several examples already. Before a computer program can get to the crux of the problem, it must have the correct initial values. These initial values do not just show up in the GPRs by magic. They get there as a result of the first set of steps in every algorithm: the initialization of its variables. In this particular algorithm, initialization (as we said in Chapter 5) consists of starting the counter at 0, setting the pointer to the address of the first character in the file to be examined, getting an input character from the keyboard, and getting the first character from the file. Collectively, these four steps comprise the initialization of the algorithm shown in Figure 6.3b as A. Figure 6.3c decomposes B into an iteration construct, such that as long as there are characters in the file to examine, the loop iterates. B1 shows what gets accomplished in each iteration. The character is tested and the count incremented if there is a match. Then the next character is prepared for examination. Recall from Chapter 5 that there are two basic techniques for controlling the number of iterations of a loop: the sentinel method and the use of a counter. Since we are unlikely to know how many characters there are in a random file, and since each file ends with an end of text (EOT) character, our choice is obvious. We use the sentinel method, i.e., testing",
    "275": "first character from the file. Collectively, these four steps comprise the initialization of the algorithm shown in Figure 6.3b as A. Figure 6.3c decomposes B into an iteration construct, such that as long as there are characters in the file to examine, the loop iterates. B1 shows what gets accomplished in each iteration. The character is tested and the count incremented if there is a match. Then the next character is prepared for examination. Recall from Chapter 5 that there are two basic techniques for controlling the number of iterations of a loop: the sentinel method and the use of a counter. Since we are unlikely to know how many characters there are in a random file, and since each file ends with an end of text (EOT) character, our choice is obvious. We use the sentinel method, i.e., testing each character to see if we are examining a character in the file or the EOT character. Figure 6.3c also shows the initialization step in greater detail. Four LC-3 registers (R0, R1, R2, and R3) have been specified to handle the four requirements of the algorithm: the input character from the keyboard, the current character being tested, the counter, and the pointer to the next character to be tested. Figure 6.3d decomposes both B1 and C using the sequential construct in both cases. In the case of B1, first the current character is tested (B2), and the counter incremented if we have a match, and then the next character is fetched (B3). In the case of C, first the count is prepared for display by converting it from a 2's complement integer to an ASCII code (C1), and then the actual character output is performed (C2). Finally, Figure 6.3e completes the decomposition, replacing B2 with the elements of the condition construct and B3 with the sequential construct (first the pointer is incremented, and then the next character to be scanned is loaded). The last step (and usually the easiest part) is to write the LC-3 code corresponding to each box",
    "276": "the pointer to the next character to be tested. Figure 6.3d decomposes both B1 and C using the sequential construct in both cases. In the case of B1, first the current character is tested (B2), and the counter incremented if we have a match, and then the next character is fetched (B3). In the case of C, first the count is prepared for display by converting it from a 2's complement integer to an ASCII code (C1), and then the actual character output is performed (C2). Finally, Figure 6.3e completes the decomposition, replacing B2 with the elements of the condition construct and B3 with the sequential construct (first the pointer is incremented, and then the next character to be scanned is loaded). The last step (and usually the easiest part) is to write the LC-3 code corresponding to each box in Figure 6.3e. Note that Figure 6.3e is essentially identical to Figure 5.16 of Chapter 5 (except now you know where it all came from!). [3pc] Before leaving this topic, it is worth pointing out that it is not always possible to understand everything at the outset. When you find that to be the case, it is not a signal simply to throw up your hands and quit. In such cases (which realistically are most cases), you should see if you can make sense of a piece of the problem, and expand from there. Problems are like puzzles; initially they can be opaque, but the more you work at it, the more they yield under your attack. Once you do understand what is given, what is being asked for, and how to proceed, you are ready to return to square one (Figure 6.3a) and restart the process of systematically decomposing the problem. § DEBUGGING Debugging a program is pretty much applied common sense. A simple debugging example comes to mind: You are driving to a place you have never visited, and somewhere along the way you made a wrong turn. What do you do now? One common “driving debugging” technique",
    "277": "simply to throw up your hands and quit. In such cases (which realistically are most cases), you should see if you can make sense of a piece of the problem, and expand from there. Problems are like puzzles; initially they can be opaque, but the more you work at it, the more they yield under your attack. Once you do understand what is given, what is being asked for, and how to proceed, you are ready to return to square one (Figure 6.3a) and restart the process of systematically decomposing the problem. § DEBUGGING Debugging a program is pretty much applied common sense. A simple debugging example comes to mind: You are driving to a place you have never visited, and somewhere along the way you made a wrong turn. What do you do now? One common “driving debugging” technique is to wander aimlessly, hoping to find your way back. When that does not work, and you are finally willing to listen to the person sitting next to you, you turn around and return to some “known” position on the route. Then, using a map (very difficult for some people), you follow the directions provided, periodically comparing where you are (from landmarks you see out the window) with where the map says you should be, until you reach your desired destination. Debugging is somewhat like that. A logical error in a program can make you take a wrong turn. The simplest way to keep track of where you are as compared to where you want to be is to trace the program. trace This consists of keeping track of the sequence of instructions that have been executed and the results produced by each instruction executed. When you examine the sequence of instructions executed, you can detect errors in the flow of the program. When you compare what each instruction has done to what it is supposed to do, you can detect logical errors in the program. In short, when the behavior of the program as it is executing is different",
    "278": "(from landmarks you see out the window) with where the map says you should be, until you reach your desired destination. Debugging is somewhat like that. A logical error in a program can make you take a wrong turn. The simplest way to keep track of where you are as compared to where you want to be is to trace the program. trace This consists of keeping track of the sequence of instructions that have been executed and the results produced by each instruction executed. When you examine the sequence of instructions executed, you can detect errors in the flow of the program. When you compare what each instruction has done to what it is supposed to do, you can detect logical errors in the program. In short, when the behavior of the program as it is executing is different from what it should be doing, you know there is a bug. A useful technique is to partition the program into parts, often referred to as modules, and examine the results that have been modules computed at the end of execution of each module. In fact, the structured programming approach discussed in Section 6.1 can help you determine where in the program's execution you should examine results. This allows you to systematically get to the point where you are focusing your attention on the instruction or instructions that are causing the problem. §.§ Debugging Operations Many sophisticated debugging tools are offered in the marketplace, and undoubtedly you will use many of them in the years ahead. In Chapter 15, for example, we will examine debugging techniques using a source-level debugger for C. Right now, however, we wish to stay at the level of the machine architecture, so we will see what we can accomplish with a few very elementary interactive debugging operations. We will set breakpoints, single-step, and examine the state of a program written in the LC-3 ISA. In Chapter 15, We will see these same concepts again: breakpoints, single-stepping, and examining program state that we are introducing here,",
    "279": "the program's execution you should examine results. This allows you to systematically get to the point where you are focusing your attention on the instruction or instructions that are causing the problem. §.§ Debugging Operations Many sophisticated debugging tools are offered in the marketplace, and undoubtedly you will use many of them in the years ahead. In Chapter 15, for example, we will examine debugging techniques using a source-level debugger for C. Right now, however, we wish to stay at the level of the machine architecture, so we will see what we can accomplish with a few very elementary interactive debugging operations. We will set breakpoints, single-step, and examine the state of a program written in the LC-3 ISA. In Chapter 15, We will see these same concepts again: breakpoints, single-stepping, and examining program state that we are introducing here, but applied to a C program, instead of the 0s and 1s of a program written in the LC-3 ISA. When debugging interactively, the user sits in front of the keyboard and monitor and issues commands to the computer. In our case, this means operating an LC-3 simulator, using the menu available with the simulator. It is important to be able to: 1. Write values into memory locations and into registers. 2. Execute instruction sequences in a program. 3. Stop execution when desired. 4. Examine what is in memory and registers at any point in the program. These few simple operations will go a long way toward debugging programs. §.§.§ Set Values In order to test the execution of a part of a program in isolation without having to worry about parts of the program that come before it, it is useful to first write values in memory and in registers that would have been written by earlier parts of the program. For example, suppose one module in your program supplies input from a keyboard, and a subsequent module operates on that input. Suppose you want to test the second module before you have finished debugging the first module. If",
    "280": "able to: 1. Write values into memory locations and into registers. 2. Execute instruction sequences in a program. 3. Stop execution when desired. 4. Examine what is in memory and registers at any point in the program. These few simple operations will go a long way toward debugging programs. §.§.§ Set Values In order to test the execution of a part of a program in isolation without having to worry about parts of the program that come before it, it is useful to first write values in memory and in registers that would have been written by earlier parts of the program. For example, suppose one module in your program supplies input from a keyboard, and a subsequent module operates on that input. Suppose you want to test the second module before you have finished debugging the first module. If you know that the keyboard input module ends up with an ASCII code in R0, you can test the module that operates on that input by first writing an ASCII code into R0. §.§.§ Execute Sequences It is important to be able to execute a sequence of instructions and then stop execution in order to examine the values that the program has computed as a result of executing that sequence. Three simple mechanisms are usually available for doing this: run, step, and set breakpoints. The Run command causes the program to execute until something makes it stop. This can be either a HALT instruction or a breakpoint. The Step command causes the program to execute a fixed number of instructions and then stop. The interactive user enters the number of instructions he/she wishes the simulator to execute before it stops. When that number is 1, the computer executes one instruction, then stops. Executing one instruction and then stopping is called single-stepping. It allows the person debugging the single stepping program to examine the individual results of each instruction executed. The Set Breakpoint command causes the program to stop execution at a specific instruction in a program. Executing the debugging command",
    "281": "program has computed as a result of executing that sequence. Three simple mechanisms are usually available for doing this: run, step, and set breakpoints. The Run command causes the program to execute until something makes it stop. This can be either a HALT instruction or a breakpoint. The Step command causes the program to execute a fixed number of instructions and then stop. The interactive user enters the number of instructions he/she wishes the simulator to execute before it stops. When that number is 1, the computer executes one instruction, then stops. Executing one instruction and then stopping is called single-stepping. It allows the person debugging the single stepping program to examine the individual results of each instruction executed. The Set Breakpoint command causes the program to stop execution at a specific instruction in a program. Executing the debugging command Set Breakpoint consists of adding an address to a list maintained by the simulator. During the FETCH phase of each instruction, the simulator compares the PC with the addresses in that list. If there is a match, execution stops. Thus, the effect of setting a breakpoint is to allow execution to proceed until the PC contains an address that has been set as a breakpoint. This is useful if one wishes to know what has been computed up to a particular point in the program. One sets a breakpoint at that address in the program and executes the Run command. The program executes until that point and then stops so the user can examine what has been computed up to that point. (When one no longer wishes to have the program stop execution at that point, the breakpoint can be removed by executing the Clear Breakpoint command.) §.§.§ Display Values Finally, it is useful to examine the results of execution when the simulator has stopped execution. The Display command allows the user to examine the contents of any memory location or any register. §.§ Use of an Interactive Debugger We conclude this chapter with four examples, showing how the use",
    "282": "been set as a breakpoint. This is useful if one wishes to know what has been computed up to a particular point in the program. One sets a breakpoint at that address in the program and executes the Run command. The program executes until that point and then stops so the user can examine what has been computed up to that point. (When one no longer wishes to have the program stop execution at that point, the breakpoint can be removed by executing the Clear Breakpoint command.) §.§.§ Display Values Finally, it is useful to examine the results of execution when the simulator has stopped execution. The Display command allows the user to examine the contents of any memory location or any register. §.§ Use of an Interactive Debugger We conclude this chapter with four examples, showing how the use of interactive debugging operations can help us find errors in a program. We have chosen the following four errors: (1) incorrectly setting the loop control so that the loop executes an incorrect number of times, (2) confusing the load instruction 0010, which loads a register with the contents of a memory location, with the load effective address instruction 1110, which loads a register with the address of a memory location, (3) forgetting which instructions set the condition codes, resulting in a branch instruction testing the wrong condition, and (4) not covering all possible cases of input values. §.§.§ Example 1: Multiplying Without a Multiply Instruction Let's start with an example we have seen before, multiplying two positive integers when the computer (such as the LC-3) does not have a multiply instruction. This time we will assume the two integers to be multiplied are in R4 and R5, and the result of execution (the product of those two integers) will be put in R2. Figure 6.4 shows the program we have written to do the job. 36pc Address 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 2-17 x3200 1|c0 1 0 1c|1 0",
    "283": "loads a register with the address of a memory location, (3) forgetting which instructions set the condition codes, resulting in a branch instruction testing the wrong condition, and (4) not covering all possible cases of input values. §.§.§ Example 1: Multiplying Without a Multiply Instruction Let's start with an example we have seen before, multiplying two positive integers when the computer (such as the LC-3) does not have a multiply instruction. This time we will assume the two integers to be multiplied are in R4 and R5, and the result of execution (the product of those two integers) will be put in R2. Figure 6.4 shows the program we have written to do the job. 36pc Address 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 2-17 x3200 1|c0 1 0 1c|1 0 1 1c|0 0 1 1c|0 1c|1 0 0 0 0 1c|0 1l R2 <- 0 2-17 x3201 1|c0 0 0 1c|1 0 1 1c|0 0 1 1c|0 1c|0 0 1c|0 1 0 1c|0 1l R2 <- R2 + R4 2-17 x3202 1|c0 0 0 1c|1 1 0 1c|1 1 0 1c|1 1c|1 1 1 1 1 1c|1 1l R5 <- R5 - 1 2-17 x3203 1|c0 0 0 1c|0 0 1 1c|1 1 1 1 1 1 1 1 0 1c|1 1l BRzp x3201 2-17 x3204 1|c1 1 1 1c|1 0 0 0 1c|0 0 0 1 0 0 1 0 1c|1 1l HALT 2-17Debugging Example 1. An LC-3 program to multiply (without a Multiply instruction). If we examine the program instruction by instruction, we note that the program first clears R2 (that is, initializes R2 to 0) and then attempts to perform the multiplication by adding R4 to itself a number of times equal to the initial value in R5. Each time an add is performed, R5 is decremented. When R5=0, the program terminates. It looks like the program should work! Upon execution, however, we find that if R4 initially contains the integer 10 and R5 initially contains the",
    "284": "R5 - 1 2-17 x3203 1|c0 0 0 1c|0 0 1 1c|1 1 1 1 1 1 1 1 0 1c|1 1l BRzp x3201 2-17 x3204 1|c1 1 1 1c|1 0 0 0 1c|0 0 0 1 0 0 1 0 1c|1 1l HALT 2-17Debugging Example 1. An LC-3 program to multiply (without a Multiply instruction). If we examine the program instruction by instruction, we note that the program first clears R2 (that is, initializes R2 to 0) and then attempts to perform the multiplication by adding R4 to itself a number of times equal to the initial value in R5. Each time an add is performed, R5 is decremented. When R5=0, the program terminates. It looks like the program should work! Upon execution, however, we find that if R4 initially contains the integer 10 and R5 initially contains the integer 3, the program produces the result 40. What went wrong? Our first thought is to trace the program. Before we do that, we note that the program assumes positive integers in R4 and R5. Using the Set Values command, we put the value 10 in R4 and the value 3 in R5. It is also useful to annotate each instruction with some algorithmic description of exactly what each instruction is doing. While this can be very tedious and not very helpful in a 10,000 instruction program, it often can be very helpful after one has isolated a bug to within a few instructions. There is a big difference between quickly eyeballing a sequence of instructions and stating precisely what each instruction is doing. Quickly eyeballing often results in mistaking what one eyeballs! Stating precisely usually does not. We have included in Figure 6.4, next to each instruction, such an annotation. Figure 6.5a shows a trace of the program, which we can obtain by single-stepping. The column labeled PC shows the contents of the PC at the start of each instruction. R2, R4, and R5 show the values in those three registers at the start of each instruction. 36pc4c(a) PC",
    "285": "instruction with some algorithmic description of exactly what each instruction is doing. While this can be very tedious and not very helpful in a 10,000 instruction program, it often can be very helpful after one has isolated a bug to within a few instructions. There is a big difference between quickly eyeballing a sequence of instructions and stating precisely what each instruction is doing. Quickly eyeballing often results in mistaking what one eyeballs! Stating precisely usually does not. We have included in Figure 6.4, next to each instruction, such an annotation. Figure 6.5a shows a trace of the program, which we can obtain by single-stepping. The column labeled PC shows the contents of the PC at the start of each instruction. R2, R4, and R5 show the values in those three registers at the start of each instruction. 36pc4c(a) PC R2 R4 R5 x3201 0 10 3 x3202 10 10 3 x3203 10 10 2 x3201 10 10 2 x3202 20 10 2 x3203 20 10 1 x3201 20 10 1 x3202 30 10 1 x3203 30 10 0 x3201 30 10 0 x3202 40 10 0 x3203 40 10 -1 x3204 40 10 -1 40 10 -1 4c(b) PC R2 R4 R5 x3203 10 10 2 x3203 20 10 1 x3203 30 10 0 x3203 40 10 -1 Debugging Example 1. (a) A trace of the Multiply program. (b) Tracing with breakpoints. A quick look at the trace shows that the loop body was executed four times, rather than three. That suggests that the condition codes for our branch instruction could have been set incorrectly. From there it is a short step to noting that the branch should have been taken only when R5 was positive, and not when R5 is 0. That is, bit[10]=1 in the branch instruction caused the extra iteration of the loop. The program can be corrected by simply replacing the instruction at x3203 with We should also note that we could have saved a lot of the work of tracing the program by using",
    "286": "R2 R4 R5 x3203 10 10 2 x3203 20 10 1 x3203 30 10 0 x3203 40 10 -1 Debugging Example 1. (a) A trace of the Multiply program. (b) Tracing with breakpoints. A quick look at the trace shows that the loop body was executed four times, rather than three. That suggests that the condition codes for our branch instruction could have been set incorrectly. From there it is a short step to noting that the branch should have been taken only when R5 was positive, and not when R5 is 0. That is, bit[10]=1 in the branch instruction caused the extra iteration of the loop. The program can be corrected by simply replacing the instruction at x3203 with We should also note that we could have saved a lot of the work of tracing the program by using a breakpoint. That is, instead of examining the results of each instruction, if we set a breakpoint at x3203, we would examine the results of each iteration of the loop. Setting a breakpoint to stop the program after each iteration of the loop is often enough to have us see the problem (and debug the program) without the tedium of single-stepping each iteration of the loop. Figure 6.5b shows the results of tracing the program, where each step is one iteration of the loop. We see that the loop executed four times instead of three, immediately identifying the bug. One last comment before we leave this example. Before we started tracing the program, we initialized R4 and R5 with values 10 and 3. When testing a program, it is important to judiciously choose the initial values for the test. Here, the program stated that the program had to work only for positive integers. So, 10 and 3 are probably OK. What if a (different) multiply program had been [-6pt] written to work for all integers? Then, we could have tried initial values of -6 and 3, 4 and -12, and perhaps -5 and -7. The problem with this set of",
    "287": "single-stepping each iteration of the loop. Figure 6.5b shows the results of tracing the program, where each step is one iteration of the loop. We see that the loop executed four times instead of three, immediately identifying the bug. One last comment before we leave this example. Before we started tracing the program, we initialized R4 and R5 with values 10 and 3. When testing a program, it is important to judiciously choose the initial values for the test. Here, the program stated that the program had to work only for positive integers. So, 10 and 3 are probably OK. What if a (different) multiply program had been [-6pt] written to work for all integers? Then, we could have tried initial values of -6 and 3, 4 and -12, and perhaps -5 and -7. The problem with this set of tests is that we have left out one of the most important initial values of all: 0. For the program to work for “all” integers, it has to work for 0 as well. The point is that, for a program to work, it must work for all valid source operands, and a good test of such a program is to set source operands to the unusual values, the ones the programmer may have failed to consider. These values are often referred to colloquially as corner cases, and more often that not are the values for which the program does not operate correctly. §.§.§ Example 2: Adding a Column of Numbers The program of Figure 6.6 is supposed to add the numbers stored in the 10 locations starting with x3100, and leave the result in R1. 36pc Address 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 2-17 x3000 1|c0 1 0 1c|1 0 0 1c|1 0 0 1c|1 1c|1 0 0 0 0 1c|0 1l R1 <- 0 2-17 x3001 1|c0 1 0 1c|1 1 0 1c|0 1 0 1c|0 1c|1 0 0 0 0 1c|0 1l R4 <- 0 2-17 x3002 1|c0",
    "288": "set source operands to the unusual values, the ones the programmer may have failed to consider. These values are often referred to colloquially as corner cases, and more often that not are the values for which the program does not operate correctly. §.§.§ Example 2: Adding a Column of Numbers The program of Figure 6.6 is supposed to add the numbers stored in the 10 locations starting with x3100, and leave the result in R1. 36pc Address 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 2-17 x3000 1|c0 1 0 1c|1 0 0 1c|1 0 0 1c|1 1c|1 0 0 0 0 1c|0 1l R1 <- 0 2-17 x3001 1|c0 1 0 1c|1 1 0 1c|0 1 0 1c|0 1c|1 0 0 0 0 1c|0 1l R4 <- 0 2-17 x3002 1|c0 0 0 1c|1 1 0 1c|0 1 0 1c|0 1c|1 0 1 0 1 1c|0 1l R4 <- R4 + 10 2-17 x3003 1|c0 0 1 1c|0 0 1 1c|0 0 1 1 1 1 1 1 0 1c|0 1l R2 <- M[x3100] 2-17 x3004 1|c0 1 1 1c|0 0 1 1c|1 0 1 1c|0 0 0 0 0 0 1c|0 1l R3 <- M[R2] 2-17 x3005 1|c0 0 0 1c|1 0 1 1c|0 0 1 1c|0 1c|1 0 0 0 0 1c|1 1l R2 <- R2 + 1 2-17 x3006 1|c0 0 0 1c|1 0 0 1c|1 0 0 1c|1 1c|0 0 1c|0 0 1 1c|1 1l R1 <- R1 + R3 2-17 x3007 1|c0 0 0 1c|1 1 0 1c|0 1 0 1c|0 1c|1 1 1 1 1 1c|1 1l R4 <- R4 - 1 2-17 x3008 1|c0 0 0 1c|0 0 0 1c|1 1 1 1 1 1 1 0 1 1c|1 1l BRp x3004 2-17 x3009 1|c1 1 1 1c|1 0 0 0 1c|0 0 0 1 0 0 1 0 1c|1 1l HALT 2-17 Debugging Example 2. An LC-3 program to add 10 integers. The contents of the 20 memory locations starting at location x3100",
    "289": "1c|0 1l R3 <- M[R2] 2-17 x3005 1|c0 0 0 1c|1 0 1 1c|0 0 1 1c|0 1c|1 0 0 0 0 1c|1 1l R2 <- R2 + 1 2-17 x3006 1|c0 0 0 1c|1 0 0 1c|1 0 0 1c|1 1c|0 0 1c|0 0 1 1c|1 1l R1 <- R1 + R3 2-17 x3007 1|c0 0 0 1c|1 1 0 1c|0 1 0 1c|0 1c|1 1 1 1 1 1c|1 1l R4 <- R4 - 1 2-17 x3008 1|c0 0 0 1c|0 0 0 1c|1 1 1 1 1 1 1 0 1 1c|1 1l BRp x3004 2-17 x3009 1|c1 1 1 1c|1 0 0 0 1c|0 0 0 1 0 0 1 0 1c|1 1l HALT 2-17 Debugging Example 2. An LC-3 program to add 10 integers. The contents of the 20 memory locations starting at location x3100 are shown in Figure 6.7. 2c Address Contents x3100 x3107 x3101 x2819 x3102 x0110 x3103 x0310 x3104 x0110 x3105 x1110 x3106 x11B1 x3107 x0019 x3108 x0007 x3109 x0004 x310A x0000 x310B x0000 x310C x0000 x310D x0000 x310E x0000 x310F x0000 x3110 x0000 x3111 x0000 x3112 x0000 x3113 x0000 Contents of memory locations x3100 to x3113 for Debugging Example 2 The program should work as follows. The instructions in x3000 to x3003 initialize the variables. In x3000, the sum (R1) is initialized to 0. In x3001 and x3002, the loop control (R4), which counts the number of values added to R1, is initialized to #10. The program subtracts 1 each time through the loop and repeats until R4 contains 0. In x3003, the base register (R2) is initialized to the starting location of the values to be added: x3100. From there, each time through the loop, one value is loaded into R3 (in x3004), the base register is incremented to get ready for the next iteration (x3005), the value in R3 is added to R1, which contains the running sum (x3006), the counter is decremented (x3007), the P bit is tested, and if true, the PC is set to x3004 to",
    "290": "program should work as follows. The instructions in x3000 to x3003 initialize the variables. In x3000, the sum (R1) is initialized to 0. In x3001 and x3002, the loop control (R4), which counts the number of values added to R1, is initialized to #10. The program subtracts 1 each time through the loop and repeats until R4 contains 0. In x3003, the base register (R2) is initialized to the starting location of the values to be added: x3100. From there, each time through the loop, one value is loaded into R3 (in x3004), the base register is incremented to get ready for the next iteration (x3005), the value in R3 is added to R1, which contains the running sum (x3006), the counter is decremented (x3007), the P bit is tested, and if true, the PC is set to x3004 to begin the next iteration of the loop body (x3008). After 10 times through the loop, R4 contains 0, the P bit is 0, the branch is not taken, and the program terminates (x3009). It looks like the program should work. However, when we execute the program and then check the value in R1, we find the number x0024, which is not x8135, the sum of the numbers stored in locations x3100 to x3109. What went wrong? We turn to the debugger and trace the program. Figure 6.8 shows a trace of the first four instructions executed. Note that after the instruction at x3003 has executed, R2 contains x3107, not x3100, as we had expected. The problem is that the opcode 0010 loaded the contents of M[x3100] (i.e., x3107) into R2, not the address x3100. The result was to add the ten numbers starting at M[x3107] instead of the ten numbers starting at M[x3100]. 36pc PC R1 R2 R4 x3001 0 x x x3002 0 x 0 x3003 0 x #10 x3004 0 x3107 #10 Debugging Example 2. A trace of the first four instructions of the Add program Our mistake: We used the wrong opcode. We should have used the",
    "291": "not x8135, the sum of the numbers stored in locations x3100 to x3109. What went wrong? We turn to the debugger and trace the program. Figure 6.8 shows a trace of the first four instructions executed. Note that after the instruction at x3003 has executed, R2 contains x3107, not x3100, as we had expected. The problem is that the opcode 0010 loaded the contents of M[x3100] (i.e., x3107) into R2, not the address x3100. The result was to add the ten numbers starting at M[x3107] instead of the ten numbers starting at M[x3100]. 36pc PC R1 R2 R4 x3001 0 x x x3002 0 x 0 x3003 0 x #10 x3004 0 x3107 #10 Debugging Example 2. A trace of the first four instructions of the Add program Our mistake: We used the wrong opcode. We should have used the opcode 1110 which would have loaded R2 with the address x3100. We correct the bug by replacing the opcode 0010 with 1110, and the program runs correctly. §.§.§ Example 3: Does a Sequence of Memory Locations Contain a 5 The program of Figure 6.9 has been written to examine the contents of the 10 memory locations starting at address x3100 and to store a 1 in R0 if any of them contains a 5 and a 0 in R0 if none of them contains a 5. 36pc Address 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 2-17 x3000 1|c0 1 0 1c|1 0 0 1c|0 0 0 1c|0 1c|1 0 0 0 0 1c|0 1l R0 <- 0 2-17 x3001 1|c0 0 0 1c|1 0 0 1c|0 0 0 1c|0 1c|1 0 0 0 0 1c|1 1l R0 <- R0 + 1 2-17 x3002 1|c0 1 0 1c|1 0 0 1c|1 0 0 1c|1 1c|1 0 0 0 0 1c|0 1l R1 <- 0 2-17 x3003 1|c0 0 0 1c|1 0 0 1c|1 0 0 1c|1 1c|1 1 1 0 1 1c|1 1l R1 <- R1 - 5 2-17 x3004 1|c0 1",
    "292": "and to store a 1 in R0 if any of them contains a 5 and a 0 in R0 if none of them contains a 5. 36pc Address 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 2-17 x3000 1|c0 1 0 1c|1 0 0 1c|0 0 0 1c|0 1c|1 0 0 0 0 1c|0 1l R0 <- 0 2-17 x3001 1|c0 0 0 1c|1 0 0 1c|0 0 0 1c|0 1c|1 0 0 0 0 1c|1 1l R0 <- R0 + 1 2-17 x3002 1|c0 1 0 1c|1 0 0 1c|1 0 0 1c|1 1c|1 0 0 0 0 1c|0 1l R1 <- 0 2-17 x3003 1|c0 0 0 1c|1 0 0 1c|1 0 0 1c|1 1c|1 1 1 0 1 1c|1 1l R1 <- R1 - 5 2-17 x3004 1|c0 1 0 1c|1 0 1 1c|1 0 1 1c|1 1c|1 0 0 0 0 1c|0 1l R3 <- 0 2-17 x3005 1|c0 0 0 1c|1 0 1 1c|1 0 1 1c|1 1c|1 0 1 0 1 1c|0 1l R3 <- R3 + 10 2-17 x3006 1|c0 0 1 1c|0 1 0 1c|0 0 0 0 0 0 1 0 0 1c|1 1l R4 <- M[x3010] 2-17 x3007 1|c0 1 1 1c|0 0 1 1c|0 1 0 1c|0 0 0 0 0 0 1c|0 1l R2 <- M[R4] 2-17 x3008 1|c0 0 0 1c|1 0 1 1c|0 0 1 1c|0 1c|0 0 1c|0 0 0 1c|1 1l R2 <- R2 + R1 2-17 x3009 1|c0 0 0 1c|0 0 1 1c|0 0 0 0 0 0 0 1 0 1c|1 1l BRz x300F 2-17 x300A 1|c0 0 0 1c|1 1 0 1c|0 1 0 1c|0 1c|1 0 0 0 0 1c|1 1l R4 <- R4 + 1 2-17 x300B 1|c0 0 0 1c|1 0 1 1c|1 0 1 1c|1 1c|1 1 1 1 1 1c|1 1l R3 <- R3 - 1 2-17 x300C 1|c0 1 1 1c|0 0 1 1c|0 1 0 1c|0 0 0 0 0 0 1c|0 1l R2 <-",
    "293": "1l R4 <- M[x3010] 2-17 x3007 1|c0 1 1 1c|0 0 1 1c|0 1 0 1c|0 0 0 0 0 0 1c|0 1l R2 <- M[R4] 2-17 x3008 1|c0 0 0 1c|1 0 1 1c|0 0 1 1c|0 1c|0 0 1c|0 0 0 1c|1 1l R2 <- R2 + R1 2-17 x3009 1|c0 0 0 1c|0 0 1 1c|0 0 0 0 0 0 0 1 0 1c|1 1l BRz x300F 2-17 x300A 1|c0 0 0 1c|1 1 0 1c|0 1 0 1c|0 1c|1 0 0 0 0 1c|1 1l R4 <- R4 + 1 2-17 x300B 1|c0 0 0 1c|1 0 1 1c|1 0 1 1c|1 1c|1 1 1 1 1 1c|1 1l R3 <- R3 - 1 2-17 x300C 1|c0 1 1 1c|0 0 1 1c|0 1 0 1c|0 0 0 0 0 0 1c|0 1l R2 <- M[R4] 2-17 x300D 1|c0 0 0 1c|0 0 0 1c|1 1 1 1 1 1 1 0 1 1c|0 1l BRp x3008 2-17 x300E 1|c0 1 0 1c|1 0 0 1c|0 0 0 1c|0 1c|1 0 0 0 0 1c|0 1l R0 <- 0 2-17 x300F 1|c1 1 1 1c|1 0 0 0 1c|0 0 0 1 0 0 1 0 1c|1 1l HALT 2-17 x3010 1|c0 0 1 1 0 0 0 1 0 0 0 0 0 0 0 1c|0 1l x3100 2-17 Debugging Example 3. An LC-3 program to detect the presence of a 5. The program is supposed to do the following: The first six instructions (at x3000 to x3005) initialize R0 to 1, R1 to -5, and R3 to 10. The instruction at x3006 initializes R4 to the address (x3100) of the first location to be tested, and x3007 loads the contents of x3100 into R2. The instructions at x3008 and x3009 determine if R2 contains the value 5 by adding -5 to R2 and branching to x300F if the result is 0. Since R0 is initialized to 1, the program terminates with R0 reporting the presence of a 5 among the locations tested. x300A",
    "294": "0 1c|1 1l HALT 2-17 x3010 1|c0 0 1 1 0 0 0 1 0 0 0 0 0 0 0 1c|0 1l x3100 2-17 Debugging Example 3. An LC-3 program to detect the presence of a 5. The program is supposed to do the following: The first six instructions (at x3000 to x3005) initialize R0 to 1, R1 to -5, and R3 to 10. The instruction at x3006 initializes R4 to the address (x3100) of the first location to be tested, and x3007 loads the contents of x3100 into R2. The instructions at x3008 and x3009 determine if R2 contains the value 5 by adding -5 to R2 and branching to x300F if the result is 0. Since R0 is initialized to 1, the program terminates with R0 reporting the presence of a 5 among the locations tested. x300A increments R4, preparing to load the next value. x300B decrements R3, indicating the number of values remaining to be tested. x300C loads the next value into R2. x300D branches back to x3008 to repeat the process if R3 still indicates more values to be tested. If R3=0, we have exhausted our tests, so R0 is set to 0 (x300E), and the program terminates (x300F). When we run the program for some sample data that contains a 5 in one of the memory locations, the program terminates with R0=0, indicating there were no 5s in locations x3100 to x310A. What went wrong? We examine a trace of the program, with a breakpoint set at x300D. The results are shown in Figure 6.10. 36pc PC R1 R2 R3 R4 x300D -5 7 9 3101 x300D -5 32 8 3102 x300D -5 0 7 3013 Debugging Example 3. Tracing Example 3 with a breakpoint at x300D. The first time the PC is at x300D, we have already tested the value stored in x3100, we have loaded 7 (the contents of x3101) into R2, and R3 indicates there are still nine values to be tested. R4 contains the address from which we most recently",
    "295": "the program terminates (x300F). When we run the program for some sample data that contains a 5 in one of the memory locations, the program terminates with R0=0, indicating there were no 5s in locations x3100 to x310A. What went wrong? We examine a trace of the program, with a breakpoint set at x300D. The results are shown in Figure 6.10. 36pc PC R1 R2 R3 R4 x300D -5 7 9 3101 x300D -5 32 8 3102 x300D -5 0 7 3013 Debugging Example 3. Tracing Example 3 with a breakpoint at x300D. The first time the PC is at x300D, we have already tested the value stored in x3100, we have loaded 7 (the contents of x3101) into R2, and R3 indicates there are still nine values to be tested. R4 contains the address from which we most recently loaded R2. The second time the PC is at x300D, we have loaded 32 (the contents of x3102) into R2, and R3 indicates there are eight values still to be tested. The third time the PC is at x300D, we have loaded 0 (the contents of x3103) into R2, and R3 indicates seven values still to be tested. The value 0 loaded into R2 causes the branch instruction at x300D to be not taken, R0 is set to 0 (x300E), and the program terminates (x300F) before the locations containing a 5 are tested. The error in the program occurred because the branch instruction immediately followed the load instruction which set the condition codes based on what was loaded. That wiped out the condition codes set by the iteration control instruction at x300B which was keeping track of the number of iterations left to do. Since the branch instruction should branch if there are still more memory locations to examine, the branch instruction should have immediately followed the iteration control instruction, and NOT the load instruction which also sets condition codes. A conditional branch instruction should be considered the second instruction in a pair of instructions. Instruction A ; sets the",
    "296": "0 loaded into R2 causes the branch instruction at x300D to be not taken, R0 is set to 0 (x300E), and the program terminates (x300F) before the locations containing a 5 are tested. The error in the program occurred because the branch instruction immediately followed the load instruction which set the condition codes based on what was loaded. That wiped out the condition codes set by the iteration control instruction at x300B which was keeping track of the number of iterations left to do. Since the branch instruction should branch if there are still more memory locations to examine, the branch instruction should have immediately followed the iteration control instruction, and NOT the load instruction which also sets condition codes. A conditional branch instruction should be considered the second instruction in a pair of instructions. Instruction A ; sets the condition codes BR instruction ; branches based on the condition codes The first instruction in the pair (Instruction A) sets the condition codes. The second instruction (BR) branches or not, depending on the condition codes set by instruction A. It is important to never insert any instruction that sets condition codes between instruction A and the branch instruction, since doing so will wipe out the condition codes set by instruction A that are needed by the branch instruction. Since the branch at x300D was based on the value loaded into R2, instead of how many values remained to be tested, the third time the branch instruction was executed, it was not taken when it should have been. If we interchange the instructions at x300B and x300C, the branch instruction at x300D immediately follows the iteration control instruction and the program executes correctly. It is also worth noting that the branch at x300D coincidentally behaved correctly the first two times it executed because the load instruction at x300C loaded positive values into R2. The bug did not produce incorrect behavior until the third iteration. It would be nice if bugs would manifest themselves the first time they are encountered, but that",
    "297": "so will wipe out the condition codes set by instruction A that are needed by the branch instruction. Since the branch at x300D was based on the value loaded into R2, instead of how many values remained to be tested, the third time the branch instruction was executed, it was not taken when it should have been. If we interchange the instructions at x300B and x300C, the branch instruction at x300D immediately follows the iteration control instruction and the program executes correctly. It is also worth noting that the branch at x300D coincidentally behaved correctly the first two times it executed because the load instruction at x300C loaded positive values into R2. The bug did not produce incorrect behavior until the third iteration. It would be nice if bugs would manifest themselves the first time they are encountered, but that is often not the case. Coincidences do occur, which adds to the challenges of debugging. §.§.§ Example 4: Finding the First 1 in a Word -2 Our last example contains an error that is usually one of the hardest to find, as we will see. The program of Figure 6.11 has been written to examine the contents of a memory location, find the first bit (reading from left to right) that is set, and store its bit position into R1. If no bit is set, the program is to store -1 in R1. For example, if the location examined contained 0010000110000000, the program would terminate with R1=13. If the location contained 0000000000000110, the program would terminate with R1=2. 36pc Address 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 2-17 x3000 1|c0 1 0 1c|1 0 0 1c|1 0 0 1c|1 1c|1 0 0 0 0 1c|0 1l R1 <- 0 2-17 x3001 1|c0 0 0 1c|1 0 0 1c|1 0 0 1c|1 1c|1 0 1 1 1 1c|1 1l R1 <- R1 + 15 2-17 x3002 1|c1 0 1 1c|0 0 1 1c|0 0 0 0 0 0 0 1 1 1c|0",
    "298": "location, find the first bit (reading from left to right) that is set, and store its bit position into R1. If no bit is set, the program is to store -1 in R1. For example, if the location examined contained 0010000110000000, the program would terminate with R1=13. If the location contained 0000000000000110, the program would terminate with R1=2. 36pc Address 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 2-17 x3000 1|c0 1 0 1c|1 0 0 1c|1 0 0 1c|1 1c|1 0 0 0 0 1c|0 1l R1 <- 0 2-17 x3001 1|c0 0 0 1c|1 0 0 1c|1 0 0 1c|1 1c|1 0 1 1 1 1c|1 1l R1 <- R1 + 15 2-17 x3002 1|c1 0 1 1c|0 0 1 1c|0 0 0 0 0 0 0 1 1 1c|0 1l R2 <- M[M[x3009]] 2-17 x3003 1|c0 0 0 1c|0 1 0 1c|0 0 0 0 0 0 0 1 0 1c|0 1l BRn x3008 2-17 x3004 1|c0 0 0 1c|1 0 0 1c|1 0 0 1c|1 1c|1 1 1 1 1 1c|1 1l R1 <- R1 - 1 2-17 x3005 1|c0 0 0 1c|1 0 1 1c|0 0 1 1c|0 1c|0 0 1c|0 0 1 1c|0 1l R2 <- R2 + R2 2-17 x3006 1|c0 0 0 1c|0 1 0 1c|0 0 0 0 0 0 0 0 0 1c|1 1l BRn x3008 2-17 x3007 1|c0 0 0 1c|0 1 1 1c|1 1 1 1 1 1 1 1 0 1c|0 1l BRnzp x3004 2-17 x3008 1|c1 1 1 1c|1 0 0 0 0 0 0 1 0 0 1 0 1c|1 1l HALT 2-17 x3009 1|c0 0 1 1 0 1 0 0 0 0 0 0 0 0 0 1c|0 1l x3400 2-17 Debugging Example 4. An LC-3 program to find the first 1 in a word. The program Figure 6.11 is supposed to work as follows (and it usually does): x3000 and x3001 initialize R1 to 15, the bit number of the left-most bit. x3002 loads",
    "299": "1c|0 1c|0 0 1c|0 0 1 1c|0 1l R2 <- R2 + R2 2-17 x3006 1|c0 0 0 1c|0 1 0 1c|0 0 0 0 0 0 0 0 0 1c|1 1l BRn x3008 2-17 x3007 1|c0 0 0 1c|0 1 1 1c|1 1 1 1 1 1 1 1 0 1c|0 1l BRnzp x3004 2-17 x3008 1|c1 1 1 1c|1 0 0 0 0 0 0 1 0 0 1 0 1c|1 1l HALT 2-17 x3009 1|c0 0 1 1 0 1 0 0 0 0 0 0 0 0 0 1c|0 1l x3400 2-17 Debugging Example 4. An LC-3 program to find the first 1 in a word. The program Figure 6.11 is supposed to work as follows (and it usually does): x3000 and x3001 initialize R1 to 15, the bit number of the left-most bit. x3002 loads R2 with the contents of x3400, the bit pattern to be examined. Since x3400 is too far from x3000 for a LD instruction, the load indirect instruction is used, obtaining the location of the bit pattern in x3009. x3003 tests the most significant bit of the bit pattern (bit [15]), and if it is a 1, branches to x3008, where the program terminates with R1=15. If the most significant bit is 0, the branch is not taken, and processing continues at x3004. The loop body, locations x3004 to x3007, does two things. First (x3004), it subtracts 1 from R1, yielding the bit number of the next bit to the right. Second (x3005), it adds R2 to itself, resulting in the contents of R2 shifting left one bit, resulting in the next bit to the right being shifted into the bit [15] position. Third (x3006), the BR instruction tests the \"new\" bit [15], and if it is a 1, branches to x3008, where the program halts with R1 containing the actual bit number of the current left-most bit. If the new bit [15] is 0, x3007 is an unconditional branch to x3004 for the next iteration of the loop body. The",
    "300": "the program terminates with R1=15. If the most significant bit is 0, the branch is not taken, and processing continues at x3004. The loop body, locations x3004 to x3007, does two things. First (x3004), it subtracts 1 from R1, yielding the bit number of the next bit to the right. Second (x3005), it adds R2 to itself, resulting in the contents of R2 shifting left one bit, resulting in the next bit to the right being shifted into the bit [15] position. Third (x3006), the BR instruction tests the \"new\" bit [15], and if it is a 1, branches to x3008, where the program halts with R1 containing the actual bit number of the current left-most bit. If the new bit [15] is 0, x3007 is an unconditional branch to x3004 for the next iteration of the loop body. The process continues until the first 1 is found. The program works correctly almost all the time. However, when we ran the program on our data, the program failed to terminate. What went wrong? A trace of the program, with a breakpoint set at x3007, is shown in Figure 6.12. 36pc PC R1 x3007 14 x3007 13 x3007 12 x3007 11 x3007 10 x3007 9 x3007 8 x3007 7 x3007 6 x3007 5 x3007 4 x3007 3 x3007 2 x3007 1 x3007 0 x3007 -1 x3007 -2 x3007 -3 x3007 -4 Debugging Example 4. A Trace of Debugging Example 4 with a breakpoint at x3007. Each time the PC contained the address x3007, R1 contained a value smaller by 1 than the previous time. The reason is as follows: After R1 was decremented and the value in R2 shifted left, the bit tested was a 0, and so the program did not terminate. This continued for values in R1 equal to 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, -1, -2, -3, -4, and so forth. The problem was that the initial value in x3400 was x0000. The program worked fine as long as",
    "301": "x3007 10 x3007 9 x3007 8 x3007 7 x3007 6 x3007 5 x3007 4 x3007 3 x3007 2 x3007 1 x3007 0 x3007 -1 x3007 -2 x3007 -3 x3007 -4 Debugging Example 4. A Trace of Debugging Example 4 with a breakpoint at x3007. Each time the PC contained the address x3007, R1 contained a value smaller by 1 than the previous time. The reason is as follows: After R1 was decremented and the value in R2 shifted left, the bit tested was a 0, and so the program did not terminate. This continued for values in R1 equal to 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, -1, -2, -3, -4, and so forth. The problem was that the initial value in x3400 was x0000. The program worked fine as long as there was at least one 1 present. For the case where x3400 contained all zeros, the conditional branch at x3006 was never taken, and so the program continued with execution of x3007, then x3004, x3005, x3006, x3007, and then back again to x3004. There was no way to break out of the sequence x3004, x3005, x3006, x3007, and back again to x3004. We call the sequence x3004 to x3007 a loop. Because there is no way for the program execution to break out of this loop, we call it an infinite loop. Thus, the program never terminates, and so we can never get the correct answer. Again, we emphasize that this is often the hardest error to detect because it is as we said earlier a corner case. The programmer assumed that at least one bit was set. What if no bits are set? That is, it is not enough for a program to execute correctly most of the time; it must execute correctly all the time, independent of the data that the program is asked to process. 6.1 Can a procedure that is not an algorithm be constructed from the three basic constructs of structured programming? If so, demonstrate",
    "302": "to x3004. We call the sequence x3004 to x3007 a loop. Because there is no way for the program execution to break out of this loop, we call it an infinite loop. Thus, the program never terminates, and so we can never get the correct answer. Again, we emphasize that this is often the hardest error to detect because it is as we said earlier a corner case. The programmer assumed that at least one bit was set. What if no bits are set? That is, it is not enough for a program to execute correctly most of the time; it must execute correctly all the time, independent of the data that the program is asked to process. 6.1 Can a procedure that is not an algorithm be constructed from the three basic constructs of structured programming? If so, demonstrate through an example. 6.2 The LC-3 has no Subtract instruction. If a programmer needed to subtract two numbers he/she would have to write a routine to handle it. Show the systematic decomposition of the process of subtracting two integers. 6.3 Recall the machine busy example from previous chapters. Suppose memory location x4000 contains an integer between 0 and 15 identifying a particular machine that has just become busy. Suppose further that the value in memory location x4001 tells which machines are busy and which machines are idle. Write an LC-3 machine language program that sets the appropriate bit in x4001 indicating that the machine in x4000 is busy. For example, if x4000 contains x0005 and x4001 contains x3101 at the start of execution, x4001 should contain x3121 after your program terminates. 6.4 Write a short LC-3 program that compares the two numbers in R1 and R2 and puts the value 0 in R0 if R1= R2, 1 if R1> R2 and -1 if R1< R2. 6.5 Which of the two algorithms for multiplying two numbers is preferable and why? 88 · 3 = 88 + 88 + 88 OR 3 + 3 + 3 + 3 + … + 3?",
    "303": "a particular machine that has just become busy. Suppose further that the value in memory location x4001 tells which machines are busy and which machines are idle. Write an LC-3 machine language program that sets the appropriate bit in x4001 indicating that the machine in x4000 is busy. For example, if x4000 contains x0005 and x4001 contains x3101 at the start of execution, x4001 should contain x3121 after your program terminates. 6.4 Write a short LC-3 program that compares the two numbers in R1 and R2 and puts the value 0 in R0 if R1= R2, 1 if R1> R2 and -1 if R1< R2. 6.5 Which of the two algorithms for multiplying two numbers is preferable and why? 88 · 3 = 88 + 88 + 88 OR 3 + 3 + 3 + 3 + … + 3? 6.6 Use your answers from Exercises 6.4 and 6.5 to develop a program that efficiently multiplies two integers and places the result in R3. Show the complete systematic decomposition, from the problem statement to the final program. 6.7 What does the following LC-3 program do? llllll x3001 1110 0000 0000 1100 x3002 1110 0010 0001 0000 x3003 0101 0100 1010 0000 x3004 0010 0100 0001 0011 x3005 0110 0110 0000 0000 x3006 0110 1000 0100 0000 x3007 0001 0110 1100 0100 x3008 0111 0110 0000 0000 x3009 0001 0000 0010 0001 x300A 0001 0010 0110 0001 x300B 0001 0100 1011 1111 x300C 0000 0011 1111 1000 x300D 1111 0000 0010 0101 x300E 0000 0000 0000 0101 x300F 0000 0000 0000 0100 x3010 0000 0000 0000 0011 x3011 0000 0000 0000 0110 x3012 0000 0000 0000 0010 x3013 0000 0000 0000 0100 x3014 0000 0000 0000 0111 x3015 0000 0000 0000 0110 x3016 0000 0000 0000 1000 x3017 0000 0000 0000 0111 x3018 0000 0000 0000 0101 6.8 Why is it necessary to initialize R2 in the character counting example in Section 6.1.4? In other words, in what manner might the program behave incorrectly if the R2 ← 0 step were",
    "304": "0000 x3004 0010 0100 0001 0011 x3005 0110 0110 0000 0000 x3006 0110 1000 0100 0000 x3007 0001 0110 1100 0100 x3008 0111 0110 0000 0000 x3009 0001 0000 0010 0001 x300A 0001 0010 0110 0001 x300B 0001 0100 1011 1111 x300C 0000 0011 1111 1000 x300D 1111 0000 0010 0101 x300E 0000 0000 0000 0101 x300F 0000 0000 0000 0100 x3010 0000 0000 0000 0011 x3011 0000 0000 0000 0110 x3012 0000 0000 0000 0010 x3013 0000 0000 0000 0100 x3014 0000 0000 0000 0111 x3015 0000 0000 0000 0110 x3016 0000 0000 0000 1000 x3017 0000 0000 0000 0111 x3018 0000 0000 0000 0101 6.8 Why is it necessary to initialize R2 in the character counting example in Section 6.1.4? In other words, in what manner might the program behave incorrectly if the R2 ← 0 step were removed from the routine? 6.9 Using the iteration construct, write an LC-3 machine language routine that displays exactly 100 Zs on the screen. 6.10 Using the conditional construct, write an LC-3 machine language routine that determines if a number stored in R2 is odd. 6.11 Write an LC-3 machine language routine to increment each of the numbers stored in memory location A through memory location B. Assume these locations have already been initialized with meaningful numbers. The addresses A and B can be found in memory locations x3100 and x3101. *6pt 6.12 a. Write an LC-3 machine language routine that echoes the last character typed at the keyboard. If the user types an R , the program then immediately outputs an R on the screen. b. Expand the routine from part a such that it echoes a line at a time. For example, if the user types: The quick brown fox jumps over the lazy dog. then the program waits for the user to press the Enter key (the ASCII code for which is x0A) and then outputs the same line. 6.13 Notice that we can shift a number to the left by one bit position by adding it to",
    "305": "location A through memory location B. Assume these locations have already been initialized with meaningful numbers. The addresses A and B can be found in memory locations x3100 and x3101. *6pt 6.12 a. Write an LC-3 machine language routine that echoes the last character typed at the keyboard. If the user types an R , the program then immediately outputs an R on the screen. b. Expand the routine from part a such that it echoes a line at a time. For example, if the user types: The quick brown fox jumps over the lazy dog. then the program waits for the user to press the Enter key (the ASCII code for which is x0A) and then outputs the same line. 6.13 Notice that we can shift a number to the left by one bit position by adding it to itself. For example, when the binary number 0011 is added to itself, the result is 0110. Shifting a number one bit pattern to the right is not as easy. Devise a routine in LC-3 machine code to shift the contents of memory location x3100 to the right by one bit. 6.14 Consider the following machine language program: x3000 0101 0100 1010 0000 x3001 0001 0010 0111 1111 x3002 0001 0010 0111 1111 x3003 0001 0010 0111 1111 x3004 0000 1000 0000 0010 x3005 0001 0100 1010 0001 x3006 0000 1111 1111 1010 x3007 1111 0000 0010 0101 What are the possible initial values of R1 that cause the final value in R2 to be 3? 6.15 Shown below are the contents of memory and registers before and after the LC-3 instruction at location x3010 is executed. Your job: Identify the instruction stored in x3010. Note: There is enough information below to uniquely specify the instruction at x3010. 9130pt10pt Before After 0pt10ptR0:0pt10pt x3208 x3208 R1: x2d7c x2d7c R2: xe373 xe373 R3: x2053 x2053 R4: x33ff x33ff R5: x3f1f x3f1f R6: xf4a2 xf4a2 R7: x5220 x5220 1|c|…0pt10pt x3400: x3001 x3001 x3401: x7a00 x7a00 x3402: x7a2b x7a2b x3403: xa700 xa700 x3404: xf011 xf011",
    "306": "1010 0000 x3001 0001 0010 0111 1111 x3002 0001 0010 0111 1111 x3003 0001 0010 0111 1111 x3004 0000 1000 0000 0010 x3005 0001 0100 1010 0001 x3006 0000 1111 1111 1010 x3007 1111 0000 0010 0101 What are the possible initial values of R1 that cause the final value in R2 to be 3? 6.15 Shown below are the contents of memory and registers before and after the LC-3 instruction at location x3010 is executed. Your job: Identify the instruction stored in x3010. Note: There is enough information below to uniquely specify the instruction at x3010. 9130pt10pt Before After 0pt10ptR0:0pt10pt x3208 x3208 R1: x2d7c x2d7c R2: xe373 xe373 R3: x2053 x2053 R4: x33ff x33ff R5: x3f1f x3f1f R6: xf4a2 xf4a2 R7: x5220 x5220 1|c|…0pt10pt x3400: x3001 x3001 x3401: x7a00 x7a00 x3402: x7a2b x7a2b x3403: xa700 xa700 x3404: xf011 xf011 x3405: x2003 x2003 x3406: x31ba xe373 x3407: xc100 xc100 x3408: xefef xefef 1|c|…0pt10pt 6.16 An LC-3 program is located in memory locations x3000 to x3006. It starts executing at x3000. If we keep track of all values loaded into the MAR as the program executes, we will get a sequence that starts as follows. Such a sequence of values is referred to as a trace. 913 MAR Trace 0pt10ptx30000pt10pt x3005 x3001 x3002 x3006 x4001 x3003 x0021 We have shown below some of the bits stored in locations x3000 to x3006. Your job is to fill in each blank space with a 0 or a 1, as appropriate. 0pt10pt x3000 0 0 1 0 0 0 0 0pt10pt x300l 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 1 0pt10pt x3002 1 0 1 1 0 0 0 0pt10pt x3003 0pt10pt x3004 1 1 1 1 0 0 0 0 0 0 1 0 0 1 0 1 0pt10pt x3005 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0pt10pt x3006 6.17 Shown below are the contents of registers before and after the LC-3 instruction at location x3210",
    "307": "referred to as a trace. 913 MAR Trace 0pt10ptx30000pt10pt x3005 x3001 x3002 x3006 x4001 x3003 x0021 We have shown below some of the bits stored in locations x3000 to x3006. Your job is to fill in each blank space with a 0 or a 1, as appropriate. 0pt10pt x3000 0 0 1 0 0 0 0 0pt10pt x300l 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 1 0pt10pt x3002 1 0 1 1 0 0 0 0pt10pt x3003 0pt10pt x3004 1 1 1 1 0 0 0 0 0 0 1 0 0 1 0 1 0pt10pt x3005 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0pt10pt x3006 6.17 Shown below are the contents of registers before and after the LC-3 instruction at location x3210 is executed. Your job: Identify the instruction stored in x3210. Note: There is enough information below to uniquely specify the instruction at x3210. 0pt10pt Before After 0pt10pt R0: xFF1D xFF1D 0pt10pt R1: x301C x301C 0pt10pt R2: x2F11 x2F11 0pt10pt R3: x5321 x5321 0pt10pt R4: x331F x331F 0pt10pt R5: x1F22 x1F22 0pt10pt R6: x01FF x01FF 0pt10pt R7: x341F x3211 0pt10pt PC: x3210 x3220 0pt10pt N: 0 0 0pt10pt Z: 1 1 0pt10pt P: 0 0 6.18 The LC-3 has no Divide instruction. A programmer needing to divide two numbers would have to write a routine to handle it. Show the systematic decomposition of the process of dividing two positive integers. Write an LC-3 machine language program starting at location x3000 which divides the number in memory location x4000 by the number in memory location x4001 and stores the quotient at x5000 and the remainder at x500l. 6.19 It is often necessary to encrypt messages to keep them away from prying eyes. A message can be represented as a string of ASCII characters, one per memory location, in consecutive memory locations. Bits [15:8] of each location contains 0, and the location immediately following the string contains x0000. A student who has not",
    "308": "x3210 x3220 0pt10pt N: 0 0 0pt10pt Z: 1 1 0pt10pt P: 0 0 6.18 The LC-3 has no Divide instruction. A programmer needing to divide two numbers would have to write a routine to handle it. Show the systematic decomposition of the process of dividing two positive integers. Write an LC-3 machine language program starting at location x3000 which divides the number in memory location x4000 by the number in memory location x4001 and stores the quotient at x5000 and the remainder at x500l. 6.19 It is often necessary to encrypt messages to keep them away from prying eyes. A message can be represented as a string of ASCII characters, one per memory location, in consecutive memory locations. Bits [15:8] of each location contains 0, and the location immediately following the string contains x0000. A student who has not taken this course has written the following LC-3 machine language program to encrypt the message starting at location x4000 by adding 4 to each character and storing the resulting message at x5000. For example, if the message at x4000 is “Matt,” then the encrypted message at x5000 is “Qeyy.” However, there are four bugs in his code. Find and correct these errors so that the program works correctly. x3000 1110 0000 0000 1010 x3001 0010 0010 0000 1010 x3002 0110 0100 0000 0000 x3003 0000 0100 0000 0101 x3004 0001 0100 1010 0101 x3005 0111 0100 0100 0000 x3006 0001 0000 0010 0001 x3007 0001 0010 0110 0001 x3008 0000 1001 1111 1001 x3009 0110 0100 0100 0000 x300A 1111 0000 0010 0101 x300B 0100 0000 0000 0000 x300C 0101 0000 0000 0000 6.20 Redo Exercise 6.18 for all integers, not just positive integers. 6.21 You have been asked to design the volume control system in a stereo. The user controls the volume by using “volume up” and “volume down” buttons on the stereo. When the user presses the “volume up” button, the volume should increase by 1; when the user presses the “volume down” button, the volume should decrease",
    "309": "these errors so that the program works correctly. x3000 1110 0000 0000 1010 x3001 0010 0010 0000 1010 x3002 0110 0100 0000 0000 x3003 0000 0100 0000 0101 x3004 0001 0100 1010 0101 x3005 0111 0100 0100 0000 x3006 0001 0000 0010 0001 x3007 0001 0010 0110 0001 x3008 0000 1001 1111 1001 x3009 0110 0100 0100 0000 x300A 1111 0000 0010 0101 x300B 0100 0000 0000 0000 x300C 0101 0000 0000 0000 6.20 Redo Exercise 6.18 for all integers, not just positive integers. 6.21 You have been asked to design the volume control system in a stereo. The user controls the volume by using “volume up” and “volume down” buttons on the stereo. When the user presses the “volume up” button, the volume should increase by 1; when the user presses the “volume down” button, the volume should decrease by 1. The volume level is represented as a 4-bit unsigned value, ranging from 0 to 15. If the user presses “volume up” when the volume is already at the maximum level of 15, the volume should remain at 15; similarly, if the user presses “volume down” when the volume is already at the minimum level of 0, the volume should remain at 0. The memory location x3100 has been directly hooked up to the speakers so that reading bits 3 through 0 from that memory location will give the current speaker volume, while writing bits 3 through 0 of that memory location will set the new speaker volume. When the user presses one of the volume buttons, the stereo hardware will reset the PC of the processor to x3000 and begin execution. If the user had pressed “volume up”, then memory location x3101 will be set to 1; otherwise, if the user had pressed “volume down”, then the memory location x3101 will be set to 0. Below is the program that controls the volume on the stereo. Two of the instructions in the program have been left out. Your job: fill in the missing instructions so that the program",
    "310": "should remain at 0. The memory location x3100 has been directly hooked up to the speakers so that reading bits 3 through 0 from that memory location will give the current speaker volume, while writing bits 3 through 0 of that memory location will set the new speaker volume. When the user presses one of the volume buttons, the stereo hardware will reset the PC of the processor to x3000 and begin execution. If the user had pressed “volume up”, then memory location x3101 will be set to 1; otherwise, if the user had pressed “volume down”, then the memory location x3101 will be set to 0. Below is the program that controls the volume on the stereo. Two of the instructions in the program have been left out. Your job: fill in the missing instructions so that the program controls the volume correctly as specified. t]|c|c|l| Address Contents Description x3000 0010000011111111 R0 ← M[x3100] x3001 0010001011111111 R1 ← M[x3101] x3002 0000010000000100 Branch to x3007 if Z is set x3003 x3004 0000010000000101 Branch to x300A if Z is set x3005 0001000000100001 R0 ← R0 + x0001 x3006 0000111000000011 Branch always to x300A x3007 0001001000100000 R1 ← R0 + x0000 x3008 0000010000000001 Branch to x300A if Z is set x3009 x300A 0011000011110101 M[x3100] ← R0 x300B 1111000000100101 TRAP x25 6.22STAR A warehouse is controlled by an electronic lock having an n-digit combination. The electronic lock has ten buttons, labeled 0 to 9 on its face. To open the lock, a user presses a sequence of n buttons. The corresponding ASCII characters get loaded into sequential locations of memory, starting at location x3150. After n buttons have been pressed, the null character x00 is loaded into the next sequential memory location. The program shown below determines whether or not the lock should open, depending on whether the combination entered agrees with the combination stored in the n memory locations starting at x3100. If the lock should open, the program stores a 1 in location x3050. If the lock should not open, the",
    "311": "0000010000000001 Branch to x300A if Z is set x3009 x300A 0011000011110101 M[x3100] ← R0 x300B 1111000000100101 TRAP x25 6.22STAR A warehouse is controlled by an electronic lock having an n-digit combination. The electronic lock has ten buttons, labeled 0 to 9 on its face. To open the lock, a user presses a sequence of n buttons. The corresponding ASCII characters get loaded into sequential locations of memory, starting at location x3150. After n buttons have been pressed, the null character x00 is loaded into the next sequential memory location. The program shown below determines whether or not the lock should open, depending on whether the combination entered agrees with the combination stored in the n memory locations starting at x3100. If the lock should open, the program stores a 1 in location x3050. If the lock should not open, the program stores a 0 in location x3050. Note that some of the instructions are missing. Complete the program by filling in the missing instructions. x3000 0101 101 101 1 00000 ; R5 – x0000 x3001 0010 000 000001111 ; R0 – M[x3011] x3002 0010 001 000001101 ; R1 – M[x3010] x3003 0110 010 000 000000 ; R2 – M[R0] x3004 x3005 0110 011 001 000000 ; R3 – M[R1] x3006 1001 011 011 111111 ; NOT R3 x3007 0001 011 011 1 00001 ; R3 – R3 + 1 x3008 x3009 0000 101 000000100 ; Branch to x300E if N or P is set x300A x300B x300C 0000 111 111110110 ; Branch always to x3003 x300D x300E 0011 101 001000001 ; Store R5 in x3050 x300F 1111 0000 0010 0101 ; HALT x3010 0011 0001 0000 0000 ; x3100 x3011 0011 0001 0101 0000 ; x3150 A simple change to the contents of memory will allow us to eliminate the instructions at memory locations x3006 and x3007 in our program. What is the change? 6.23 STAR The PC is loaded with x3000, and the instruction at address x3000 is executed. In fact, execution continues and four more instructions are executed.",
    "312": "x3005 0110 011 001 000000 ; R3 – M[R1] x3006 1001 011 011 111111 ; NOT R3 x3007 0001 011 011 1 00001 ; R3 – R3 + 1 x3008 x3009 0000 101 000000100 ; Branch to x300E if N or P is set x300A x300B x300C 0000 111 111110110 ; Branch always to x3003 x300D x300E 0011 101 001000001 ; Store R5 in x3050 x300F 1111 0000 0010 0101 ; HALT x3010 0011 0001 0000 0000 ; x3100 x3011 0011 0001 0101 0000 ; x3150 A simple change to the contents of memory will allow us to eliminate the instructions at memory locations x3006 and x3007 in our program. What is the change? 6.23 STAR The PC is loaded with x3000, and the instruction at address x3000 is executed. In fact, execution continues and four more instructions are executed. The table below contains the contents of various registers at the end of execution for each of the five (total) instructions. Your job: complete the table. PC MAR MDR IR R0 R1 Before execution starts x3000 —— —— —— x0000 x0000 After the first finishes xB333 x2005 After the 2nd finishes x0601 After the 3rd finishes x1___ x0001 After the 4th finishes x1___ x6666 After the 5th finishes x0BFC Let's start execution again, starting with PC = x3000. First, we re-initialize R0 and R1 to 0, and set a breakpoint at x3004. We press RUN eleven times, each time the program executes until the breakpoint. What are the final values of R0 and R1? 6.24 A student is debugging his program. His program does not have access to memory locations x0000 to x2FFF. Why that is the case we will discuss before the end of the book. The term is \"privileged memory\" but not something for you to worry about today. He sets a breakpoint at x3050, and then starts executing the program. When the program stops, he examines the contents of several memory locations and registers, then hits single step. The simulator executes one instruction and then stops. He",
    "313": "4th finishes x1___ x6666 After the 5th finishes x0BFC Let's start execution again, starting with PC = x3000. First, we re-initialize R0 and R1 to 0, and set a breakpoint at x3004. We press RUN eleven times, each time the program executes until the breakpoint. What are the final values of R0 and R1? 6.24 A student is debugging his program. His program does not have access to memory locations x0000 to x2FFF. Why that is the case we will discuss before the end of the book. The term is \"privileged memory\" but not something for you to worry about today. He sets a breakpoint at x3050, and then starts executing the program. When the program stops, he examines the contents of several memory locations and registers, then hits single step. The simulator executes one instruction and then stops. He again examines the contents of the memory locations and registers. They are as follows: Before After PC x3050 x3051 R0 x2F5F xFFFF R1 x4200 x4200 R2 x0123 x0123 R3 x2323 x2323 R4 x0010 x0010 R5 x0000 x0000 R6 x1000 x1000 R7 x0522 x0522 M[x3050] x6??? x6??? M[x4200] x5555 x5555 M[x4201] xFFFF xFFFF Complete the contents of location x3050 0 1 1 0 6.25 A student is writing a program and needs to subtract the contents of R1 from the contents of R2, and put the result in R3. Instead of writing: [t]0.5 NOT R3,R1 ADD R3,R3,#1 ADD R3,R3,R2 he writes: [t]0.5 NOT R3,R1 .FILL x16E1 ADD R3,R3,R2 He assembles the program and attempts to execute it. Does the subtract execute correctly? Why or why not? 6.26STAR During the execution of an LC-3 program, an instruction in the program starts executing at clock cycle T and requires 15 cycles to complete. The table below lists ALL five clock cycles during the processing of this instruction which require use of the bus. The table shows for each of those clock cycles: which clock cycle, the state of the state machine, the value on the bus, and the important control signals that are",
    "314": "1 0 6.25 A student is writing a program and needs to subtract the contents of R1 from the contents of R2, and put the result in R3. Instead of writing: [t]0.5 NOT R3,R1 ADD R3,R3,#1 ADD R3,R3,R2 he writes: [t]0.5 NOT R3,R1 .FILL x16E1 ADD R3,R3,R2 He assembles the program and attempts to execute it. Does the subtract execute correctly? Why or why not? 6.26STAR During the execution of an LC-3 program, an instruction in the program starts executing at clock cycle T and requires 15 cycles to complete. The table below lists ALL five clock cycles during the processing of this instruction which require use of the bus. The table shows for each of those clock cycles: which clock cycle, the state of the state machine, the value on the bus, and the important control signals that are active during that clock cycle. Cycle State Bus Important Control Signals For This Cycle T 18 x3010 LD.MAR = 1, LD.PC =1, PCMux = PC + 1, GatePC = 1 T + 4 T + 6 x3013 T + 10 x4567 T + 14 x0000 LD.REG = 1, LD.CC = 1, GateMDR = 1, DR = 001 a. Fill in the missing entries in the table. b. What is the instruction being processed? c. Where in memory is that instruction? d. How many clock cycles does it take memory to read or write? e. There is enough information above for you to know the contents of three memory locations. What are they and what are their contents? 6.27STAR An LC-3 program starts execution at x3000. During the execution of the program, a snapshot of all 8 registers were taken at six different times as shown below: before the program executes, after execution of instruction 1, after execution of instruction 2, after execution of instruction 3, after execution of instruction 4, after execution of instruction 5, and after execution of instruction 6. Registers Initial After 1st After 2nd After 3rd After 4th After 5th After 6th Value Instruction Instruction Instruction Instruction",
    "315": "the missing entries in the table. b. What is the instruction being processed? c. Where in memory is that instruction? d. How many clock cycles does it take memory to read or write? e. There is enough information above for you to know the contents of three memory locations. What are they and what are their contents? 6.27STAR An LC-3 program starts execution at x3000. During the execution of the program, a snapshot of all 8 registers were taken at six different times as shown below: before the program executes, after execution of instruction 1, after execution of instruction 2, after execution of instruction 3, after execution of instruction 4, after execution of instruction 5, and after execution of instruction 6. Registers Initial After 1st After 2nd After 3rd After 4th After 5th After 6th Value Instruction Instruction Instruction Instruction Instruction Instruction R0 x4006 x4050 x4050 x4050 x4050 x4050 x4050 R1 x5009 x5009 x5009 x5009 x5009 x5009 x5009 R2 x4008 x4008 x4008 x4008 x4008 x4008 xC055 R3 x4002 x8005 x8005 x8005 x8005 R4 x4003 x4003 x4003 x4003 x4003 R5 x400D x400D x400D x400D x400D R6 x400C x400C x400C x400C x400C x400C x400C R7 x6001 x6001 x6001 x6001 x400E Also, during the execution of the program, the PC trace, the MAR trace, and the MDR trace were also recorded as shown below. Note that a PC trace records the addresses of the instructions executed in sequence by the program. PC Trace x400D x400E MAR Trace MDR Trace xA009 x3025 x1703 x4040 x400E x1403 Your job: Fill in the missing entries in the 3 tables above. ../art/ch07/,../art/designelements/,../art/designelements/UnNumberedArt/makechapterhead#1 @ (0,0) (432,-577) < g r a p h i c s > (428,-577)1@9.52667in(381.5,-181) < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > 1212chapter 1212chapter 7212 3032#1 36.4pc4@ CHAPTER: ASSEMBLY LANGUAGE By now, you",
    "316": "the execution of the program, the PC trace, the MAR trace, and the MDR trace were also recorded as shown below. Note that a PC trace records the addresses of the instructions executed in sequence by the program. PC Trace x400D x400E MAR Trace MDR Trace xA009 x3025 x1703 x4040 x400E x1403 Your job: Fill in the missing entries in the 3 tables above. ../art/ch07/,../art/designelements/,../art/designelements/UnNumberedArt/makechapterhead#1 @ (0,0) (432,-577) < g r a p h i c s > (428,-577)1@9.52667in(381.5,-181) < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > 1212chapter 1212chapter 7212 3032#1 36.4pc4@ CHAPTER: ASSEMBLY LANGUAGE By now, you are probably a little tired of 1s and 0s and keeping track of 0001 meaning ADD and 1001 meaning NOT. Also, wouldn't it be nice if we could refer to a memory location by some meaningful symbolic name instead of memorizing its 16-bit address? And wouldn't it be nice if we could represent each instruction in some more easily comprehensible way, instead of having to keep track of which bit of the instruction conveys which individual piece of information about the instruction. It turns out that help is on the way. In this chapter, we introduce assembly language, a mechanism that does all of the above, and more. § ASSEMBLY LANGUAGE PROGRAMMING—MOVING UP A LEVEL Recall the levels of transformation identified in Figure 1.6 of Chapter 1. Algorithms are transformed into programs described in some mechanical language. This mechanical language can be, as it is in Chapter 5, the machine language of a particular computer. Recall that a program is in a computer's machine language if every instruction in the program is from the ISA of that computer. On the other hand, the mechanical language can be more user-friendly. We generally partition mechanical languages into two classes, high-level and low-level.",
    "317": "way, instead of having to keep track of which bit of the instruction conveys which individual piece of information about the instruction. It turns out that help is on the way. In this chapter, we introduce assembly language, a mechanism that does all of the above, and more. § ASSEMBLY LANGUAGE PROGRAMMING—MOVING UP A LEVEL Recall the levels of transformation identified in Figure 1.6 of Chapter 1. Algorithms are transformed into programs described in some mechanical language. This mechanical language can be, as it is in Chapter 5, the machine language of a particular computer. Recall that a program is in a computer's machine language if every instruction in the program is from the ISA of that computer. On the other hand, the mechanical language can be more user-friendly. We generally partition mechanical languages into two classes, high-level and low-level. Of the two, high-level languages are much more user-friendly. Examples are C, C++, Java, Fortran, COBOL, Python, plus more than a thousand others. Instructions in a high-level language almost (but not quite) resemble statements in a natural language such as English. High-level languages tend to be ISA independent. That is, once you learn how to program in C (or Fortran or Python) for one ISA, it is a small step to write programs in C (or Fortran or Python) for another ISA. Before a program written in a high-level language can be executed, it must be translated into a program in the ISA of the computer on which it is expected to execute. It is often the case that each statement in the high-level language specifies several instructions in the ISA of the computer. In Chapter 11, we will introduce the high-level language C, and in Chapters 12 through 19, we will show the relationship between various statements in C and their corresponding translations to LC-3 code. In this chapter, however, we will only move up a small step from the ISA we dealt with in Chapter 5. A small step up from the ISA of a machine is that",
    "318": "or Python) for one ISA, it is a small step to write programs in C (or Fortran or Python) for another ISA. Before a program written in a high-level language can be executed, it must be translated into a program in the ISA of the computer on which it is expected to execute. It is often the case that each statement in the high-level language specifies several instructions in the ISA of the computer. In Chapter 11, we will introduce the high-level language C, and in Chapters 12 through 19, we will show the relationship between various statements in C and their corresponding translations to LC-3 code. In this chapter, however, we will only move up a small step from the ISA we dealt with in Chapter 5. A small step up from the ISA of a machine is that ISA's assembly language. Assembly language is a low-level language. There is no assembly language confusing an instruction in a low-level language with a statement in English. Each assembly language instruction usually specifies a single instruction in the ISA. Unlike high-level languages, which are usually ISA independent, low-level languages are very much ISA dependent. In fact, it is usually the case that each ISA has only one assembly language. The purpose of assembly language is to make the programming process more user-friendly than programming in machine language (i.e., in the ISA of the computer with which we are dealing), while still providing the programmer with detailed control over the instructions that the computer can execute. So, for example, while still retaining control over the detailed instructions the computer is to carry out, we are freed from having to remember what opcode is 0001 and what opcode is 1001, or what is being stored in memory location 0011111100001010 and what is being stored in location 0011111100000101. Assembly languages let us use mnemonic devices for opcodes, such as ADD for 0001 and NOT for 1001, and they let us give meaningful symbolic names to memory locations, such as SUM or PRODUCT, rather than",
    "319": "that each ISA has only one assembly language. The purpose of assembly language is to make the programming process more user-friendly than programming in machine language (i.e., in the ISA of the computer with which we are dealing), while still providing the programmer with detailed control over the instructions that the computer can execute. So, for example, while still retaining control over the detailed instructions the computer is to carry out, we are freed from having to remember what opcode is 0001 and what opcode is 1001, or what is being stored in memory location 0011111100001010 and what is being stored in location 0011111100000101. Assembly languages let us use mnemonic devices for opcodes, such as ADD for 0001 and NOT for 1001, and they let us give meaningful symbolic names to memory locations, such as SUM or PRODUCT, rather than use the memory locations' 16-bit addresses. This makes it easier to differentiate which memory location is keeping track of a SUM and which memory location is keeping track of a PRODUCT. We call these names symbolic addresses. We will see, starting in Chapter 11, that when we take the larger step of moving up to a higher-level language (such as C), programming will be even more user-friendly, but in doing so, we will relinquish some control over exactly which detailed ISA instructions are to be carried out to accomplish the work specified by a high-level language statement. § AN ASSEMBLY LANGUAGE PROGRAM We will begin our study of the LC-3 assembly language by means of an example. The program in Figure 7.1 multiplies the integer intially stored in NUMBER by 6 by adding the integer to itself six times. For example, if the integer is 123, the program computes the product by adding 123 + 123 + 123 + 123 + 123 + 123. Where have you seen that before? :-) The program consists of 21 lines of code. We have added a line number to each line of the program in order to be able to refer to individual",
    "320": "C), programming will be even more user-friendly, but in doing so, we will relinquish some control over exactly which detailed ISA instructions are to be carried out to accomplish the work specified by a high-level language statement. § AN ASSEMBLY LANGUAGE PROGRAM We will begin our study of the LC-3 assembly language by means of an example. The program in Figure 7.1 multiplies the integer intially stored in NUMBER by 6 by adding the integer to itself six times. For example, if the integer is 123, the program computes the product by adding 123 + 123 + 123 + 123 + 123 + 123. Where have you seen that before? :-) The program consists of 21 lines of code. We have added a line number to each line of the program in order to be able to refer to individual lines easily. This is a common practice. These line numbers are not part of the program. Ten lines start with a semicolon, designating that they are strictly for the benefit of the human reader. More on this momentarily. Seven lines (06, 07, 08, 0C, 0D, 0E, and 10) specify assembly language instructions to be translated into machine language instructions of the LC-3, which will be executed when the program runs. The remaining four lines (05, 12, 13, and 15) contain pseudo-ops, which are pseudo-ops messages from the programmer to the translation program to help in the translation process. The translation program is called an assemblerassembler (in this case the LC-3 assembler), and the translation process is called assembly. assembly language [fontsize=911,formatcom=] 01 ; 02 ; Program to multiply an integer by the constant 6. 03 ; Before execution, an integer must be stored in NUMBER. 04 ; 05 .ORIG x3050 06 LD R1,SIX 07 LD R2,NUMBER 08 AND R3,R3,#0 ; Clear R3. It will 09 ; contain the product. 0A ; The inner loop 0B ; 0C AGAIN ADD R3,R3,R2 0D ADD R1,R1,#-1 ; R1 keeps track of 0E BRp AGAIN ; the iterations 0F ; 10 HALT 11 ;",
    "321": "the LC-3, which will be executed when the program runs. The remaining four lines (05, 12, 13, and 15) contain pseudo-ops, which are pseudo-ops messages from the programmer to the translation program to help in the translation process. The translation program is called an assemblerassembler (in this case the LC-3 assembler), and the translation process is called assembly. assembly language [fontsize=911,formatcom=] 01 ; 02 ; Program to multiply an integer by the constant 6. 03 ; Before execution, an integer must be stored in NUMBER. 04 ; 05 .ORIG x3050 06 LD R1,SIX 07 LD R2,NUMBER 08 AND R3,R3,#0 ; Clear R3. It will 09 ; contain the product. 0A ; The inner loop 0B ; 0C AGAIN ADD R3,R3,R2 0D ADD R1,R1,#-1 ; R1 keeps track of 0E BRp AGAIN ; the iterations 0F ; 10 HALT 11 ; 12 NUMBER .BLKW 1 13 SIX .FILL x0006 14 ; 15 .END An assembly language program §.§ Instructions Instead of an instruction being 16 0s and 1s, as is the case in the LC-3 ISA, an instruction in assembly language consists of four parts, as follows: Label Opcode Operands ; Comment Two of the parts (Label and Comment) are optional. More on that momentarily. §.§.§ Opcodes and Operands Two of the parts (Opcode and Operands) are mandatory. For an assembly language instruction to correspond to an instruction in the LC-3 ISA, it must have an Opcode (the thing the instruction is to do), and the appropriate number of Operands (the things it is supposed to do it to). Not surprisingly, this was exactly what we encountered in Chapter 5 when we studied the LC-3 ISA. The Opcode is a symbolic name for the opcode of the corresponding LC-3 instruction. The idea is that it is easier to remember an operation by the symbolic name ADD, AND, or LDR than by the 4-bit quantity 0001, 0101, or 0110. Figure 5.3 (also Figure A.2) lists the Opcodes of the 15 LC-3 instructions. Pages xxx through yyy show the assembly language representations for",
    "322": "More on that momentarily. §.§.§ Opcodes and Operands Two of the parts (Opcode and Operands) are mandatory. For an assembly language instruction to correspond to an instruction in the LC-3 ISA, it must have an Opcode (the thing the instruction is to do), and the appropriate number of Operands (the things it is supposed to do it to). Not surprisingly, this was exactly what we encountered in Chapter 5 when we studied the LC-3 ISA. The Opcode is a symbolic name for the opcode of the corresponding LC-3 instruction. The idea is that it is easier to remember an operation by the symbolic name ADD, AND, or LDR than by the 4-bit quantity 0001, 0101, or 0110. Figure 5.3 (also Figure A.2) lists the Opcodes of the 15 LC-3 instructions. Pages xxx through yyy show the assembly language representations for the 15 LC-3 instructions. The number of operands depends on the operation being performed. For example, the ADD instruction (line 0C in the program of Figure 7.1) requires three operands (two sources to obtain the numbers to be added, and one destination to designate where the result is to be stored). All three operands must be explicitly identified in the instruction. AGAIN ADD R3,R3,R2 In this case the operands to be added are obtained from register 2 and from register 3. The result is to be placed in register 3. We represent each of the registers 0 through 7 as R0, R1, R2, … , R7, rather than 000, 001, 010, … , 111. The LD instruction (line 07 of the program in Figure 7.1) requires two operands (the memory location from which the value is to be read and the destination register that is to contain the value after the instruction finishes execution). In LC-3 Assembly Language, We assign symbolic names called labels to the memory locations so we will not have to remember their explicit 16 bit addresses. In this case, the location from which labels the value is to be read is given the label NUMBER. The",
    "323": "instruction. AGAIN ADD R3,R3,R2 In this case the operands to be added are obtained from register 2 and from register 3. The result is to be placed in register 3. We represent each of the registers 0 through 7 as R0, R1, R2, … , R7, rather than 000, 001, 010, … , 111. The LD instruction (line 07 of the program in Figure 7.1) requires two operands (the memory location from which the value is to be read and the destination register that is to contain the value after the instruction finishes execution). In LC-3 Assembly Language, We assign symbolic names called labels to the memory locations so we will not have to remember their explicit 16 bit addresses. In this case, the location from which labels the value is to be read is given the label NUMBER. The destination (i.e., where the value is to be loaded) is register 2. LD R2, NUMBER As we discussed in Section 5.1.6, operands can be obtained from registers, from memory, or they may be literal (i.e., immediate) values in the instruction. In the case of register operands, the registers are explicitly represented (such as R2 and R3 in line 0C). In the case of memory operands, the symbolic name of the memory location is explicitly represented (such as NUMBER in line 07 and SIX in line 06). In the case of immediate operands, the actual value is explicitly represented (such as the value 0 in line 08). AND R3, R3, #0 ; Clear R3. It will contain the product. A literal value must contain a symbol identifying the representation base literal of the number. We use # for decimal, x for hexadecimal, and b for binary. Sometimes there is no ambiguity, such as in the case 3F0A, which decimal!symbol forhexadecimal!symbol forbinary!symbol for is a hex number. Nonetheless, we write it as x3F0A. Sometimes there is ambiguity, such as in the case 1000. x1000 represents the decimal number 4096, b1000 represents the decimal number 8, and #1000 represents the decimal number 1000.",
    "324": "the case of memory operands, the symbolic name of the memory location is explicitly represented (such as NUMBER in line 07 and SIX in line 06). In the case of immediate operands, the actual value is explicitly represented (such as the value 0 in line 08). AND R3, R3, #0 ; Clear R3. It will contain the product. A literal value must contain a symbol identifying the representation base literal of the number. We use # for decimal, x for hexadecimal, and b for binary. Sometimes there is no ambiguity, such as in the case 3F0A, which decimal!symbol forhexadecimal!symbol forbinary!symbol for is a hex number. Nonetheless, we write it as x3F0A. Sometimes there is ambiguity, such as in the case 1000. x1000 represents the decimal number 4096, b1000 represents the decimal number 8, and #1000 represents the decimal number 1000. §.§.§ Labels Labels are symbolic names that are used to identify memory locations that are referred to explicitly in the program. In LC-3 assembly language, a label consists of from one to 20 alphanumeric characters (i.e., each character is a capital or lowercase letter of the English alphabet, or a decimal digit), starting with a letter of the alphabet. However, not all sequences of characters that follow these rules can be used as labels. You know that computer programs can not tolerate ambiguity. So, ADD, NOT, x1000, R4 and other character strings that have specific meanings in an LC-3 program can not be used as labels. They could confuse the LC-3 Assembler as it tries to translate the LC-3 Assembly Language program into a program in the LC-3 ISA. Such not-allowed character strings are often referred to as reserved words. NOW, Under21, R2D2, R785, and C3PO are all examples of legitimate LC-3 assembly language labels. We said we give a label (i.e., a symbolic name) to a memory locaton if we explicitly refer to it in the program. There are two reasons for explicitly referring to a memory location. 1. The location is the target of a branch instruction (for",
    "325": "not all sequences of characters that follow these rules can be used as labels. You know that computer programs can not tolerate ambiguity. So, ADD, NOT, x1000, R4 and other character strings that have specific meanings in an LC-3 program can not be used as labels. They could confuse the LC-3 Assembler as it tries to translate the LC-3 Assembly Language program into a program in the LC-3 ISA. Such not-allowed character strings are often referred to as reserved words. NOW, Under21, R2D2, R785, and C3PO are all examples of legitimate LC-3 assembly language labels. We said we give a label (i.e., a symbolic name) to a memory locaton if we explicitly refer to it in the program. There are two reasons for explicitly referring to a memory location. 1. The location is the target of a branch instruction (for example, AGAIN in line 0C). That is, the label AGAIN identifies the location of the instruction that will be executed next if the branch is taken. 2. The location contains a value that is loaded or stored (for example, NUMBER in line 12, and SIX in line 13). Note the location AGAIN (identified in line 0C) is specifically referenced by the branch instruction in line 0E. BRp AGAIN If the result of ADD R1,R1,#–1 is positive (which results in the P bit being set), then the program branches to the location explicitly referenced as AGAIN to perform another iteration. The location NUMBER is specifically referenced by the load instruction in line 07. The value stored in the memory location explicitly referenced as NUMBER is loaded into R2. If a location in the program is not explicitly referenced, then there is no need to give it a label. §.§.§ Comments Comments are messages intended only for human consumption. They have comments no effect on the translation process and indeed are not acted on by the LC-3 assembler. They are identified in the program by semicolons. A semicolon signifies that the rest of the line is a comment and is to be",
    "326": "the branch instruction in line 0E. BRp AGAIN If the result of ADD R1,R1,#–1 is positive (which results in the P bit being set), then the program branches to the location explicitly referenced as AGAIN to perform another iteration. The location NUMBER is specifically referenced by the load instruction in line 07. The value stored in the memory location explicitly referenced as NUMBER is loaded into R2. If a location in the program is not explicitly referenced, then there is no need to give it a label. §.§.§ Comments Comments are messages intended only for human consumption. They have comments no effect on the translation process and indeed are not acted on by the LC-3 assembler. They are identified in the program by semicolons. A semicolon signifies that the rest of the line is a comment and is to be ignored by the assembler. If the semicolon is the first nonblank character on the line, the entire line is ignored. If the semicolon follows the operands of an instruction, then only the comment is ignored by the assembler. The purpose of comments is to make the program more comprehensible to the human reader. Comments help explain a nonintuitive aspect of an instruction or a set of instructions. In lines 08 and 09, the comment “Clear R3; it will contain the product” lets the reader know that the instruction on line 08 is initializing R3 prior to accumulating the product of the two numbers. While the purpose of line 08 may be obvious to the programmer today, it may not be the case two years from now, after the programmer has written an additional 30,000 instructions and cannot remember why he/she wrote AND R3,R3,#0. It may also be the case that two years from now, the programmer no longer works for the company and the company needs to modify the program in response to a product update. If the task is assigned to someone who has never seen the program before, comments go a long way toward helping that person understand",
    "327": "an instruction or a set of instructions. In lines 08 and 09, the comment “Clear R3; it will contain the product” lets the reader know that the instruction on line 08 is initializing R3 prior to accumulating the product of the two numbers. While the purpose of line 08 may be obvious to the programmer today, it may not be the case two years from now, after the programmer has written an additional 30,000 instructions and cannot remember why he/she wrote AND R3,R3,#0. It may also be the case that two years from now, the programmer no longer works for the company and the company needs to modify the program in response to a product update. If the task is assigned to someone who has never seen the program before, comments go a long way toward helping that person understand the program. It is important to make comments that provide additional insight and not just restate the obvious. There are two reasons for this. First, comments that restate the obvious are a waste of everyone's time. [-11pt] Second, they tend to obscure the comments that say something important because they add clutter to the program. For example, in line 0D, the comment “Decrement R1” would be a bad idea. It would provide no additional insight to the instruction, and it would add clutter to the page. Another purpose of comments is to make the visual presentation of a program easier to understand. That is, comments are used to separate pieces of a program from each other to make the program more readable. Lines of code that work together to compute a single result are placed on successive lines, but are separated from the rest of the program by blank lines. For example, note that lines 0C through 0E, which together form the loop body which is the crux of this computer program are separated from the rest of the code by lines 0B and 0F. There is nothing on lines 0B and 0F other than the semicolons in the first",
    "328": "the comment “Decrement R1” would be a bad idea. It would provide no additional insight to the instruction, and it would add clutter to the page. Another purpose of comments is to make the visual presentation of a program easier to understand. That is, comments are used to separate pieces of a program from each other to make the program more readable. Lines of code that work together to compute a single result are placed on successive lines, but are separated from the rest of the program by blank lines. For example, note that lines 0C through 0E, which together form the loop body which is the crux of this computer program are separated from the rest of the code by lines 0B and 0F. There is nothing on lines 0B and 0F other than the semicolons in the first column. Incidentally, another opportunity to make a program easier to read is the judicious use of white space, accomplished by adding extra spaces to a line that are ignored by the assembler – for example, having all the opcodes start in the same column on the page, whether or not the instruction has a label. §.§ Pseudo-ops (Assembler Directives) The LC-3 assembler is a program that takes as input a string of characters representing a computer program written in LC-3 assembly language and translates it into a program in the ISA of the LC-3. Pseudo-ops help the assembler perform that task. pseudo-ops The more formal name for a pseudo-op is assembler directive. assembler!directives It is called a pseudo-op because, like its Greek root \"pseudes\" (which means \"false\"), it does not refer to an operation that will be performed by the program during execution. Rather, the pseudo-op is strictly a message from the assembly language programmer to the assembler to help the assembler in the assembly process. Once the assembler handles the message, the pseudo-op is discarded. The LC-3 assembly language contains five pseudo-ops that we will find useful in our assembly language programming: .ORIG, .FILL, .BLKW, .STRINGZ, and .END. All",
    "329": "LC-3 assembler is a program that takes as input a string of characters representing a computer program written in LC-3 assembly language and translates it into a program in the ISA of the LC-3. Pseudo-ops help the assembler perform that task. pseudo-ops The more formal name for a pseudo-op is assembler directive. assembler!directives It is called a pseudo-op because, like its Greek root \"pseudes\" (which means \"false\"), it does not refer to an operation that will be performed by the program during execution. Rather, the pseudo-op is strictly a message from the assembly language programmer to the assembler to help the assembler in the assembly process. Once the assembler handles the message, the pseudo-op is discarded. The LC-3 assembly language contains five pseudo-ops that we will find useful in our assembly language programming: .ORIG, .FILL, .BLKW, .STRINGZ, and .END. All are easily recognizable by the dot as their first character. §.§.§ .ORIG .ORIG tells the assembler where in memory to place the LC-3 program. In line 05, .ORIG x3050 says, place the first LC-3 ISA instruction in location x3050. As a result, 0010001000001100 (the translated LD R1,SIX instruction) is put in location x3050. ...and the rest of the translated LC-3 program is placed in the subsequent sequential locations in memory. For example, if the program consists of x100 LC-3 instructions, and .ORIG says to put the first instruction in x3050, the remaining xFF instructions are placed in locations x3051 to x314F. §.§.§ .FILL .FILL tells the assembler to set aside the next location in the program and initialize it with the value of the operand. The value can be either a number or a label. In line 13, the ninth location in the resulting LC-3 program is initialized to the value x0006. §.§.§ .BLKW .BLKW tells the assembler to set aside some number of sequential memory locations (i.e., a BLoc K of Words) in the program. The actual number is the operand of the .BLKW pseudo-op. In line 12, the pseudo-op instructs the assembler to set aside one location in",
    "330": "program is placed in the subsequent sequential locations in memory. For example, if the program consists of x100 LC-3 instructions, and .ORIG says to put the first instruction in x3050, the remaining xFF instructions are placed in locations x3051 to x314F. §.§.§ .FILL .FILL tells the assembler to set aside the next location in the program and initialize it with the value of the operand. The value can be either a number or a label. In line 13, the ninth location in the resulting LC-3 program is initialized to the value x0006. §.§.§ .BLKW .BLKW tells the assembler to set aside some number of sequential memory locations (i.e., a BLoc K of Words) in the program. The actual number is the operand of the .BLKW pseudo-op. In line 12, the pseudo-op instructs the assembler to set aside one location in memory (and, incidentally, to label it NUMBER). The pseudo-op .BLKW is particularly useful when the actual value of the operand is not yet known. In our example we assumed the number in location NUMBER was 123. How did it get there? A common use of .BLKW is to set aside a location in the program, as we did here, and have another section of code produce the number, perhaps from input from a keyboard (which we can not know at the time we write the program), and store that value into NUMBER before we execute the code in Figure 7.1. §.§.§ .STRINGZ .STRINGZ tells the assembler to initialize a sequence of n+1 memory locations. The argument is a sequence of n characters, inside double quotation marks. The first n words of memory are initialized with the zero-extended ASCII codes of the corresponding characters in the string. The final word of memory is initialized to 0. The last word, containing x0000, provides a convenient sentinel for processing the string of ASCII codes. For example, the code fragment .ORIG x3010 HELLO .STRINGZ \"Hello, World!\" would result in the assembler initializing locations x3010 through x301D to the following values: x3010: x0048 x3011: x0065",
    "331": "have another section of code produce the number, perhaps from input from a keyboard (which we can not know at the time we write the program), and store that value into NUMBER before we execute the code in Figure 7.1. §.§.§ .STRINGZ .STRINGZ tells the assembler to initialize a sequence of n+1 memory locations. The argument is a sequence of n characters, inside double quotation marks. The first n words of memory are initialized with the zero-extended ASCII codes of the corresponding characters in the string. The final word of memory is initialized to 0. The last word, containing x0000, provides a convenient sentinel for processing the string of ASCII codes. For example, the code fragment .ORIG x3010 HELLO .STRINGZ \"Hello, World!\" would result in the assembler initializing locations x3010 through x301D to the following values: x3010: x0048 x3011: x0065 x3012: x006C x3013: x006C x3014: x006F x3015: x002C x3016: x0020 x3017: x0057 x3018: x006F x3019: x0072 x301A: x006C x301B: x0064 x301C: x0021 x301D: x0000 §.§.§ .END .END tells the assembler it has reached the end of the program, and need not even look at anything after it. That is, any characters that come after .END will not be processed by the assembler. Note: .END does not stop the program during execution. In fact, .END does not even exist at the time of execution. It is simply a delimiter—it marks the end of the program. It is a message from the programmer, telling the assembler where the assembly language program ends. §.§ Example: The Character Count Example of Section 5.5, Revisited again! =-1 Now we are ready for a complete example. Let's consider again the problem of Section 5.5. We wish to write a program that will take a character that is input from the keyboard and count the number of occurrences of that character in a file. As before, we first develop the algorithm by constructing the flowchart. Recall that in Section 6.1, we showed how to decompose the problem systematically so as to generate the flowchart of Figure 5.16.",
    "332": "the assembler. Note: .END does not stop the program during execution. In fact, .END does not even exist at the time of execution. It is simply a delimiter—it marks the end of the program. It is a message from the programmer, telling the assembler where the assembly language program ends. §.§ Example: The Character Count Example of Section 5.5, Revisited again! =-1 Now we are ready for a complete example. Let's consider again the problem of Section 5.5. We wish to write a program that will take a character that is input from the keyboard and count the number of occurrences of that character in a file. As before, we first develop the algorithm by constructing the flowchart. Recall that in Section 6.1, we showed how to decompose the problem systematically so as to generate the flowchart of Figure 5.16. In fact, the final step of that process in Chapter 6 is the flowchart of Figure 6.3e, which is essentially identical to Figure 5.16. Next, we use the flowchart to write the actual program. This time, however, we enjoy the luxury of not worrying about 0s and 1s and instead write the program in LC-3 assembly language. The program is shown in Figure 7.2. [fontsize=89.5,formatcom=] 01 ; 02 ; Program to count occurrences of a character in a file. 03 ; Character to be input from the keyboard. 04 ; Result to be displayed on the monitor. 05 ; Program works only if no more than 9 occurrences are found. 06 ; 07 ; 08 ; Initialization 09 ; 0A .ORIG x3000 0B AND R2,R2,#0 ; R2 is counter, initialize to 0 0C LD R3,PTR ; R3 is pointer to characters 0D TRAP x23 ; R0 gets character input 0E LDR R1,R3,#0 ; R1 gets the next character 0F ; 10 ; Test character for end of file 11 ; 12 ; 13 TEST ADD R4,R1,#-4 ; Test for EOT 14 BRz OUTPUT ; If done, prepare the output 15 ; 16 ; Test character for match. If a match,",
    "333": "shown in Figure 7.2. [fontsize=89.5,formatcom=] 01 ; 02 ; Program to count occurrences of a character in a file. 03 ; Character to be input from the keyboard. 04 ; Result to be displayed on the monitor. 05 ; Program works only if no more than 9 occurrences are found. 06 ; 07 ; 08 ; Initialization 09 ; 0A .ORIG x3000 0B AND R2,R2,#0 ; R2 is counter, initialize to 0 0C LD R3,PTR ; R3 is pointer to characters 0D TRAP x23 ; R0 gets character input 0E LDR R1,R3,#0 ; R1 gets the next character 0F ; 10 ; Test character for end of file 11 ; 12 ; 13 TEST ADD R4,R1,#-4 ; Test for EOT 14 BRz OUTPUT ; If done, prepare the output 15 ; 16 ; Test character for match. If a match, increment count. 17 ; 18 NOT R1,R1 19 ADD R1,R1,#1 ; R1 <– -R1 1A ADD R1,R1,R0 ; R1 <– R0-R1. If R1=0, a match! 1B BRnp GETCHAR ; If no match, do not increment 1C ADD R2,R2,#1 1D ; 1E ; Get next character from the file 1F ; 20 GETCHAR ADD R3,R3,#1 ; Increment the pointer 21 LDR R1,R3,#0 ; R1 gets the next character to test 22 BRnzp TEST 23 ; 24 ; Output the count. 25 ; 26 OUTPUT LD R0,ASCII ; Load the ASCII template 27 ADD R0,R0,R2 ; Convert binary to ASCII 28 TRAP x21 ; ASCII code in R0 is displayed 29 TRAP x25 ; Halt machine 2A ; 2B ; Storage for pointer and ASCII template 2C ; 2D ASCII .FILL x0030 2E PTR .FILL x4000 2F .END The assembly language program to count occurrences of a character A few comments about this program: Three times during this program, assistance in the form of a service call is required of the operating system. In each case, a TRAP instruction is used. TRAP x23 causes a character to be input from the keyboard and placed in R0 (line 0D). TRAP x21 causes the",
    "334": "R1,R3,#0 ; R1 gets the next character to test 22 BRnzp TEST 23 ; 24 ; Output the count. 25 ; 26 OUTPUT LD R0,ASCII ; Load the ASCII template 27 ADD R0,R0,R2 ; Convert binary to ASCII 28 TRAP x21 ; ASCII code in R0 is displayed 29 TRAP x25 ; Halt machine 2A ; 2B ; Storage for pointer and ASCII template 2C ; 2D ASCII .FILL x0030 2E PTR .FILL x4000 2F .END The assembly language program to count occurrences of a character A few comments about this program: Three times during this program, assistance in the form of a service call is required of the operating system. In each case, a TRAP instruction is used. TRAP x23 causes a character to be input from the keyboard and placed in R0 (line 0D). TRAP x21 causes the ASCII code in R0 to be displayed on the monitor (line 28). TRAP x25 causes the machine to be halted (line 29). As we said before, we will leave the details of how the TRAP instruction is carried out until Chapter 9. The ASCII codes for the decimal digits 0 to 9 (0000 to 1001) are x30 to x39. The conversion from binary to ASCII is done simply by adding x30 to the binary value of the decimal digit. Line 2D shows the label ASCII used to identify the memory location containing x0030. The LD instruction in line 26 uses it to load x30 into R0, so it can convert the count which is in R2 from a binary value to an ASCII code. That is done by the ADD instruction in line 27. TRAP x21 in line 28 prints the ASCII code to the monitor. The file that is to be examined starts at address x4000 (see line 2E). Usually, this starting address would not be known to the programmer who is writing this program since we would want the program to work on many files, not just the one starting at x4000. To accomplish that, line 2E would",
    "335": "conversion from binary to ASCII is done simply by adding x30 to the binary value of the decimal digit. Line 2D shows the label ASCII used to identify the memory location containing x0030. The LD instruction in line 26 uses it to load x30 into R0, so it can convert the count which is in R2 from a binary value to an ASCII code. That is done by the ADD instruction in line 27. TRAP x21 in line 28 prints the ASCII code to the monitor. The file that is to be examined starts at address x4000 (see line 2E). Usually, this starting address would not be known to the programmer who is writing this program since we would want the program to work on many files, not just the one starting at x4000. To accomplish that, line 2E would be replaced with .BLKW 1, and be filled in by some other piece of code that knew the starting address of the desired file before executing the program of Figure 7.2. That situation will be discussed in Section 7.4. § THE ASSEMBLY PROCESS §.§ Introduction Before an LC-3 assembly language program can be executed, it must first be translated into a machine language program, that is, one in which each instruction is in the LC-3 ISA. It is the job of the LC-3 assembler to perform that translation. If you have available an LC-3 assembler, you can cause it to translate your assembly language program into a machine language program by executing an appropriate command. In the LC-3 assembler that is generally available via the Web, that command is assemble and requires as an argument the filename of your assembly language program. For example, if the filename is solution1.asm, then assemble solution1.asm outfile produces the file outfile, which is in the ISA of the LC-3. It is necessary to check with your instructor for the correct command line to cause the LC-3 assembler to produce a file of 0s and 1s in the ISA of the LC-3. §.§ A Two-Pass",
    "336": "a machine language program, that is, one in which each instruction is in the LC-3 ISA. It is the job of the LC-3 assembler to perform that translation. If you have available an LC-3 assembler, you can cause it to translate your assembly language program into a machine language program by executing an appropriate command. In the LC-3 assembler that is generally available via the Web, that command is assemble and requires as an argument the filename of your assembly language program. For example, if the filename is solution1.asm, then assemble solution1.asm outfile produces the file outfile, which is in the ISA of the LC-3. It is necessary to check with your instructor for the correct command line to cause the LC-3 assembler to produce a file of 0s and 1s in the ISA of the LC-3. §.§ A Two-Pass Process In this section, we will see how the assembler goes through the process of translating an assembly language program into a machine language program. We will use as our input to the process the assembly language program of Figure 7.2. You remember that there is in general a one-to-one correspondence between instructions in an assembly language program and instructions in the final machine language program. We could try to perform this translation in one pass through the assembly language program. Starting from the top of Figure 7.2, the assembler discards lines 01 to 09, since they contain only comments. Comments are strictly for human consumption; they have no bearing on the translation process. The assembler then moves on to line 0A. Line 0A is a pseudo-op; it tells the assembler that the machine language program is to start at location x3000. The assembler then moves on to line 0B, which it can easily translate into LC-3 machine code. At this point, we have x3000: 0101010010100000 The LC-3 assembler moves on to translate the next instruction (line 0C). Unfortunately, it is unable to do so since it does not know the meaning of the symbolic address PTR. At this point",
    "337": "in the final machine language program. We could try to perform this translation in one pass through the assembly language program. Starting from the top of Figure 7.2, the assembler discards lines 01 to 09, since they contain only comments. Comments are strictly for human consumption; they have no bearing on the translation process. The assembler then moves on to line 0A. Line 0A is a pseudo-op; it tells the assembler that the machine language program is to start at location x3000. The assembler then moves on to line 0B, which it can easily translate into LC-3 machine code. At this point, we have x3000: 0101010010100000 The LC-3 assembler moves on to translate the next instruction (line 0C). Unfortunately, it is unable to do so since it does not know the meaning of the symbolic address PTR. At this point the assembler is stuck, and the assembly process fails. To prevent this from occurring, the assembly process is done in two complete passes (from beginning to .END) through the entire assembly language program. The objective of the first pass is to identify the actual binary addresses corresponding to the symbolic names (or labels). This set of correspondences is known as the symbol table. In pass 1, we construct the symbol table. symbol table In pass 2, we translate the individual assembly language instructions into their corresponding machine language instructions. Thus, when the assembler examines line 0C for the purpose of translating LD R3,PTR during the second pass, it already knows that PTR is the symbolic address of memory location x3013 (from the first pass). Thus it can easily translate line 0C to x3001: 0010011000010001 The problem of not knowing the 16-bit address corresponding to PTR no longer exists. §.§ The First Pass: Creating the Symbol Table For our purposes, the symbol table is simply a correspondence of symbolic names with their 16-bit memory addresses. We obtain these correspondences by passing through the assembly language program once, noting which instruction is assigned to which memory location, and identifying each label with",
    "338": "the symbol table. In pass 1, we construct the symbol table. symbol table In pass 2, we translate the individual assembly language instructions into their corresponding machine language instructions. Thus, when the assembler examines line 0C for the purpose of translating LD R3,PTR during the second pass, it already knows that PTR is the symbolic address of memory location x3013 (from the first pass). Thus it can easily translate line 0C to x3001: 0010011000010001 The problem of not knowing the 16-bit address corresponding to PTR no longer exists. §.§ The First Pass: Creating the Symbol Table For our purposes, the symbol table is simply a correspondence of symbolic names with their 16-bit memory addresses. We obtain these correspondences by passing through the assembly language program once, noting which instruction is assigned to which memory location, and identifying each label with the memory address of its assigned entry. Recall that we provide labels in those cases where we have to refer to a location, either because it is the target of a branch instruction or because it contains data that must be loaded or stored. Consequently, if we have not made any programming mistakes, and if we identify all the labels, we will have identified all the symbolic addresses used in the program. The preceding paragraph assumes that our entire program exists between our .ORIG and .END pseudo-ops. This is true for the assembly language program of Figure 7.2. In Section 7.4, we will consider programs that consist of multiple parts, each with its own .ORIG and .END, wherein each part is assembled separately. The first pass starts, after discarding the comments on lines 01 to 09, by noting (line 0A) that the first instruction will be assigned to address x3000. We keep track of the location assigned to each instruction by means of a location counter (LC). The LC is initialized to the address specified in .ORIG, that is, x3000. The assembler examines each instruction in sequence and increments the LC once for each assembly language instruction. If the instruction",
    "339": "we will have identified all the symbolic addresses used in the program. The preceding paragraph assumes that our entire program exists between our .ORIG and .END pseudo-ops. This is true for the assembly language program of Figure 7.2. In Section 7.4, we will consider programs that consist of multiple parts, each with its own .ORIG and .END, wherein each part is assembled separately. The first pass starts, after discarding the comments on lines 01 to 09, by noting (line 0A) that the first instruction will be assigned to address x3000. We keep track of the location assigned to each instruction by means of a location counter (LC). The LC is initialized to the address specified in .ORIG, that is, x3000. The assembler examines each instruction in sequence and increments the LC once for each assembly language instruction. If the instruction examined contains a label, a symbol table entry is made for that label, specifying the current contents of LC as its address. The first pass terminates when the .END pseudo-op is reached. The first instruction that has a label is at line 13. Since it is the fifth instruction in the program and since the LC at that point contains x3004, a symbol table entry is constructed thus: The second instruction that has a label is at line 20. At this point, the LC has been incremented to x300B. Thus a symbol table entry is constructed, as follows: At the conclusion of the first pass, the symbol table has the following entries: §.§ The Second Pass: Generating the Machine Language Program The second pass consists of going through the assembly language program a second time, line by line, this time with the help of the symbol table. At each line, the assembly language instruction is translated into an LC-3 machine language instruction. Starting again at the top, the assembler again discards lines 01 through 09 because they contain only comments. Line 0A is the .ORIG pseudo-op, which the assembler uses to initialize LC to x3000. The assembler moves on to",
    "340": "x3004, a symbol table entry is constructed thus: The second instruction that has a label is at line 20. At this point, the LC has been incremented to x300B. Thus a symbol table entry is constructed, as follows: At the conclusion of the first pass, the symbol table has the following entries: §.§ The Second Pass: Generating the Machine Language Program The second pass consists of going through the assembly language program a second time, line by line, this time with the help of the symbol table. At each line, the assembly language instruction is translated into an LC-3 machine language instruction. Starting again at the top, the assembler again discards lines 01 through 09 because they contain only comments. Line 0A is the .ORIG pseudo-op, which the assembler uses to initialize LC to x3000. The assembler moves on to line 0B and produces the machine language instruction 0101010010100000. Then the assembler moves on to line 0C. This time, when the assembler gets to line 0C, it can completely assemble the instruction since it knows that PTR corresponds to x3013. The instruction is LD, which has an opcode encoding of 0010. The destination register (DR) is R3, that is, 011. The only part of the LD instruction left to do is the PCoffset. It is computed as follows: The assembler knows that PTR is the label for address x3013, and that the incremented PC is LC+1, in this case x3002. Since PTR (x3013) must be the sum of the incremented PC (x3002) and the sign-extended PCoffset, PCoffset must be x0011. Putting this all together, the assembler sets x3001 to 0010011000010001, and increments the LC to x3002. Note: In order to use the LD instruction, it is necessary that the source of the load, in this case the address whose label is PTR, is not more than +256 or -255 memory locations from the LD instruction itself. If the address of PTR had been greater than LC+1+255 or less than LC+1-256, then the offset would not fit in bits [8:0] of",
    "341": "The only part of the LD instruction left to do is the PCoffset. It is computed as follows: The assembler knows that PTR is the label for address x3013, and that the incremented PC is LC+1, in this case x3002. Since PTR (x3013) must be the sum of the incremented PC (x3002) and the sign-extended PCoffset, PCoffset must be x0011. Putting this all together, the assembler sets x3001 to 0010011000010001, and increments the LC to x3002. Note: In order to use the LD instruction, it is necessary that the source of the load, in this case the address whose label is PTR, is not more than +256 or -255 memory locations from the LD instruction itself. If the address of PTR had been greater than LC+1+255 or less than LC+1-256, then the offset would not fit in bits [8:0] of the instruction. In such a case, an assembly error would have occurred, preventing the assembly process from finishing successfully. Fortunately, PTR is close enough to the LD instruction, so the instruction assembled correctly. The second pass continues. At each step, the LC is incremented and the location specified by LC is assigned the translated LC-3 instruction or, in the case of .FILL, the value specified. When the second pass encounters the .END pseudo-op, assembly terminates. The resulting translated program is shown in Figure 7.3. 1|c|Address 1c|Binary 1|c| 1|c|0011000000000000 1|c|x3000 1|c|0101010010100000 1|c|x3001 1|c|0010011000010001 1|c|x3002 1|c|1111000000100011 1|c|x3003 1|c|0110001011000000 1|c|x3004 1|c|0001100001111100 1|c|x3005 1|c|0000010000001000 1|c|x3006 1|c|1001001001111111 1|c|x3007 1|c|0001001001100001 1|c|x3008 1|c|0001001001000000 1|c|x3009 1|c|0000101000000001 1|c|x300A 1|c|0001010010100001 1|c|x300B 1|c|0001011011100001 1|c|x300C 1|c|0110001011000000 1|c|x300D 1|c|0000111111110110 1|c|x300E 1|c|0010000000000011 1|c|x300F 1|c|0001000000000010 1|c|x3010 1|c|1111000000100001 1|c|x3011 1|c|1111000000100101 1|c|x3012 1|c|0000000000110000 1|c|x3013 1|c|0100000000000000 The machine language program for the assembly language program of Figure 7.2 That process was, on a good day, merely tedious. Fortunately, you do not have to do it for a living—the LC-3 assembler does that. And, since you now know the LC-3 assembly language, there is no need to program in machine language. Now we can write our programs symbolically in LC-3 assembly language and invoke the LC-3 assembler to create",
    "342": "of .FILL, the value specified. When the second pass encounters the .END pseudo-op, assembly terminates. The resulting translated program is shown in Figure 7.3. 1|c|Address 1c|Binary 1|c| 1|c|0011000000000000 1|c|x3000 1|c|0101010010100000 1|c|x3001 1|c|0010011000010001 1|c|x3002 1|c|1111000000100011 1|c|x3003 1|c|0110001011000000 1|c|x3004 1|c|0001100001111100 1|c|x3005 1|c|0000010000001000 1|c|x3006 1|c|1001001001111111 1|c|x3007 1|c|0001001001100001 1|c|x3008 1|c|0001001001000000 1|c|x3009 1|c|0000101000000001 1|c|x300A 1|c|0001010010100001 1|c|x300B 1|c|0001011011100001 1|c|x300C 1|c|0110001011000000 1|c|x300D 1|c|0000111111110110 1|c|x300E 1|c|0010000000000011 1|c|x300F 1|c|0001000000000010 1|c|x3010 1|c|1111000000100001 1|c|x3011 1|c|1111000000100101 1|c|x3012 1|c|0000000000110000 1|c|x3013 1|c|0100000000000000 The machine language program for the assembly language program of Figure 7.2 That process was, on a good day, merely tedious. Fortunately, you do not have to do it for a living—the LC-3 assembler does that. And, since you now know the LC-3 assembly language, there is no need to program in machine language. Now we can write our programs symbolically in LC-3 assembly language and invoke the LC-3 assembler to create the machine language versions that can execute on an LC-3 computer. § BEYOND THE ASSEMBLY OF A SINGLE ASSEMBLY LANGUAGE PROGRAM Our purpose in this chapter has been to take you up one more step from the ISA of the computer and introduce assembly language. Although it is still quite a large step from C or C++, assembly language does, in fact, save us a good deal of pain. We have also shown how a rudimentary two-pass assembler actually works to translate an assembly language program into the machine language of the LC-3 ISA. There are many more aspects to sophisticated assembly language programming that go well beyond an introductory course. However, our reason for teaching assembly language is not to deal with its sophistication, but rather to show its innate simplicity. Before we leave this chapter, however, there are a few additional highlights we should explore. §.§ The Executable Image When a computer begins execution of a program, the entity being executed is called an executable image. The executable image is created from modules executable image often created independently by several different programmers. Each module is translated separately into an object file. We have just gone through the process",
    "343": "in fact, save us a good deal of pain. We have also shown how a rudimentary two-pass assembler actually works to translate an assembly language program into the machine language of the LC-3 ISA. There are many more aspects to sophisticated assembly language programming that go well beyond an introductory course. However, our reason for teaching assembly language is not to deal with its sophistication, but rather to show its innate simplicity. Before we leave this chapter, however, there are a few additional highlights we should explore. §.§ The Executable Image When a computer begins execution of a program, the entity being executed is called an executable image. The executable image is created from modules executable image often created independently by several different programmers. Each module is translated separately into an object file. We have just gone through the process of performing that translation ourselves by mimicking the LC-3 assembler. Other modules, some written in C perhaps, are translated by the C compiler. Some modules are written by users, and some modules are supplied as library routines by the operating system. Each object file consists of instructions in the ISA of the computer being used, along with its associated data. The final step is to combine (i.e., link) all the object modules together into one linking executable image. During execution of the program, the FETCH, DECODE, … instruction cycle is applied to instructions in the executable image. §.§ More than One Object File linking!more than one object file It is very common to form an executable image from more than one object file. In fact, in the real world, where most programs invoke libraries provided by the operating system as well as modules generated by other programmers, it is much more common to have multiple object files than a single one. A case in point is our example character count program. The program counts the number of occurrences of a character in a file. A typical application could easily have the program as one module and the input data file",
    "344": "The final step is to combine (i.e., link) all the object modules together into one linking executable image. During execution of the program, the FETCH, DECODE, … instruction cycle is applied to instructions in the executable image. §.§ More than One Object File linking!more than one object file It is very common to form an executable image from more than one object file. In fact, in the real world, where most programs invoke libraries provided by the operating system as well as modules generated by other programmers, it is much more common to have multiple object files than a single one. A case in point is our example character count program. The program counts the number of occurrences of a character in a file. A typical application could easily have the program as one module and the input data file as another. If this were the case, then the starting address of the file, shown as x4000 in line 2E of Figure 7.2, would not be known when the program was written. If we replace line 2E with PTR .FILL STARTofFILE then the program of Figure 7.2 will not assemble because there will be no symbol table entry for STARTofFILE. What can we do? If the LC-3 assembly language, on the other hand, contained the pseudo-op .EXTERNAL, we could identify STARTofFILE as the symbolic name of an address that is not known at the time the program of Figure 7.2 is assembled. This would be done by the following line .EXTERNAL STARTofFILE, which would send a message to the LC-3 assembler that the absence of label STARTofFILE is not an error in the program. Rather, STARTofFILE is a label in some other module that will be translated independently. In fact, in our case, it will be the label of the location of the first character in the file to be examined by our character count program. If the LC-3 assembly language had the pseudo-op .EXTERNAL, and if we had designated STARTofFILE as .EXTERNAL, the LC-3 assembler would be able to",
    "345": "What can we do? If the LC-3 assembly language, on the other hand, contained the pseudo-op .EXTERNAL, we could identify STARTofFILE as the symbolic name of an address that is not known at the time the program of Figure 7.2 is assembled. This would be done by the following line .EXTERNAL STARTofFILE, which would send a message to the LC-3 assembler that the absence of label STARTofFILE is not an error in the program. Rather, STARTofFILE is a label in some other module that will be translated independently. In fact, in our case, it will be the label of the location of the first character in the file to be examined by our character count program. If the LC-3 assembly language had the pseudo-op .EXTERNAL, and if we had designated STARTofFILE as .EXTERNAL, the LC-3 assembler would be able to create a symbol table entry for STARTofFILE, and instead of assigning it an address, it would mark the symbol as belonging to another module. At link time, when all the modules are combined, the linker (the program that manages the “combining” process) would use the symbol table entry for STARTofFILE in linker another module to complete the translation of our revised line 2E. In this way, the .EXTERNAL pseudo-op allows references by one module to symbolic locations in another module without a problem. The proper translations are resolved by the linker. 7.1 An assembly language program contains the following two instructions. The assembler puts the translated version of the LDI instruction that follows into location x3025 of the object module. After assembly is complete, what is in location x3025? PLACE .FILL x45A7 LDI R3, PLACE 7.2 An LC-3 assembly language program contains the instruction: ASCII LD R1, ASCII The symbol table entry for ASCII is x4F08. If this instruction is executed during the running of the program, what will be contained in R1 immediately after the instruction is executed? 7.3 What is the problem with using the string AND as a label? 7.4 Create the symbol table entries generated by",
    "346": "revised line 2E. In this way, the .EXTERNAL pseudo-op allows references by one module to symbolic locations in another module without a problem. The proper translations are resolved by the linker. 7.1 An assembly language program contains the following two instructions. The assembler puts the translated version of the LDI instruction that follows into location x3025 of the object module. After assembly is complete, what is in location x3025? PLACE .FILL x45A7 LDI R3, PLACE 7.2 An LC-3 assembly language program contains the instruction: ASCII LD R1, ASCII The symbol table entry for ASCII is x4F08. If this instruction is executed during the running of the program, what will be contained in R1 immediately after the instruction is executed? 7.3 What is the problem with using the string AND as a label? 7.4 Create the symbol table entries generated by the assembler when translating the following routine into machine code: .ORIG x301C ST R3, SAVE3 ST R2, SAVE2 AND R2, R2, #0 TEST IN BRz TEST ADD R1, R0, #-10 BRn FINISH ADD R1, R0, #-15 NOT R1, R1 BRn FINISH HALT FINISH ADD R2, R2, #1 HALT SAVE3 .FILL X0000 SAVE2 .FILL X0000 .END 7.5 a. What does the following program do? .ORIG x3000 LD R2, ZERO LD R0, M0 LD R1, M1 LOOP BRz DONE ADD R2, R2, R0 ADD R1, R1, -1 BR LOOP DONE ST R2, RESULT HALT RESULT .FILL x0000 ZERO .FILL x0000 M0 .FILL x0004 M1 .FILL x0803 .END b. What value will be contained in RESULT after the program runs to completion? 7.6 Our assembler has crashed and we need your help! Create a symbol table for the program shown below, and assemble the instructions at labels A, B and D. .ORIG x3000 AND R0, R0, #0 A LD R1, E AND R2, R1, #1 BRp C B ADD R1, R1, #-1 C ADD R0, R0, R1 ADD R1, R1, #-2 D BRp C ST R0, F TRAP x25 E .BLKW 1 F .BLKW 1 .END You may assume another module deposits a",
    "347": "following program do? .ORIG x3000 LD R2, ZERO LD R0, M0 LD R1, M1 LOOP BRz DONE ADD R2, R2, R0 ADD R1, R1, -1 BR LOOP DONE ST R2, RESULT HALT RESULT .FILL x0000 ZERO .FILL x0000 M0 .FILL x0004 M1 .FILL x0803 .END b. What value will be contained in RESULT after the program runs to completion? 7.6 Our assembler has crashed and we need your help! Create a symbol table for the program shown below, and assemble the instructions at labels A, B and D. .ORIG x3000 AND R0, R0, #0 A LD R1, E AND R2, R1, #1 BRp C B ADD R1, R1, #-1 C ADD R0, R0, R1 ADD R1, R1, #-2 D BRp C ST R0, F TRAP x25 E .BLKW 1 F .BLKW 1 .END You may assume another module deposits a positive value into E before the module executes. In fifteen words or fewer, what does the above program do? 7.7 Write an LC-3 assembly language program that counts the number of 1s in the value stored in R0 and stores the result into R1. For example, if R0 contains 0001001101110000, then after the program executes, the result stored in R1 would be 0000 0000 0000 0110. 7.8 An engineer is in the process of debugging a program she has written. She is looking at the following segment of the program, and decides to place a breakpoint in memory at location 0xA404. Starting with the PC=0 xA400, she initializes all the registers to zero and runs the program until the breakpoint is encountered. Code Segment: ... 0xA400 THIS1 LEA R0, THIS1 0xA401 THIS2 LD R1, THIS2 0xA402 THIS3 LDI R2, THIS5 0xA403 THIS4 LDR R3, R0, #2 0xA404 THIS5 .FILL xA400 ... Show the contents of the register file (in hexadecimal) when the breakpoint is encountered. 7.9 What is the purpose of the .END pseudo-op? How does it differ from the HALT instruction? 7.10 The following program fragment has an error in it. Identify the error and explain how to fix",
    "348": "would be 0000 0000 0000 0110. 7.8 An engineer is in the process of debugging a program she has written. She is looking at the following segment of the program, and decides to place a breakpoint in memory at location 0xA404. Starting with the PC=0 xA400, she initializes all the registers to zero and runs the program until the breakpoint is encountered. Code Segment: ... 0xA400 THIS1 LEA R0, THIS1 0xA401 THIS2 LD R1, THIS2 0xA402 THIS3 LDI R2, THIS5 0xA403 THIS4 LDR R3, R0, #2 0xA404 THIS5 .FILL xA400 ... Show the contents of the register file (in hexadecimal) when the breakpoint is encountered. 7.9 What is the purpose of the .END pseudo-op? How does it differ from the HALT instruction? 7.10 The following program fragment has an error in it. Identify the error and explain how to fix it. ADD R3, R3, #30 ST R3, A HALT A .FILL #0 Will this error be detected when this code is assembled or when this code is run on the LC-3? 7.11 The LC-3 assembler must be able to convert constants represented in ASCII into their appropriate binary values. For instance, x2A translates into 00101010 and #12 translates into 00001100. Write an LC-3 assembly language program that reads a decimal or hexadecimal constant from the keyboard (i.e., it is preceded by a # character signifying it is a decimal, or x signifying it is hex) and prints out the binary representation. Assume the constants can be expressed with no more than two decimal or hex digits. 7.12 What does the following LC-3 program do? .ORIG x3000 AND R5, R5, #0 AND R3, R3, #0 ADD R3, R3, #8 LDI R1, A ADD R2, R1, #0 AG ADD R2, R2, R2 ADD R3, R3, #-1 BRnp AG LD R4, B AND R1, R1, R4 NOT R1, R1 ADD R1, R1, #1 ADD R2, R2, R1 BRnp NO ADD R5, R5, #1 NO HALT B .FILL xFF00 A .FILL x4000 .END 7.13 The following program adds the values stored in memory locations",
    "349": "Write an LC-3 assembly language program that reads a decimal or hexadecimal constant from the keyboard (i.e., it is preceded by a # character signifying it is a decimal, or x signifying it is hex) and prints out the binary representation. Assume the constants can be expressed with no more than two decimal or hex digits. 7.12 What does the following LC-3 program do? .ORIG x3000 AND R5, R5, #0 AND R3, R3, #0 ADD R3, R3, #8 LDI R1, A ADD R2, R1, #0 AG ADD R2, R2, R2 ADD R3, R3, #-1 BRnp AG LD R4, B AND R1, R1, R4 NOT R1, R1 ADD R1, R1, #1 ADD R2, R2, R1 BRnp NO ADD R5, R5, #1 NO HALT B .FILL xFF00 A .FILL x4000 .END 7.13 The following program adds the values stored in memory locations A, B, and C, and stores the result into memory. There are two errors in the code. For each, describe the error and indicate whether it will be detected at assembly time or at run time. Line No. 1 .ORIG x3000 2 ONE LD R0, A 3 ADD R1, R1, R0 4 TWO LD R0, B 5 ADD R1, R1, R0 6 THREE LD R0, C 7 ADD R1, R1, R0 8 ST R1, SUM 9 TRAP x25 10 A .FILL x0001 11 B .FILL x0002 12 C .FILL x0003 13 D .FILL x0004 14 .END 7.14 a. Assemble the following program: .ORIG x3000 STI R0, LABEL OUT HALT LABEL .STRINGZ \" .END b. The programmer intended the program to output a % to the monitor, and then halt. Unfortunately, the programmer got confused about the semantics of each of the opcodes (that is, exactly what function is carried out by the LC-3 in response to each opcode). Replace exactly one opcode in this program with the correct opcode to make the program work as intended. c. The original program from part a was executed. However, execution exhibited some very strange behavior. The strange behavior was in part due to",
    "350": "R0 6 THREE LD R0, C 7 ADD R1, R1, R0 8 ST R1, SUM 9 TRAP x25 10 A .FILL x0001 11 B .FILL x0002 12 C .FILL x0003 13 D .FILL x0004 14 .END 7.14 a. Assemble the following program: .ORIG x3000 STI R0, LABEL OUT HALT LABEL .STRINGZ \" .END b. The programmer intended the program to output a % to the monitor, and then halt. Unfortunately, the programmer got confused about the semantics of each of the opcodes (that is, exactly what function is carried out by the LC-3 in response to each opcode). Replace exactly one opcode in this program with the correct opcode to make the program work as intended. c. The original program from part a was executed. However, execution exhibited some very strange behavior. The strange behavior was in part due to the programming error, and in part due to the fact that the value in R0 when the program started executing was x3000. Explain what the strange behavior was and why the program behaved that way. 7.15 The following is an LC-3 program that performs a function. Assume a sequence of integers is stored in consecutive memory locations, one integer per memory location, starting at the location x4000. The sequence terminates with the value x0000. What does the following program do? .ORIG x3000 LD R0, NUMBERS LD R2, MASK LOOP LDR R1, R0, #0 BRz DONE AND R5, R1, R2 BRz L1 BRnzp NEXT L1 ADD R1, R1, R1 STR R1, R0, #0 NEXT ADD R0, R0, #1 BRnzp LOOP DONE HALT NUMBERS .FILL x4000 MASK .FILL x8000 .END 7.16 Assume a sequence of nonnegative integers is stored in consecutive memory locations, one integer per memory location, starting at location x4000. Each integer has a value between 0 and 30,000 (decimal). The sequence terminates with the value -1 (i.e., xFFFF). What does the following program do? .ORIG x3000 AND R4, R4, #0 AND R3, R3, #0 LD R0, NUMBERS LOOP LDR R1, R0, #0 NOT R2, R1 BRz DONE AND R2,",
    "351": "memory location, starting at the location x4000. The sequence terminates with the value x0000. What does the following program do? .ORIG x3000 LD R0, NUMBERS LD R2, MASK LOOP LDR R1, R0, #0 BRz DONE AND R5, R1, R2 BRz L1 BRnzp NEXT L1 ADD R1, R1, R1 STR R1, R0, #0 NEXT ADD R0, R0, #1 BRnzp LOOP DONE HALT NUMBERS .FILL x4000 MASK .FILL x8000 .END 7.16 Assume a sequence of nonnegative integers is stored in consecutive memory locations, one integer per memory location, starting at location x4000. Each integer has a value between 0 and 30,000 (decimal). The sequence terminates with the value -1 (i.e., xFFFF). What does the following program do? .ORIG x3000 AND R4, R4, #0 AND R3, R3, #0 LD R0, NUMBERS LOOP LDR R1, R0, #0 NOT R2, R1 BRz DONE AND R2, R1, #1 BRz L1 ADD R4, R4, #1 BRnzp NEXT L1 ADD R3, R3, #1 NEXT ADD R0, R0, #1 BRnzp LOOP DONE TRAP x25 NUMBERS .FILL x4000 .END 7.17=-1 Suppose you write two separate assembly language modules that you expect to be combined by the linker. Each module uses the label AGAIN, and neither module contains the pseudo-op .EXTERNAL AGAIN. Is there a problem using the label AGAIN in both modules? Why or why not? 7.18 The following LC-3 program compares two character strings of the same length. The source strings are in the .STRINGZ form. The first string starts at memory location x4000, and the second string starts at memory location x4100. If the strings are the same, the program terminates with the value 1 in R5. Insert instructions at (a), (b), and (c) that will complete the program.15pt .ORIG x3000 LD R1, FIRST LD R2, SECOND AND R0, R0, #0 LOOP ————– (a) LDR R4, R2, #0 BRz NEXT ADD R1, R1, #1 ADD R2, R2, #1 ————– (b) ————– (c) ADD R3, R3, R4 BRz LOOP AND R5, R5, #0 BRnzp DONE NEXT AND R5, R5, #0 ADD R5, R5, #1 DONE TRAP x25 FIRST .FILL",
    "352": "AGAIN. Is there a problem using the label AGAIN in both modules? Why or why not? 7.18 The following LC-3 program compares two character strings of the same length. The source strings are in the .STRINGZ form. The first string starts at memory location x4000, and the second string starts at memory location x4100. If the strings are the same, the program terminates with the value 1 in R5. Insert instructions at (a), (b), and (c) that will complete the program.15pt .ORIG x3000 LD R1, FIRST LD R2, SECOND AND R0, R0, #0 LOOP ————– (a) LDR R4, R2, #0 BRz NEXT ADD R1, R1, #1 ADD R2, R2, #1 ————– (b) ————– (c) ADD R3, R3, R4 BRz LOOP AND R5, R5, #0 BRnzp DONE NEXT AND R5, R5, #0 ADD R5, R5, #1 DONE TRAP x25 FIRST .FILL x4000 SECOND .FILL x4100 .END 7.19 When the following LC-3 program is executed, how many times will the instruction at the memory address labeled LOOP execute? .ORIG x3005 LEA R2, DATA LDR R4, R2, #0 LOOP ADD R4, R4, #-3 BRzp LOOP TRAP x25 DATA .FILL x000B .END 7.20 LC-3 assembly language modules (a) and (b) have been written by different programmers to store x0015 into memory location x4000. What is fundamentally different about their approaches? a. .ORIG x5000 AND R0, R0, #0 ADD R0, R0, #15 ADD R0, R0, #6 STI R0, PTR HALT PTR .FILL x4000 .END b. .ORIG x4000 .FILL x0015 .END 7.21 Assemble the following LC-3 assembly language program. .ORIG x3000 AND R0, R0, #0 ADD R2, R0, #10 LD R1, MASK LD R3, PTR1 LOOP LDR R4, R3, #0 AND R4, R4, R1 BRz NEXT ADD R0, R0, #1 NEXT ADD R3, R3, #1 ADD R2, R2, #-1 BRp LOOP STI R0, PTR2 HALT MASK .FILL x8000 PTR1 .FILL x4000 PTR2 .FILL x5000 .END What does the program do (in no more than 20 words)? 7.22 The LC-3 assembler must be able to map an instruction's mnemonic opcode into its binary opcode. For instance, given",
    "353": "different programmers to store x0015 into memory location x4000. What is fundamentally different about their approaches? a. .ORIG x5000 AND R0, R0, #0 ADD R0, R0, #15 ADD R0, R0, #6 STI R0, PTR HALT PTR .FILL x4000 .END b. .ORIG x4000 .FILL x0015 .END 7.21 Assemble the following LC-3 assembly language program. .ORIG x3000 AND R0, R0, #0 ADD R2, R0, #10 LD R1, MASK LD R3, PTR1 LOOP LDR R4, R3, #0 AND R4, R4, R1 BRz NEXT ADD R0, R0, #1 NEXT ADD R3, R3, #1 ADD R2, R2, #-1 BRp LOOP STI R0, PTR2 HALT MASK .FILL x8000 PTR1 .FILL x4000 PTR2 .FILL x5000 .END What does the program do (in no more than 20 words)? 7.22 The LC-3 assembler must be able to map an instruction's mnemonic opcode into its binary opcode. For instance, given an ADD, it must generate the binary pattern 0001. Write an LC-3 assembly language program that prompts the user to type in an LC-3 assembly language opcode and then displays its binary opcode. If the assembly language opcode is invalid, it displays an error message. 7.23 The following LC-3 program determines whether a character string is a palindrome or not. A palindrome is a string that reads the same backwards as forwards. For example, the string “racecar” is a palindrome. Suppose a string starts at memory location x4000, and is in the format. If the string is a palindrome, the program terminates with the value 1 in R5. If not, the program terminates with the value 0 in R5. Insert instructions at (a)–(e) that will complete the program. .ORIG x3000 LD R0, PTR ADD R1, R0, #0 AGAIN LDR R2, R1, #0 BRz CONT ADD R1, R1, #1 BRnzp AGAIN CONT ————–(a) LOOP LDR R3, R0, #0 ————–(b) NOT R4, R4 ADD R4, R4, #1 ADD R3, R3, R4 BRnp NO ————–(c) ————–(d) NOT R2, R0 ADD R2, R2, #1 ADD R2, R1, R2 BRnz YES ————–(e) YES AND R5, R5, #0 ADD R5, R5, #1 BRnzp DONE NO AND",
    "354": "A palindrome is a string that reads the same backwards as forwards. For example, the string “racecar” is a palindrome. Suppose a string starts at memory location x4000, and is in the format. If the string is a palindrome, the program terminates with the value 1 in R5. If not, the program terminates with the value 0 in R5. Insert instructions at (a)–(e) that will complete the program. .ORIG x3000 LD R0, PTR ADD R1, R0, #0 AGAIN LDR R2, R1, #0 BRz CONT ADD R1, R1, #1 BRnzp AGAIN CONT ————–(a) LOOP LDR R3, R0, #0 ————–(b) NOT R4, R4 ADD R4, R4, #1 ADD R3, R3, R4 BRnp NO ————–(c) ————–(d) NOT R2, R0 ADD R2, R2, #1 ADD R2, R1, R2 BRnz YES ————–(e) YES AND R5, R5, #0 ADD R5, R5, #1 BRnzp DONE NO AND R5, R5, #0 DONE HALT PTR .FILL x4000 .END 7.24 We want the following program fragment to shift R3 to the left by four bits, but it has an error in it. Identify the error and explain how to fix it. .ORIG x3000 AND R2, R2, #0 ADD R2, R2, #4 LOOP BRz DONE ADD R2, R2, #-1 ADD R3, R3, R3 BR LOOP DONE HALT .END 7.25 What does the pseudo-op do? Why? 7.26 Recall the assembly language program of problem 7.6. Consider the following program: .ORIG x3000 AND R0, R0, #0 D LD R1, A AND R2, R1, #1 BRp B E ADD R1, R1, #-1 B ADD R0, R0, R1 ADD R1, R1, #-2 F BRp B ST R0, C TRAP x25 A .BLKW 1 C .BLKW 1 .END The assembler translates both assembly language programs into machine language programs. What can you say about the two resulting machine language programs? 7.27 The following LC-3 assembly language program: .ORIG x3000 AND R2, R2, #0 AND R6, R6, #0 ADD R2, R2, #1 TOP ADD R3, R2, #0 ADD R4, R1, #0 SEARCH ADD R3, R3, R3 ADD R4, R4, #-1 BRp SEARCH AND R5, R3, R0 BRz",
    "355": "R3, R3 BR LOOP DONE HALT .END 7.25 What does the pseudo-op do? Why? 7.26 Recall the assembly language program of problem 7.6. Consider the following program: .ORIG x3000 AND R0, R0, #0 D LD R1, A AND R2, R1, #1 BRp B E ADD R1, R1, #-1 B ADD R0, R0, R1 ADD R1, R1, #-2 F BRp B ST R0, C TRAP x25 A .BLKW 1 C .BLKW 1 .END The assembler translates both assembly language programs into machine language programs. What can you say about the two resulting machine language programs? 7.27 The following LC-3 assembly language program: .ORIG x3000 AND R2, R2, #0 AND R6, R6, #0 ADD R2, R2, #1 TOP ADD R3, R2, #0 ADD R4, R1, #0 SEARCH ADD R3, R3, R3 ADD R4, R4, #-1 BRp SEARCH AND R5, R3, R0 BRz NEXT ADD R6, R6, R2 NEXT ADD R2, R2, R2 BRzp TOP END ST R6, RESULT HALT RESULT .BLKW 1 .END What does it do (in twenty words or fewer)? Please be BRIEF but PRECISE. You can assume that some of the registers will already contain numbers that are relevant to the program. What is the function of R0? For what range of input values does the program function as you've described above? What is the function of R1? For what range of input values does the program function as you've described above? What is the function of R6? For what range of input values does the program function as you've described above? 7.28STAR Consider the following program: The program uses only R0 and R1. Note lines (a) and (b) to indicate two missing instructions. Complete line (c). Note also that one of the instructions in the program must be labeled AGAIN and that label is missing. After execution of the program, the contents of A is x1800. During execution, we examined the computer during each clock cycle, and recorded some information for certain clock cycles, producing the table shown below. The table is ordered by the cycle number in",
    "356": "what range of input values does the program function as you've described above? What is the function of R1? For what range of input values does the program function as you've described above? What is the function of R6? For what range of input values does the program function as you've described above? 7.28STAR Consider the following program: The program uses only R0 and R1. Note lines (a) and (b) to indicate two missing instructions. Complete line (c). Note also that one of the instructions in the program must be labeled AGAIN and that label is missing. After execution of the program, the contents of A is x1800. During execution, we examined the computer during each clock cycle, and recorded some information for certain clock cycles, producing the table shown below. The table is ordered by the cycle number in which the information was collected. Note that each memory access takes 5 clock cycles. < g r a p h i c s > Fill in the missing instructions in the program, and complete the program by labeling the appropriate instruction AGAIN. Also, fill in the missing information in the table. Given values for A and B, what does the program do? 7.29STAR An LC-3 program is executing on the LC-3 Simulator when a breakpoint is encountered, and the Simulator stops. At that point, the contents of several registers are as shown in the first row of the table. After the run button is subsequently pushed, the next four instructions that are executed, none of which are an STI or LDI, produce the values shown in the table, two rows of the table per instruction executed. The first row of each pair shows the contents after the fetch phase of the corresponding instruction, and the second row of each pair after that instruction completes. Note that some values are missing, and are presented by letters A, B, C, D, E, F, G, H, I, and J. PC MAR MDR IR R0 R1 R2 R3 R4 R5 R6 R7 x1800 x7FFF",
    "357": "program do? 7.29STAR An LC-3 program is executing on the LC-3 Simulator when a breakpoint is encountered, and the Simulator stops. At that point, the contents of several registers are as shown in the first row of the table. After the run button is subsequently pushed, the next four instructions that are executed, none of which are an STI or LDI, produce the values shown in the table, two rows of the table per instruction executed. The first row of each pair shows the contents after the fetch phase of the corresponding instruction, and the second row of each pair after that instruction completes. Note that some values are missing, and are presented by letters A, B, C, D, E, F, G, H, I, and J. PC MAR MDR IR R0 R1 R2 R3 R4 R5 R6 R7 x1800 x7FFF x2211 xBFFE x31FF x2233 x5177 x3211 x21FF x5233 x3177 x2211 A x1800 B B x31FF x2233 x5177 x3211 x21FF x5233 x3177 x2211 A x1800 B B x31FF x2233 x5177 x3211 x21FF C x3177 x2211 D A E E x31FF x2233 x5177 x3211 x21FF C x3177 x2211 D F G E x31FF x2233 x5177 x3211 x21FF C x3177 x2211 H D I I x31FF x2233 x5177 x3211 x21FF C x3177 x2211 F D I I x31FF x2233 x5177 x3211 x21FF C x3177 x2211 A F J J x31FF x2233 x5177 x3211 x21FF C x3177 x2211 A F J J x31FF x2233 x5177 x3211 x223A C x3177 x2211 Your job: Determine the values of A, B, C, D, E, F, G, H, I, and J. Note that some of the values may be identical. 1-5 A B C D E 1-5 1-5 1-5 F G H I J 1-5 x _F__ 1-5 7.30STAR There are times when one wants to implement a stack in memory, but can not provide enough memory to be sure there will always be plenty of space to push values on the stack. Furthermore, there are times (beyond EE 306) when it is okay to lose some of",
    "358": "I I x31FF x2233 x5177 x3211 x21FF C x3177 x2211 F D I I x31FF x2233 x5177 x3211 x21FF C x3177 x2211 A F J J x31FF x2233 x5177 x3211 x21FF C x3177 x2211 A F J J x31FF x2233 x5177 x3211 x223A C x3177 x2211 Your job: Determine the values of A, B, C, D, E, F, G, H, I, and J. Note that some of the values may be identical. 1-5 A B C D E 1-5 1-5 1-5 F G H I J 1-5 x _F__ 1-5 7.30STAR There are times when one wants to implement a stack in memory, but can not provide enough memory to be sure there will always be plenty of space to push values on the stack. Furthermore, there are times (beyond EE 306) when it is okay to lose some of the oldest values pushed on the stack. We can save that discussion for the last class if you like. In such situations, a reasonable technique is to specify a circular stack as shown below. In this case, the stack occupies five locations x3FFB to x3FFF. Initially, the stack is empty, with R6 = x4000. The figure shows the result of successively pushing the values 1, 2, 3, 4, 5, 6, 7, 8 on the stack. < g r a p h i c s > That is, the 1 was written into x3FFF, the 2 was written into x3FFE, etc. When the time came to push the 6, the stack was full, so R6 was set to x3FFF, and the 6 was written into x3FFF, clobbering the 1 which was originally pushed. If we now pop five elements off the stack, we get 8, 7, 6, 5,and 4, AND we have an empty stack, even though R6 contains x3FFD. Why? Because 3,2, and 1 have been lost. That is, even though we have pushed 8 values, there can be at most only five values actually available on the stack for popping. We keep track of the number of actual values",
    "359": "successively pushing the values 1, 2, 3, 4, 5, 6, 7, 8 on the stack. < g r a p h i c s > That is, the 1 was written into x3FFF, the 2 was written into x3FFE, etc. When the time came to push the 6, the stack was full, so R6 was set to x3FFF, and the 6 was written into x3FFF, clobbering the 1 which was originally pushed. If we now pop five elements off the stack, we get 8, 7, 6, 5,and 4, AND we have an empty stack, even though R6 contains x3FFD. Why? Because 3,2, and 1 have been lost. That is, even though we have pushed 8 values, there can be at most only five values actually available on the stack for popping. We keep track of the number of actual values on the stack in R5. Note that R5 and R6 are known to the calling routine, so a test for underflow can be made by the calling program using R5. Further, the calling program puts the value to be pushed in R0 before calling PUSH. Your job: Complete the assembly language code shown below to implement the PUSH routine of the circular stack by filling in each of the lines:(a), (b), (c), and (d) with a missing instruction. PUSH ST R1, SAVER LD R1, NEGFULL ADD R1, R6, R1 ————–(a) LD R6, BASE SKIP ADD R6, R6, #-1 LD R1, MINUS5 ADD R1, R5, R1 BRz END ————–(b) END ————–(c) ————–(d) RET NEGFULL .FILL xC005 ; x-3FFB MINUS5 .FILL xFFFB ; #-5 BASE .FILL x4000 SAVER .BLKW #1 7.31 Memory locations x5000 to x5FFF contain 2's complement integers. What does the following program do? [t]0.5 .ORIG x3000 LD R1, ARRAY LD R2, LENGTH AND R3, R3, #0 AGAIN LDR R0, R1, #0 AND R0, R0, #1 BRz SKIP ADD R3, R3, #1 SKIP ADD R1, R1, #1 ADD R2, R2, #-1 BRp AGAIN HALT ARRAY .FILL x5000 LENGTH .FILL x1000 .END 7.32 Consider the following semi-nonsense assembly language program: line",
    "360": "the circular stack by filling in each of the lines:(a), (b), (c), and (d) with a missing instruction. PUSH ST R1, SAVER LD R1, NEGFULL ADD R1, R6, R1 ————–(a) LD R6, BASE SKIP ADD R6, R6, #-1 LD R1, MINUS5 ADD R1, R5, R1 BRz END ————–(b) END ————–(c) ————–(d) RET NEGFULL .FILL xC005 ; x-3FFB MINUS5 .FILL xFFFB ; #-5 BASE .FILL x4000 SAVER .BLKW #1 7.31 Memory locations x5000 to x5FFF contain 2's complement integers. What does the following program do? [t]0.5 .ORIG x3000 LD R1, ARRAY LD R2, LENGTH AND R3, R3, #0 AGAIN LDR R0, R1, #0 AND R0, R0, #1 BRz SKIP ADD R3, R3, #1 SKIP ADD R1, R1, #1 ADD R2, R2, #-1 BRp AGAIN HALT ARRAY .FILL x5000 LENGTH .FILL x1000 .END 7.32 Consider the following semi-nonsense assembly language program: line 1: .ORIG x8003 line 2: AND R1,R1,#0 line 3: ADD R0,R1,#5 line 4: ST R1,B line 5: LD R1,A line 6: BRz SKIP line 7: ST R0,B line 8: SKIP TRAP x25 line 9: A .BLKW #7 line 10: B .FILL #5 line 11: BANNER .STRINGZ \"We are done!\" line 12: C .FILL x0 line 13: .END A separate module will store a value in A before the above program executes. Construct the symbol table. Show the result of assembly of lines 5 through 7 above. Note: the instruction at line 8 has already been assembled for you. < g r a p h i c s > Note that two different things could cause location B to contain the value 5: the contents of line 7 or the contents of line 10. Explain the difference between line 7 causing the value 5 to be in location B and line 10 causing the value 5 to be in location B. 7.33STAR We have a program with some missing instructions, and we have a table consisting of some information and some missing information associated with five specific clock cycles of the program's execution. Your job is to complete both! Insert the",
    "361": "will store a value in A before the above program executes. Construct the symbol table. Show the result of assembly of lines 5 through 7 above. Note: the instruction at line 8 has already been assembled for you. < g r a p h i c s > Note that two different things could cause location B to contain the value 5: the contents of line 7 or the contents of line 10. Explain the difference between line 7 causing the value 5 to be in location B and line 10 causing the value 5 to be in location B. 7.33STAR We have a program with some missing instructions, and we have a table consisting of some information and some missing information associated with five specific clock cycles of the program's execution. Your job is to complete both! Insert the missing instructions in the program and the missing information in the table. Cycle numbering starts at 1. That is, cycle 1 is the first clock cycle of the processing of LD R0,A. Note that we have not said anything about the number of clock cycles a memory access takes. You do have enough information to figure that out for yourself. Note that we are asking for the value of the registers DURING each clock cycle. [fontsize=] .ORIG x3000 LD R0, A LD R1, B NOT R1, R1 ADD R1, R1, #1 AND R2, R2, #0 AGAIN ————– (a) ————– (b) BRnzp AGAIN DONE ST R2, C HALT A .FILL #5 B .FILL ——– (c) C .BLKW #1 .END < g r a p h i c s > What is stored in C at the end of execution for the specific operands given in memory locations A and B? Actually, the program was written by a student, so as expected, he did not get it quite right. Almost, but not quite! Your final task on this problem is to examine the code, figure out what the student was trying to do, point out where he messed up, and how you",
    "362": "Note that we are asking for the value of the registers DURING each clock cycle. [fontsize=] .ORIG x3000 LD R0, A LD R1, B NOT R1, R1 ADD R1, R1, #1 AND R2, R2, #0 AGAIN ————– (a) ————– (b) BRnzp AGAIN DONE ST R2, C HALT A .FILL #5 B .FILL ——– (c) C .BLKW #1 .END < g r a p h i c s > What is stored in C at the end of execution for the specific operands given in memory locations A and B? Actually, the program was written by a student, so as expected, he did not get it quite right. Almost, but not quite! Your final task on this problem is to examine the code, figure out what the student was trying to do, point out where he messed up, and how you would fix it. It is not necessary to write any code, just explain briefly how you would fix it. What was the student trying to do? How did the student mess up? How would you fix his program? 7.34 It is often useful to find the midpoint between two values. For this problem, assume A and B are both even numbers, and that A is less than B. For example, if A=2 and B=8, the midpoint is 5. The following program finds the midpoint of two even numbers A and B by continually incrementing the smaller number and decrementing the larger number. You can assume that A and B have been loaded with values before this program starts execution. Your job: Insert the missing instructions. .ORIG x3000 LD R0,A LD R1,B X —————— (a) —————— (b) ADD R2,R2,R1 —————— (c) ADD R1,R1,#-1 —————— (d) BRnzp X DONE ST R1,C TRAP x25 A .BLKW 1 B .BLKW 1 C .BLKW 1 .END 7.35STAR The program stored in memory locations x3000 to x3007 loads a value from memory location x3100, then does some processing, and then stores a result in memory location x3101. Shown below is an incomplete specification of the program.",
    "363": "numbers, and that A is less than B. For example, if A=2 and B=8, the midpoint is 5. The following program finds the midpoint of two even numbers A and B by continually incrementing the smaller number and decrementing the larger number. You can assume that A and B have been loaded with values before this program starts execution. Your job: Insert the missing instructions. .ORIG x3000 LD R0,A LD R1,B X —————— (a) —————— (b) ADD R2,R2,R1 —————— (c) ADD R1,R1,#-1 —————— (d) BRnzp X DONE ST R1,C TRAP x25 A .BLKW 1 B .BLKW 1 C .BLKW 1 .END 7.35STAR The program stored in memory locations x3000 to x3007 loads a value from memory location x3100, then does some processing, and then stores a result in memory location x3101. Shown below is an incomplete specification of the program. Your job: complete the pecification of the program. Address Contents Assembly code x3000 0101 001 001 1 00000 AND R1, R1, #0 x3001 0010 000 LD R0, x3100 x3002 0000 110 000000011 BRnz x3006 x3003 0001 ADD x3004 x3005 0000 111 x3006 0011 001 ST R1, x3101 x3007 1111 0000 0010 0101 HALT To help you in this process, we have taken a snapshot of part of the state of the machine before the first instruction executes and at several instruction boundaries thereafter, that is, after a number of instructions executed. Part of the snapshot is shown below. Your job is to complete the snapshot. Note that the program enters the TRAP x25 service routine after executing 17 instructions. Therefore some instructions must execute more than once. Note that in the table below: some entries are designated xxxx. You do not have to fill in those entries. Also, you can ignore snapshots for any instructions that are not listed in the table. Instruction # PC MAR MDR R0 R1 Initial x3000 xxxx xxxx xxxx xxxx 1 x3001 xxxx xxxx xxxx 2 x3002 3 x3003 xxxx xxxx 4 x3004 x1240 5 x3005 xxxx xxxx x0002 9 x3005 xxxx xxxx x0001 13",
    "364": "have taken a snapshot of part of the state of the machine before the first instruction executes and at several instruction boundaries thereafter, that is, after a number of instructions executed. Part of the snapshot is shown below. Your job is to complete the snapshot. Note that the program enters the TRAP x25 service routine after executing 17 instructions. Therefore some instructions must execute more than once. Note that in the table below: some entries are designated xxxx. You do not have to fill in those entries. Also, you can ignore snapshots for any instructions that are not listed in the table. Instruction # PC MAR MDR R0 R1 Initial x3000 xxxx xxxx xxxx xxxx 1 x3001 xxxx xxxx xxxx 2 x3002 3 x3003 xxxx xxxx 4 x3004 x1240 5 x3005 xxxx xxxx x0002 9 x3005 xxxx xxxx x0001 13 x3005 xxxx xxxx x0000 14 x3002 xxxx xxxx 15 x3006 xxxx xxxx 16 x3007 17 xxxx xxxx xxxx 7.36 The modulo operator (A mod B) is the remainder one gets when dividing A by B. For example, 10 mod 5 is 0, 12 mod 7 is 5. The program below is supposed to perform A mod B, where A is in x3100 and B is in x3101. The result should be stored at location x3200. However, the programmer made a serious mistake, so the program does not work. You can assume that A and B are both positive integers. .ORIG x3000 ; Line 1 LD R3, L2 ; 2 LDR R0, R3, #0 ; 3 LDR R1, R3, #1 ; 4 NOT R2, R1 ; 5 ADD R2, R2, #1 ; 6 L1 ADD R0, R0, R2 ; 7 BRzp L1 ; 8 ADD R0, R0, R1 ; 9 ST R0, L3 ; 10 HALT ; 11 L2 .FILL x3100 ; 12 L3 .FILL x3200 ; 13 .END ; 14 After the instruction at line 6 has executed, what are the contents of R0,R1,and R2? NOTE: the correct answer in each case is one of the following: A, -A, B,",
    "365": "in x3100 and B is in x3101. The result should be stored at location x3200. However, the programmer made a serious mistake, so the program does not work. You can assume that A and B are both positive integers. .ORIG x3000 ; Line 1 LD R3, L2 ; 2 LDR R0, R3, #0 ; 3 LDR R1, R3, #1 ; 4 NOT R2, R1 ; 5 ADD R2, R2, #1 ; 6 L1 ADD R0, R0, R2 ; 7 BRzp L1 ; 8 ADD R0, R0, R1 ; 9 ST R0, L3 ; 10 HALT ; 11 L2 .FILL x3100 ; 12 L3 .FILL x3200 ; 13 .END ; 14 After the instruction at line 6 has executed, what are the contents of R0,R1,and R2? NOTE: the correct answer in each case is one of the following: A, -A, B, -B, 0, 1, -1. There is a bug in the program. What line is it at and what should the correct instruction be? 7.37STAR During the processing of an LC-3 program by the data path we have been using in class, the computer stops due to a breakpoint set at x3000. The contents of certain registers and memory locations at that time are as follows: R2 through R7: x0000 M[x3000]: x1263 M[x3003]: x0000 The LC-3 is restarted and executes exactly four instructions. To accomplish this, a number of clock cycles are required. In 15 of those clock cycles, the bus must be utilized. The table below lists those 15 clock cycles in sequential order, along with the values that are gated onto the LC-3 bus in each. 2-2 BUS 2-2 1st: x3000 2-2 2nd: x1263 2-2 3rd: x009A 2-2 4th: x3001 2-2 5th: xA000 2-2 6th: 2-2 7th: 2-2 8th: 2-2 9th: 2-2 10th: 2-2 11th: 2-2 12th: 2-2 13th: x3003 2-2 14th: x1263 2-2 15th: x009D 2-2 Fill in the missing entries above. What are the four instructions that were executed? What are the contents of R0 and R1 after the four instructions execute? ../art/ch05/,../art/designelements/,../art/designelements/UnNumberedArt/makechapterhead#1 @ (0,0) (432,-577) <",
    "366": "that time are as follows: R2 through R7: x0000 M[x3000]: x1263 M[x3003]: x0000 The LC-3 is restarted and executes exactly four instructions. To accomplish this, a number of clock cycles are required. In 15 of those clock cycles, the bus must be utilized. The table below lists those 15 clock cycles in sequential order, along with the values that are gated onto the LC-3 bus in each. 2-2 BUS 2-2 1st: x3000 2-2 2nd: x1263 2-2 3rd: x009A 2-2 4th: x3001 2-2 5th: xA000 2-2 6th: 2-2 7th: 2-2 8th: 2-2 9th: 2-2 10th: 2-2 11th: 2-2 12th: 2-2 13th: x3003 2-2 14th: x1263 2-2 15th: x009D 2-2 Fill in the missing entries above. What are the four instructions that were executed? What are the contents of R0 and R1 after the four instructions execute? ../art/ch05/,../art/designelements/,../art/designelements/UnNumberedArt/makechapterhead#1 @ (0,0) (432,-577) < g r a p h i c s > (428,-577)1@9.52667in(381.5,-181) < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > 1212chapter 1212chapter 7212 3032#1 36.4pc4@ CHAPTER: THE LC-3 In Chapter 4, we discussed the basic components of a computer—its memory, its processing unit, including the associated temporary storage (usually a set of registers), input and output devices, and the control unit that directs the activity of all the units (including itself!). We also studied the six phases of the instruction cycle—FETCH, DECODE, ADDRESS EVALUATION, OPERAND FETCH, EXECUTE, and STORE RESULT. We used elements of the LC-3 to illustrate some of the concepts. In fact, we introduced five opcodes: two operate instructions (ADD and AND), one data movement instruction (LD), and two control instructions (BR and TRAP). We are now ready to study the LC-3 in much greater detail. - Recall from Chapter 1 that the ISA is the interface between what the software commands and what the hardware actually carries",
    "367": "1212chapter 1212chapter 7212 3032#1 36.4pc4@ CHAPTER: THE LC-3 In Chapter 4, we discussed the basic components of a computer—its memory, its processing unit, including the associated temporary storage (usually a set of registers), input and output devices, and the control unit that directs the activity of all the units (including itself!). We also studied the six phases of the instruction cycle—FETCH, DECODE, ADDRESS EVALUATION, OPERAND FETCH, EXECUTE, and STORE RESULT. We used elements of the LC-3 to illustrate some of the concepts. In fact, we introduced five opcodes: two operate instructions (ADD and AND), one data movement instruction (LD), and two control instructions (BR and TRAP). We are now ready to study the LC-3 in much greater detail. - Recall from Chapter 1 that the ISA is the interface between what the software commands and what the hardware actually carries out. In this chapter, we will point out most of the important features of the ISA of the LC-3. (A few elements we will leave for Chapter 8 and Chapter 9.) You will need these features to write programs in the LC-3's own language, that is, in the LC-3's machine language. A complete description of the ISA of the LC-3 is contained in Appendix A. § THE ISA: OVERVIEW The ISA specifies all the information about the computer that the software has to be aware of. In other words, the ISA specifies everything in the computer that is available to a programmer when he/she writes programs in the computer's own machine language. Most people, however, do not write programs in the computer's own machine language, but rather opt for writing programs in a high-level language like C++ or Python (or Fortran or COBOL, which have been around for more than 50 years). Thus, the ISA also specifies everything in the computer that is needed by someone (a compiler writer) who wishes to translate programs written in a high-level language into the machine language of the computer. The ISA specifies the memory organization, register set, and instruction set, including the opcodes,",
    "368": "is contained in Appendix A. § THE ISA: OVERVIEW The ISA specifies all the information about the computer that the software has to be aware of. In other words, the ISA specifies everything in the computer that is available to a programmer when he/she writes programs in the computer's own machine language. Most people, however, do not write programs in the computer's own machine language, but rather opt for writing programs in a high-level language like C++ or Python (or Fortran or COBOL, which have been around for more than 50 years). Thus, the ISA also specifies everything in the computer that is needed by someone (a compiler writer) who wishes to translate programs written in a high-level language into the machine language of the computer. The ISA specifies the memory organization, register set, and instruction set, including the opcodes, data types, and addressing modes of the instructions in the instruction set. §.§ Memory Organization The LC-3 memory has an address space of 2^16 (i.e., 65,536) locations, and an addressability of 16 bits. Not all 65,536 addresses are actually used for memory locations, but we will leave that discussion for Chapter 9. Since the normal unit of data that is processed in the LC-3 is 16 bits, we refer to 16 bits as one word, and we say the LC-3 is word-addressable.LC-3!word sizeLC-3!addressability §.§ Registers Since it usually takes far more than one clock cycle to obtain data from memory, the LC-3 provides (like almost all computers) additional temporary storage locations that can be accessed in a single clock cycle. The most common type of temporary storage locations and the one used in the LC-3 is a set of registers. Each register in the set is called a general purpose register (GPR). Like memory locations, registers store information that can be operated on later. The number of bits stored in each register is usually one word. In the LC-3, this means 16 bits. Registers must be uniquely identifiable. The LC-3 specifies eight GPRs, each identified by a 3-bit register number.",
    "369": "processed in the LC-3 is 16 bits, we refer to 16 bits as one word, and we say the LC-3 is word-addressable.LC-3!word sizeLC-3!addressability §.§ Registers Since it usually takes far more than one clock cycle to obtain data from memory, the LC-3 provides (like almost all computers) additional temporary storage locations that can be accessed in a single clock cycle. The most common type of temporary storage locations and the one used in the LC-3 is a set of registers. Each register in the set is called a general purpose register (GPR). Like memory locations, registers store information that can be operated on later. The number of bits stored in each register is usually one word. In the LC-3, this means 16 bits. Registers must be uniquely identifiable. The LC-3 specifies eight GPRs, each identified by a 3-bit register number. They are referred to as R0, R1, … R7. Figure 5.1 shows a snapshot of the LC-3's register set, sometimes called a register file, with the eight values 1, 3, 5, 7, -2, -4, -6, and -8 stored in R0, … R7, respectively. < g r a p h i c s > A snapshot of the LC-3's register file Recall from Chapter 4 that the instruction to ADD the contents of R0 to R1 and store the result in R2 is specified as where the two sources of the ADD instruction are specified in bits [8:6] and bits [2:0]. The destination of the ADD result is specified in bits [11:9]. Figure 5.2 shows the contents of the register file of Figure 5.1 AFTER the instruction ADD R2, R1, R0. is executed. < g r a p h i c s > The register file of Figure 5.1 after the ADD instruction §.§ The Instruction Set Recall from Chapter 4 that an instruction is made up of two things, its opcode (what the instruction is asking the computer to do) and its operands (who the computer is expected to do it to!). The instruction set is defined by its set",
    "370": "Recall from Chapter 4 that the instruction to ADD the contents of R0 to R1 and store the result in R2 is specified as where the two sources of the ADD instruction are specified in bits [8:6] and bits [2:0]. The destination of the ADD result is specified in bits [11:9]. Figure 5.2 shows the contents of the register file of Figure 5.1 AFTER the instruction ADD R2, R1, R0. is executed. < g r a p h i c s > The register file of Figure 5.1 after the ADD instruction §.§ The Instruction Set Recall from Chapter 4 that an instruction is made up of two things, its opcode (what the instruction is asking the computer to do) and its operands (who the computer is expected to do it to!). The instruction set is defined by its set of opcodes, data types, and addressing modes. The addressing modes determine where the operands are located. The data type is the representation of the operands in 0's and 1's. The ADD example above has an opcode ADD, one addressing mode ( register mode), and one data type (2's complement integer). The instruction directs the computer to perform a 2's complement integer addition, and specifies the locations (GPRs) where the computer is expected to find the operands and the location (a GPR) where the computer is to write the result. We saw in Chapter 4 that the ADD instruction can also have two addressing modes (register mode and immediate mode), where one of the two operands is literally contained in bits[4:0] of the instruction. Figure 5.3 lists all the instructions of the LC-3, the bit encoding [15:12] for each opcode, and the format of each instruction. Some of them you recognize from Chapter 4. Many others will be explained in Sections 5.2, 5.3, and 5.4. < g r a p h i c s > Formats of the entire LC-3 instruction set. NOTE: ^+ indicates instructions that modify condition codes §.§ Opcodes Some ISAs have a very large number of opcodes,",
    "371": "integer addition, and specifies the locations (GPRs) where the computer is expected to find the operands and the location (a GPR) where the computer is to write the result. We saw in Chapter 4 that the ADD instruction can also have two addressing modes (register mode and immediate mode), where one of the two operands is literally contained in bits[4:0] of the instruction. Figure 5.3 lists all the instructions of the LC-3, the bit encoding [15:12] for each opcode, and the format of each instruction. Some of them you recognize from Chapter 4. Many others will be explained in Sections 5.2, 5.3, and 5.4. < g r a p h i c s > Formats of the entire LC-3 instruction set. NOTE: ^+ indicates instructions that modify condition codes §.§ Opcodes Some ISAs have a very large number of opcodes, one for each of a very large number of tasks that a program may wish to carry out. The x86 ISA has more than 200 opcodes. Other ISAs have a very small set of opcodes. Some ISAs have specific opcodes to help with processing scientific calculations. For example, the Hewlett Packard Precision Architecture can specify the compound operation (A· B)+C with one opcode; that is, a multiply, followed by an add on three source operands A,B, and C. Other ISAs have instructions that process video images obtained from the World Wide Web. The Intel x86 ISA added a number of instructions which they originally called MMX instructions because they e Xtended the ISA to assist with Multi Media applications that use the Web. Still other ISAs have specific opcodes to help with handling the tasks of the operating system. For example, the VAX ISA, popular in the 1980s, used a single opcode instead of a long sequence of instructions that other computers used to save the information associated with a program that was in the middle of executing prior to switching to another program. The decision as to which instructions to include or leave out of an ISA is usually",
    "372": "with one opcode; that is, a multiply, followed by an add on three source operands A,B, and C. Other ISAs have instructions that process video images obtained from the World Wide Web. The Intel x86 ISA added a number of instructions which they originally called MMX instructions because they e Xtended the ISA to assist with Multi Media applications that use the Web. Still other ISAs have specific opcodes to help with handling the tasks of the operating system. For example, the VAX ISA, popular in the 1980s, used a single opcode instead of a long sequence of instructions that other computers used to save the information associated with a program that was in the middle of executing prior to switching to another program. The decision as to which instructions to include or leave out of an ISA is usually a hotly debated topic in a company when a new ISA is being specified. The LC-3 ISA has 15 instructions, each identified by its unique opcode. The opcode is specified in bits [15:12] of the instruction. Since four bits are used to specify the opcode, 16 distinct opcodes are possible. However, the LC-3 ISA specifies only 15 opcodes. The code 1101 has been left unspecified, reserved for some future need that we are not able to anticipate today. As we already discussed briefly in Chapter 4, there are three different types of instructions, which means three different types of opcodes: operates, data movement, and control. Operate instructions process information. Data movement instructions move information between memory and the registers and between registers/memory and input/output devices. Control instructions change the sequence of instructions that will be executed. That is, they enable the execution of an instruction other than the one that is stored in the next sequential location in memory. §.§ Data Types As we first pointed out in Section 2.1.2, a data type is a representation of information such that the ISA has opcodes that operate on that representation. There are many ways to represent the same information in a",
    "373": "1101 has been left unspecified, reserved for some future need that we are not able to anticipate today. As we already discussed briefly in Chapter 4, there are three different types of instructions, which means three different types of opcodes: operates, data movement, and control. Operate instructions process information. Data movement instructions move information between memory and the registers and between registers/memory and input/output devices. Control instructions change the sequence of instructions that will be executed. That is, they enable the execution of an instruction other than the one that is stored in the next sequential location in memory. §.§ Data Types As we first pointed out in Section 2.1.2, a data type is a representation of information such that the ISA has opcodes that operate on that representation. There are many ways to represent the same information in a computer. That should not surprise us, since in our daily lives, we regularly represent the same information in many different ways. For example, a child, when asked how old he is, might hold up three fingers, signifying that he is 3 years old.[-33pt] If the child is particularly precocious, he might write the decimal digit 3 to indicate his age. Or, if the child is a CS or CE major at the university, he might write 0000000000000011, the 16-bit binary representation for 3. If he is a chemistry major, he might write 3.0 · 10^0. All four represent the same value: 3.data type In addition to the representation of a single number by different bit patterns in different data types, it is also the case that the same bit pattern can correspond to different numbers, depending on the data type. For example, the 16 bits 0011000100110000 represent the 2's complement integer 12,592, the ASCII code for 10, and a bit vector such that b_13, b_12, b_7, b_4, and b_3 have the relevant property of the bit vector. That should also not surprise us, since in our daily lives, the same representation can correspond to multiple interpretations, as is the case",
    "374": "Or, if the child is a CS or CE major at the university, he might write 0000000000000011, the 16-bit binary representation for 3. If he is a chemistry major, he might write 3.0 · 10^0. All four represent the same value: 3.data type In addition to the representation of a single number by different bit patterns in different data types, it is also the case that the same bit pattern can correspond to different numbers, depending on the data type. For example, the 16 bits 0011000100110000 represent the 2's complement integer 12,592, the ASCII code for 10, and a bit vector such that b_13, b_12, b_7, b_4, and b_3 have the relevant property of the bit vector. That should also not surprise us, since in our daily lives, the same representation can correspond to multiple interpretations, as is the case with a red light. When you see it on the roadway while you are driving, it means you should stop. When you see it at Centre Bell where the Montreal Canadiens play hockey, it means someone has just scored a goal. Every opcode will interpret the bit patterns of its operands according to the data type it is designed to support. In the case of the ADD opcode, for example, the hardware will interpret the bit patterns of its operands as 2's complement integers. Therefore, if a programmer stored the bit pattern 0011000100110000 in R3, thinking that the bit pattern represented the integer 10, the instruction ADD R4,R3,#10 would write the integer 12,602 into R4, and not the ASCII code for the integer 20. Why? Because the opcode ADD interprets the bit patterns of its operands as 2's complement integers, and not ASCII codes, regardless what the person creating those numbers intended. §.§ Addressing Modes An addressing mode is a mechanism for specifying where the operand is located. An operand can generally be found in one of three places: in memory, in a register, or as a part of the instruction. If the operand is a part of the instruction,",
    "375": "support. In the case of the ADD opcode, for example, the hardware will interpret the bit patterns of its operands as 2's complement integers. Therefore, if a programmer stored the bit pattern 0011000100110000 in R3, thinking that the bit pattern represented the integer 10, the instruction ADD R4,R3,#10 would write the integer 12,602 into R4, and not the ASCII code for the integer 20. Why? Because the opcode ADD interprets the bit patterns of its operands as 2's complement integers, and not ASCII codes, regardless what the person creating those numbers intended. §.§ Addressing Modes An addressing mode is a mechanism for specifying where the operand is located. An operand can generally be found in one of three places: in memory, in a register, or as a part of the instruction. If the operand is a part of the instruction, we refer to it as a literal or as an immediate operand.immediate operand The term literal comes from the fact that the bits of the instruction literally form the operand. The term immediate comes from the fact that we can obtain the operand immediately from the instruction, that is, we don't have to look elsewhere for it. The LC-3 supports five addressing modes: immediate (or literal), register, and three memory addressing modes: PC-relative, indirect, and Base+offset.LC-3!addressing modes We will see in Section 5.2 that operate instructions use two addressing modes: register and immediate. We will see in Section 5.3 that data movement instructions use four of the five addressing modes. §.§ Condition Codes One final item will complete our overview of the ISA of the LC-3: condition codes.condition codes The LC-3 has three single-bit registers that are individually set (set to 1) or cleared (set to 0) each time one of the eight general purpose registers is written into as a result of execution of one of the operate instructions or one of the load instructions. Each operate instruction performs a computation and writes the result into a general purpose register. Each load instruction reads the contents of a memory",
    "376": "five addressing modes: immediate (or literal), register, and three memory addressing modes: PC-relative, indirect, and Base+offset.LC-3!addressing modes We will see in Section 5.2 that operate instructions use two addressing modes: register and immediate. We will see in Section 5.3 that data movement instructions use four of the five addressing modes. §.§ Condition Codes One final item will complete our overview of the ISA of the LC-3: condition codes.condition codes The LC-3 has three single-bit registers that are individually set (set to 1) or cleared (set to 0) each time one of the eight general purpose registers is written into as a result of execution of one of the operate instructions or one of the load instructions. Each operate instruction performs a computation and writes the result into a general purpose register. Each load instruction reads the contents of a memory location and write the value found there into a general purpose register. We will discuss all the operate instructions in Section 5.2 and all the load instructions in Section 5.3. The three single-bit registers are called N, Z, and P, corresponding to their meaning: negative, zero, and positive. Each time a GPR is written by an operate or a load instruction, the N, Z, and P one-bit registers are individually set to 0 or 1, corresponding to whether the result written to the GPR is negative, zero, or positive. That is, if the result is negative, the N register is set, and Z and P are cleared. If the result is zero, Z is set and N and P are cleared. If the result is positive, P is set and N and Z are cleared. The set of three single-bit registers are referred to as condition codes because the condition of those bits are used to change the sequence of execution of the instructions in a computer program. Many ISAs use condition codes to change the execution sequence. SPARC and x86 are two examples. We will show how the LC-3 does it in Section 5.4. § OPERATE INSTRUCTIONS §.§ ADD,",
    "377": "instruction, the N, Z, and P one-bit registers are individually set to 0 or 1, corresponding to whether the result written to the GPR is negative, zero, or positive. That is, if the result is negative, the N register is set, and Z and P are cleared. If the result is zero, Z is set and N and P are cleared. If the result is positive, P is set and N and Z are cleared. The set of three single-bit registers are referred to as condition codes because the condition of those bits are used to change the sequence of execution of the instructions in a computer program. Many ISAs use condition codes to change the execution sequence. SPARC and x86 are two examples. We will show how the LC-3 does it in Section 5.4. § OPERATE INSTRUCTIONS §.§ ADD, AND, and NOT Operate instructions process data. Arithmetic operations (like ADD, SUB, MUL, and DIV) and logical operations (like AND, OR, NOT, XOR) are common examples. The LC-3 has three operate instructions: ADD, AND, and NOT. The NOT (opcode=1001) instruction is the only operate instruction that performs a unary operation, that is, the operation requires one source operand. The NOT instruction bit-wise complements a 16-bit source operand and stores the result in a destination register. NOT uses the register addressing mode for both its source and destination. Bits [8:6] specify the source register and bits [11:9] specify the destination register. Bits [5:0] must contain all 1s. If R5 initially contains 0101000011110000, after executing the following instruction: R3 will contain 1010111100001111. Figure 5.4 shows the key parts of the data path that are used to perform the NOT instruction shown here. Since NOT is a unary operation, only the A input of the ALU is relevant. It is sourced from R5. The control signal to the ALU directs the ALU to perform the bit-wise complement operation. The output of the ALU (the result of the operation) is stored into R3 and the condition codes are set, completing the execution of the",
    "378": "instruction bit-wise complements a 16-bit source operand and stores the result in a destination register. NOT uses the register addressing mode for both its source and destination. Bits [8:6] specify the source register and bits [11:9] specify the destination register. Bits [5:0] must contain all 1s. If R5 initially contains 0101000011110000, after executing the following instruction: R3 will contain 1010111100001111. Figure 5.4 shows the key parts of the data path that are used to perform the NOT instruction shown here. Since NOT is a unary operation, only the A input of the ALU is relevant. It is sourced from R5. The control signal to the ALU directs the ALU to perform the bit-wise complement operation. The output of the ALU (the result of the operation) is stored into R3 and the condition codes are set, completing the execution of the NOT instruction. < g r a p h i c s > Data path relevant to the execution of NOT R3, R5 Recall from Chapter 4 that the ADD (opcode=0001) and AND (opcode=0101) instructions both perform binary operations; they require two 16-bit source operands. The ADD instruction performs a 2's complement addition of its two source operands. The AND instruction performs a bit-wise AND of each pair of bits of its two 16-bit operands. Like the NOT, the ADD and AND use the register addressing mode for one of the source operands and for the destination operand. Bits [8:6] specify the source register and bits [11:9] specify the destination register (where the result will be written). §.§ Immediates The second source operand for both ADD and AND instructions (as also discussed in Chapter 4) can be specified by either register mode or as an immediate operand. Bit [5] determines which. If bit [5] is 0, then the second source operand uses a register, and bits [2:0] specify which register. In that case, bits [4:3] are set to 0 to complete the specification of the instruction. In the ADD instruction shown below, if R4 contains the value 6 and R5 contains",
    "379": "performs a bit-wise AND of each pair of bits of its two 16-bit operands. Like the NOT, the ADD and AND use the register addressing mode for one of the source operands and for the destination operand. Bits [8:6] specify the source register and bits [11:9] specify the destination register (where the result will be written). §.§ Immediates The second source operand for both ADD and AND instructions (as also discussed in Chapter 4) can be specified by either register mode or as an immediate operand. Bit [5] determines which. If bit [5] is 0, then the second source operand uses a register, and bits [2:0] specify which register. In that case, bits [4:3] are set to 0 to complete the specification of the instruction. In the ADD instruction shown below, if R4 contains the value 6 and R5 contains the value -18, then R1 will contain the value -12 after the instruction is executed. If bit[5] is 1, the second source operand is contained within the instruction. In that case the second source operand is obtained by sign-extending bits [4:0] to 16 bits before performing the ADD or AND. The result of the ADD (or AND) instruction is written to the destination register and the condition codes are set, completing the execution of the ADD (or AND) instruction. Figure 5.5 shows the key parts of the data path that are used to perform the instruction ADD R1, R4, #-2. < g r a p h i c s > Data path relevant to the execution of ADD R1, R4, #-2[6pt] Since the immediate operand in an ADD or AND instruction must fit in bits [4:0] of the instruction, not all 2's complement integers can be immediate operands. Question: Which integers are OK (i.e., which integers can be used as immediate operands)? example example mathmargin@ to 13@ to 7pc1012 Example 9.5117.5pc by 3@ 1.5pcafterheadingafterindentfalse What does the following instruction do? 28pc Register 2 is cleared (i.e., set to all 0s). What does the following instruction do? 28pc Register 6 is",
    "380": "to the destination register and the condition codes are set, completing the execution of the ADD (or AND) instruction. Figure 5.5 shows the key parts of the data path that are used to perform the instruction ADD R1, R4, #-2. < g r a p h i c s > Data path relevant to the execution of ADD R1, R4, #-2[6pt] Since the immediate operand in an ADD or AND instruction must fit in bits [4:0] of the instruction, not all 2's complement integers can be immediate operands. Question: Which integers are OK (i.e., which integers can be used as immediate operands)? example example mathmargin@ to 13@ to 7pc1012 Example 9.5117.5pc by 3@ 1.5pcafterheadingafterindentfalse What does the following instruction do? 28pc Register 2 is cleared (i.e., set to all 0s). What does the following instruction do? 28pc Register 6 is incremented (i.e., R6← R6+1). Note that a register can be used as a source and also as a destination in the same instruction. This is true for all the instructions in the LC-3. Recall that the negative of an integer represented in 2's complement can be obtained by complementing the number and adding 1. Therefore, assuming the values A and B are in R0 and R1, what sequence of three instructions performs “A minus B” and writes the result into R2? 28pc Question: What distasteful result is also produced by this sequence? How can it easily be avoided?[-3.8pc] §.§ The LEA Instruction (although not really an operate) Where to put the LEA instruction is a matter for debate (when you have nothing more important to do!). It does not really operate on data, it simply loads a register with an address. It clearly does not move data from memory to a register, nor is it a control instruction. We had to put it somewhere so we chose to discuss it here! LEA (opcode=1110) loads the register specified by bits [11:9] of the instruction with the value formed by adding the incremented program counter to the sign-extended bits [8:0] of the",
    "381": "B are in R0 and R1, what sequence of three instructions performs “A minus B” and writes the result into R2? 28pc Question: What distasteful result is also produced by this sequence? How can it easily be avoided?[-3.8pc] §.§ The LEA Instruction (although not really an operate) Where to put the LEA instruction is a matter for debate (when you have nothing more important to do!). It does not really operate on data, it simply loads a register with an address. It clearly does not move data from memory to a register, nor is it a control instruction. We had to put it somewhere so we chose to discuss it here! LEA (opcode=1110) loads the register specified by bits [11:9] of the instruction with the value formed by adding the incremented program counter to the sign-extended bits [8:0] of the instruction. We saw this method of constructing an address in Chapter 4 with the LD instruction. However, in this case, the instruction does not access memory, it simply loads the computed address into a register. Perhaps a better name for this opcode would be CEA (for Compute Effective Address). However, since many microprocessors in industry that have this instruction in their ISAs call it LEA (for Load Effective Address), we have chosen to use the same acronym. We shall see shortly that the LEA instruction is useful to initialize a register with an address that is very close to the address of the instruction doing the initializing. If memory location x4018 contains the instruction LEA R5, #-3, and the PC contains x4018, R5 will contain x4016 after the instruction at x4018 is executed. Question: Why will R5 not contain the address x4015? Figure 5.6 shows the relevant parts of the data path required to execute the LEA instruction. Note that the value to be loaded into the register does not involve any access to memory. ...nor does it have any effect on the condition codes. < g r a p h i c s > Data path relevant to the",
    "382": "their ISAs call it LEA (for Load Effective Address), we have chosen to use the same acronym. We shall see shortly that the LEA instruction is useful to initialize a register with an address that is very close to the address of the instruction doing the initializing. If memory location x4018 contains the instruction LEA R5, #-3, and the PC contains x4018, R5 will contain x4016 after the instruction at x4018 is executed. Question: Why will R5 not contain the address x4015? Figure 5.6 shows the relevant parts of the data path required to execute the LEA instruction. Note that the value to be loaded into the register does not involve any access to memory. ...nor does it have any effect on the condition codes. < g r a p h i c s > Data path relevant to the execution of LEA R5, #-3 § DATA MOVEMENT INSTRUCTIONS Data movement instructions move information between-14pt the general purpose registers and memory, and between the registers and the input/output devices. We will ignore for now the business of moving information from input devices to registers and from registers to output devices. This will be an important part of Chapter 9. In this chapter, we will confine ourselves to moving information between memory and the general purpose registers. The process of moving information from memory to a register is called a load, and the process of moving information from a register to memory is called a store. In both cases, the information in the location containing the source operand remains unchanged. In both cases, the location of the destination operand is overwritten with the source operand, destroying in the process the previous value that was in the destination location. The LC-3 contains six instructions that move information: LD, LDR, LDI, ST, STR, and STI. The format of the load and store instructions is as follows: Data movement instructions require two operands, a source and a destination. The source is the data to be moved; the destination is the location where it is",
    "383": "this chapter, we will confine ourselves to moving information between memory and the general purpose registers. The process of moving information from memory to a register is called a load, and the process of moving information from a register to memory is called a store. In both cases, the information in the location containing the source operand remains unchanged. In both cases, the location of the destination operand is overwritten with the source operand, destroying in the process the previous value that was in the destination location. The LC-3 contains six instructions that move information: LD, LDR, LDI, ST, STR, and STI. The format of the load and store instructions is as follows: Data movement instructions require two operands, a source and a destination. The source is the data to be moved; the destination is the location where it is moved to. One of these locations is a register, the other is a memory location or an input/output device. In this chapter we will assume the second operand is in memory. In Chapter 9 we will study the cases where the second operand is an input or output device. Bits[11:9] specify one of these operands, – the register. If the instruction is a load, DR refers to the destination general purpose register that will contain the value after it is read from memory (at the completion of the instruction cycle). If the instruction is a store, SR refers to the register that contains the value that will be written to memory. Bits [8:0] contain the address generation bits. That is, bits [8:0] contain information that is used to compute the 16-bit address of the second operand. In the case of the LC-3's data movement instructions, there are three ways to interpret bits [8:0]. They are collectively called addressing modes. The opcode specifies how to interpret bits [8:0]. That is, the LC-3's opcode specifies which of the three addressing modes should be used to obtain the address of the operand from bits [8:0] of the instruction. §.§ PC-Relative Mode LD (opcode=0010)",
    "384": "instruction is a load, DR refers to the destination general purpose register that will contain the value after it is read from memory (at the completion of the instruction cycle). If the instruction is a store, SR refers to the register that contains the value that will be written to memory. Bits [8:0] contain the address generation bits. That is, bits [8:0] contain information that is used to compute the 16-bit address of the second operand. In the case of the LC-3's data movement instructions, there are three ways to interpret bits [8:0]. They are collectively called addressing modes. The opcode specifies how to interpret bits [8:0]. That is, the LC-3's opcode specifies which of the three addressing modes should be used to obtain the address of the operand from bits [8:0] of the instruction. §.§ PC-Relative Mode LD (opcode=0010) and ST (opcode=0011) specify the PC-relative addressing mode. We have already discussed this addressing mode in Chapter 4. It is so named because bits [8:0] of the instruction specify an offset relative to the PC. The memory address is computed by sign-extending bits [8:0] to 16 bits, and adding the result to the incremented PC. The incremented PC is the contents of the program counter after the FETCH phase; that is, after the PC has been incremented. If a load, the memory location corresponding to the computed memory address is read, and the result loaded into the register LC-3!PC-relative addressing mode specified by bits [11:9] of the instruction. ...and the N, Z, and P one-bit condition codes are set depending on whether the value loaded is negative, positive or zero. If the following instruction is located at x4018, it will cause the contents of x3FC8 to be loaded into R2. Figure 5.7 shows the relevant parts of the data path required to execute this instruction. The three steps of the LD instruction are identified. In step 1, the incremented PC (x4019) is added to the sign-extended value contained in IR[8:0] (xFFAF), and the result (x3FC8) is loaded into the MAR.",
    "385": "contents of the program counter after the FETCH phase; that is, after the PC has been incremented. If a load, the memory location corresponding to the computed memory address is read, and the result loaded into the register LC-3!PC-relative addressing mode specified by bits [11:9] of the instruction. ...and the N, Z, and P one-bit condition codes are set depending on whether the value loaded is negative, positive or zero. If the following instruction is located at x4018, it will cause the contents of x3FC8 to be loaded into R2. Figure 5.7 shows the relevant parts of the data path required to execute this instruction. The three steps of the LD instruction are identified. In step 1, the incremented PC (x4019) is added to the sign-extended value contained in IR[8:0] (xFFAF), and the result (x3FC8) is loaded into the MAR. In step 2, memory is read and the contents of x3FC8 are loaded into the MDR. Suppose the value stored in x3FC8 is 5. In step 3, the value 5 is loaded into R2 and the NZP condition codes are set, completing the instruction cycle. < g r a p h i c s > Data path relevant to execution of LD R2, x1AF Note that the address of the memory operand is limited to a small range of the total memory. That is, the address can only be within +256 or -255 locations of the LD or ST instruction. This is the range provided by the sign-extended value contained in bits[8:0] of the instruction. If a load instruction needs to access a memory location further away from the load instruction, one of the other two addressing modes must be used. §.§ Indirect Mode LDI (opcode=1010) and STI (opcode=1011) specify the indirect addressing mode. An address is first formed exactly the same way as with LD and ST. However, instead of this address being the address of the operand to be loaded or stored, it is the address of the address of the operand to be loaded or stored. Hence",
    "386": "of LD R2, x1AF Note that the address of the memory operand is limited to a small range of the total memory. That is, the address can only be within +256 or -255 locations of the LD or ST instruction. This is the range provided by the sign-extended value contained in bits[8:0] of the instruction. If a load instruction needs to access a memory location further away from the load instruction, one of the other two addressing modes must be used. §.§ Indirect Mode LDI (opcode=1010) and STI (opcode=1011) specify the indirect addressing mode. An address is first formed exactly the same way as with LD and ST. However, instead of this address being the address of the operand to be loaded or stored, it is the address of the address of the operand to be loaded or stored. Hence the name indirect. Note that the address of the operand can be anywhere in the computer's memory, not just within the range provided by bits [8:0] of the instruction as is the case for LD and ST. The destination register for the LDI and the source register for STI, like all the other loads and stores, are specified in bits [11:9] of the instruction.LC-3!indirect addressing mode If the instruction is in x4A1B, and the contents of x49E8 is x2110, execution of this instruction results in the contents of x2110 being loaded into R3. < g r a p h i c s > Data path relevant to the execution of LDI R3, x1CC Figure 5.8 shows the relevant parts of the data path required to execute this instruction. As is the case with the LD and ST instructions, the first step consists of adding the incremented PC (x4A1C) to the sign-extended value contained in IR[8:0] (xFFCC), and the result (x49E8) loaded into the MAR. In step 2, memory is read and the contents of x49E8 (x2110) is loaded into the MDR. In step 3, since x2110 is not the operand, but the address of the operand, it is loaded into",
    "387": "[11:9] of the instruction.LC-3!indirect addressing mode If the instruction is in x4A1B, and the contents of x49E8 is x2110, execution of this instruction results in the contents of x2110 being loaded into R3. < g r a p h i c s > Data path relevant to the execution of LDI R3, x1CC Figure 5.8 shows the relevant parts of the data path required to execute this instruction. As is the case with the LD and ST instructions, the first step consists of adding the incremented PC (x4A1C) to the sign-extended value contained in IR[8:0] (xFFCC), and the result (x49E8) loaded into the MAR. In step 2, memory is read and the contents of x49E8 (x2110) is loaded into the MDR. In step 3, since x2110 is not the operand, but the address of the operand, it is loaded into the MAR. In step 4, memory is again read, and the MDR again loaded. This time the MDR is loaded with the contents of x2110. Suppose the value -1 is stored in memory location x2110. In step 5, the contents of the MDR (i.e., -1) are loaded into R3 and the NZP condition codes are set, completing the instruction cycle. §.§ Base+offset Mode LDR (opcode=0110) and STR (opcode=0111) specify the Base+offset addressing mode. The Base+offset mode is so named because the address of the operand is obtained by adding a sign-extended 6-bit offset to a base register. The 6-bit offset is obtained from the instruction, bits[5:0]. The base register is specified by bits[8:6] of the instruction. LC-3!base+offset addressing mode If R2 contains the 16-bit quantity x2345, the following instruction loads R1 with the contents of x2362. < g r a p h i c s > Data path relevant to the execution of LDR R1, R2, x1D Figure 5.9 shows the relevant parts of the data path required to execute this instruction. First the contents of R2 (x2345) are added to the sign-extended value contained in IR[5:0] (x001D), and the result (x2362) is loaded into the MAR. Second, memory is",
    "388": "§.§ Base+offset Mode LDR (opcode=0110) and STR (opcode=0111) specify the Base+offset addressing mode. The Base+offset mode is so named because the address of the operand is obtained by adding a sign-extended 6-bit offset to a base register. The 6-bit offset is obtained from the instruction, bits[5:0]. The base register is specified by bits[8:6] of the instruction. LC-3!base+offset addressing mode If R2 contains the 16-bit quantity x2345, the following instruction loads R1 with the contents of x2362. < g r a p h i c s > Data path relevant to the execution of LDR R1, R2, x1D Figure 5.9 shows the relevant parts of the data path required to execute this instruction. First the contents of R2 (x2345) are added to the sign-extended value contained in IR[5:0] (x001D), and the result (x2362) is loaded into the MAR. Second, memory is read, and the contents of x2362 are loaded into the MDR. Suppose the value stored in memory location x2362 is x0F0F. Third, and finally, the contents of the MDR (in this case, x0F0F) are loaded into R1 and the NZP condition codes are set, completing the execution of the LDR instruction. Note that the Base+offset addressing mode also allows the address of the operand to be anywhere in the computer's memory. §.§ An Example We conclude our study of addressing modes with a comprehensive example. Assume the contents of memory locations x30F6 through x30FC are as shown in Figure 5.10, and the PC contains x30F6. We will examine the effects of carrying out the seven instructions starting at location x30FC. A Code Fragment illustrating the three ddressing modes Since the PC points initially to location x30F6, the first instruction to be executed is the one stored in location x30F6. The opcode of that instruction is 1110, load effective address (LEA). LEA loads the register specified by bits [11:9] with the address formed by sign-extending bits [8:0] of the instruction and adding the result to the incremented PC. The 16-bit value obtained by sign-extending bits [8:0] of the instruction is xFFFD.",
    "389": "address of the operand to be anywhere in the computer's memory. §.§ An Example We conclude our study of addressing modes with a comprehensive example. Assume the contents of memory locations x30F6 through x30FC are as shown in Figure 5.10, and the PC contains x30F6. We will examine the effects of carrying out the seven instructions starting at location x30FC. A Code Fragment illustrating the three ddressing modes Since the PC points initially to location x30F6, the first instruction to be executed is the one stored in location x30F6. The opcode of that instruction is 1110, load effective address (LEA). LEA loads the register specified by bits [11:9] with the address formed by sign-extending bits [8:0] of the instruction and adding the result to the incremented PC. The 16-bit value obtained by sign-extending bits [8:0] of the instruction is xFFFD. The incremented PC is x30F7. Therefore, at the end of execution of the LEA instruction, R1 contains x30F4, and the PC contains x30F7. Next, the instruction stored in location x30F7 is executed. Since the opcode 0001 specifies ADD, the sign-extended immediate in bits [4:0] (since bit[5] is 1) is added to the contents of the register specified in bits [8:6], and the result is written to the register specified by bits [11:9]. Since the previous instruction wrote x30F4 into R1, and the sign-extended immediate value is x000E, the sum is x3102. At the end of execution of this instruction, R2 contains x3102, and the PC contains x30F8. R1 still contains x30F4. Next, the instruction stored in x30F8. The opcode 0011 specifies the ST instruction, which stores the contents of the register specified by bits[11:9] (R2) into the memory location whose address is computed using the PC-relative addressing mode. That is, the address is computed by adding the incremented PC (x30F9) to the 16-bit value obtained by sign-extending bits[8:0] of the instruction (xFFFB). Therefore, at the end of execution of the ST instruction, memory location x30F4 (i.e., x30F9 + xFFFB) contains the value stored in R2 (x3102) and the PC contains",
    "390": "and the result is written to the register specified by bits [11:9]. Since the previous instruction wrote x30F4 into R1, and the sign-extended immediate value is x000E, the sum is x3102. At the end of execution of this instruction, R2 contains x3102, and the PC contains x30F8. R1 still contains x30F4. Next, the instruction stored in x30F8. The opcode 0011 specifies the ST instruction, which stores the contents of the register specified by bits[11:9] (R2) into the memory location whose address is computed using the PC-relative addressing mode. That is, the address is computed by adding the incremented PC (x30F9) to the 16-bit value obtained by sign-extending bits[8:0] of the instruction (xFFFB). Therefore, at the end of execution of the ST instruction, memory location x30F4 (i.e., x30F9 + xFFFB) contains the value stored in R2 (x3102) and the PC contains x30F9. Next the instruction at x3059. The AND instruction, with an immediate operand x0000. At the end of execution, R2 contains the value 0, and the PC contains x30FA. At x30FA, the opcode 0001 specifies the ADD instruction. After execution, R2 contains the value 5, and the PC contains x30FB. =1 At x30FB, the opcode 0111 signifies the STR instruction. STR (like LDR) uses the Base+offset addressing mode. The memory address is obtained by adding the contents of the BASE Register (specified by bits [8:6]) to the sign-extended offset contained in bits [5:0]. In this case, bits [8:6] specify R1, which contains x30F4. The 16-bit sign-extended offset is x000E. Since x30F4+x000E is x3102, the memory address is x3102. The STR instruction stores into x3102 the contents of the register specified by bits [11:9], in this case R2. Since R2 contains the value 5, at the end of execution of this instruction, M[x3102] contains the value 5, and the PC contains x30FC. Finally the instruction at x30FC. The opcode 1010 specifies LDI. LDI (like STI) uses the indirect addressing mode. The memory address is obtained by first forming an address as is done in the PC-relative addressing mode. Bits[8:0] are sign-extended",
    "391": "STR (like LDR) uses the Base+offset addressing mode. The memory address is obtained by adding the contents of the BASE Register (specified by bits [8:6]) to the sign-extended offset contained in bits [5:0]. In this case, bits [8:6] specify R1, which contains x30F4. The 16-bit sign-extended offset is x000E. Since x30F4+x000E is x3102, the memory address is x3102. The STR instruction stores into x3102 the contents of the register specified by bits [11:9], in this case R2. Since R2 contains the value 5, at the end of execution of this instruction, M[x3102] contains the value 5, and the PC contains x30FC. Finally the instruction at x30FC. The opcode 1010 specifies LDI. LDI (like STI) uses the indirect addressing mode. The memory address is obtained by first forming an address as is done in the PC-relative addressing mode. Bits[8:0] are sign-extended to 16 bits (xFFF7) and added to the incremented PC (x30FD). Their sum (x30F4) is the address of the operand address. Since M[x30F4] contains x3102, x3102 is the operand address. The LDI instruction loads the value found at this address (in this case 5) into the register identified by bits [11:9] of the instruction (in this case R3). At the end of execution of this instruction, R3 contains the value 5 and the PC contains x30FD. § CONTROL INSTRUCTIONS Control instructions change the sequence of instructions to be executed. If there were no control instructions, the next instruction fetched after the current instruction finishes would always be the instruction located in the next sequential memory location. As you know, this is because the PC is incremented in the FETCH phase of each instruction cycle. We have already seen in the program of Section 4.4 that it is often useful to be able to break that sequence. The LC-3 has five opcodes that enable the sequential execution flow to be broken: conditional branch, unconditional jump, subroutine call (sometimes called function), TRAP, and Return from Trap or Interrupt (RTI). In this section, we will deal almost entirely with the most common control",
    "392": "end of execution of this instruction, R3 contains the value 5 and the PC contains x30FD. § CONTROL INSTRUCTIONS Control instructions change the sequence of instructions to be executed. If there were no control instructions, the next instruction fetched after the current instruction finishes would always be the instruction located in the next sequential memory location. As you know, this is because the PC is incremented in the FETCH phase of each instruction cycle. We have already seen in the program of Section 4.4 that it is often useful to be able to break that sequence. The LC-3 has five opcodes that enable the sequential execution flow to be broken: conditional branch, unconditional jump, subroutine call (sometimes called function), TRAP, and Return from Trap or Interrupt (RTI). In this section, we will deal almost entirely with the most common control instruction, the conditional branch. We will also discuss the unconditional jump and conditional branch the TRAP instruction. The TRAP instruction, often called service call, is useful because it allows a programmer to get help from the operating system to do things that the typical programmer does not fully understand how to do. Typical examples: getting information into the computer from input devices, displaying information to output devices, and stopping the computer. The TRAP instruction breaks the sequential execution of a user program to start a sequence of instructions in the operating system. How the TRAP instruction does this, and in fact, most of the discussion of the TRAP instruction and all of the discussion of the subroutine call and the return from interrupt we will leave for Chapters 8 and 9. §.§ Conditional Branches Of the five instructions which change the execution flow from the next sequential instruction to an instruction located someplace else in the program, only one of them decides each time it is executed whether to execute the next instruction in sequence or whether to execute an instruction from outside that sequence. The instruction that makes that decision each time it is executed is the conditional branch",
    "393": "input devices, displaying information to output devices, and stopping the computer. The TRAP instruction breaks the sequential execution of a user program to start a sequence of instructions in the operating system. How the TRAP instruction does this, and in fact, most of the discussion of the TRAP instruction and all of the discussion of the subroutine call and the return from interrupt we will leave for Chapters 8 and 9. §.§ Conditional Branches Of the five instructions which change the execution flow from the next sequential instruction to an instruction located someplace else in the program, only one of them decides each time it is executed whether to execute the next instruction in sequence or whether to execute an instruction from outside that sequence. The instruction that makes that decision each time it is executed is the conditional branch instruction BR (opcode = 0000). Like all instructions in the LC-3, the PC is incremented during the FETCH phase of its instruction cycle. Based on the execution of previous instructions in the program, the conditional branch's EXECUTE phase either does nothing or it loads the PC with the address of the instruction it wishes to execute next. If the conditional branch instruction does nothing during the EXECUTE phase, then the incremented PC will remain unchanged, and the next instruction executed will be the next instruction in sequence. That decision, whether to do nothing to the incremented PC, or whether to change it, is based on previous results computed by the program, which are reflected in the condition codes discussed in Section 5.1.7. We will explain. The format of the conditional branch instruction is as follows: Bits [11], [10], and [9] are associated with the three condition codes, N, Z, and P. As you know, the three operate instructions (ADD, AND, and NOT) and the three load instructions (LD, LDI, and LDR) in the LC-3 write values into general purpose registers, and also set the three condition codes in accordance with whether the value written is negative, zero, or positive. The",
    "394": "branch instruction does nothing during the EXECUTE phase, then the incremented PC will remain unchanged, and the next instruction executed will be the next instruction in sequence. That decision, whether to do nothing to the incremented PC, or whether to change it, is based on previous results computed by the program, which are reflected in the condition codes discussed in Section 5.1.7. We will explain. The format of the conditional branch instruction is as follows: Bits [11], [10], and [9] are associated with the three condition codes, N, Z, and P. As you know, the three operate instructions (ADD, AND, and NOT) and the three load instructions (LD, LDI, and LDR) in the LC-3 write values into general purpose registers, and also set the three condition codes in accordance with whether the value written is negative, zero, or positive. The conditional branch instruction uses that information to determine whether or not to depart from the usual sequential execution of instructions that we get as a result of incrementing PC during the FETCH phase of each instruction. We said (without explanation) in the computer program we studied in Section 4.4 that if bits [11:9] of the conditional branch instruction is 101, we will depart from the usual sequential execution if the last value written into a register by one of the six instructions listed above is not 0. We are now ready to see exactly what causes that to happen. During the EXECUTE phase of the BR instruction cycle, the processor examines the condition codes whose associated bits in the instruction, bits [11:9], are 1. Note the lower case n, z, and p in bits [11:9] of the BR instruction format shown above. If bit [11] is 1, condition code N is examined. If bit [10] is 1, condition code Z is examined. If bit [9] is 1, condition code P is examined. If any of bits [11:9] are 0, the associated condition codes are not examined. If any of the condition codes that are examined are set (i.e., equal to",
    "395": "we will depart from the usual sequential execution if the last value written into a register by one of the six instructions listed above is not 0. We are now ready to see exactly what causes that to happen. During the EXECUTE phase of the BR instruction cycle, the processor examines the condition codes whose associated bits in the instruction, bits [11:9], are 1. Note the lower case n, z, and p in bits [11:9] of the BR instruction format shown above. If bit [11] is 1, condition code N is examined. If bit [10] is 1, condition code Z is examined. If bit [9] is 1, condition code P is examined. If any of bits [11:9] are 0, the associated condition codes are not examined. If any of the condition codes that are examined are set (i.e., equal to 1), then the PC is loaded with the address obtained in the EVALUATE ADDRESS phase. If none of the condition codes that are examined are set, the incremented PC is left unchanged, and the next sequential instruction will be fetched at the start of the next instruction cycle. The address obtained during the EVALUATE ADDRESS phase of the instruction cycle is generated using the PC-relative addressing mode. In our example in Section 4.4, the ADD instruction in memory location x3004 subtracted 1 from R2, wrote the result to R2, and set the condition codes. The BR instruction in memory location x3005 shows bits[11:9] = 101. Since bit[11] is 1, if the N bit is set, the result of the ADD must have been negative. Since bit[9] is also 1, if the P bit is set, the result must have been positive. Since bit[10] is 0, we do not examine the Z bit. Thus if the previous result is positive or negative (i.e., not 0), the PC is loaded with x3003, the address calculated in the EVALUATE ADDRESS phase of the branch instuction. Recall that the program of Figure 4.7 used R2 to keep track of the number of times the",
    "396": "is generated using the PC-relative addressing mode. In our example in Section 4.4, the ADD instruction in memory location x3004 subtracted 1 from R2, wrote the result to R2, and set the condition codes. The BR instruction in memory location x3005 shows bits[11:9] = 101. Since bit[11] is 1, if the N bit is set, the result of the ADD must have been negative. Since bit[9] is also 1, if the P bit is set, the result must have been positive. Since bit[10] is 0, we do not examine the Z bit. Thus if the previous result is positive or negative (i.e., not 0), the PC is loaded with x3003, the address calculated in the EVALUATE ADDRESS phase of the branch instuction. Recall that the program of Figure 4.7 used R2 to keep track of the number of times the number 5 was added to R3. As long as we were not done with all our additions, the result of subtracting 1 from R2 was not zero. When we were done with our additions, subtracting 1 from R2 produced the result 0, so Z was set to 1, N and P were set to 0. At that point, bits[11:9] checked the N and P condition codes which were 0, so the incremented PC was not changed, and the instruction at location x3006, a trap to the operating system to halt the computer was executed next. Let's look at another example. Suppose the following instruction is located at x4027, and the last value loaded into a general purpose register was 0. Figure 5.11 shows the data path elements that are required to execute this instruction. Note the logic required to determine whether the sequential instruction flow should be broken. Each of the three AND gates corresponds to one of the three condition codes. The output of the AND gate is 1 if the corresponding condition code is 1 and if the associated bit in the instruction directs the hardware to check that condition code. If any of the three AND gates",
    "397": "the N and P condition codes which were 0, so the incremented PC was not changed, and the instruction at location x3006, a trap to the operating system to halt the computer was executed next. Let's look at another example. Suppose the following instruction is located at x4027, and the last value loaded into a general purpose register was 0. Figure 5.11 shows the data path elements that are required to execute this instruction. Note the logic required to determine whether the sequential instruction flow should be broken. Each of the three AND gates corresponds to one of the three condition codes. The output of the AND gate is 1 if the corresponding condition code is 1 and if the associated bit in the instruction directs the hardware to check that condition code. If any of the three AND gates have an output 1, the OR gate has an output 1, indicating that the sequential instruction flow should be broken, and the PC should be loaded with the address evaluated during the EVALUATE ADDRESS phase of the instruction cycle. In the case of the conditional branch instruction at x4027, the answer is yes, and the PC is loaded with x4101, replacing x4028, which had been loaded into the PC during the FETCH phase of the BR instruction. < g r a p h i c s > Data path relevant to the execution of BRz x0D9 Another example. If all three bits [11:9] are 1, then all three condition codes are examined. In this case, since the last result stored into a register had to be either negative, zero, or positive (there are no other choices!), one of the three condition codes must be in state 1. Since all three are examined, the PC is loaded with the address obtained in the EVALUATE ADDRESS phase. We call this an unconditional branch since the instruction flow is changed unconditionally, that is, independent of the data that is processed. For example, if the following instruction, located at x507B, is executed, the PC",
    "398": "replacing x4028, which had been loaded into the PC during the FETCH phase of the BR instruction. < g r a p h i c s > Data path relevant to the execution of BRz x0D9 Another example. If all three bits [11:9] are 1, then all three condition codes are examined. In this case, since the last result stored into a register had to be either negative, zero, or positive (there are no other choices!), one of the three condition codes must be in state 1. Since all three are examined, the PC is loaded with the address obtained in the EVALUATE ADDRESS phase. We call this an unconditional branch since the instruction flow is changed unconditionally, that is, independent of the data that is processed. For example, if the following instruction, located at x507B, is executed, the PC is loaded with x5001. [-16pt] Question: What happens if all three bits [11:9] in the BR instruction are 0? §.§ Two methods of Loop Control We saw in Section 4.4 in our multiplication program that we repeatedly executed a sequence of instructions until the contents of a register was 0. We call that sequence a loop body, and each time the loop body is executed one iteration of the loop body. The BR instruction at the end of the sequence controls the number of times the loop body is executed. There are two common ways to control the number of iterations. Loop Control with a Counter Suppose we know that the 12 locations x3100 to x310B contain integers, and we wish to compute the sum of these 12 integers. A flowchart for an algorithm to solve the problem is shown in Figure 5.12. < g r a p h i c s > An algorithm for adding integers using a counter for loop control First, as in all algorithms, we must initialize our variables. That is,variables!initializing we must set up the initial values of the variables that the computer will use in executing the program that solves the problem. There",
    "399": "the loop body is executed one iteration of the loop body. The BR instruction at the end of the sequence controls the number of times the loop body is executed. There are two common ways to control the number of iterations. Loop Control with a Counter Suppose we know that the 12 locations x3100 to x310B contain integers, and we wish to compute the sum of these 12 integers. A flowchart for an algorithm to solve the problem is shown in Figure 5.12. < g r a p h i c s > An algorithm for adding integers using a counter for loop control First, as in all algorithms, we must initialize our variables. That is,variables!initializing we must set up the initial values of the variables that the computer will use in executing the program that solves the problem. There are three such variables: the address of the next integer to be added (assigned to R1), the running sum (assigned to R3), and the number of integers left to be added (assigned to R2). The three variables are initialized as follows: The address of the first integer to be added is put in R1. R3, which will keep track of the running sum, is initialized to 0. R2, which will keep track of the number of integers left to be added, is initialized to 12. Then the process of adding begins. The program repeats the process of loading into R4 one of the 12 integers, and adding it to R3. Each time we perform the ADD, we increment R1 so it will point to (i.e., contain the address of) the next number to be added and decrement R2 so we will know how many numbers still need to be added. When R2 becomes zero, the Z condition code is set, and we can detect that we are done. The 10-instruction program shown in Figure 5.13 accomplishes the task. 36pc A program that implements the algorithm of Figure 5.12 The details of the program execution are as follows: The program starts",
    "400": "the running sum, is initialized to 0. R2, which will keep track of the number of integers left to be added, is initialized to 12. Then the process of adding begins. The program repeats the process of loading into R4 one of the 12 integers, and adding it to R3. Each time we perform the ADD, we increment R1 so it will point to (i.e., contain the address of) the next number to be added and decrement R2 so we will know how many numbers still need to be added. When R2 becomes zero, the Z condition code is set, and we can detect that we are done. The 10-instruction program shown in Figure 5.13 accomplishes the task. 36pc A program that implements the algorithm of Figure 5.12 The details of the program execution are as follows: The program starts with PC = x3000. The first instruction (at location x3000) initializes R1 with the address x3100. (The incremented PC is x3001; the sign-extended PCoffset is x00FF.) The instruction at x3001 clears R3. R3 will keep track of the running sum, so it must start with the value 0. As we said previously, this is called initializing the SUM to zero. The instructions at x3002 and x3003 initialize R2 to 12, the number of integers to be added. R2 will keep track of how many numbers have already been added. This will be done (by the instruction in x3008) by decrementing R2 after each addition takes place. The instruction at x3004 is a conditional branch instruction. Note that bit [10] is a 1. That means that the Z condition code will be examined. If it is set, we know R2 must have just been decremented to 0. That means there are no more numbers to be added and we are done. If it is clear, we know we still have work to do and we continue with another iteration of the loop body. The instruction at x3005 loads the next integer into R4, and the instruction at x3006 adds it to",
    "401": "The instructions at x3002 and x3003 initialize R2 to 12, the number of integers to be added. R2 will keep track of how many numbers have already been added. This will be done (by the instruction in x3008) by decrementing R2 after each addition takes place. The instruction at x3004 is a conditional branch instruction. Note that bit [10] is a 1. That means that the Z condition code will be examined. If it is set, we know R2 must have just been decremented to 0. That means there are no more numbers to be added and we are done. If it is clear, we know we still have work to do and we continue with another iteration of the loop body. The instruction at x3005 loads the next integer into R4, and the instruction at x3006 adds it to R3. The instructions at x3007 and x3008 perform the necessary bookkeeping. The instruction at x3007 increments R1, so R1 will point to the next location in memory containing an integer to be added. The instruction at x3008 decrements R2, which is keeping track of the number of integers still to be added, sets the condition codes. The instruction at x3009 is an unconditional branch, since bits [11:9] are all 1. It loads the PC with x3004. It also does not affect the condition codes, so the next instruction to be executed (the conditional branch at x3004) will be based on the instruction executed at x3008. This is worth saying again. The conditional branch instruction at x3004 follows the instruction at x3009, which does not affect condition codes, which in turn follows the instruction at x3008. Thus, the conditional branch instruction at x3004 will be based on the condition codes set by the instruction at x3008. The instruction at x3008 sets the condition codes based on the value produced by decrementing R2. As long as there are still integers to be added, the ADD instruction at x3008 will produce a value greater than zero and therefore clear the Z condition code.",
    "402": "is an unconditional branch, since bits [11:9] are all 1. It loads the PC with x3004. It also does not affect the condition codes, so the next instruction to be executed (the conditional branch at x3004) will be based on the instruction executed at x3008. This is worth saying again. The conditional branch instruction at x3004 follows the instruction at x3009, which does not affect condition codes, which in turn follows the instruction at x3008. Thus, the conditional branch instruction at x3004 will be based on the condition codes set by the instruction at x3008. The instruction at x3008 sets the condition codes based on the value produced by decrementing R2. As long as there are still integers to be added, the ADD instruction at x3008 will produce a value greater than zero and therefore clear the Z condition code. The conditional branch instruction at x3004 examines the Z condition code. As long as Z is clear, the PC will not be affected, and the next iteration of the loop body will begin. That is, the next instruction cycle will start with an instruction fetch from x3005. The conditional branch instruction causes the execution sequence to follow: x3000, x3001, x3002, x3003, x3004, x3005, x3006, x3007, x3008, x3009, x3004, x3005, x3006, x3007, x3008, x3009, x3004, x3005, and so on . The loop body consists of the instructions at x3005 to x3009. When the value in R2 becomes 0, the PC is loaded with x300A, and the program continues at x300A with its next activity. You may have noticed that we can remove the branch instruction at x3004 if we replace the unconditional branch instruction at x3009 with a conditional branch that tests for not 0 (i.e., bits[11:9]=101), and branches to the instruction currently located in x3005. It is tempting to do that since it decreases the loop body by one instruction. BUT, we admonish you not to do that! The program as shown obeys the rules of structured programming that we will discuss in Chapter 6. The short cut does work",
    "403": "x3003, x3004, x3005, x3006, x3007, x3008, x3009, x3004, x3005, x3006, x3007, x3008, x3009, x3004, x3005, and so on . The loop body consists of the instructions at x3005 to x3009. When the value in R2 becomes 0, the PC is loaded with x300A, and the program continues at x300A with its next activity. You may have noticed that we can remove the branch instruction at x3004 if we replace the unconditional branch instruction at x3009 with a conditional branch that tests for not 0 (i.e., bits[11:9]=101), and branches to the instruction currently located in x3005. It is tempting to do that since it decreases the loop body by one instruction. BUT, we admonish you not to do that! The program as shown obeys the rules of structured programming that we will discuss in Chapter 6. The short cut does work for this simple example, but it breaks the methodology of structured programming. You do not want to get in the habit of taking such short cuts, since for larger programs it is a clear invitation to disaster. More on this in Chapter 6. Finally, it is worth noting that we could have written a program to add these 12 integers without any control instructions. We still would have needed the LEA instruction in x3000 to initialize R1. We would not have needed the instruction at x3001 to initialize the running sum, nor the instructions at x3002, and x3003 to initialize the number of integers left to be added. We could have loaded the contents of x3100 directly into R3, and then repeatedly (by incrementing R1, loaded subsequent integers into R4, and adding R4 to the running sum in R3 11 more times! After the addition of the twelfth integer, we would go on to the next task, as does the example of Figure 5.13 with the branch instruction in x3004. Unfortunately, instead of a 10-instruction program, we would have a 35-instruction program. Moreover, if we had wished to add 100 integers without any control instructions instead of 12, we would",
    "404": "without any control instructions. We still would have needed the LEA instruction in x3000 to initialize R1. We would not have needed the instruction at x3001 to initialize the running sum, nor the instructions at x3002, and x3003 to initialize the number of integers left to be added. We could have loaded the contents of x3100 directly into R3, and then repeatedly (by incrementing R1, loaded subsequent integers into R4, and adding R4 to the running sum in R3 11 more times! After the addition of the twelfth integer, we would go on to the next task, as does the example of Figure 5.13 with the branch instruction in x3004. Unfortunately, instead of a 10-instruction program, we would have a 35-instruction program. Moreover, if we had wished to add 100 integers without any control instructions instead of 12, we would have had a 299 instruction program instead of 10. The control instructions in the example of Figure 5.13 permit the reuse of sequences of code (the loop body) by breaking the sequential instruction execution flow. Loop Control with a Sentinel The example above controls the number of times the loop body executes by means of a counter. [-10pt] We knew we wanted to execute the loop 12 times, so we simply set a counter to 12, and then after each execution of the loop, we decremented the counter and checked to see if it was zero. If it was not zero, we set the PC to the start of the loop and continued with another iteration.loop!counter-controlled A second method for controlling the number of executions of a loop is to use a sentinel. This method is particularly effective if we do not know loop!sentinel-controlled ahead of time how many iterations we will want to perform. Each iteration is usually based on processing a value. We append to our sequence of values to be processed a value that we know ahead of time can never occur (i.e., the sentinel). For example, if we are adding a sequence of numbers, a sentinel",
    "405": "we wanted to execute the loop 12 times, so we simply set a counter to 12, and then after each execution of the loop, we decremented the counter and checked to see if it was zero. If it was not zero, we set the PC to the start of the loop and continued with another iteration.loop!counter-controlled A second method for controlling the number of executions of a loop is to use a sentinel. This method is particularly effective if we do not know loop!sentinel-controlled ahead of time how many iterations we will want to perform. Each iteration is usually based on processing a value. We append to our sequence of values to be processed a value that we know ahead of time can never occur (i.e., the sentinel). For example, if we are adding a sequence of numbers, a sentinel could be a letter A or a *, that is, something that is not a number. Our loop test is simply a test for the occurrence of the sentinel. When we find it, we know we are done. Suppose we know the values stored in locations x3100 to x310B are all positive. Then we could use any negative number as a sentinel. Let's say the sentinel stored at memory address x310C is -1. The resulting flowchart for this solution is shown in Figure 5.14 and the resulting program is shown in Figure 5.15. < g r a p h i c s > An algorithm for adding integers using a sentinel for loop control. As before, the instruction at x3000 loads R1 with the address of the first value to be added, and the instruction at x3001 initializes R3 (which keeps track of the sum) to 0. At x3002, we load the contents of the next memory location into R4. If the sentinel is loaded, the N condition code is set. The conditional branch at x3003 examines the N condition code. If N=1, PC is loaded with x3008 and onto the next task. If N=0, R4 must contain a valid",
    "406": "a sentinel. Let's say the sentinel stored at memory address x310C is -1. The resulting flowchart for this solution is shown in Figure 5.14 and the resulting program is shown in Figure 5.15. < g r a p h i c s > An algorithm for adding integers using a sentinel for loop control. As before, the instruction at x3000 loads R1 with the address of the first value to be added, and the instruction at x3001 initializes R3 (which keeps track of the sum) to 0. At x3002, we load the contents of the next memory location into R4. If the sentinel is loaded, the N condition code is set. The conditional branch at x3003 examines the N condition code. If N=1, PC is loaded with x3008 and onto the next task. If N=0, R4 must contain a valid number to be added. In this case, the number is added to R3 (x3004), R1 is incremented to point to the next memory location (x3005), R4 is loaded with the contents of the next memory location (x3006), and the PC is loaded with x3003 to begin the next iteration (x3007). 36pc A program that implements the algorithm of Figure 5.14 §.§ The JMP Instruction The conditional branch instruction, for all its capability, does have one unfortunate limitation. The next instruction executed must be within the range of addresses that can be computed by adding the incremented PC to the sign-extended offset obtained from bits [8:0] of the instruction. Since bits [8:0] specify a 2's complement integer, the next instruction executed after the conditional branch can be at most +256 or -255 locations from the branch instruction itself. What if we would like to execute next an instruction that is 2,000 locations from the current instruction. We cannot fit the value 2,000 into the 9-bit field; ergo, the conditional branch instruction does not work. The LC-3 ISA does provide an instruction JMP (opcode = 1100) that can do the job. The JMP instruction loads the PC with the contents of the",
    "407": "§.§ The JMP Instruction The conditional branch instruction, for all its capability, does have one unfortunate limitation. The next instruction executed must be within the range of addresses that can be computed by adding the incremented PC to the sign-extended offset obtained from bits [8:0] of the instruction. Since bits [8:0] specify a 2's complement integer, the next instruction executed after the conditional branch can be at most +256 or -255 locations from the branch instruction itself. What if we would like to execute next an instruction that is 2,000 locations from the current instruction. We cannot fit the value 2,000 into the 9-bit field; ergo, the conditional branch instruction does not work. The LC-3 ISA does provide an instruction JMP (opcode = 1100) that can do the job. The JMP instruction loads the PC with the contents of the register specified by bits [8:6] of the instruction. If the following JMP instruction is located at address x4000, R2 contains the value x6600, and the PC contains x4000, then the instruction at x4000 (the JMP instruction) will be executed, followed by the instruction located at x6600. Since registers contain 16 bits (the full address space of memory), the JMP instruction has no limitation on where the next instruction to be executed must reside. §.§ The TRAP Instruction We will discuss the details of how the TRAP instruction works in Chapter 9. However, because it will be useful long before that to get data into and out of the computer, we discuss here the TRAP instruction. The TRAP (opcode=1111) instruction changes the PC to a memory address that is part of the operating system so that the operating system will perform some task on behalf of the program that is executing. In the language of operating system jargon, we say the TRAP instruction invokes an operating system service call. Bits [7:0] of the TRAP instruction form the trapvector, an 8-bit code that identifies the service call that the program wishes the operating system to perform on its behalf. Table A.2 contains",
    "408": "has no limitation on where the next instruction to be executed must reside. §.§ The TRAP Instruction We will discuss the details of how the TRAP instruction works in Chapter 9. However, because it will be useful long before that to get data into and out of the computer, we discuss here the TRAP instruction. The TRAP (opcode=1111) instruction changes the PC to a memory address that is part of the operating system so that the operating system will perform some task on behalf of the program that is executing. In the language of operating system jargon, we say the TRAP instruction invokes an operating system service call. Bits [7:0] of the TRAP instruction form the trapvector, an 8-bit code that identifies the service call that the program wishes the operating system to perform on its behalf. Table A.2 contains the trapvectors for all the service calls that we will use with the LC-3 in this book. Once the operating system is finished performing the service call, the program counter is set to the address of the instruction following the TRAP instruction, and the program continues. In this way, a program can, during its execution, request services from the operating system and continue processing after each such service is performed. The services we will require for now are [fontsize=914] * Input a character from the keyboard (trapvector = x23). * Output a character to the monitor (trapvector = x21). * Halt the program (trapvector = x25). § ANOTHER EXAMPLE: COUNTING OCCURRENCES OF A CHARACTER We will finish our introduction to the ISA of the LC-3 with another example program. Suppose we would like to be able to input a character from the keyboard, then count the number of occurrences of that character in a file, and finally display that count on the monitor. We will simplify the problem by assuming that the number of occurrences of any character that we would be interested in is small enough that it can be expressed with a single decimal digit. That is, there",
    "409": "system and continue processing after each such service is performed. The services we will require for now are [fontsize=914] * Input a character from the keyboard (trapvector = x23). * Output a character to the monitor (trapvector = x21). * Halt the program (trapvector = x25). § ANOTHER EXAMPLE: COUNTING OCCURRENCES OF A CHARACTER We will finish our introduction to the ISA of the LC-3 with another example program. Suppose we would like to be able to input a character from the keyboard, then count the number of occurrences of that character in a file, and finally display that count on the monitor. We will simplify the problem by assuming that the number of occurrences of any character that we would be interested in is small enough that it can be expressed with a single decimal digit. That is, there will be at most nine occurrences. This simplification allows us to not have to worry about complex conversion routines between the binary count and the ASCII display on the monitor—a subject we will get into in Chapter 10, but not today. Figure 5.16 is a flowchart of the algorithm that solves this problem. Note that each step is expressed both in English and also (in parentheses) in terms of an LC-3 implementation. < g r a p h i c s > An algorithm to count occurrences of a character The first step is (as always) to initialize all the variables. This means providing starting values (called initial values) for R0, R1, R2, and R3, the four registers the computer will use to execute the program that will solve the problem. R2 will keep track of the number of occurrences; in Figure 5.16, it is referred to as Count. It is initialized to zero. R3 will point to the next character in the file that is being examined. We refer to it as a pointer since it points to (i.e., contains the address of) the location where the next character of the file that we wish to examine resides. The",
    "410": "in English and also (in parentheses) in terms of an LC-3 implementation. < g r a p h i c s > An algorithm to count occurrences of a character The first step is (as always) to initialize all the variables. This means providing starting values (called initial values) for R0, R1, R2, and R3, the four registers the computer will use to execute the program that will solve the problem. R2 will keep track of the number of occurrences; in Figure 5.16, it is referred to as Count. It is initialized to zero. R3 will point to the next character in the file that is being examined. We refer to it as a pointer since it points to (i.e., contains the address of) the location where the next character of the file that we wish to examine resides. The pointer is initialized with the address of the first character in the file. R0 will hold the character that is being counted; we will input that character from the keyboard and put it in R0. R1 will hold, in turn, each character that we get from the file being examined. We should also note that there is no requirement that the file we are examining be close to or far away from the program we are developing. For example, it is perfectly reasonable for the program we are developing to start at x3000, and the file we are examining to start at x9000. If that were the case, in the initialization process, R3 would be initialized to x9000. The next step is to count the number of occurrences of the input character. This is done by processing, in turn, each character in the file being examined, until the file is exhausted. Processing each character requires one iteration of a loop. Recall from Section 5.4.3 that there are two common methods for keeping track of iterations of a loop. We will use the sentinel method, using the ASCII code for EOT (End of Transmission) (00000100) as the sentinel. A table of",
    "411": "the file we are examining be close to or far away from the program we are developing. For example, it is perfectly reasonable for the program we are developing to start at x3000, and the file we are examining to start at x9000. If that were the case, in the initialization process, R3 would be initialized to x9000. The next step is to count the number of occurrences of the input character. This is done by processing, in turn, each character in the file being examined, until the file is exhausted. Processing each character requires one iteration of a loop. Recall from Section 5.4.3 that there are two common methods for keeping track of iterations of a loop. We will use the sentinel method, using the ASCII code for EOT (End of Transmission) (00000100) as the sentinel. A table of ASCII codes is in Appendix E. In each iteration of the loop, the contents of R1 are first compared to the ASCII code for EOT. If they are equal, the loop is exited, and the program moves on to the final step, displaying on the screen the number of occurrences. If not, there is work to do. R1 (the current character under examination) is compared to R0 (the character input from the keyboard). If they match, R2 is incremented. In either case, we move on to getting the next character. The pointer R3 is incremented, the next character is loaded into R1, and the program returns to the test that checks for the sentinel at the end of the file. When the end of the file is reached, all the characters have been examined, and the count is contained as a binary number in R2. In order to display the count on the monitor, it is first converted to an ASCII code. Since we have assumed the count is less than 10, we can do this by putting a leading 0011 in front of the 4-bit binary representation of the count. Note in Figure E.2 the relationship between the binary",
    "412": "character under examination) is compared to R0 (the character input from the keyboard). If they match, R2 is incremented. In either case, we move on to getting the next character. The pointer R3 is incremented, the next character is loaded into R1, and the program returns to the test that checks for the sentinel at the end of the file. When the end of the file is reached, all the characters have been examined, and the count is contained as a binary number in R2. In order to display the count on the monitor, it is first converted to an ASCII code. Since we have assumed the count is less than 10, we can do this by putting a leading 0011 in front of the 4-bit binary representation of the count. Note in Figure E.2 the relationship between the binary value of each decimal digit between 0 and 9 and its corresponding ASCII code. Finally, the count is output to the monitor, and the program terminates. Figure 5.17 is a machine language program that implements the flowchart of Figure 5.16. 36pc A machine language program that implements the algorithm of Figure 5.16 First the initialization steps. The instruction at x3000 clears R2 by ANDing it with x0000. The instruction at x3001 loads the starting address of the file to be examined into R3. Again, we note that this file can be anywhere in memory. Prior to starting execution at x3000, some sequence of instructions must have stored the first address of this file in x3012. Location x3002 contains the TRAP instruction, which requests the operating system to perform a service call on behalf of this program. The function requested, as identified by the 8-bit trapvector 00100011 (i.e., x23), is to load into R0 the ASCII code of the next character typed on the keyboard. Table A.2 lists trapvectors for all operating system service calls that can be performed on behalf of a user program. The instruction at x3003 loads the character pointed to by R3 into R1. Then the process",
    "413": "clears R2 by ANDing it with x0000. The instruction at x3001 loads the starting address of the file to be examined into R3. Again, we note that this file can be anywhere in memory. Prior to starting execution at x3000, some sequence of instructions must have stored the first address of this file in x3012. Location x3002 contains the TRAP instruction, which requests the operating system to perform a service call on behalf of this program. The function requested, as identified by the 8-bit trapvector 00100011 (i.e., x23), is to load into R0 the ASCII code of the next character typed on the keyboard. Table A.2 lists trapvectors for all operating system service calls that can be performed on behalf of a user program. The instruction at x3003 loads the character pointed to by R3 into R1. Then the process of examining characters begins. We start (x3004) by subtracting 4 (the ASCII code for EOT) from R1, and storing it in R4. If the result is zero, the end of the file has been reached, and it is time to output the count. The instruction at x3005 conditionally branches to x300E, where the process of outputting the count begins. If R4 is not equal to zero, the character in R1 is legitimate and must be examined. The sequence of instructions at locations x3006, x3007, and x3008 determine if the contents of R1 and R0 are identical. Taken together, the three instructions compute R0 - R1 This produces all zeros only if the bit patterns of R1 and R0 are identical. If the bit patterns are not identical, the conditional branch at x3009 branches to x300B, that is, it skips the instruction at x300A, which increments the counter (R2). The instruction at x300B increments R3, so it will point to the next character in the file being examined, the instruction at x300C loads that character into R1, and the instruction at x300D unconditionally takes us back to x3004 to start processing that character. When the sentinel (EOT) is finally detected, the",
    "414": "R4 is not equal to zero, the character in R1 is legitimate and must be examined. The sequence of instructions at locations x3006, x3007, and x3008 determine if the contents of R1 and R0 are identical. Taken together, the three instructions compute R0 - R1 This produces all zeros only if the bit patterns of R1 and R0 are identical. If the bit patterns are not identical, the conditional branch at x3009 branches to x300B, that is, it skips the instruction at x300A, which increments the counter (R2). The instruction at x300B increments R3, so it will point to the next character in the file being examined, the instruction at x300C loads that character into R1, and the instruction at x300D unconditionally takes us back to x3004 to start processing that character. When the sentinel (EOT) is finally detected, the process of outputting the count begins (at x300E). The instruction at x300E loads 00110000 into R0, and the instruction at x300F adds the count to R0. This converts the binary representation of the count (in R2) to the ASCII representation of the count (in R0). The instruction at x3010 invokes a TRAP to the operating system to output the contents of R0 to the monitor. When that is done and the program resumes execution, the instruction at x3011 invokes a TRAP instruction to terminate the program. Question: Can you improve the execution of the above program? Hint: How many times are the instructions at x3006 and x3007 executed. What small change will decrease the total number of instructions that have to be executed. § THE DATA PATH REVISITED Before we leave Chapter 5, let us revisit the data path diagram that we first encountered in Chapter 3 (Figure 3.33). Many of the structures we have seen earlier in this chapter in Figures 5.4, 5.5, 5.6, 5.7, 5.8, 5.9, and 5.11. We reproduce the data path diagram as Figure 5.18. Note at the outset that there are two kinds of arrows in the data path, those with arrowheads filled in, and",
    "415": "of R0 to the monitor. When that is done and the program resumes execution, the instruction at x3011 invokes a TRAP instruction to terminate the program. Question: Can you improve the execution of the above program? Hint: How many times are the instructions at x3006 and x3007 executed. What small change will decrease the total number of instructions that have to be executed. § THE DATA PATH REVISITED Before we leave Chapter 5, let us revisit the data path diagram that we first encountered in Chapter 3 (Figure 3.33). Many of the structures we have seen earlier in this chapter in Figures 5.4, 5.5, 5.6, 5.7, 5.8, 5.9, and 5.11. We reproduce the data path diagram as Figure 5.18. Note at the outset that there are two kinds of arrows in the data path, those with arrowheads filled in, and those with arrowheads not filled in. Filled-in arrowheads designate information that is processed. Unfilled-in arrowheads designate control signals. Control signals emanate from the block labeled “Control.” The connections from Control to most control signals have been left off Figure 5.18 to reduce unnecessary clutter in the diagram. 36pc < g r a p h i c s > The data path of the LC-3 §.§ Basic Components of the Data Path §.§.§ The Global Bus The most obvious item on the data path diagram is the heavy black structure with arrowheads at both ends. This represents the data path's global bus. The LC-3 global bus consists of 16 wires and associated electronics. It allows one structure to transfer up to 16 bits of information to another structure by making the necessary electronic connections on the bus. Exactly one value can be transferred on the bus at one time. Note that each structure that supplies values to the bus has a triangle just behind its input arrow to the bus. This triangle (called a tri-state device) allows the computer's control logic to enable exactly one supplier to provide information to the bus at any one time. The structure wishing to obtain",
    "416": "path of the LC-3 §.§ Basic Components of the Data Path §.§.§ The Global Bus The most obvious item on the data path diagram is the heavy black structure with arrowheads at both ends. This represents the data path's global bus. The LC-3 global bus consists of 16 wires and associated electronics. It allows one structure to transfer up to 16 bits of information to another structure by making the necessary electronic connections on the bus. Exactly one value can be transferred on the bus at one time. Note that each structure that supplies values to the bus has a triangle just behind its input arrow to the bus. This triangle (called a tri-state device) allows the computer's control logic to enable exactly one supplier to provide information to the bus at any one time. The structure wishing to obtain the value being supplied can do so by asserting its LD.x (load enable) signal (recall our discussion of gated latches in Section 3.4.2). Not all computers have a single global bus. The pros and cons of a single global bus is yet another topic that will have to wait for later in your education. §.§.§ Memory One of the most important parts of any computer is the memory that contains both instructions and data. Memory is accessed by loading the memory address register (MAR) with the address of the location to be accessed. To perform a load, control signals then read the contents of that memory location, and the result of that read is delivered by the memory to the memory data register (MDR). On the other hand, to perform a store, the data to be stored is loaded into the MDR. Then the control signals assert a write enable (WE) signal in order to store the value contained in MDR into the memory location specified by MAR. §.§.§ The ALU and the Register File The ALU is the processing element. It has two inputs, source 1 from a register and source 2 from either a register or the sign-extended",
    "417": "important parts of any computer is the memory that contains both instructions and data. Memory is accessed by loading the memory address register (MAR) with the address of the location to be accessed. To perform a load, control signals then read the contents of that memory location, and the result of that read is delivered by the memory to the memory data register (MDR). On the other hand, to perform a store, the data to be stored is loaded into the MDR. Then the control signals assert a write enable (WE) signal in order to store the value contained in MDR into the memory location specified by MAR. §.§.§ The ALU and the Register File The ALU is the processing element. It has two inputs, source 1 from a register and source 2 from either a register or the sign-extended immediate value provided by the instruction. The registers (R0 through R7) can provide two values, source 1, which is controlled by the 3-bit register number SR1, and source 2, which is controlled by the 3-bit register number SR2. SR1 and SR2 are fields in the LC-3 operate instructions. The selection of a second register operand or a sign-extended immediate operand is determined by bit [5] of the LC-3 instruction. Note the mux that provides source 2 to the ALU. The select line of that mux is bit [5] of the LC-3 operate instruction. The results of an ALU operation are (a) a result that is stored in one of the registers, and (b) the three single-bit condition codes. Note that the ALU can supply 16 bits to the bus, and that value can then be written into the register specified by the 3-bit register number DR. Also, note that the 16 bits supplied to the bus are also input to logic that determines whether that 16-bit value is negative, zero, or positive. The three one-bit condition code registers N, Z, and P are set accordingly. §.§.§ The PC and the PCMUX At the start of each instruction cycle, the PC",
    "418": "is determined by bit [5] of the LC-3 instruction. Note the mux that provides source 2 to the ALU. The select line of that mux is bit [5] of the LC-3 operate instruction. The results of an ALU operation are (a) a result that is stored in one of the registers, and (b) the three single-bit condition codes. Note that the ALU can supply 16 bits to the bus, and that value can then be written into the register specified by the 3-bit register number DR. Also, note that the 16 bits supplied to the bus are also input to logic that determines whether that 16-bit value is negative, zero, or positive. The three one-bit condition code registers N, Z, and P are set accordingly. §.§.§ The PC and the PCMUX At the start of each instruction cycle, the PC supplies to the MAR over the global bus the address of the instruction to be fetched. In addition, the PC, in turn, is supplied via the three-to-one PCMUX. During the FETCH phase of the instruction cycle, the PC is incremented and written into the PC. That is shown as the rightmost input to the PCMUX. If the current instruction is a control instruction, then the relevant source of the PCMUX depends on which control instruction is currently being processed. If the current instruction is a conditional branch and the branch is taken, then the PC is loaded with the incremented PC + PCoffset (the 16-bit value obtained by sign-extending IR[8:0]). Note that this addition takes place in the special adder and not in the ALU. The output of the adder is the middle input to PCMUX. The third input to PCMUX is obtained from the global bus. Its use will become clear after we discuss other control instructions in Chapters 9. §.§.§ The MARMUX As you know, memory is accessed by supplying the address to the MAR. The MARMUX controls which of two sources will supply the MAR with the appropriate address during the execution of a load, a store,",
    "419": "a control instruction, then the relevant source of the PCMUX depends on which control instruction is currently being processed. If the current instruction is a conditional branch and the branch is taken, then the PC is loaded with the incremented PC + PCoffset (the 16-bit value obtained by sign-extending IR[8:0]). Note that this addition takes place in the special adder and not in the ALU. The output of the adder is the middle input to PCMUX. The third input to PCMUX is obtained from the global bus. Its use will become clear after we discuss other control instructions in Chapters 9. §.§.§ The MARMUX As you know, memory is accessed by supplying the address to the MAR. The MARMUX controls which of two sources will supply the MAR with the appropriate address during the execution of a load, a store, or a TRAP instruction. The right input to the MARMUX is obtained by adding either the incremented PC or a base register to zero or a literal value supplied by the IR. Whether the PC or a base register and what literal value depends on which opcode is being processed. The control signal ADDR1MUX specifies the PC or base register. The control signal ADDR2MUX specifies which of four values is to be added. The left input to MARMUX provides the zero-extended trapvector, which is needed to invoke service calls, and will be discussed in detail in Chapter 9. §.§ The Instruction Cycle Specific to the LC-3 We complete our tour of the LC-3 data path by following the flow through an instruction cycle. Suppose the content of the PC is x3456 and the content of location x3456 is Suppose the LC-3 has just completed processing the instruction at x3455, which happened to be an ADD instruction. §.§.§ FETCH As you know, the instruction cycle starts with the FETCH phase. That is, the instruction is obtained by accessing memory with the address contained in the PC. In the first cycle, the contents of the PC are loaded via the global bus",
    "420": "The control signal ADDR2MUX specifies which of four values is to be added. The left input to MARMUX provides the zero-extended trapvector, which is needed to invoke service calls, and will be discussed in detail in Chapter 9. §.§ The Instruction Cycle Specific to the LC-3 We complete our tour of the LC-3 data path by following the flow through an instruction cycle. Suppose the content of the PC is x3456 and the content of location x3456 is Suppose the LC-3 has just completed processing the instruction at x3455, which happened to be an ADD instruction. §.§.§ FETCH As you know, the instruction cycle starts with the FETCH phase. That is, the instruction is obtained by accessing memory with the address contained in the PC. In the first cycle, the contents of the PC are loaded via the global bus into the MAR, and the PC is incremented and loaded into the PC. At the end of this cycle, the PC contains x3457. In the next cycle (if memory can provide information in one cycle), the memory is read, and the instruction 0110011010000100 is loaded into the MDR. In the next cycle, the contents of the MDR are loaded into the instruction register (IR), completing the FETCH phase. §.§.§ DECODE In the next cycle, the contents of the IR are decoded, resulting in the control logic providing the correct control signals (unfilled arrowheads) to control the processing of the rest of this instruction. The opcode is 0110, identifying the LDR instruction. This means that the Base+offset addressing mode is to be used to determine the address of data to be loaded into the destination register R3. §.§.§ EVALUATE ADDRESS In the next cycle, the contents of R2 (the base register) and the sign-extended bits [5:0] of the IR are added and supplied via the MARMUX to the MAR. The SR1 field specifies 010, the register to be read to obtain the base address. ADDR1MUX selects SR1OUT, and ADDR2MUX selects the second from the right source. §.§.§ OPERAND FETCH In the",
    "421": "the instruction register (IR), completing the FETCH phase. §.§.§ DECODE In the next cycle, the contents of the IR are decoded, resulting in the control logic providing the correct control signals (unfilled arrowheads) to control the processing of the rest of this instruction. The opcode is 0110, identifying the LDR instruction. This means that the Base+offset addressing mode is to be used to determine the address of data to be loaded into the destination register R3. §.§.§ EVALUATE ADDRESS In the next cycle, the contents of R2 (the base register) and the sign-extended bits [5:0] of the IR are added and supplied via the MARMUX to the MAR. The SR1 field specifies 010, the register to be read to obtain the base address. ADDR1MUX selects SR1OUT, and ADDR2MUX selects the second from the right source. §.§.§ OPERAND FETCH In the next cycle (or more than one, if memory access takes more than one cycle), the data at that address is loaded into the MDR. §.§.§ EXECUTE The LDR instruction does not require an EXECUTE phase, so this phase takes zero cycles. §.§.§ STORE RESULT In the last cycle, the contents of the MDR are gated onto the global bus, from which they are loaded into R3, and supplied to the condition code logic in order to set the NZP condition codes. 5.1 Given instructions ADD, JMP, LEA, and NOT, identify whether the instructions are operate instructions, data movement instructions, or control instructions. For each instruction, list the addressing modes that can be used with the instruction. 5.2 A memory's addressibility is 64 bits. What does that tell you about the size of the MAR and MDR? 5.3 There are two common ways to terminate a loop. One way uses a counter to keep track of the number of iterations. The other way uses an element called a ____. What is the distinguishing characteristic of this element? 5.4 Say we have a memory consisting of 256 locations, and each location contains 16 bits. a. How many bits are required for the",
    "422": "which they are loaded into R3, and supplied to the condition code logic in order to set the NZP condition codes. 5.1 Given instructions ADD, JMP, LEA, and NOT, identify whether the instructions are operate instructions, data movement instructions, or control instructions. For each instruction, list the addressing modes that can be used with the instruction. 5.2 A memory's addressibility is 64 bits. What does that tell you about the size of the MAR and MDR? 5.3 There are two common ways to terminate a loop. One way uses a counter to keep track of the number of iterations. The other way uses an element called a ____. What is the distinguishing characteristic of this element? 5.4 Say we have a memory consisting of 256 locations, and each location contains 16 bits. a. How many bits are required for the address? b. If we use the PC-relative addressing mode, and want to allow control transfer between instructions 20 locations away, how many bits of a branch instruction are needed to specify the PC-relative offset? c. If a control instruction is in location 3, what is the PC-relative offset of address 10. Assume that the control transfer instructions work the same way as in the LC-3. 5.5 a. What is an addressing mode? b. Name three places an instruction's operands might be located. c. List the five addressing modes of the LC-3, and for each one state where the operand is located (from part b). d. What addressing mode is used by the ADD instruction shown in Section 5.1.2? by 0pt plus 1pt 5.6 Recall the machine busy example from Section 2.7.1. Assuming the BUSYNESS bit vector is stored in R2, we can use the LC-3 instruction 0101 011 010 1 00001 (AND R3, R2, #1) to determine whether machine 0 is busy or not. If the result of this instruction is 0, then machine 0 is busy. a. Write an LC-3 instruction that determines whether machine 2 is busy. b. Write an LC-3 instruction that determines whether both machines 2",
    "423": "way as in the LC-3. 5.5 a. What is an addressing mode? b. Name three places an instruction's operands might be located. c. List the five addressing modes of the LC-3, and for each one state where the operand is located (from part b). d. What addressing mode is used by the ADD instruction shown in Section 5.1.2? by 0pt plus 1pt 5.6 Recall the machine busy example from Section 2.7.1. Assuming the BUSYNESS bit vector is stored in R2, we can use the LC-3 instruction 0101 011 010 1 00001 (AND R3, R2, #1) to determine whether machine 0 is busy or not. If the result of this instruction is 0, then machine 0 is busy. a. Write an LC-3 instruction that determines whether machine 2 is busy. b. Write an LC-3 instruction that determines whether both machines 2 and 3 are busy. c. Write an LC-3 instruction that indicates none of the machines are busy. d. Can you write an LC-3 instruction that determines whether machine 6 is busy? Is there a problem here? 5.7 What is the largest positive number we can represent literally (i.e., as an immediate value) within an LC-3 ADD instruction? 5.8 We want to increase the number of registers that we can specify in the LC-3 ADD instruction to 32. Do you see any problem with that? Explain. 5.9 We would like to have an instruction that does nothing. Many ISAs actually have an opcode devoted to doing nothing. It is usually called NOP, for NO OPERATION. The instruction is fetched, decoded, and executed. The execution phase is to do nothing! Which of the following three instructions could be used for NOP and have the program still work correctly? a. 0001 001 001 1 00000 b. 0000 111 000000001 c. 0000 000 000000000 What does the ADD instruction do that the others do not do? 5.10 What is the difference between the following LC-3 instructions A and B? How are they similar? How are they different? A: 0000111101010101 B: 0100111101010101 5.11 We wish",
    "424": "to increase the number of registers that we can specify in the LC-3 ADD instruction to 32. Do you see any problem with that? Explain. 5.9 We would like to have an instruction that does nothing. Many ISAs actually have an opcode devoted to doing nothing. It is usually called NOP, for NO OPERATION. The instruction is fetched, decoded, and executed. The execution phase is to do nothing! Which of the following three instructions could be used for NOP and have the program still work correctly? a. 0001 001 001 1 00000 b. 0000 111 000000001 c. 0000 000 000000000 What does the ADD instruction do that the others do not do? 5.10 What is the difference between the following LC-3 instructions A and B? How are they similar? How are they different? A: 0000111101010101 B: 0100111101010101 5.11 We wish to execute a single LC-3 instruction that will subtract the decimal number 20 from register 1 and put the result into register 2. Can we do it? If yes, do it. If not, explain why not. 5.12 After executing the following LC-3 instruction: ADD R2, R0, R1, we notice that R0[15] equals R1[15], but is different from R2[15]. We are told that R0 and R1 contain UNSIGNED integers (that is, nonnegative integers between 0 and 65,535). Under what conditions can we trust the result in R2? 5.13 a. How might one use a single LC-3 instruction to move the value in R2 into R3? b. The LC-3 has no subtract instruction. How could one perform the following operation using only three LC-3 instructions: R1 ← R2-R3 c. Using only one LC-3 instruction and without changing the contents of any register, how might one set the condition codes based on the value that resides in R1? d. Is there a sequence of LC-3 instructions that will cause the condition codes at the end of the sequence to be N=1, Z=1, and P=0? Explain. e. Write an LC-3 instruction that clears the contents of R2. 5.14 The LC-3 does not have an",
    "425": "told that R0 and R1 contain UNSIGNED integers (that is, nonnegative integers between 0 and 65,535). Under what conditions can we trust the result in R2? 5.13 a. How might one use a single LC-3 instruction to move the value in R2 into R3? b. The LC-3 has no subtract instruction. How could one perform the following operation using only three LC-3 instructions: R1 ← R2-R3 c. Using only one LC-3 instruction and without changing the contents of any register, how might one set the condition codes based on the value that resides in R1? d. Is there a sequence of LC-3 instructions that will cause the condition codes at the end of the sequence to be N=1, Z=1, and P=0? Explain. e. Write an LC-3 instruction that clears the contents of R2. 5.14 The LC-3 does not have an opcode for the logical function OR. That is, there is no instruction in the LC-3 ISA that performs the OR operation. However, we can write a sequence of instructions to implement the OR operation. The four instruction sequence below performs the OR of the contents of register 1 and register 2 and puts the result in register 3. Fill in the two missing instructions so that the four instruction sequence will do the job. [fontsize=914] (1): 1001 100 001 111111 (2): (3): 0101 110 100 000 101 (4): 5.15 State the contents of R1, R2, R3, and R4 after the program starting at location x3100 halts. 913ptAddress0pt10.12pt Data 0011 0001 0000 0000 1110 001 0001000000pt10.1pt 0011 0001 0000 0001 0010 010 000100000 0011 0001 0000 0010 1010 011 000100000 0011 0001 0000 0011 0110 100 010 000001 0011 0001 0000 0100 1111 0000 0010 0101 : : : : 0011 0001 0010 0010 0100 0101 0110 0110 0011 0001 0010 0011 0100 0101 0110 0111 : : : : 0100 0101 0110 0111 1010 1011 1100 1101 0100 0101 0110 1000 1111 1110 1101 0011 5.16 Which LC-3 addressing mode makes the most sense to use under the following conditions.",
    "426": "the two missing instructions so that the four instruction sequence will do the job. [fontsize=914] (1): 1001 100 001 111111 (2): (3): 0101 110 100 000 101 (4): 5.15 State the contents of R1, R2, R3, and R4 after the program starting at location x3100 halts. 913ptAddress0pt10.12pt Data 0011 0001 0000 0000 1110 001 0001000000pt10.1pt 0011 0001 0000 0001 0010 010 000100000 0011 0001 0000 0010 1010 011 000100000 0011 0001 0000 0011 0110 100 010 000001 0011 0001 0000 0100 1111 0000 0010 0101 : : : : 0011 0001 0010 0010 0100 0101 0110 0110 0011 0001 0010 0011 0100 0101 0110 0111 : : : : 0100 0101 0110 0111 1010 1011 1100 1101 0100 0101 0110 1000 1111 1110 1101 0011 5.16 Which LC-3 addressing mode makes the most sense to use under the following conditions. (There may be more than one correct answer to each of these; therefore, justify your answers with some explanation.) a. You want to load one value from an address which is less than ±2^8 locations away. b. You want to load one value from an address which is more than 2^8 locations away. c. You want to load an array of sequential addresses. 5.17 How many times does the LC-3 make a read or write request to memory during the processing of the LD instruction? How many times during the processing of the LDI instruction? How many times during the processing of the LEA instruction? Processing includes all phases of the instruction cycle. 5.18 The program counter contains the address of an LDR instruction. In order for the LC-3 to process that instruction, how many memory accesses must be made? Repeat this task for STI and TRAP. 5.19 The LC-3 Instruction Register (IR) is made up of 16 bits, of which the least significant nine bits [8:0] represent the PC-relative offset for the LD instruction. If we change the ISA so that bits [6:0] represent the PC-relative offset, what is the new range of addresses we can load data from",
    "427": "of sequential addresses. 5.17 How many times does the LC-3 make a read or write request to memory during the processing of the LD instruction? How many times during the processing of the LDI instruction? How many times during the processing of the LEA instruction? Processing includes all phases of the instruction cycle. 5.18 The program counter contains the address of an LDR instruction. In order for the LC-3 to process that instruction, how many memory accesses must be made? Repeat this task for STI and TRAP. 5.19 The LC-3 Instruction Register (IR) is made up of 16 bits, of which the least significant nine bits [8:0] represent the PC-relative offset for the LD instruction. If we change the ISA so that bits [6:0] represent the PC-relative offset, what is the new range of addresses we can load data from using the LD instruction? 5.20 If we made the LC-3 ISA such that we allow the LD instruction to load data only ±32 locations away from the incremented PC value, how many bits would be required for the PC-relative offset in the LD instruction? 5.21 What is the maximum number of TRAP service routines that the LC-3 ISA can support? Explain. 5.22 The PC contains x3010. The following memory locations contain values as shown: [fontsize=914] x3050: x70A4 x70A2: x70A3 x70A3: xFFFF x70A4: x123B The following three LC-3 instructions are then executed, causing a value to be loaded into R6. What is that value? [fontsize=914] x3010 1110 0110 0011 1111 x3011 0110 1000 1100 0000 x3012 0110 1101 0000 0000 We could replace the three-instruction sequence with a single instruction. What is it? - 5.23 Suppose the following LC-3 program is loaded into memory starting at location x30FF: [fontsize=914] x30FF 1110 0010 0000 0001 x3100 0110 0100 0100 0010 x3101 1111 0000 0010 0101 x3102 0001 0100 0100 0001 x3103 0001 0100 1000 0010 If the program is executed, what is the value in R2 at the end of execution? 5.24 An LDR instruction, located at x3200, uses R4 as its",
    "428": "Explain. 5.22 The PC contains x3010. The following memory locations contain values as shown: [fontsize=914] x3050: x70A4 x70A2: x70A3 x70A3: xFFFF x70A4: x123B The following three LC-3 instructions are then executed, causing a value to be loaded into R6. What is that value? [fontsize=914] x3010 1110 0110 0011 1111 x3011 0110 1000 1100 0000 x3012 0110 1101 0000 0000 We could replace the three-instruction sequence with a single instruction. What is it? - 5.23 Suppose the following LC-3 program is loaded into memory starting at location x30FF: [fontsize=914] x30FF 1110 0010 0000 0001 x3100 0110 0100 0100 0010 x3101 1111 0000 0010 0101 x3102 0001 0100 0100 0001 x3103 0001 0100 1000 0010 If the program is executed, what is the value in R2 at the end of execution? 5.24 An LDR instruction, located at x3200, uses R4 as its base register. The value currently in R4 is x4011. What is the largest address that this instruction can load from? Suppose we redefine the LDR offset to be zero-extended, rather than sign-extended. Then what would be the largest address that this instruction could load from? With the new definition, what would be the smallest address that this instruction could load from? 5.25 Write an LC-3 program that compares two numbers in R2 and R3 and puts the larger number in R1. If the numbers are equal, then R1 is set equal to 0. 5.26 Your task is to consider the successor to the LC-3. We will add ten additional opcodes to the ISA, and expand the register set from 8 to 16. We will change the memory to byte-addressible, with total address space of 64K bytes. Instructions will remain 16 bits wide. Also, we will encode all instructions, both old and new, with the same fields as the original 15 instructions, although we may need to change the size of some of the fields. a. Is there any problem completing the detailed specification of the successor to the LC-3, as described above? Explain. b. How many bits do we need",
    "429": "from? 5.25 Write an LC-3 program that compares two numbers in R2 and R3 and puts the larger number in R1. If the numbers are equal, then R1 is set equal to 0. 5.26 Your task is to consider the successor to the LC-3. We will add ten additional opcodes to the ISA, and expand the register set from 8 to 16. We will change the memory to byte-addressible, with total address space of 64K bytes. Instructions will remain 16 bits wide. Also, we will encode all instructions, both old and new, with the same fields as the original 15 instructions, although we may need to change the size of some of the fields. a. Is there any problem completing the detailed specification of the successor to the LC-3, as described above? Explain. b. How many bits do we need in the PC to be able to address all of memory? c. If we want 128 different operating system routines to be able to be accessed with a trap instruction and we form the address of each of these routines by shifting the trap vector to the left by 5 bits, what is the minimum amount of memory required by the trap service routines? d. If, in the new version of the LC-3, we reduced the number of registers from eight to four and kept the number of opcodes at 16, what is the largest immediate value we could represent in an ADD instruction on this new machine? 5.27 Before the seven instructions are executed in the example of Section 5.3.5, R2 contains the value xAAAA. How many different values are contained in R2 during the execution of the seven instructions? What are they? 5.28 It is the case that we REALLY don't need to have load indirect (1010) and store indirect (1011) instructions. We can accomplish the same results using other instruction sequences instead of using these instructions. Replace the store indirect (1011) instruction in the code below with whatever instructions are necessary to perform the same function. [fontsize=914]",
    "430": "the trap service routines? d. If, in the new version of the LC-3, we reduced the number of registers from eight to four and kept the number of opcodes at 16, what is the largest immediate value we could represent in an ADD instruction on this new machine? 5.27 Before the seven instructions are executed in the example of Section 5.3.5, R2 contains the value xAAAA. How many different values are contained in R2 during the execution of the seven instructions? What are they? 5.28 It is the case that we REALLY don't need to have load indirect (1010) and store indirect (1011) instructions. We can accomplish the same results using other instruction sequences instead of using these instructions. Replace the store indirect (1011) instruction in the code below with whatever instructions are necessary to perform the same function. [fontsize=914] x3000 0010 0000 0000 0010 x3001 1011 0000 0000 0010 x3002 1111 0000 0010 0101 x3003 0000 0000 0100 1000 x3004 1111 0011 1111 1111 5.29 The LC-3 ISA contains the instruction LDR DR, BaseR, offset. After the instruction is decoded, the following operations (called microinstructions) are carried out to complete the processing of the LDR instruction: 36pc910 Suppose that the architect of the LC-3 wanted to include an instruction that would copy the memory location with address given by and store it into the memory location whose address is in . a. The instruction is not really necessary since it can be accomplished with a sequence of existing LC-3 instructions. What sequence of existing LC-3 instructions implements (also called “emulates”) ? b. If the instruction were added to the LC-3 ISA, what sequence of microinstructions, following the decode operation, would emulate ? -2 5.30 The following table shows a part of the LC-3's memory: 913ptAddress0pt10.12pt Data 0011 0001 0000 0000 1001 001 001 1111110pt10.1pt 0011 0001 0000 0001 0001 010 000 000 001 0011 0001 0000 0010 1001 010 010 111111 0011 0001 0000 0011 0000 010 111111100 State what is known about R1 and R0 if the conditional",
    "431": "the architect of the LC-3 wanted to include an instruction that would copy the memory location with address given by and store it into the memory location whose address is in . a. The instruction is not really necessary since it can be accomplished with a sequence of existing LC-3 instructions. What sequence of existing LC-3 instructions implements (also called “emulates”) ? b. If the instruction were added to the LC-3 ISA, what sequence of microinstructions, following the decode operation, would emulate ? -2 5.30 The following table shows a part of the LC-3's memory: 913ptAddress0pt10.12pt Data 0011 0001 0000 0000 1001 001 001 1111110pt10.1pt 0011 0001 0000 0001 0001 010 000 000 001 0011 0001 0000 0010 1001 010 010 111111 0011 0001 0000 0011 0000 010 111111100 State what is known about R1 and R0 if the conditional branch redirects control to location x3100. 5.31 The figure below shows a snapshot of the 8 registers of the LC-3 before and after the instruction at location x1000 is executed. Fill in the bits of the instruction at location x1000. 911 BEFORE [ 2-20pc1pc R0 x0000; 2-20pc1pc R1 x1111; 2-20pc1pc R2 x2222; 2-20pc1pc R3 x3333; 2-20pc1pc R4 x4444; 2-20pc1pc R5 x5555; 2-20pc1pc R6 x6666; 2-20pc1pc R7 x7777; 2-2 ] AFTER [ 2-20pc1pc R0 x0000; 2-20pc1pc R1 x1111; 2-20pc1pc R2 x2222; 2-20pc1pc R3 x3333; 2-20pc1pc R4 x4444; 2-20pc1pc R5 xFFF8; 2-20pc1pc R6 x6666; 2-20pc1pc R7 x7777; 2-2 ] 0x1000: 0 0 0 1 -2 5.32 If the condition codes have values N=0, Z=0, P=1 at the beginning of the execution of the following sequence of LC-3 instructions, what will their values be at the end of the execution of the following sequence of LC-3 instructions? [fontsize=914] x3050 0000 0010 0000 0010 x3051 0101 0000 0010 0000 x3052 0000 1110 0000 0010 x3053 0101 0000 0010 0000 x3054 0001 0000 0011 1111 5.33 If the value stored in R0 is 5 at the end of the execution of the following instructions, what can be inferred about R5? [fontsize=913] x2FFF 0101 0000 0010",
    "432": "x5555; 2-20pc1pc R6 x6666; 2-20pc1pc R7 x7777; 2-2 ] AFTER [ 2-20pc1pc R0 x0000; 2-20pc1pc R1 x1111; 2-20pc1pc R2 x2222; 2-20pc1pc R3 x3333; 2-20pc1pc R4 x4444; 2-20pc1pc R5 xFFF8; 2-20pc1pc R6 x6666; 2-20pc1pc R7 x7777; 2-2 ] 0x1000: 0 0 0 1 -2 5.32 If the condition codes have values N=0, Z=0, P=1 at the beginning of the execution of the following sequence of LC-3 instructions, what will their values be at the end of the execution of the following sequence of LC-3 instructions? [fontsize=914] x3050 0000 0010 0000 0010 x3051 0101 0000 0010 0000 x3052 0000 1110 0000 0010 x3053 0101 0000 0010 0000 x3054 0001 0000 0011 1111 5.33 If the value stored in R0 is 5 at the end of the execution of the following instructions, what can be inferred about R5? [fontsize=913] x2FFF 0101 0000 0010 0000 x3000 0101 1111 1110 0000 x3001 0001 1101 1110 0001 x3002 0101 1001 0100 0110 x3003 0000 0100 0000 0001 x3004 0001 0000 0010 0001 x3005 0001 1101 1000 0110 x3006 0001 1111 1110 0001 x3007 0001 0011 1111 1000 x3008 0000 1001 1111 1001 x3009 0101 1111 1110 0000 5.34 Using the overall data path in Figure 5.18, identify the elements that implement the NOT instruction of Figure 5.4. 5.35 Using the overall data path in Figure 5.18, identify the elements that implement the ADD instruction of Figure 5.5. 5.36 Using the overall data path in Figure 5.18, identify the elements that implement the LD instruction of Figure 5.6. 5.37 Using the overall data path in Figure 5.18, identify the elements that implement the LDI instruction of Figure 5.7. 5.38 Using the overall data path in Figure 5.18, identify the elements that implement the LDR instruction of Figure 5.8. 5.39 Using the overall data path in Figure 5.18, identify the elements that implement the LEA instruction of Figure 5.9. 5.40 The logic diagram below shows part of the control structure of the LC-3 machine. What is the purpose of the signal labeled A? < g r a p",
    "433": "identify the elements that implement the NOT instruction of Figure 5.4. 5.35 Using the overall data path in Figure 5.18, identify the elements that implement the ADD instruction of Figure 5.5. 5.36 Using the overall data path in Figure 5.18, identify the elements that implement the LD instruction of Figure 5.6. 5.37 Using the overall data path in Figure 5.18, identify the elements that implement the LDI instruction of Figure 5.7. 5.38 Using the overall data path in Figure 5.18, identify the elements that implement the LDR instruction of Figure 5.8. 5.39 Using the overall data path in Figure 5.18, identify the elements that implement the LEA instruction of Figure 5.9. 5.40 The logic diagram below shows part of the control structure of the LC-3 machine. What is the purpose of the signal labeled A? < g r a p h i c s > -2 5.41 A part of the implementation of the LC-3 architecture is shown on the top of the next page. a. What information does Y provide? b. The signal X is the control signal that gates the gated D latch. Is there an error in the logic that produces X? < g r a p h i c s > 5.42 The LC-3 macho-company had decided to use opcode 1101 to implement a new instruction. They need you help to pick the most useful one from the following: a. MOVE Ri, Rj; The contents of Rj are copied into Ri. b. NAND Ri, Rj, Rk; Ri is the bit-wise NAND of Rj, Rk c. SHFL Ri, Rj, #2; The contents of Rj are shifted left 2 bits and stored into Ri. d. MUL Ri, Rj, Rk; Ri is the product of 2's complement integers in Rj, Rk. Justify your answer. 5.43ADD When a computer executes an instruction, the state of the computer is changed as a result of that execution. Is there any difference in the state of the LC-3 computer as a result of executing instruction 1 below vs executing instruction 2 below? Explain.",
    "434": "h i c s > 5.42 The LC-3 macho-company had decided to use opcode 1101 to implement a new instruction. They need you help to pick the most useful one from the following: a. MOVE Ri, Rj; The contents of Rj are copied into Ri. b. NAND Ri, Rj, Rk; Ri is the bit-wise NAND of Rj, Rk c. SHFL Ri, Rj, #2; The contents of Rj are shifted left 2 bits and stored into Ri. d. MUL Ri, Rj, Rk; Ri is the product of 2's complement integers in Rj, Rk. Justify your answer. 5.43ADD When a computer executes an instruction, the state of the computer is changed as a result of that execution. Is there any difference in the state of the LC-3 computer as a result of executing instruction 1 below vs executing instruction 2 below? Explain. We can assume the state of the LC-3 computer before execution is the same in both cases. instruction 1: 0001 000 000 1 00000 register 0 <– register 0 + #0 instruction 2: 0000 111 000000000 branch to PC' + #0 if any of N,Z,orP is set 5.44ADD A program wishes to load a value from memory into register 1, and on the basis of the value loaded, execute code starting at x3040 if the value loaded is positive, execute code starting at x3080 if the value loaded is negative, or execute code starting at location x3003 if the value loaded is zero. The first instruction of this program (load a value into register R1) is shown in x3000. Part a Write the instructions for locations x3001 and x3002. 1.8ex[0pt]x3000: (3,0.325) (3,0.325)0010 001 011111111 1.8ex[0pt]x3001: (3,0.325) (3,0.325) 1.8ex[0pt]x3002: (3,0.325) (3,0.325) Part b The program segment below starts execution at x3000. When the program halts, what is contained in register 0? x3000: 0101 000 000 1 00000 ;register 0 <– 0 x3001: 0001 000 000 1 00001 ;register 0 <– register 0 + 1 x3002: 0000 001 111111110 ;branch p -2 x3003: 1111 0000 0010 0101 ;TRAP x25 Part c Two",
    "435": "and on the basis of the value loaded, execute code starting at x3040 if the value loaded is positive, execute code starting at x3080 if the value loaded is negative, or execute code starting at location x3003 if the value loaded is zero. The first instruction of this program (load a value into register R1) is shown in x3000. Part a Write the instructions for locations x3001 and x3002. 1.8ex[0pt]x3000: (3,0.325) (3,0.325)0010 001 011111111 1.8ex[0pt]x3001: (3,0.325) (3,0.325) 1.8ex[0pt]x3002: (3,0.325) (3,0.325) Part b The program segment below starts execution at x3000. When the program halts, what is contained in register 0? x3000: 0101 000 000 1 00000 ;register 0 <– 0 x3001: 0001 000 000 1 00001 ;register 0 <– register 0 + 1 x3002: 0000 001 111111110 ;branch p -2 x3003: 1111 0000 0010 0101 ;TRAP x25 Part c Two of the outputs of a 3 to 8 decoder are used as inputs to an AND gate as shown below. < g r a p h i c s > 5.45ADD In class we showed the first few states of the finite state machine that is required for processing instructions of a computer program written for LC-3. In the first state, the computer does two things, represented as: Why does the microarchictecture put the contents of the PC into the MAR? Why does the microarchitecture increment the PC? 5.46ADD R0 contains the ASCII code of a capital letter in the English alphabet. If the instruction 0001000000000001 is executed, we wish to end up with the lower case version of that letter in R0. What must be true of the values in the other registers before this instruction executes for this to happen? 5.47ADD Recall the 2^2 by 16-bit memory from problem 6 of problem set 3. It is reproduced below. Recall that each of the four muxes on the diagram have 4-bit input sources and a 4-bit output, and that each 4-bit source is the output of a single 4-bit memory cell. < g r a p h i c",
    "436": "state, the computer does two things, represented as: Why does the microarchictecture put the contents of the PC into the MAR? Why does the microarchitecture increment the PC? 5.46ADD R0 contains the ASCII code of a capital letter in the English alphabet. If the instruction 0001000000000001 is executed, we wish to end up with the lower case version of that letter in R0. What must be true of the values in the other registers before this instruction executes for this to happen? 5.47ADD Recall the 2^2 by 16-bit memory from problem 6 of problem set 3. It is reproduced below. Recall that each of the four muxes on the diagram have 4-bit input sources and a 4-bit output, and that each 4-bit source is the output of a single 4-bit memory cell. < g r a p h i c s > Part a: Unfortunately, the memory was wired by a student and he got the inputs to some of the muxes mixed up. That is, instead of the 4 bits from a memory cell going to the correct 4-bit input of the mux, the 4 bits all went to one of the other 4-bit sources of that mux. The result was, as you can imagine, a mess. To figure out the mix-up in the wiring, the following sequence of memory accesses was performed: To figure out the mix-up in the wiring, the following sequence of memory accesses was performed: t]c|c|c Read/Write MDR MAR Write x134B 01 Write xFCA2 10 Write xBEEF 11 Write x072A 00 Read xF34F 10 Read x1CAB 01 Read x0E2A 00 Note: On a write, MDR is loaded before the access. On a read, MDR is loaded as a result of the access. Your job is to identify the mix-up in the wiring. Show which memory cells were wired to which mux inputs by filling in their corresponding addresses in the blanks provided. Note that one address has already been supplied for you. < g r a p h i c s > Part b: After",
    "437": "result was, as you can imagine, a mess. To figure out the mix-up in the wiring, the following sequence of memory accesses was performed: To figure out the mix-up in the wiring, the following sequence of memory accesses was performed: t]c|c|c Read/Write MDR MAR Write x134B 01 Write xFCA2 10 Write xBEEF 11 Write x072A 00 Read xF34F 10 Read x1CAB 01 Read x0E2A 00 Note: On a write, MDR is loaded before the access. On a read, MDR is loaded as a result of the access. Your job is to identify the mix-up in the wiring. Show which memory cells were wired to which mux inputs by filling in their corresponding addresses in the blanks provided. Note that one address has already been supplied for you. < g r a p h i c s > Part b: After rewiring the muxes correctly and initializing all memory cells to xF, the following sequence of accesses was performed. Note that some of the information about each access has been left out. Your job: Fill in the blanks. t]c|c|c Read/Write MDR MAR Write x72 (1,0)10(1,0)10 0 (1,0)10 Write x8FAF 11 Read x72A3 (1,0)100 Read xFFFF 1(1,0)10 Write x732D (1,0)101 Read xFFFF 0(1,0)10 Write x(1,0)107(1,0)10(1,0)10 0(1,0)10 Read x37A3 (1,0)101 Read x(1,0)10(1,0)10(1,0)10D (1,0)101 Show the contents of the memory cells by putting the hex digit that is stored in each after all the accesses have been performed. < g r a p h i c s > 5.48ADD After these two instructions execute: x3030 0001 000 001 0 00 010 x3031 0000 011 000000111 the next instruction to execute will be the instruction at x3039 if what condition is met? 5.49ADD We wish to know if R0 is being used as the Base Register for computing the address in an LDR instruction. Since the instruction is in memory, we can load it into R4. And, since the Base Register is identified in bits 8:6 of the instruction, we can Load R5 with 0000000111000000, and then execute AND R6,R5,R4. We would know that R0",
    "438": "0(1,0)10 Write x(1,0)107(1,0)10(1,0)10 0(1,0)10 Read x37A3 (1,0)101 Read x(1,0)10(1,0)10(1,0)10D (1,0)101 Show the contents of the memory cells by putting the hex digit that is stored in each after all the accesses have been performed. < g r a p h i c s > 5.48ADD After these two instructions execute: x3030 0001 000 001 0 00 010 x3031 0000 011 000000111 the next instruction to execute will be the instruction at x3039 if what condition is met? 5.49ADD We wish to know if R0 is being used as the Base Register for computing the address in an LDR instruction. Since the instruction is in memory, we can load it into R4. And, since the Base Register is identified in bits 8:6 of the instruction, we can Load R5 with 0000000111000000, and then execute AND R6,R5,R4. We would know that R0 is the base register if what condition is met? 5.50STAR Three instructions all construct an address by sign-extending the low 9 bits of the instruction and adding it to the incremented PC. < g r a p h i c s > The xxxxxxxxx represents the 9-bit offset that is sign-extended. Where does the LC-3 microarchitecture put the result of adding the 9-bit sign-extended offset to the incremented PC? Conditional Branch: LEA: LD: 5.51STAR An aggressive young engineer decides to build and sell the LC-3, but is told that if he wants to succeed, he really needs a SUBTRACT instruction. Given the unused opcode 1101, he decides to specify the SUBTRACT instruction as follows: < g r a p h i c s > The instruction is defined as: DR ← SR2 - SR1, and the condition codes are set. Assume DR, SR1, and SR2 are all different registers. To accomplish this, the engineer needs to add three states to the state machine and a mux and register A to the data path. The modified state machine is shown below and the modified data path is shown on the next page. The mux is controlled by a new control signal",
    "439": "adding the 9-bit sign-extended offset to the incremented PC? Conditional Branch: LEA: LD: 5.51STAR An aggressive young engineer decides to build and sell the LC-3, but is told that if he wants to succeed, he really needs a SUBTRACT instruction. Given the unused opcode 1101, he decides to specify the SUBTRACT instruction as follows: < g r a p h i c s > The instruction is defined as: DR ← SR2 - SR1, and the condition codes are set. Assume DR, SR1, and SR2 are all different registers. To accomplish this, the engineer needs to add three states to the state machine and a mux and register A to the data path. The modified state machine is shown below and the modified data path is shown on the next page. The mux is controlled by a new control signal SR2SEL which selects one of its two sources. SR2SEL/1: SR2OUT, REGISTER_A Your job: For the state machine shown below, fill in the empty boxes with the control signals that are needed in order to implement the SUBTRACT instruction. For the data path, fill in the value in register A. < g r a p h i c s > < g r a p h i c s > 5.52ADD Here is a list of the 16 opcodes. Circle the ones that write to a general purpose register (R0 to R7) at some point during the instruction cycle. ADD AND BR JMP JSR LD LEA LDI LDR NOT RTI ST STI STR TRAP reserved 5.53ADD The 8 general purpose registers of the LC-3 (R0 to R7) make up the Register File. To write a value to a register, the LC-3 control unit must supply 16 bits of data (BUS[15:0]), a destination register (DR[2:0]), and a write enable signal (LD.REG) to load a register. The Combinational Logic Block below shows inputs BUS[15:0], DR[2:0], and LD.REG and outputs DinR0[15:0], DinR1[15:0], DinR2[15:0], ... DinR7[15:0], LD.R0, LD.R1, LD.R2, ... LD.R7. Your job: Add wires, logic gates, and standard logic blocks as necessary to complete",
    "440": "g r a p h i c s > 5.52ADD Here is a list of the 16 opcodes. Circle the ones that write to a general purpose register (R0 to R7) at some point during the instruction cycle. ADD AND BR JMP JSR LD LEA LDI LDR NOT RTI ST STI STR TRAP reserved 5.53ADD The 8 general purpose registers of the LC-3 (R0 to R7) make up the Register File. To write a value to a register, the LC-3 control unit must supply 16 bits of data (BUS[15:0]), a destination register (DR[2:0]), and a write enable signal (LD.REG) to load a register. The Combinational Logic Block below shows inputs BUS[15:0], DR[2:0], and LD.REG and outputs DinR0[15:0], DinR1[15:0], DinR2[15:0], ... DinR7[15:0], LD.R0, LD.R1, LD.R2, ... LD.R7. Your job: Add wires, logic gates, and standard logic blocks as necessary to complete the Combinational Logic Block. Note: If you use a standard logic block, it is not necessary to show the individual gates. However, it is necessary to identify the logic block specifically (e.g., “16-to-1 mux”), along with labels for each relevant input or output, according to its function. < g r a p h i c s > 5.54ADD All instructions load the MDR during the fetch phase of the instruction cycle to fetch the instruction from memory on its way to the IR. After decode has completed, some instructions load the MDR again, using the source 0 input to the mux labeled A on the data path. Other instructions load the MDR, using the source 1 input to mux A. Only one of the 15 LC-3 instructions loads the MDR after decode, using both source 0 and source 1 at different times during the processing of that instruction. What is the opcode of that instruction? 5.55STAR An LC-3 program starts execution at x3000. During the execution of the program, a snapshot of all 8 registers were taken at six different times as shown below: before the program executes, after execution of instruction 1, after execution of instruction 2, after execution",
    "441": "load the MDR during the fetch phase of the instruction cycle to fetch the instruction from memory on its way to the IR. After decode has completed, some instructions load the MDR again, using the source 0 input to the mux labeled A on the data path. Other instructions load the MDR, using the source 1 input to mux A. Only one of the 15 LC-3 instructions loads the MDR after decode, using both source 0 and source 1 at different times during the processing of that instruction. What is the opcode of that instruction? 5.55STAR An LC-3 program starts execution at x3000. During the execution of the program, a snapshot of all 8 registers were taken at six different times as shown below: before the program executes, after execution of instruction 1, after execution of instruction 2, after execution of instruction 3, after execution of instruction 4, after execution of instruction 5, and after execution of instruction 6. Registers Initial After 1st After 2nd After 3rd After 4th After 5th After 6th Value Instruction Instruction Instruction Instruction Instruction Instruction R0 x4006 x4050 x4050 x4050 x4050 x4050 x4050 R1 x5009 x5009 x5009 x5009 x5009 x5009 x5009 R2 x4008 x4008 x4008 x4008 x4008 x4008 xC055 R3 x4002 x8005 x8005 x8005 x8005 R4 x4003 x4003 x4003 x4003 x4003 R5 x400D x400D x400D x400D x400D R6 x400C x400C x400C x400C x400C x400C x400C R7 x6001 x6001 x6001 x6001 x400E Also, during the execution of the program, the PC trace, the MAR trace, and the MDR trace were also recorded as shown below. Note that a PC trace records the addresses of the instructions executed in sequence by the program. PC Trace x400D x400E MAR Trace MDR Trace xA009 x3025 x1703 x4040 x400E x1403 Your job: Fill in the missing entries in the 3 tables above. 5.56ADD This problem tests your knowledge of the instruction cycle for processing the NOT instruction. You are asked to show the values of several control signals in every clock cycle of the sequence that is used to process",
    "442": "x4008 x4008 x4008 xC055 R3 x4002 x8005 x8005 x8005 x8005 R4 x4003 x4003 x4003 x4003 x4003 R5 x400D x400D x400D x400D x400D R6 x400C x400C x400C x400C x400C x400C x400C R7 x6001 x6001 x6001 x6001 x400E Also, during the execution of the program, the PC trace, the MAR trace, and the MDR trace were also recorded as shown below. Note that a PC trace records the addresses of the instructions executed in sequence by the program. PC Trace x400D x400E MAR Trace MDR Trace xA009 x3025 x1703 x4040 x400E x1403 Your job: Fill in the missing entries in the 3 tables above. 5.56ADD This problem tests your knowledge of the instruction cycle for processing the NOT instruction. You are asked to show the values of several control signals in every clock cycle of the sequence that is used to process the NOT instruction. The instruction cycle starts with state 18 as shown in the table below. Your job: Identify each state in the sequence, and show the values of the control signals listed during each state in the sequence. Use the convention specified below. For a particular state, if the value of a control signal does not matter, fill it with an X. You may not have to use all the rows. Note: Assume a memory access takes one clock cycle. Cycle State LD.PC LD.MAR LD.MDR LD.REG LD.CC GateALU GatePC ALUK PCMUX 1 18 2 3 4 5 6 7 8 9 10 5.57ADD < g r a p h i c s > 1. What opcodes use IR[11:9] as inputs to SR1? 2. Where does the control signal of this mux come from? Be specific! 3. What opcodes use this input to the MARMUX? 5.58ADD Let's use the unused opcode to implement a new instruction, as shown below: < g r a p h i c s > To accomplish this, we will need a small addition to the data path, shown below in boldface: < g r a p h i c s > The following five additional",
    "443": "with an X. You may not have to use all the rows. Note: Assume a memory access takes one clock cycle. Cycle State LD.PC LD.MAR LD.MDR LD.REG LD.CC GateALU GatePC ALUK PCMUX 1 18 2 3 4 5 6 7 8 9 10 5.57ADD < g r a p h i c s > 1. What opcodes use IR[11:9] as inputs to SR1? 2. Where does the control signal of this mux come from? Be specific! 3. What opcodes use this input to the MARMUX? 5.58ADD Let's use the unused opcode to implement a new instruction, as shown below: < g r a p h i c s > To accomplish this, we will need a small addition to the data path, shown below in boldface: < g r a p h i c s > The following five additional states are needed to control the data path to carry out the work of this instruction. < g r a p h i c s > Note: State B loads the negative of the contents of MDR into TEMP. Part a: Complete the table below by identifying the values of the control signals needed to carry out the work of each state. 90LD.PC 90LD.MAR 90LD.MDR 90LD.CC 90LD.TEMP 90GatePC 90GateMDR 90GateALU 2c|90SR1MUX[1:0] 90ALUMUX 2c|90ALUK[1:0] 90MIO.EN 90R.W 2-160.20in-0.10in State 13 2-160.20in-0.10in State A 2-160.20in-0.10in State B 2-160.20in-0.10in State C 2-160.20in-0.10in State D 2-16 Part b: What does the new instruction do? 5.59ADD very LC-3 instruction takes 8 cycles to be fetched and decoded, if we assume every memory access takes 5 cycles. The total number of cycles an LC-3 instruction takes to be completely processed, however, depends on what has to be done for that instruction. Assuming every memory access takes 5 cycles, and assuming the LC-3 processes one instruction at a time, from beginning to end, how many clock cycles does each instruction take? For each instruction, how many cycles are required to process it? Instruction Number of cycles ADD AND LD LEA LDI NOT BRnzp TRAP 5.60ADD < g r",
    "444": "each state. 90LD.PC 90LD.MAR 90LD.MDR 90LD.CC 90LD.TEMP 90GatePC 90GateMDR 90GateALU 2c|90SR1MUX[1:0] 90ALUMUX 2c|90ALUK[1:0] 90MIO.EN 90R.W 2-160.20in-0.10in State 13 2-160.20in-0.10in State A 2-160.20in-0.10in State B 2-160.20in-0.10in State C 2-160.20in-0.10in State D 2-16 Part b: What does the new instruction do? 5.59ADD very LC-3 instruction takes 8 cycles to be fetched and decoded, if we assume every memory access takes 5 cycles. The total number of cycles an LC-3 instruction takes to be completely processed, however, depends on what has to be done for that instruction. Assuming every memory access takes 5 cycles, and assuming the LC-3 processes one instruction at a time, from beginning to end, how many clock cycles does each instruction take? For each instruction, how many cycles are required to process it? Instruction Number of cycles ADD AND LD LEA LDI NOT BRnzp TRAP 5.60ADD < g r a p h i c s > Note that several of the lines (i.e., signals) in the LC-3 data path have been drawn in boldface. Each line is designated by a boldface number 1,2,or 3. Not all instructions use all three lines. That is, some instructions would not function correctly if the line (i.e., signal) were removed. List the opcodes that utilize line 1 during their processing of an instruction. List the opcodes that utilize line 2 during their processing of an instruction. List the opcodes that require LD.CC=1 on line 3 during their processing of an instruction. Note the logic (in boldface) added to the data path. The output of that logic is labeled X. What does X=1 indicate if ALUK is ADD? 5.61STAR During the execution of an LC3 program, the processor datapath was monitored for four instructions in the program that were processed consecutively. The table below shows all clock cycles during which the bus was utilized. It shows the clock cycle number, the value on the bus and the state (from the state machine diagram) for some of these clock cycles. Processing of the first instruction starts at clock cycle T. Each memory access in this",
    "445": "that utilize line 1 during their processing of an instruction. List the opcodes that utilize line 2 during their processing of an instruction. List the opcodes that require LD.CC=1 on line 3 during their processing of an instruction. Note the logic (in boldface) added to the data path. The output of that logic is labeled X. What does X=1 indicate if ALUK is ADD? 5.61STAR During the execution of an LC3 program, the processor datapath was monitored for four instructions in the program that were processed consecutively. The table below shows all clock cycles during which the bus was utilized. It shows the clock cycle number, the value on the bus and the state (from the state machine diagram) for some of these clock cycles. Processing of the first instruction starts at clock cycle T. Each memory access in this LC3 machine takes five clock cycles. Your job: Fill in the missing entries in the table below. You only need to fill in the cells not marked with `x'. Note: There are five clock cycles for which you need to provide the control signals. Not all LC3 control signals are shown in the table. However, all control signals that are required for those five clock cycles have been included. Note: For the DRMUX signal, write `11.9', `R7', or `SP'; for the R.W signal, write a `R' or a `W'; for the PCMUX signal, write `PC+1', `BUS', or `ADDER'; for all other control signals, write down the actual bit. If a control signal is not relevant in a given cycle, mark it with a dash (i.e., -). Inst. Clock Bus State 13 c| Control Signals # Cycle 13 c| 5-17 Gate Gate Gate Gate LD. LD. LD. LD. LD. DR MIO. R.W PC PC MDR ALU MARMUX PC MDR MAR CC Reg MUX EN MUX Inst. 1 T + 0 x3010 2-17 T + 6 x x x x x x x x x x x x x 2-17 T + 8 x00AB x x x x x x x x",
    "446": "required for those five clock cycles have been included. Note: For the DRMUX signal, write `11.9', `R7', or `SP'; for the R.W signal, write a `R' or a `W'; for the PCMUX signal, write `PC+1', `BUS', or `ADDER'; for all other control signals, write down the actual bit. If a control signal is not relevant in a given cycle, mark it with a dash (i.e., -). Inst. Clock Bus State 13 c| Control Signals # Cycle 13 c| 5-17 Gate Gate Gate Gate LD. LD. LD. LD. LD. DR MIO. R.W PC PC MDR ALU MARMUX PC MDR MAR CC Reg MUX EN MUX Inst. 1 T + 0 x3010 2-17 T + 6 x x x x x x x x x x x x x 2-17 T + 8 x00AB x x x x x x x x x x x x x 2-17 T + 9 28 2-17 T + 10 28 2-17 T + 11 28 2-17 T + 12 x 28 x x x x x x x x x x x x x 2-17 T + 13 x 28 x x x x x x x x x x x x x 2-17 T + 14 x x x x x x x x x x x x x Inst. 2 T + 15 x1510 18 x x x x x x x x x x x x x 2-17 x2219 x x x x x x x x x x x x x 2-17 x x x x x x x x x x x x x 2-17 T + 29 x8001 Inst. 3 T + 30 x x x x x x x x x x x x x 2-17 T+ 36 x0804 x x x x x x x x x x x x x Inst. 4 18 x x x x x x x x x x x x x 2-17 x x1200 x x x x x x x x x x x x x x 2-17 x x0000",
    "447": "+ 14 x x x x x x x x x x x x x Inst. 2 T + 15 x1510 18 x x x x x x x x x x x x x 2-17 x2219 x x x x x x x x x x x x x 2-17 x x x x x x x x x x x x x 2-17 T + 29 x8001 Inst. 3 T + 30 x x x x x x x x x x x x x 2-17 T+ 36 x0804 x x x x x x x x x x x x x Inst. 4 18 x x x x x x x x x x x x x 2-17 x x1200 x x x x x x x x x x x x x x 2-17 x x0000 x x x x x x x x x x x x x x ../art/ch04/,../art/designelements/,../art/designelements/UnNumberedArt/ CHAPTER: THE VON NEUMANN MODEL We are now ready to raise our level of abstraction another notch. We will build on the logic structures that we studied in Chapter 3, both decision elements and storage elements, to construct the basic computer model first proposed in the 1940s, usually referred to as the von Neumann machine. ...and, we will write our first computer program in the ISA of the LC-3. § BASIC COMPONENTS To get a task done by a computer, we need two things: (a) a computer program that specifies what the computer must do to perform the task, and (b) the computer that is to carry out the task. A computer program consists of a set of instructions, each specifying a well-defined piece of work for the computer to carry out. The instruction is the smallest piece of work specified in a computer program. That is, the computer either carries out the work specified by an instruction or it does not. The computer does not have the luxury of carrying out only a piece of an instruction. John von Neumann proposed a fundamental model",
    "448": "the 1940s, usually referred to as the von Neumann machine. ...and, we will write our first computer program in the ISA of the LC-3. § BASIC COMPONENTS To get a task done by a computer, we need two things: (a) a computer program that specifies what the computer must do to perform the task, and (b) the computer that is to carry out the task. A computer program consists of a set of instructions, each specifying a well-defined piece of work for the computer to carry out. The instruction is the smallest piece of work specified in a computer program. That is, the computer either carries out the work specified by an instruction or it does not. The computer does not have the luxury of carrying out only a piece of an instruction. John von Neumann proposed a fundamental model of a computer for processing computer programs in 1946. Figure <ref> shows its basic components. We have taken a little poetic license and added a few of our own minor embellishments to von Neumann's original diagram. The von Neumann model consists of five parts: memory, a processing unit, input, output, and a control unit. The computer program is contained in the computer's memory. The data the program needs to carry out the work of the program is either contained in the program's memory, or is obtained from the input devices. The results of the program's execution is provided by the output devices. The order in which the instructions are carried out is performed by the control unit. von Neumann!model We will describe each of the five parts of the von Neumann model in greater detail. < g r a p h i c s > The von Neumann model, overall block diagram §.§ Memory Recall that in Chapter 3 we examined a simple 2^2-by-3-bit memory that was constructed out of gates and latches. A more realistic memory for one of today's computer systems is 2^34 by 8 bits. That is, a typical memory in today's world of computers consists of",
    "449": "the computer's memory. The data the program needs to carry out the work of the program is either contained in the program's memory, or is obtained from the input devices. The results of the program's execution is provided by the output devices. The order in which the instructions are carried out is performed by the control unit. von Neumann!model We will describe each of the five parts of the von Neumann model in greater detail. < g r a p h i c s > The von Neumann model, overall block diagram §.§ Memory Recall that in Chapter 3 we examined a simple 2^2-by-3-bit memory that was constructed out of gates and latches. A more realistic memory for one of today's computer systems is 2^34 by 8 bits. That is, a typical memory in today's world of computers consists of 2^34 distinct memory locations, each of which is capable of storing 8 bits of information. We say that such a memory has an address space of 2^34 uniquely identifiable locations, and an addressability of 8 bits. We refer to such a memory as a 16-gigabyte memory (abbreviated, 16 GB). The “16 giga” refers to the 2^34 locations, and the “byte” refers to the 8 bits stored in each location. The term 16 giga because 16 is 2^4 and giga is the term we use to represent 2^30, which is approximately one billion; 2^4 times 2^30 = 2^34. A byte is the word we use to describe 8 bits, much the byte way we use the word gallon to describe four quarts. We note (as we will note again and again) that with k bits, we can represent uniquely 2^k items. Thus, to uniquely identify 2^34 memory locations, each location must have its own 34-bit address. In Chapter 5, we will begin the complete definition of the LC-3 computer. We will see that the memory address space of the LC-3 is 2^16, and the addressability is 16 bits. Recall from Chapter 3 that we access memory by providing the address from",
    "450": "refers to the 8 bits stored in each location. The term 16 giga because 16 is 2^4 and giga is the term we use to represent 2^30, which is approximately one billion; 2^4 times 2^30 = 2^34. A byte is the word we use to describe 8 bits, much the byte way we use the word gallon to describe four quarts. We note (as we will note again and again) that with k bits, we can represent uniquely 2^k items. Thus, to uniquely identify 2^34 memory locations, each location must have its own 34-bit address. In Chapter 5, we will begin the complete definition of the LC-3 computer. We will see that the memory address space of the LC-3 is 2^16, and the addressability is 16 bits. Recall from Chapter 3 that we access memory by providing the address from which we wish to read, or to which we wish to write. To read the contents of a memory location, we first place the address of that location in the memory's address register ( MAR), and then interrogate the computer's memory. The information stored in the location having that address will be placed in the memory's data register ( MDR). To write (or store) a value in a memory location, we first write the address of the memory location in the MAR, and the value to be stored in the MDR. We then interrogate the computer's memory with the Write Enable signal asserted. The information contained in the MDR will be written into the memory location whose address is in the MAR. Before we leave the notion of memory for the moment, let us again emphasize the two characteristics of a memory location: its address and what is stored there. Figure <ref> shows a representation of a memory consisting of eight locations. Its addresses are shown at the left, numbered in binary from 0 to 7. Each location contains 8 bits of information. Note that the value 6 is stored in the memory location whose address is 4, and the",
    "451": "To write (or store) a value in a memory location, we first write the address of the memory location in the MAR, and the value to be stored in the MDR. We then interrogate the computer's memory with the Write Enable signal asserted. The information contained in the MDR will be written into the memory location whose address is in the MAR. Before we leave the notion of memory for the moment, let us again emphasize the two characteristics of a memory location: its address and what is stored there. Figure <ref> shows a representation of a memory consisting of eight locations. Its addresses are shown at the left, numbered in binary from 0 to 7. Each location contains 8 bits of information. Note that the value 6 is stored in the memory location whose address is 4, and the value 4 is stored in the memory location whose address is 6. These represent two very different situations. < g r a p h i c s > Location 6 contains the value 4; location 4 contains the value 6 Finally, an analogy: the post office boxes in your local post office. The box number is like the memory location's address. Each box number is unique. The information stored in the memory location is like the letters contained in the post office box. As time goes by, what is contained in the post office box at any particular moment can change. But the box number remains the same. So, too, with each memory location. The value stored in that location can be changed, but the location's memory address remains unchanged. §.§ Processing Unit The actual processing of information in the computer is carried out by the processing unit.processing unit The processing unit in a modern computer can consist of many sophisticated complex functional units, each performing one particular operation (divide, square root, etc.). The simplest processing unit, and the one normally thought of when discussing the basic von Neumann model, is the ALU. ALU is the abbreviation for Arithmetic and",
    "452": "address. Each box number is unique. The information stored in the memory location is like the letters contained in the post office box. As time goes by, what is contained in the post office box at any particular moment can change. But the box number remains the same. So, too, with each memory location. The value stored in that location can be changed, but the location's memory address remains unchanged. §.§ Processing Unit The actual processing of information in the computer is carried out by the processing unit.processing unit The processing unit in a modern computer can consist of many sophisticated complex functional units, each performing one particular operation (divide, square root, etc.). The simplest processing unit, and the one normally thought of when discussing the basic von Neumann model, is the ALU. ALU is the abbreviation for Arithmetic and Logic Unit, so called because ALU it is usually capable of performing basic arithmetic functions (like ADD and SUBTRACT) and basic logic operations (like bit-wise AND, OR, and NOT) that we have already studied in Chapter 2. We will see in Chapter 5, that the LC-3 has an ALU, which can perform ADD, AND, and NOT operations. Two of these (ADD and AND) we will discuss in this chapter. The ALU normally processes data elements of a fixed size referred to as the word length of the computer. The data elements are called words. word lengthword For example, to perform ADD, the ALU receives two words as inputs and produces a single word (the sum) as output. Each ISA has its own word length, depending on the intended use of the computer. Most microprocessors today that are used in PCs or workstations have a word length of 64 bits (as is the case with Intel's \"Core\" processors) or 32 bits (as is the case with Intel's \"Atom\" processors). Even most microprocessors now used in cell phones have 64 bit word lengths, such as Apple's A7 through A11 processors, and Qualcomm's SnapDragon processors. However, the microprocessors used in very inexpensive applications",
    "453": "(ADD and AND) we will discuss in this chapter. The ALU normally processes data elements of a fixed size referred to as the word length of the computer. The data elements are called words. word lengthword For example, to perform ADD, the ALU receives two words as inputs and produces a single word (the sum) as output. Each ISA has its own word length, depending on the intended use of the computer. Most microprocessors today that are used in PCs or workstations have a word length of 64 bits (as is the case with Intel's \"Core\" processors) or 32 bits (as is the case with Intel's \"Atom\" processors). Even most microprocessors now used in cell phones have 64 bit word lengths, such as Apple's A7 through A11 processors, and Qualcomm's SnapDragon processors. However, the microprocessors used in very inexpensive applications often have word lengths of as little as 16 or even 8 bits. In the LC-3, the ALU processes 16-bit words. We say the LC-3 has a word length of 16 bits. It is almost always the case that a computer provides some small amount of storage very close to the ALU to allow results to be temporarily stored if they will be needed to produce additional results in the near future. For example, if a computer is to calculate (A+B)· C, it could store the result of A+B in memory, and then subsequently read it in order to multiply that result by C. However, the time it takes to access memory is long compared to the time it takes to perform the ADD or MULTIPLY. Almost all computers, therefore, have temporary storage for storing the result of A+B in order to avoid the much longer access time that would be necessary when it came time to multiply. The most common form of temporary storage is a set of registers, like the register described in Section 3.7. Typically, the size of each register is identical to the size of values processed by the ALU, that is, they each contain one",
    "454": "they will be needed to produce additional results in the near future. For example, if a computer is to calculate (A+B)· C, it could store the result of A+B in memory, and then subsequently read it in order to multiply that result by C. However, the time it takes to access memory is long compared to the time it takes to perform the ADD or MULTIPLY. Almost all computers, therefore, have temporary storage for storing the result of A+B in order to avoid the much longer access time that would be necessary when it came time to multiply. The most common form of temporary storage is a set of registers, like the register described in Section 3.7. Typically, the size of each register is identical to the size of values processed by the ALU, that is, they each contain one word. The LC-3 has eight registers (R0, R1, … R7), each containing 16 bits. Current microprocessors typically contain 32 registers, each consisting of 32 or 64 bits, depending on the architecture. These serve the same purpose as the eight 16-bit registers in the LC-3. However, the importance of temporary storage for values that most modern computers will need shortly means many computers today have an additional set of special purpose registers consisting of 128 bits of information to handle special needs. Those special needs we will have to save for later in your studies. §.§ Input and Output In order for a computer to process information, the information must get into the computer. In order to use the results of that processing, those results must be displayed in some fashion outside the computer. Many devices exist for the purposes of input and output. They are generically referred to in computer jargon as peripherals because they are in some sense accessories peripherals to the processing function. Nonetheless, they are no less important. I/O In the LC-3 we will have the two most basic input and output devices. For input, we will use the keyboard; for output, we will use the monitor.",
    "455": "many computers today have an additional set of special purpose registers consisting of 128 bits of information to handle special needs. Those special needs we will have to save for later in your studies. §.§ Input and Output In order for a computer to process information, the information must get into the computer. In order to use the results of that processing, those results must be displayed in some fashion outside the computer. Many devices exist for the purposes of input and output. They are generically referred to in computer jargon as peripherals because they are in some sense accessories peripherals to the processing function. Nonetheless, they are no less important. I/O In the LC-3 we will have the two most basic input and output devices. For input, we will use the keyboard; for output, we will use the monitor. There are, of course, many other input and output devices in computer systems today. For input we have among other things the mouse, digital scanners, and shopping mall kiosks to help you navigate the shopping mall. For output we have among other things printers, LED displays, disks, and shopping mall kiosks to help you navigate the shopping mall. :-) In the old days, a lot of input and output was carried out by punched cards. Fortunately, for those who would have to lug around boxes of cards, the use of punched cards has largely disappeared. §.§ Control Unit The control unit is like the conductor of an orchestra; it is in charge of making all the other parts of the computer play together. As we will see when we describe the step-by-step process of executing a computer program, it is the control unit that keeps track of both where we are within the process of executing the program and where we are in the process of executing each instruction. To keep track of which instruction is being executed, the control unit has an instruction register to contain that instruction. To keep track of which instruction is to be processed next,",
    "456": "the old days, a lot of input and output was carried out by punched cards. Fortunately, for those who would have to lug around boxes of cards, the use of punched cards has largely disappeared. §.§ Control Unit The control unit is like the conductor of an orchestra; it is in charge of making all the other parts of the computer play together. As we will see when we describe the step-by-step process of executing a computer program, it is the control unit that keeps track of both where we are within the process of executing the program and where we are in the process of executing each instruction. To keep track of which instruction is being executed, the control unit has an instruction register to contain that instruction. To keep track of which instruction is to be processed next, the control unit has a register that contains the next instruction's address. For historical reasons, that register is called the program counter (abbreviated PC), although a better name for it would be the instruction pointer, since the contents of this register are, in some sense, “pointing” to the next instruction to be processed. Curiously, Intel does in fact call that register the instruction pointer, but the simple elegance of that name has not caught on. Instruction RegisterProgram CounterInstruction Pointer § THE LC-3: AN EXAMPLE VON NEUMANN MACHINE In Chapter 5, we will specify in detail the LC-3, a simple computer that we will study extensively. We have already shown you its data path in Chapter 3 (Figure 3.35) and identified several of its structures in Section 4.1. In this section, we will pull together all the parts of the LC-3 we need to describe it as a von Neumann computer (see Figure <ref>). < g r a p h i c s > The LC-3 as an example of the von Neumann model We constructed Figure <ref> by starting with the LC-3's full data path (Figure 3.35) and removing all elements that are not essential to pointing out the five",
    "457": "register the instruction pointer, but the simple elegance of that name has not caught on. Instruction RegisterProgram CounterInstruction Pointer § THE LC-3: AN EXAMPLE VON NEUMANN MACHINE In Chapter 5, we will specify in detail the LC-3, a simple computer that we will study extensively. We have already shown you its data path in Chapter 3 (Figure 3.35) and identified several of its structures in Section 4.1. In this section, we will pull together all the parts of the LC-3 we need to describe it as a von Neumann computer (see Figure <ref>). < g r a p h i c s > The LC-3 as an example of the von Neumann model We constructed Figure <ref> by starting with the LC-3's full data path (Figure 3.35) and removing all elements that are not essential to pointing out the five basic components of the von Neumann model. Note that there are two kinds of arrowheads in Figure <ref>: filled-in and not-filled-in. Filled-in arrowheads denote data elements that flow along the corresponding paths. Not-filled-in arrowheads denote control signals that control the processing of the data elements. For example, the box labeled ALU in the processing unit processes two 16-bit values and produces a 16-bit result. The two sources and the result are all data, and are designated by filled-in arrowheads. The operation performed on those two 16-bit data elements (it is labeled ALUK) is part of the control—therefore, a not-filled-in arrowhead. 1.5pc MEMORY consists of the storage elements, along with the Memory Address Regiser (MAR) for addressing individual locations and the Memory Data Register (MDR) for holding the contents of a memory location on its way to/from the storage. Note that the MAR contains 16 bits, reflecting the fact that the memory address space of the LC-3 is 2^16 memory locations. The MDR contains 16 bits, reflecting the fact that each memory location contains 16 bits—that is, that the LC-3 is 16-bit addressable. INPUT/OUTPUT consists of a keyboard and a monitor. The simplest keyboard requires two registers, a keyboard data register",
    "458": "produces a 16-bit result. The two sources and the result are all data, and are designated by filled-in arrowheads. The operation performed on those two 16-bit data elements (it is labeled ALUK) is part of the control—therefore, a not-filled-in arrowhead. 1.5pc MEMORY consists of the storage elements, along with the Memory Address Regiser (MAR) for addressing individual locations and the Memory Data Register (MDR) for holding the contents of a memory location on its way to/from the storage. Note that the MAR contains 16 bits, reflecting the fact that the memory address space of the LC-3 is 2^16 memory locations. The MDR contains 16 bits, reflecting the fact that each memory location contains 16 bits—that is, that the LC-3 is 16-bit addressable. INPUT/OUTPUT consists of a keyboard and a monitor. The simplest keyboard requires two registers, a keyboard data register (KBDR) for holding the ASCII codes of keys struck, and a keyboard status register (KBSR) for maintaining status information about the keys struck. The simplest monitor also requires two registers, a display data register (DDR) for holding the ASCII code of something to be displayed on the screen, and a display status register (DSR) for maintaining associated status information. These input and output registers will be discussed in detail in Chapter 9. THE PROCESSING UNIT consists of a functional unit (ALU) that performs arithmetic and logic operations and eight registers (R0, … R7) for storing temporary values that will be needed in the near future as operands for subsequent instructions. The LC-3 ALU can perform one arithmetic operation (addition) and two logical operations (bitwise AND and bitwise NOT). THE CONTROL UNIT consists of all the structures needed to*6pt manage the processing that is carried out by the computer. Its most important structure is the finite state machine, which directs all the activity. Recall the finite state machines in Section 3.6. Processing is carried out step by step, or rather, clock cycle by clock cycle. Note the CLK input to the finite state machine in Figure <ref>. It specifies how long",
    "459": "input and output registers will be discussed in detail in Chapter 9. THE PROCESSING UNIT consists of a functional unit (ALU) that performs arithmetic and logic operations and eight registers (R0, … R7) for storing temporary values that will be needed in the near future as operands for subsequent instructions. The LC-3 ALU can perform one arithmetic operation (addition) and two logical operations (bitwise AND and bitwise NOT). THE CONTROL UNIT consists of all the structures needed to*6pt manage the processing that is carried out by the computer. Its most important structure is the finite state machine, which directs all the activity. Recall the finite state machines in Section 3.6. Processing is carried out step by step, or rather, clock cycle by clock cycle. Note the CLK input to the finite state machine in Figure <ref>. It specifies how long each clock cycle lasts. The instruction register (IR) is also an input to the finite state machine since the LC-3 instruction being processed determines what activities must be carried out. The program counter (PC) is also a part of the control unit; it keeps track of the next instruction to be executed after the current instruction finishes. Note that all the external outputs of the finite state machine in Figure 4.3 have arrowheads that are not filled in. These outputs control the processing throughout the computer. For example, one of these outputs (two bits) is ALUK, which controls the operation performed in the ALU (ADD, AND, or NOT) during the current clock cycle. Another output is GateALU, which determines whether or not the output of the ALU is provided to the processor bus during the current clock cycle. The complete description of the data path, control, and finite state machine for one implementation of the LC-3 is the subject of Appendix C. § INSTRUCTION PROCESSING The central idea in the von Neumann model of computer processing is that the program and data are both stored as sequences of bits in the computer's memory, and the program is executed one instruction",
    "460": "the external outputs of the finite state machine in Figure 4.3 have arrowheads that are not filled in. These outputs control the processing throughout the computer. For example, one of these outputs (two bits) is ALUK, which controls the operation performed in the ALU (ADD, AND, or NOT) during the current clock cycle. Another output is GateALU, which determines whether or not the output of the ALU is provided to the processor bus during the current clock cycle. The complete description of the data path, control, and finite state machine for one implementation of the LC-3 is the subject of Appendix C. § INSTRUCTION PROCESSING The central idea in the von Neumann model of computer processing is that the program and data are both stored as sequences of bits in the computer's memory, and the program is executed one instruction at a time under the direction of the control unit. §.§ The Instruction The most basic unit of computer processing is the instruction. It is made up of two parts, the opcode (what the instruction does) and the operands (who it does it to!). opcodeoperand There are fundamentally three kinds of instructions: operates, data movement, and control, although many ISAs have some special instructions that are necessary for those ISAs. Operate instructions operate on data. The LC-3 has three operate instructions: one arithmetic (ADD), and two logicals (AND and NOT). Data movement instructions move information from the processing unit to and from memory and to and from input/output devices. The LC-3 has six data movement instructions. Control instructions are necessary for altering the sequential processing of instructions. That is, normally the next instruction executed is the instruction contained in the next memory location. If a program consists of instructions 1,2,3,4...10 located in memory locations A, A+1, A+2, ...A+9, normally the instructions would be executed in the sequence 1,2,3...10. We will see before we leave Chapter 4, however, that sometimes we will want to change the sequence. Control instructions enable us to do that. An LC-3 instruction consists of 16 bits",
    "461": "have some special instructions that are necessary for those ISAs. Operate instructions operate on data. The LC-3 has three operate instructions: one arithmetic (ADD), and two logicals (AND and NOT). Data movement instructions move information from the processing unit to and from memory and to and from input/output devices. The LC-3 has six data movement instructions. Control instructions are necessary for altering the sequential processing of instructions. That is, normally the next instruction executed is the instruction contained in the next memory location. If a program consists of instructions 1,2,3,4...10 located in memory locations A, A+1, A+2, ...A+9, normally the instructions would be executed in the sequence 1,2,3...10. We will see before we leave Chapter 4, however, that sometimes we will want to change the sequence. Control instructions enable us to do that. An LC-3 instruction consists of 16 bits (one word), numbered from left to right, bit [15] to bit [0]. Bits [15:12] contain the opcode. This means there are at most 2^4 distinct opcodes. Actually, we only use 15 of the possible 4-bit codes. One is reserved for some future use. Bits [11:0] are used to figure out where the operands are. In this chapter we will introduce five of the LC-3's 15 instructions, two operates (ADD and AND), one data movement (LD), and two control (BR and TRAP). We will save for Chapters 5, 8, and 9 the other ten instructions. example example mathmargin@ to 13@ to 7pc1012 Example 9.5117.5pc by 3@ 1.5pcafterheadingafterindentfalse 1012 The ADD Instruction The ADD instruction is an operate instruction that requires three operands: two source operands (the data that is to be added) and one destination operand (where the sum is to be stored after the addition is performed). We said that the processing unit of the LC-3 contained eight registers for purposes of storing data that may be needed later. In fact, the ADD instruction requires that at least one of the two source operands is contained in one of these registers, and that the result of the ADD is put",
    "462": "five of the LC-3's 15 instructions, two operates (ADD and AND), one data movement (LD), and two control (BR and TRAP). We will save for Chapters 5, 8, and 9 the other ten instructions. example example mathmargin@ to 13@ to 7pc1012 Example 9.5117.5pc by 3@ 1.5pcafterheadingafterindentfalse 1012 The ADD Instruction The ADD instruction is an operate instruction that requires three operands: two source operands (the data that is to be added) and one destination operand (where the sum is to be stored after the addition is performed). We said that the processing unit of the LC-3 contained eight registers for purposes of storing data that may be needed later. In fact, the ADD instruction requires that at least one of the two source operands is contained in one of these registers, and that the result of the ADD is put into one of these eight registers. Since there are eight registers, three bits are necessary to identify each register. The 16-bit LC-3 ADD instruction has one of the following two forms (we say formats):28pc9.512 28pc9.512 7.5pc3pt Both formats show the 4-bit opcode for ADD, contained in bits [15:12]: 0001. Bits [11:9] identify the location to be used for storing the result, in this case register 6 (R6). Bits [8:6] identify the register that contains one of the two source operands, in this case R2. The only difference in the two formats is the 1 or 0 stored in bit 5, and what that means. In the first case, bit 5 is 0, signifying that the second source operand is in the register specified by bits [2:0], in this case R6. In the second case, bit 5 is 1, signifying that the second source operand is formed by sign-extending the integer in bits [4:0] to 16 bits. In this case, the second source operand is the positive integer 6. Thus, the instruction we have just encoded is interpreted, depending on whether bit 5 is a 0 or a 1 as either “Add the contents of register 2 (R2) to the contents",
    "463": "result, in this case register 6 (R6). Bits [8:6] identify the register that contains one of the two source operands, in this case R2. The only difference in the two formats is the 1 or 0 stored in bit 5, and what that means. In the first case, bit 5 is 0, signifying that the second source operand is in the register specified by bits [2:0], in this case R6. In the second case, bit 5 is 1, signifying that the second source operand is formed by sign-extending the integer in bits [4:0] to 16 bits. In this case, the second source operand is the positive integer 6. Thus, the instruction we have just encoded is interpreted, depending on whether bit 5 is a 0 or a 1 as either “Add the contents of register 2 (R2) to the contents of register 6 (R6) and store the result back into register 6 (R6),” or \"Add the contents of register 2 (R2) to the positive integer 6 and store the result into register 6. We will use both formats in a program we will write before we leave Chapter 4. 1012 The AND Instruction The AND instruction is also an operate instruction, and it behaves essentially identical to the ADD instruction, except for one thing. Instead of ADDing the two source operands, the AND instruction performs a bit-wise AND of the corresponding bits of the two source operands. For example, the instruction shown below 28pc9.512 7.5pc3pt is an AND instruction since bits [15:12] = 0101. The two sources are R3 and the immediate value 0. The instruction loads R2 with the value 0 since the AND instruction performs a bit-wise AND where the bit of the second operand is always 0. As we shall see, this instruction is a convenient technique for making sure a particular register contains 0 at the start of processing. We refer to this technique as initializing R2 to 0. The LD Instruction The LD instruction requires two operands. LD stands for load, which is computerese for",
    "464": "instruction, and it behaves essentially identical to the ADD instruction, except for one thing. Instead of ADDing the two source operands, the AND instruction performs a bit-wise AND of the corresponding bits of the two source operands. For example, the instruction shown below 28pc9.512 7.5pc3pt is an AND instruction since bits [15:12] = 0101. The two sources are R3 and the immediate value 0. The instruction loads R2 with the value 0 since the AND instruction performs a bit-wise AND where the bit of the second operand is always 0. As we shall see, this instruction is a convenient technique for making sure a particular register contains 0 at the start of processing. We refer to this technique as initializing R2 to 0. The LD Instruction The LD instruction requires two operands. LD stands for load, which is computerese for “go to a particular memory location, read the value that is contained there, and store that value in one of the registers.” The two operands that are required are the value to be read from memory and the destination register which will contain that value after the instruction has completed processing. There are many formulas that can be used for calculating the address of the memory location to be read. Each formula is called an addressing mode.addressing mode The particular addressing mode identified by the use of the opcode LD is called PC+offset. We will see in Chapter 5 that there are other addressing modes in the LC-3 ISA corresponding to other formulas for calculating the address of a memory location. The 16-bit LC-3 LD instruction has the following format: 9.512 The four-bit opcode for LD is 0010. Bits [11:9] identify the register that will contain the value read from memory after the instruction is executed. Bits [8:0] are used to calculate the address of the location to be read. Since the addressing mode for LD is PC+offset, this address is computed by sign-extending the 2's complement integer contained in bits [8:0] to 16 bits, and adding it to the",
    "465": "calculating the address of the memory location to be read. Each formula is called an addressing mode.addressing mode The particular addressing mode identified by the use of the opcode LD is called PC+offset. We will see in Chapter 5 that there are other addressing modes in the LC-3 ISA corresponding to other formulas for calculating the address of a memory location. The 16-bit LC-3 LD instruction has the following format: 9.512 The four-bit opcode for LD is 0010. Bits [11:9] identify the register that will contain the value read from memory after the instruction is executed. Bits [8:0] are used to calculate the address of the location to be read. Since the addressing mode for LD is PC+offset, this address is computed by sign-extending the 2's complement integer contained in bits [8:0] to 16 bits, and adding it to the current contents of the program counter. In summary, the instruction tells the computer to add 198 to the contents of the PC to form the address of a memory location, and to load the contents of that memory location into R2. If bits [8:0] had been 111111001, the instruction would have been interpreted: \"Add -7 to the contents of the PC to form the address of a memory location. §.§ The Instruction Cycle (not the clock cycle!) Instructions are processed under the direction of the control unit in a very systematic, step-by-step manner. The entire sequence of steps needed to process an instruction is called the instruction cycle. instruction cycle The instruction cycle consists of six sequential phases, each phase requiring zero or more steps. We say zero steps to indicate that most computers have been designed such that not all instructions require all six phases. We will discuss this momentarily. instruction cycle!phases of But first, we will examine the six phases of the instruction cycle: FETCH DECODE EVALUATE ADDRESS FETCH OPERANDS EXECUTE STORE RESULT The process is as follows (again refer to Figure <ref>, our simplified version of the LC-3 data path): §.§.§ FETCH The FETCH phase obtains the",
    "466": "PC to form the address of a memory location. §.§ The Instruction Cycle (not the clock cycle!) Instructions are processed under the direction of the control unit in a very systematic, step-by-step manner. The entire sequence of steps needed to process an instruction is called the instruction cycle. instruction cycle The instruction cycle consists of six sequential phases, each phase requiring zero or more steps. We say zero steps to indicate that most computers have been designed such that not all instructions require all six phases. We will discuss this momentarily. instruction cycle!phases of But first, we will examine the six phases of the instruction cycle: FETCH DECODE EVALUATE ADDRESS FETCH OPERANDS EXECUTE STORE RESULT The process is as follows (again refer to Figure <ref>, our simplified version of the LC-3 data path): §.§.§ FETCH The FETCH phase obtains the next instruction from memory and loads it into the instruction register (IR) of the control unit. Recall that a computer program consists of a number of instructions, that each instruction is represented by a sequence of bits, and that the entire program (in the von Neumann model) is stored in the computer's memory. In order to carry out the work of an instruction, we must first identify where it is. The program counter (PC) contains the address of the next instruction to be processed. Thus, the FETCH phase takes the following steps: First the MAR is loaded with the contents of the PC. Next, the memory is interrogated, which results in the next instruction being placed by the memory into the MDR. Finally, the IR is loaded with the contents of the MDR. We are now ready for the next phase, decoding the instruction. However, when the instruction finishes execution, and we wish to fetch the next instruction, we would like the PC to contain the address of the next instruction. This is accomplished by having the FETCH phase perform one more task, it increments the PC. In that way, after the current instruction finishes, the FETCH phase of the",
    "467": "of an instruction, we must first identify where it is. The program counter (PC) contains the address of the next instruction to be processed. Thus, the FETCH phase takes the following steps: First the MAR is loaded with the contents of the PC. Next, the memory is interrogated, which results in the next instruction being placed by the memory into the MDR. Finally, the IR is loaded with the contents of the MDR. We are now ready for the next phase, decoding the instruction. However, when the instruction finishes execution, and we wish to fetch the next instruction, we would like the PC to contain the address of the next instruction. This is accomplished by having the FETCH phase perform one more task, it increments the PC. In that way, after the current instruction finishes, the FETCH phase of the next instruction will load into the IR the contents of the next memory location, provided the execution of the current instruction does not involve changing the value in the PC. The complete description of the FETCH phase is as follows: Step 1: Load the MAR with the contents of the PC, and simultaneously increment the PC. Step 2: Interrogate memory, resulting in the instruction being placed in the MDR. Step 3: Load the IR with the contents of the MDR. =1 Each of these steps is under the direction of the control unit, much like, as we said previously, the instruments in an orchestra are under the control of a conductor's baton. Each stroke of the conductor's baton corresponds to one machine cycle. We will see in Section 4.3.5 that the amount of time taken by each machine cycle is one clock cycle. In fact, we often use the two terms interchangeably. Step 1 takes one clock cycle. Step 2 could take one clock cycle, or many clock cycles, depending on how long it takes to access the computer's memory. Step 3 takes one clock cycle. In a modern digital computer, a clock cycle takes a very small fraction of",
    "468": "resulting in the instruction being placed in the MDR. Step 3: Load the IR with the contents of the MDR. =1 Each of these steps is under the direction of the control unit, much like, as we said previously, the instruments in an orchestra are under the control of a conductor's baton. Each stroke of the conductor's baton corresponds to one machine cycle. We will see in Section 4.3.5 that the amount of time taken by each machine cycle is one clock cycle. In fact, we often use the two terms interchangeably. Step 1 takes one clock cycle. Step 2 could take one clock cycle, or many clock cycles, depending on how long it takes to access the computer's memory. Step 3 takes one clock cycle. In a modern digital computer, a clock cycle takes a very small fraction of a second. Indeed, a 3.1 GHz Intel Core i7 completes 3.1 billion clock cycles in one second. Said another way, one clock cycle takes 0.322 billionths of a second (0.322 nanoseconds). Recall that the light bulb that is helping you read this text is switching on and off at the rate of 60 times a second. Thus, in the time it takes a light bulb to switch on and off once, today's computers can complete more than 51 million clock cycles! §.§.§ DECODE The DECODE phase examines the instruction in order to figure out what the microarchitecture is being asked to do. Recall the decoders we studied in Chapter 3. In the LC-3, a 4-to-16 decoder identifies which of the 16 opcodes is to be processed (even though one of the 16 is not used!). Input is the four-bit opcode IR[15:12]. The output line asserted is the one corresponding to the opcode at the input. Depending on which output of the decoder is asserted, the remaining 12 bits identify what else is needed to process that instruction. §.§.§ EVALUATE ADDRESS This phase computes the address of the memory location that is needed to process the instruction. Recall the example of",
    "469": "it takes a light bulb to switch on and off once, today's computers can complete more than 51 million clock cycles! §.§.§ DECODE The DECODE phase examines the instruction in order to figure out what the microarchitecture is being asked to do. Recall the decoders we studied in Chapter 3. In the LC-3, a 4-to-16 decoder identifies which of the 16 opcodes is to be processed (even though one of the 16 is not used!). Input is the four-bit opcode IR[15:12]. The output line asserted is the one corresponding to the opcode at the input. Depending on which output of the decoder is asserted, the remaining 12 bits identify what else is needed to process that instruction. §.§.§ EVALUATE ADDRESS This phase computes the address of the memory location that is needed to process the instruction. Recall the example of the LD instruction: The LD instruction causes a value stored in memory to be loaded into a register. In that example, the address was obtained by sign-extending bits [8:0] of the instruction to 16 bits, and adding that value to the current contents of the PC. This calculation was performed during the EVALUATE ADDRESS phase. It is worth noting that not all instructions access memory to load or store data. For example, we have already seen that the ADD and AND instructions in the LC-3 obtain their source operands from registers or from the instruction itself, and store the result of the ADD or AND instruction in a register. For those instructions, the EVALUATE ADDRESS phase is not needed. §.§.§ FETCH OPERANDS This phase obtains the source operands needed to process the instruction. In the LD example, this phase took two steps: loading MAR with the address calculated in the EVALUATE ADDRESS phase, and reading memory, which resulted in the source operand being placed in MDR. In the ADD example, this phase consisted of obtaining the source operands from R2 and R6. In most current microprocessors, this phase (for the ADD instruction) can be done at the same time the",
    "470": "not all instructions access memory to load or store data. For example, we have already seen that the ADD and AND instructions in the LC-3 obtain their source operands from registers or from the instruction itself, and store the result of the ADD or AND instruction in a register. For those instructions, the EVALUATE ADDRESS phase is not needed. §.§.§ FETCH OPERANDS This phase obtains the source operands needed to process the instruction. In the LD example, this phase took two steps: loading MAR with the address calculated in the EVALUATE ADDRESS phase, and reading memory, which resulted in the source operand being placed in MDR. In the ADD example, this phase consisted of obtaining the source operands from R2 and R6. In most current microprocessors, this phase (for the ADD instruction) can be done at the same time the instruction is being executed (the 5th phase of the instruction cycle). Exactly how we can speed up the processing of an instruction in this way is a fascinating subject, but one we are forced to leave for later in your education. §.§.§ EXECUTE This phase carries out the execution of the instruction. In the ADD example, this phase consisted of the step of performing the addition in the ALU. §.§.§ STORE RESULT The final phase of an instruction's execution. The result is written to its designated destination. In the case of the ADD instruction, in many computers this action is performed during the EXECUTE phase. That is, in many computers, including the LC-3, an ADD instruction can fetch its source operands, perform the ADD in the ALU, and store the result in the destination register all in a single clock cycle. A separate STORE RESULT phase is not needed. Once the instruction cycle has been completed, the control unit begins the instruction cycle for the next instruction, starting from the top with the FETCH phase. Since the PC was updated during the previous instruction cycle, it contains at this point the address of the instruction stored in the next sequential",
    "471": "the step of performing the addition in the ALU. §.§.§ STORE RESULT The final phase of an instruction's execution. The result is written to its designated destination. In the case of the ADD instruction, in many computers this action is performed during the EXECUTE phase. That is, in many computers, including the LC-3, an ADD instruction can fetch its source operands, perform the ADD in the ALU, and store the result in the destination register all in a single clock cycle. A separate STORE RESULT phase is not needed. Once the instruction cycle has been completed, the control unit begins the instruction cycle for the next instruction, starting from the top with the FETCH phase. Since the PC was updated during the previous instruction cycle, it contains at this point the address of the instruction stored in the next sequential memory location. Thus the next sequential instruction is fetched next. Processing continues in this way until something breaks this sequential flow, or the program finishes execution. It is worth noting again that although the instruction cycle consists of six phases, not all instructions require all six phases. As already pointed out, the LC-3 ADD instruction does not require a separate EVALUATE ADDRESS phase or a separate STORE RESULT phase. The LC-3 LD instruction does not require an EXECUTE phase. On the other hand, there are instructions in other ISAs that require all six phases. example example mathmargin@ to 13@ to 7pc1012 Example 9.5117.5pc by 3@ 1.5pcafterheadingafterindentfalse ADD [eax], edx This is an example of an Intel x86 instruction that requires all six phases of the instruction cycle. All instructions require the first two phases, FETCH and DECODE. This instruction uses the eax register to calculate the address of a memory location (EVALUATE ADDRESS). The contents of that memory location are then read (FETCH OPERAND), added to the contents of the edx register (EXECUTE), and the result written into the memory location that originally contained the first source operand (STORE RESULT). §.§ Changing the Sequence of Execution Everything we have said",
    "472": "EVALUATE ADDRESS phase or a separate STORE RESULT phase. The LC-3 LD instruction does not require an EXECUTE phase. On the other hand, there are instructions in other ISAs that require all six phases. example example mathmargin@ to 13@ to 7pc1012 Example 9.5117.5pc by 3@ 1.5pcafterheadingafterindentfalse ADD [eax], edx This is an example of an Intel x86 instruction that requires all six phases of the instruction cycle. All instructions require the first two phases, FETCH and DECODE. This instruction uses the eax register to calculate the address of a memory location (EVALUATE ADDRESS). The contents of that memory location are then read (FETCH OPERAND), added to the contents of the edx register (EXECUTE), and the result written into the memory location that originally contained the first source operand (STORE RESULT). §.§ Changing the Sequence of Execution Everything we have said thus far happens when a computer program is executed in sequence. That is, the first instruction is executed, then the second instruction is executed, followed by the third instruction, and so on. We have identified two types of instructions, the ADD and AND, which are examples of operate instructions in that they operate on data, and the LD, which is an example of a data movement instruction in that it moves data from one place to another. There are other examples of both operate instructions and data movement instructions, as we will discover in Chapter 5 when we study the LC-3 in greater detail. operate instructionsdata movement instructions There is a third type of instruction, the control instruction, whose purpose is to change control instructions the sequence of instruction execution. For example, there are times, as we shall see very soon, when it is desirable to first execute the first instruction, then the second, then the third, then the first again, the second again, then the third again, then the first for the third time, the second for the third time, and so on. As we know, each instruction cycle starts with loading the MAR with the PC. Thus, if",
    "473": "an example of a data movement instruction in that it moves data from one place to another. There are other examples of both operate instructions and data movement instructions, as we will discover in Chapter 5 when we study the LC-3 in greater detail. operate instructionsdata movement instructions There is a third type of instruction, the control instruction, whose purpose is to change control instructions the sequence of instruction execution. For example, there are times, as we shall see very soon, when it is desirable to first execute the first instruction, then the second, then the third, then the first again, the second again, then the third again, then the first for the third time, the second for the third time, and so on. As we know, each instruction cycle starts with loading the MAR with the PC. Thus, if we wish to change the sequence of instructions executed, we must change the contents of the PC between the time it is incremented (during the FETCH phase of one instruction) and the start of the FETCH phase of the next instruction. Control instructions perform that function by loading the PC during the EXECUTE phase, which wipes out the incremented PC that was loaded during the FETCH phase. The result is that, at the start of the next instruction cycle, when the computer accesses the PC to obtain the address of an instruction to fetch, it will get the address loaded during the previous instruction's EXECUTE phase, rather than the next sequential instruction in the computer's program. The most common control instruction is the conditional branch (BR), which either changes the contents of the PC or does not change the contents of the PC, depending on the result of a previous instruction (usually the instruction that is executed immediately before the conditional branch instruction). The BR Instruction The BR instruction consists of three parts, the opcode (bits [15:12] = 0000), the condition to be tested (bits [11:9]), and the addressing mode bits (bits [8:0]) which are used to form the address",
    "474": "that was loaded during the FETCH phase. The result is that, at the start of the next instruction cycle, when the computer accesses the PC to obtain the address of an instruction to fetch, it will get the address loaded during the previous instruction's EXECUTE phase, rather than the next sequential instruction in the computer's program. The most common control instruction is the conditional branch (BR), which either changes the contents of the PC or does not change the contents of the PC, depending on the result of a previous instruction (usually the instruction that is executed immediately before the conditional branch instruction). The BR Instruction The BR instruction consists of three parts, the opcode (bits [15:12] = 0000), the condition to be tested (bits [11:9]), and the addressing mode bits (bits [8:0]) which are used to form the address to be loaded into the PC if the result of the previous instruction agrees with the test specified by bits [11:9]. The addressing mode, i.e., the mechanism used to determine the actual address is the same one we used in the LD instruction. Bits [8:0] are sign-extended to 16 bits and then added to the current contents of the PC. Suppose the BR instruction shown below is located in memory location x36C9. 28pc The opcode 0000 identifies the instruction as a conditional branch. Bits [11:9] = 101 specifies that the test to be performed on the most recent result is whether or not that result is something other than 0. In Chapter 5 we will describe in detail all the tests that can be performed on the most recent result. For now, we will just use one test: Is the result not zero? Bits [8:0] is the value -6. Assume the previous instruction executed (in memory location x36C8) was an ADD instruction and the result of the ADD was 0. Since the test \"not-zero\" failed, the BR instruction would do nothing during its EXECUTE phase, and so the next instruction executed would be the instruction at M[x36CA], the address formed",
    "475": "Suppose the BR instruction shown below is located in memory location x36C9. 28pc The opcode 0000 identifies the instruction as a conditional branch. Bits [11:9] = 101 specifies that the test to be performed on the most recent result is whether or not that result is something other than 0. In Chapter 5 we will describe in detail all the tests that can be performed on the most recent result. For now, we will just use one test: Is the result not zero? Bits [8:0] is the value -6. Assume the previous instruction executed (in memory location x36C8) was an ADD instruction and the result of the ADD was 0. Since the test \"not-zero\" failed, the BR instruction would do nothing during its EXECUTE phase, and so the next instruction executed would be the instruction at M[x36CA], the address formed by incrementing the PC during the FETCH phase of the BR instruction's instruction cycle. On the other hand, if the result of the ADD instruction is not 0, then the test succeeds, causing the BR instruction to load PC with x36C4, the address formed by sign-extending bits [8:0] to 16 bits and adding that value (-6) to the incremented PC (x36CA). Thus the next instruction executed after the BR instruction at x36C9 is either the instruction at x36CA or the one at x36C4, depending on whether the result of the ADD instruction was zero or not zero. §.§ Control of the Instruction Cycle The instruction cycle is controlled by a synchronous finite state machine. An abbreviated version of its state diagram, highlighting a few of the LC-3 instructions discussed in this chapter is shown in Figure <ref>. As is the case with the finite state machines studied in Section 3.6, each state corresponds to one machine cycle of activity which takes one clock cycle to perform. The processing controlled by each state is described within the node representing that state. The arcs show the next state transitions. Processing starts with state 1. The FETCH phase takes three clock cycles, corresponding",
    "476": "(x36CA). Thus the next instruction executed after the BR instruction at x36C9 is either the instruction at x36CA or the one at x36C4, depending on whether the result of the ADD instruction was zero or not zero. §.§ Control of the Instruction Cycle The instruction cycle is controlled by a synchronous finite state machine. An abbreviated version of its state diagram, highlighting a few of the LC-3 instructions discussed in this chapter is shown in Figure <ref>. As is the case with the finite state machines studied in Section 3.6, each state corresponds to one machine cycle of activity which takes one clock cycle to perform. The processing controlled by each state is described within the node representing that state. The arcs show the next state transitions. Processing starts with state 1. The FETCH phase takes three clock cycles, corresponding to the three steps described earlier. In the first clock cycle, the MAR is loaded with the contents of the PC, and the PC is incremented. In order for the contents of the PC to be loaded into the MAR (see Figure <ref>), the finite state machine must assert GatePC and LD.MAR. GatePC connects the PC to the processor bus. LD.MAR, the write enable signal of the MAR register, loads the contents of the bus into the MAR at the end of the current clock cycle. (Registers are loaded at the end of the clock cycle if the corresponding control signal is asserted.) < g r a p h i c s > An abbreviated state diagram of the LC-3 In order for the PC to be incremented (again, see Figure <ref>), the finite state machine must assert the PCMUX select lines to choose the output of the box labeled +1 and must also assert the LD.PC signal to load the output of the PCMUX into the PC at the end of the current cycle. The finite state machine then goes to state 2. Here, the MDR is loaded with the instruction, which is read from memory. In state 3,",
    "477": "LD.MAR, the write enable signal of the MAR register, loads the contents of the bus into the MAR at the end of the current clock cycle. (Registers are loaded at the end of the clock cycle if the corresponding control signal is asserted.) < g r a p h i c s > An abbreviated state diagram of the LC-3 In order for the PC to be incremented (again, see Figure <ref>), the finite state machine must assert the PCMUX select lines to choose the output of the box labeled +1 and must also assert the LD.PC signal to load the output of the PCMUX into the PC at the end of the current cycle. The finite state machine then goes to state 2. Here, the MDR is loaded with the instruction, which is read from memory. In state 3, the instruction is transferred from the MDR to the instruction register (IR). This requires the finite state machine to assert GateMDR and LD.IR, which causes the IR to be loaded at the end of the clock cycle, concluding the FETCH phase of the instruction cycle. The DECODE phase takes one clock cycle. In state 4, using the external input IR, and in particular the opcode bits of the instruction, the finite state machine can go to the appropriate next state for processing instructions depending on the particular opcode in IR[15:12]. Three of the 15 paths out of State 4 are shown. Processing continues clock cycle by clock cycle until the instruction completes execution, and the next state logic returns the finite state machine to state 1. As has already been discussed, it is sometimes necessary not to execute the next sequential instruction but rather to access another location to find the next instruction to execute. As we have said, instructions that change the flow of instruction processing in this way are called control instructions. In the case of the conditional branch instruction (BR), at the end of its instruction cycle, the PC contains one of two addresses: Either the incremented",
    "478": "and in particular the opcode bits of the instruction, the finite state machine can go to the appropriate next state for processing instructions depending on the particular opcode in IR[15:12]. Three of the 15 paths out of State 4 are shown. Processing continues clock cycle by clock cycle until the instruction completes execution, and the next state logic returns the finite state machine to state 1. As has already been discussed, it is sometimes necessary not to execute the next sequential instruction but rather to access another location to find the next instruction to execute. As we have said, instructions that change the flow of instruction processing in this way are called control instructions. In the case of the conditional branch instruction (BR), at the end of its instruction cycle, the PC contains one of two addresses: Either the incremented PC which was loaded in State 1 or the new address computed from sign-extending bits [8:0] of the BR instruction and adding it to the PC, which was loaded in State 63. Which address gets loaded into the PC depends on the test of the most recent result. Appendix C contains a full description of the implementation of the LC-3, including its full state diagram and data path. We will not go into that level of detail in this chapter. Our objective here is to show you that there is nothing magic about the processing of the instruction cycle, and that a properly completed state diagram would be able to control, clock cycle by clock cycle, all the steps required to execute all the phases of every instruction cycle. Since each instruction cycle ends by returning to state 1, the finite state machine can process, clock cycle by clock cycle, a complete computer program. §.§ Halting the Computer (the TRAP instruction) From everything we have said, it appears that the computer will continue processing instructions, carrying out the instruction cycle again and again, ad nauseum. Since the computer does not have the capacity to be bored, must this continue until",
    "479": "including its full state diagram and data path. We will not go into that level of detail in this chapter. Our objective here is to show you that there is nothing magic about the processing of the instruction cycle, and that a properly completed state diagram would be able to control, clock cycle by clock cycle, all the steps required to execute all the phases of every instruction cycle. Since each instruction cycle ends by returning to state 1, the finite state machine can process, clock cycle by clock cycle, a complete computer program. §.§ Halting the Computer (the TRAP instruction) From everything we have said, it appears that the computer will continue processing instructions, carrying out the instruction cycle again and again, ad nauseum. Since the computer does not have the capacity to be bored, must this continue until someone pulls the plug and disconnects power to the computer? Usually, user programs execute under the control of an operating system. Linux, DOS, MacOS, and Windows are all examples of operating systems. Operating systems are just computer programs themselves. As far as the computer is concerned, the instruction cycle continues whether a user program is being processed or the operating system is being processed. This is fine as far as user programs are concerned since each user program terminates with a control instruction that changes the PC to again start processing the operating system—often to initiate the execution of another user program. < g r a p h i c s > The clock circuit and its control6pt But what if we actually want to stop this potentially infinite sequence of instruction cycles? Recall our analogy to the conductor's baton, beating at the rate of billions of clock cycles per second. Stopping the instruction sequencing requires stopping the conductor's baton. We have pointed out many times that there is inside the computer a component that corresponds very closely to the conductor's baton. It is called the clock, and it defines the amount of time each machine cycle takes. We saw",
    "480": "system is being processed. This is fine as far as user programs are concerned since each user program terminates with a control instruction that changes the PC to again start processing the operating system—often to initiate the execution of another user program. < g r a p h i c s > The clock circuit and its control6pt But what if we actually want to stop this potentially infinite sequence of instruction cycles? Recall our analogy to the conductor's baton, beating at the rate of billions of clock cycles per second. Stopping the instruction sequencing requires stopping the conductor's baton. We have pointed out many times that there is inside the computer a component that corresponds very closely to the conductor's baton. It is called the clock, and it defines the amount of time each machine cycle takes. We saw in Chapter 3 that the clock enables the synchronous finite state machine to continue on to the next clock cycle. In Chapter 3 the next clock cycle corresponded to the next state of the danger sign we designed. Here the next clock cycle corresponds to the next state of the instruction cycle which is either the next state of the current phase of the instruction cycle, or the first state of the next phase of the instruction cycle. Stopping the instruction cycle requires stopping the clock. Figure <ref>a shows a block diagram of the clock circuit, consisting primarily of a clock generator and a RUN latch. The clock generator is a crystal run latch oscillator, a piezoelectric device that you may have studied in your physics or chemistry class. For our purposes, the crystal oscillator is a black box (recall our definition of black box in Section 1.4) that produces the oscillating voltage shown in Figure <ref>b. Note the resemblance of that voltage to the conductor's baton. Every clock cycle, the voltage rises to 1.2 volts and then drops back to 0 volts. If the RUN latch is in the 1 state (i.e., Q=1), the output of the clock circuit",
    "481": "current phase of the instruction cycle, or the first state of the next phase of the instruction cycle. Stopping the instruction cycle requires stopping the clock. Figure <ref>a shows a block diagram of the clock circuit, consisting primarily of a clock generator and a RUN latch. The clock generator is a crystal run latch oscillator, a piezoelectric device that you may have studied in your physics or chemistry class. For our purposes, the crystal oscillator is a black box (recall our definition of black box in Section 1.4) that produces the oscillating voltage shown in Figure <ref>b. Note the resemblance of that voltage to the conductor's baton. Every clock cycle, the voltage rises to 1.2 volts and then drops back to 0 volts. If the RUN latch is in the 1 state (i.e., Q=1), the output of the clock circuit is the same as the output of the clock generator. If the RUN latch is in the 0 state (i.e., Q=0), the output of the clock circuit is 0. Thus, stopping the instruction cycle requires only clearing the RUN latch. Every computer has some mechanism for doing that. In some older machines, it is done by executing a HALT instruction. In the LC-3, as in many other machines, it is done under control of the operating system, as we will see in Chapter 9. For now it is enough to know that if a user program requires help from the operating system, it requests that help with the TRAP instruction (opcode = 1111) and an 8-bit code called a trap vector which identifies the help that the user program needs. The 8-bit code x25 tells the operating system that the program has finished executing and the computer can stop processing instructions. Question: If a HALT instruction can clear the RUN latch, thereby stopping the instruction cycle, what instruction is needed to set the RUN latch, thereby reinitiating[-3.6pc] the instruction cycle? Hint: This is a trick question! § OUR FIRST PROGRAM: A MULTIPLICATION ALGORITHM We now have all that we need",
    "482": "In the LC-3, as in many other machines, it is done under control of the operating system, as we will see in Chapter 9. For now it is enough to know that if a user program requires help from the operating system, it requests that help with the TRAP instruction (opcode = 1111) and an 8-bit code called a trap vector which identifies the help that the user program needs. The 8-bit code x25 tells the operating system that the program has finished executing and the computer can stop processing instructions. Question: If a HALT instruction can clear the RUN latch, thereby stopping the instruction cycle, what instruction is needed to set the RUN latch, thereby reinitiating[-3.6pc] the instruction cycle? Hint: This is a trick question! § OUR FIRST PROGRAM: A MULTIPLICATION ALGORITHM We now have all that we need to write our first program. We have a data movement instruction LD to load data from memory into a register, we have two operate instructions, ADD for performing arithmetic and AND for performing a bit-wise logical operation. We have a control instruction BR for loading the PC with an address different from the incremented PC so the instruction to be executed next will NOT be the instruction in the next sequential location in memory. And we have the TRAP instruction (aka system call) which allows us to ask the operating system for help, in this case to stop the computer. With all that under our belt, we can write our first program. Suppose the computer does not know how to multiply two positive integers. In the old days, that was true for a lot of computers! They had ADD instructions, but they did not have multiply instructions. What to do? Suppose we wanted to multiply 5 times 4. Even if we do not know how to multiply, if we know that 5 times 4 is 5+5+5+5, and the computer has an ADD instruction, we can write a program that can multiply. All we have to do is add 5 to",
    "483": "executed next will NOT be the instruction in the next sequential location in memory. And we have the TRAP instruction (aka system call) which allows us to ask the operating system for help, in this case to stop the computer. With all that under our belt, we can write our first program. Suppose the computer does not know how to multiply two positive integers. In the old days, that was true for a lot of computers! They had ADD instructions, but they did not have multiply instructions. What to do? Suppose we wanted to multiply 5 times 4. Even if we do not know how to multiply, if we know that 5 times 4 is 5+5+5+5, and the computer has an ADD instruction, we can write a program that can multiply. All we have to do is add 5 to itself four times. Figure <ref> illustrates the process. < g r a p h i c s > Flowchart for an algorithm that multiplies two positive integers Let us assume that memory location x3007, abbreviated M[x3007], contains the value 5, and M[x3008] contains the value 4. We start by copying the two values from memory to the two registers R1 and R2. We are going to accumulate the results of the additions in R3 so we initialize R3 to 0. Then we add 5 to R3, and subtract 1 from R2 so we will know how many more times we will need to add 5 to R3. We keep doing this (adding 5 to R3 and subtracting 1 from R2) until R2 contains the value 0. That tells us that we have added 5 to R3 four times and we are done, so we HALT the computer. R3 contains the value 20, the result of our multiplication. Figure <ref> shows the actual LC-3 program, stored in memory locations x3000 to x3008. The Program Counter, which keeps track of the next instruction to be executed, initially contains the address x3000. To move the data from memory locations M[x3007] and M[x3008] to",
    "484": "and R2. We are going to accumulate the results of the additions in R3 so we initialize R3 to 0. Then we add 5 to R3, and subtract 1 from R2 so we will know how many more times we will need to add 5 to R3. We keep doing this (adding 5 to R3 and subtracting 1 from R2) until R2 contains the value 0. That tells us that we have added 5 to R3 four times and we are done, so we HALT the computer. R3 contains the value 20, the result of our multiplication. Figure <ref> shows the actual LC-3 program, stored in memory locations x3000 to x3008. The Program Counter, which keeps track of the next instruction to be executed, initially contains the address x3000. To move the data from memory locations M[x3007] and M[x3008] to R1 and R2, we use the data movement instruction LD. The LC-3 computer executes the LD instruction in M[x3000] by sign-extending the offset (in this case 6) to 16 bits, adding it to the incremented PC (in this case x3001 since we incremented the PC during the FETCH phase of this instruction), fetching the data from M[x3007], and loading it in R1. The LD instruction in M[x3001] is executed in the same way. R3 is initialized to 0 by performing a bit-wise AND of the contents of R3 with the sign-extended immediate value 0, and loading the result into R3. Next the computer executes the ADD instructions at M[x3003] and M[x3004]. The ADD instruction at M[x3003] adds the contents of R1 to the contents of R3, and loads the result into R3. The ADD instruction at M[x3004] adds -1 to the contents of R2, which keeps track of how many times the value 5 has been added to R3. At this point, the PC contains the address x3005. The BR instruction in M[x3005] loads the PC with the address x3003 if the result of the previous instruction (the one in M[x3004]) is not 0. If the result of the previous",
    "485": "in R1. The LD instruction in M[x3001] is executed in the same way. R3 is initialized to 0 by performing a bit-wise AND of the contents of R3 with the sign-extended immediate value 0, and loading the result into R3. Next the computer executes the ADD instructions at M[x3003] and M[x3004]. The ADD instruction at M[x3003] adds the contents of R1 to the contents of R3, and loads the result into R3. The ADD instruction at M[x3004] adds -1 to the contents of R2, which keeps track of how many times the value 5 has been added to R3. At this point, the PC contains the address x3005. The BR instruction in M[x3005] loads the PC with the address x3003 if the result of the previous instruction (the one in M[x3004]) is not 0. If the result of the previous instruction is 0, the BR instruction does nothing and so the next instruction to be executed is the instruction at M[x3006], i.e., the incremented PC is x3006. Thus the two ADD instructions execute again and again, until the result of executing the instruction in M[x3004] produces the value 0, indicating that the value 5 has been added four times. Finally, the TRAP instruction in M[x3006] is executed, which is a call to the operating system to halt the computer. 36pc A program that multiplies without a multiply instruction 4.1 Name the five components of the von Neumann model. For each component, state its purpose. 4.2 Briefly describe the interface between the memory and the processing unit. That is, describe the method by which the memory and the processing unit communicate. 4.3 What is misleading about the name program counter? Why is the name instruction pointer more insightful? 4.4 What is the word length of a computer? How does the word length of a computer affect what the computer is able to compute? That is, is it a valid argument, in light of what you learned in Chapter 1, to say that a computer with a larger word size can process",
    "486": "the TRAP instruction in M[x3006] is executed, which is a call to the operating system to halt the computer. 36pc A program that multiplies without a multiply instruction 4.1 Name the five components of the von Neumann model. For each component, state its purpose. 4.2 Briefly describe the interface between the memory and the processing unit. That is, describe the method by which the memory and the processing unit communicate. 4.3 What is misleading about the name program counter? Why is the name instruction pointer more insightful? 4.4 What is the word length of a computer? How does the word length of a computer affect what the computer is able to compute? That is, is it a valid argument, in light of what you learned in Chapter 1, to say that a computer with a larger word size can process more information and therefore is capable of computing more than a computer with a smaller word size? 4.5 The following table represents a small memory. Refer to this table for the following questions. 0pt10ptAddress0pt10pt Data 0pt10pt00000pt10pt 0001 1110 0100 0011 0001 1111 0000 0010 0101 0010 0110 1111 0000 0001 0011 0000 0000 0000 0000 0100 0000 0000 0110 0101 0101 0000 0000 0000 0110 0110 1111 1110 1101 0011 0pt10pt 01110pt10pt 0000 0110 1101 1001 a. What binary value does location 3 contain? Location 6? b. The binary value within each location can be interpreted in many ways. We have seen that binary values can represent unsigned numbers, 2's complement signed numbers, floating point numbers, and so forth. (1) Interpret location 0 and location 1 as 2's complement integers. (2) Interpret location 4 as an ASCII value. (3) Interpret locations 6 and 7 as an IEEE floating point number. Location 6 contains number [15:0]. Location 7 contains number [31:16]. (4) Interpret location 0 and location 1 as unsigned integers. c. In the von Neumann model, the contents of a memory location can also be an instruction. If the binary pattern in location 0 were interpreted as an instruction, what",
    "487": "0101 0000 0000 0000 0110 0110 1111 1110 1101 0011 0pt10pt 01110pt10pt 0000 0110 1101 1001 a. What binary value does location 3 contain? Location 6? b. The binary value within each location can be interpreted in many ways. We have seen that binary values can represent unsigned numbers, 2's complement signed numbers, floating point numbers, and so forth. (1) Interpret location 0 and location 1 as 2's complement integers. (2) Interpret location 4 as an ASCII value. (3) Interpret locations 6 and 7 as an IEEE floating point number. Location 6 contains number [15:0]. Location 7 contains number [31:16]. (4) Interpret location 0 and location 1 as unsigned integers. c. In the von Neumann model, the contents of a memory location can also be an instruction. If the binary pattern in location 0 were interpreted as an instruction, what instruction would it represent? d. A binary value can also be interpreted as a memory address. Say the value stored in location 5 is a memory address. To which location does it refer? What binary value does that location contain? 4.6 What are the two components of an instruction? What information do these two components contain? 4.7 Suppose a 32-bit instruction takes the following format: 0pt10ptOPCODE0pt10pt SR DR IMM If there are 60 opcodes and 32 registers, what is the range of values that can be represented by the immediate (IMM)? Assume IMM is a 2's complement value. 4.8 Suppose a 32-bit instruction takes the following format: 0pt10ptOPCODE0pt10pt DR SR1 SR2 UNUSED If there are 225 opcodes and 120 registers, a. What is the minimum number of bits required to represent the OPCODE? b. What is the minimum number of bits required to represent the Destination Register (DR)? c. What is maximum number of UNUSED bits in the instruction encoding? 4.9 The FETCH phase of the instruction cycle does two important things. One is that it loads the instruction to be processed next into the IR. What is the other important thing? - 4.10 Examples 4.1, 4.2, and 4.5 illustrate",
    "488": "instruction takes the following format: 0pt10ptOPCODE0pt10pt SR DR IMM If there are 60 opcodes and 32 registers, what is the range of values that can be represented by the immediate (IMM)? Assume IMM is a 2's complement value. 4.8 Suppose a 32-bit instruction takes the following format: 0pt10ptOPCODE0pt10pt DR SR1 SR2 UNUSED If there are 225 opcodes and 120 registers, a. What is the minimum number of bits required to represent the OPCODE? b. What is the minimum number of bits required to represent the Destination Register (DR)? c. What is maximum number of UNUSED bits in the instruction encoding? 4.9 The FETCH phase of the instruction cycle does two important things. One is that it loads the instruction to be processed next into the IR. What is the other important thing? - 4.10 Examples 4.1, 4.2, and 4.5 illustrate the processing of the ADD, LDR, and JMP instructions. The PC, IR, MAR, and MDR are written in various phases of the instruction cycle, depending on the opcode of the particular instruction. In each location in the table below, enter the opcodes which write to the corresponding register (row) during the corresponding phase (column) of the instruction cycle. 913 Fetch Evaluate Fetch Store Instruction Decode Address Data Execute Result 0pt10ptPC0pt10pt 0pt10ptIR0pt10pt 0pt10ptMAR0pt10pt 0pt10ptMDR0pt10pt 4.11 State the phases of the instruction cycle and briefly describe what operations occur in each phase. 4.12 For the instructions ADD, LDR, and JMP, write the operations that occur in each phase of the instruction cycle. 4.13 Say it takes 100 cycles to read from or write to memory and only one cycle to read from or write to a register. Calculate the number of cycles it takes for each phase of the instruction cycle for both the IA-32 instruction “ADD [eax], edx” (refer to Example 4.3) and the LC-3 instruction “ADD R6, R2, R6.” Assume each phase (if required) takes one cycle, unless a memory access is required. 4.14 Describe the execution of the JMP instruction if R3 contains x369C (refer to Example 4.5). 4.15",
    "489": "Evaluate Fetch Store Instruction Decode Address Data Execute Result 0pt10ptPC0pt10pt 0pt10ptIR0pt10pt 0pt10ptMAR0pt10pt 0pt10ptMDR0pt10pt 4.11 State the phases of the instruction cycle and briefly describe what operations occur in each phase. 4.12 For the instructions ADD, LDR, and JMP, write the operations that occur in each phase of the instruction cycle. 4.13 Say it takes 100 cycles to read from or write to memory and only one cycle to read from or write to a register. Calculate the number of cycles it takes for each phase of the instruction cycle for both the IA-32 instruction “ADD [eax], edx” (refer to Example 4.3) and the LC-3 instruction “ADD R6, R2, R6.” Assume each phase (if required) takes one cycle, unless a memory access is required. 4.14 Describe the execution of the JMP instruction if R3 contains x369C (refer to Example 4.5). 4.15 If a HALT instruction can clear the RUN latch, thereby stopping the instruction cycle, what instruction is needed to set the RUN latch, thereby reinitiating the instruction cycle? 4.16 a. If a machine cycle is 2 nanoseconds (i.e., 2· 10^-9 seconds), how many machine cycles occur each second? b. If the computer requires on the average eight cycles to process each instruction, and the computer processes instructions one at a time from beginning to end, how many instructions can the computer process in 1 second? - c. Preview of future courses: In today's microprocessors, many features are added to increase the number of instructions processed each second. One such feature is the computer's equivalent of an assembly line. Each phase of the instruction cycle is implemented as one or more separate pieces of logic. Each step in the processing of an instruction picks up where the previous step left off in the previous machine cycle. Using this feature, an instruction can be fetched from memory every machine cycle and handed off at the end of the machine cycle to the decoder, which performs the decoding function during the next machine cycle while the next instruction is being fetched. Ergo, the",
    "490": "each instruction, and the computer processes instructions one at a time from beginning to end, how many instructions can the computer process in 1 second? - c. Preview of future courses: In today's microprocessors, many features are added to increase the number of instructions processed each second. One such feature is the computer's equivalent of an assembly line. Each phase of the instruction cycle is implemented as one or more separate pieces of logic. Each step in the processing of an instruction picks up where the previous step left off in the previous machine cycle. Using this feature, an instruction can be fetched from memory every machine cycle and handed off at the end of the machine cycle to the decoder, which performs the decoding function during the next machine cycle while the next instruction is being fetched. Ergo, the assembly line. Assuming instructions are located at sequential addresses in memory, and nothing breaks the sequential flow, how many instructions can the microprocessor execute each second if the assembly line is present? (The assembly line is called a pipeline, which you will encounter in your advanced courses. There are many reasons why the assembly line cannot operate at its maximum rate, a topic you will consider at length in some of these courses.) 4.17STAR In this problem we perform five successive accesses to memory. The table below shows for each access whether it is a read (Load) or write (Store), and the contents of the MAR and MDR at the completion of the access. Some entries are not shown. Note that we have shortened the addressibility to 5 bits, rather than the 16 bits that we are used to in the LC-3 in order to decrease the excess writing you would have to do. t]c|c|c|c|c|c|c|c|1c 7cOperations on Memory 2-81c| R/W MAR 5c|MDR 2-8 Operation 1 W 1 1 1 1 0 2-82-8 Operation 2 2-8 Operation 3 W 1 0 2-8 Operation 4 2-8 Operation 5 2-8 The three tables below show the contents of memory locations x4000 to x4004",
    "491": "rate, a topic you will consider at length in some of these courses.) 4.17STAR In this problem we perform five successive accesses to memory. The table below shows for each access whether it is a read (Load) or write (Store), and the contents of the MAR and MDR at the completion of the access. Some entries are not shown. Note that we have shortened the addressibility to 5 bits, rather than the 16 bits that we are used to in the LC-3 in order to decrease the excess writing you would have to do. t]c|c|c|c|c|c|c|c|1c 7cOperations on Memory 2-81c| R/W MAR 5c|MDR 2-8 Operation 1 W 1 1 1 1 0 2-82-8 Operation 2 2-8 Operation 3 W 1 0 2-8 Operation 4 2-8 Operation 5 2-8 The three tables below show the contents of memory locations x4000 to x4004 before the first access, after the third access, and after the fifth access. Again, not all entries are shown. We have added an unusual constraint to this problem in order to get one correct answer. The MDR can ONLY be loaded from memory as a result of a Load (Read) access. < g r a p h i c s > Your job: Fill in the missing entries. Hint: As you know, writes to memory require MAR to be loaded with the memory address, and MDR to loaded with the data to be written (stored). The data in the MDR must come from a previous read (Load). 4.18STAR The 2^2 by 3 bit memory discussed in class is accessed during five consecutive clock cycles. The table below shows the values of the 2-bit Address, 1-bit Write Enable, and 3-bit Data-In signals during each access. A[1:0] WE D_in[2:0] cycle 1 0 1 1 1 0 1 cycle 2 1 1 0 1 1 0 cycle 3 1 0 1 0 1 0 cycle 4 0 1 1 0 1 1 cycle 5 0 0 0 0 0 0 Your job: Fill in the value stored in each memory cell and the",
    "492": "> Your job: Fill in the missing entries. Hint: As you know, writes to memory require MAR to be loaded with the memory address, and MDR to loaded with the data to be written (stored). The data in the MDR must come from a previous read (Load). 4.18STAR The 2^2 by 3 bit memory discussed in class is accessed during five consecutive clock cycles. The table below shows the values of the 2-bit Address, 1-bit Write Enable, and 3-bit Data-In signals during each access. A[1:0] WE D_in[2:0] cycle 1 0 1 1 1 0 1 cycle 2 1 1 0 1 1 0 cycle 3 1 0 1 0 1 0 cycle 4 0 1 1 0 1 1 cycle 5 0 0 0 0 0 0 Your job: Fill in the value stored in each memory cell and the three Data-Out lines just before the end of the 5^th cycle. Assume initially that all 12 memory cells store the value 1. In the figure below, each question mark (?) indicates a value that you need to fill in. < g r a p h i c s > 4.19STAR Shown below is a byte-addressible memory consisting of 8 locations, and its associated MAR and MDR. Both MAR and MDR consist of flip flops which are latched at the start of each clock cycle based on the values on their corresponding input lines. A memory read is initiated every cycle and the data is available by the end of that cycle. < g r a p h i c s > Just before the start of cycle 1, MAR contains 000, MDR contains 00010101, and the contents of each memory location is as shown. Memory Location Value x0 01010000 x1 11110001 x2 10000011 x3 00010101 x4 11000110 x5 10101011 x6 00111001 x7 01100010 (a) What do MAR and MDR contain just before the end of cycle 1. 1.8ex[0pt]MAR: (1.3,0.325) (1.3,0.325) 1.8ex[0pt]MDR: (1.3,0.325) (1.3,0.325) (b) What does MDR contain just before the end of cycle 4. 1.8ex[0pt]MDR: (1.3,0.325) (1.3,0.325) chap08../art/ch10/,../art/designelements/,../art/designelements/UnNumberedArt/makechapterhead#1 @",
    "493": "and its associated MAR and MDR. Both MAR and MDR consist of flip flops which are latched at the start of each clock cycle based on the values on their corresponding input lines. A memory read is initiated every cycle and the data is available by the end of that cycle. < g r a p h i c s > Just before the start of cycle 1, MAR contains 000, MDR contains 00010101, and the contents of each memory location is as shown. Memory Location Value x0 01010000 x1 11110001 x2 10000011 x3 00010101 x4 11000110 x5 10101011 x6 00111001 x7 01100010 (a) What do MAR and MDR contain just before the end of cycle 1. 1.8ex[0pt]MAR: (1.3,0.325) (1.3,0.325) 1.8ex[0pt]MDR: (1.3,0.325) (1.3,0.325) (b) What does MDR contain just before the end of cycle 4. 1.8ex[0pt]MDR: (1.3,0.325) (1.3,0.325) chap08../art/ch10/,../art/designelements/,../art/designelements/UnNumberedArt/makechapterhead#1 @ (0,0) (432,-577) < g r a p h i c s > (428,-577)1@9.52667in(381.5,-181) < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > 1212chapter 1212chapter 7212 3032#1 36.4pc4@ CHAPTER: A CALCULATOR Before we leave LC-3 assembly language and raise the level of abstraction to the C programming language, it is useful to step back and pull together much of what we have learned with a comprehensive example. The intent is to demonstrate the use of many of the concepts discussed thus far, as well as to show an example of well-documented, clearly written code, where the example is much more complicated than what can fit on one or two pages. Our example is a program that simulates the actions of a calculator that a person can use to add, subract, and multiply 2's complement integers. The person will enter numbers into the calculator-simulator by typing keys on the keyboard. Results of a computation will be displayed on the monitor. The",
    "494": "c s > 1212chapter 1212chapter 7212 3032#1 36.4pc4@ CHAPTER: A CALCULATOR Before we leave LC-3 assembly language and raise the level of abstraction to the C programming language, it is useful to step back and pull together much of what we have learned with a comprehensive example. The intent is to demonstrate the use of many of the concepts discussed thus far, as well as to show an example of well-documented, clearly written code, where the example is much more complicated than what can fit on one or two pages. Our example is a program that simulates the actions of a calculator that a person can use to add, subract, and multiply 2's complement integers. The person will enter numbers into the calculator-simulator by typing keys on the keyboard. Results of a computation will be displayed on the monitor. The calculator simulation consists of a main program and 11 separate subroutines. You are encouraged to study this example before moving on to Chapter 11 and High-Level Language Programming. Two topics we have not discussed thus far are needed to understand the workings of the calculator simulation: (1) the conversion of integers between ASCII strings and 2's complement, and (2) arithmetic using a stack, the method most calculators use. The reason for two data types and conversion between them: We need one data type for input/output and another for doing arithmetic. Numbers entered via the keyboard and displayed on the monitor use ASCII codes to represent the numbers. Arithmetic uses 2's complement integers. We will need to convert the number the person types from ASCII codes to a 2's complement integer, and we will need to convert the result of the computation from a 2's complement integer to ASCII codes in order to display it on the monitor. Section 10.1 deals with data type conversion. With respect to the way calculators perform arithmetic, the mechanism used by most calculators is very different from the way most desktop and laptop computers perform arithmetic. The ISAs of most desktops and laptops are like",
    "495": "using a stack, the method most calculators use. The reason for two data types and conversion between them: We need one data type for input/output and another for doing arithmetic. Numbers entered via the keyboard and displayed on the monitor use ASCII codes to represent the numbers. Arithmetic uses 2's complement integers. We will need to convert the number the person types from ASCII codes to a 2's complement integer, and we will need to convert the result of the computation from a 2's complement integer to ASCII codes in order to display it on the monitor. Section 10.1 deals with data type conversion. With respect to the way calculators perform arithmetic, the mechanism used by most calculators is very different from the way most desktop and laptop computers perform arithmetic. The ISAs of most desktops and laptops are like the LC-3, where arithmetic instructions get their source operands from general purpose registers, and store the results of the arithmetic operations in general purpose registers. Our simulation of a calculator, like most calculators, does not use general purpose registers. Instead it uses a stack. Source operands are popped from the stack, and the result of the operation is pushed back onto the stack. Section 10.2 deals with arithmetic using a stack instead of general purpose registers. Finally, Section 10.3 contains a full discussion of the calculator-simulator, along with all the subroutines that are needed to make it work. § DATA TYPE CONVERSION data type conversion It has been a long time since we talked about data types. We have already been exposed to several data types: unsigned integers for address arithmetic, 2's complement integers for integer arithmetic, 16-bit binary strings for logical operations, floating point numbers for scientific computation, and ASCII codes for interaction with input and output devices. It is important that every instruction be provided with source operands of the data type that the instruction requires. For example, an ALU requires operands that are 2's complement integers to perform an ADD. If the ALU were supplied with floating",
    "496": "onto the stack. Section 10.2 deals with arithmetic using a stack instead of general purpose registers. Finally, Section 10.3 contains a full discussion of the calculator-simulator, along with all the subroutines that are needed to make it work. § DATA TYPE CONVERSION data type conversion It has been a long time since we talked about data types. We have already been exposed to several data types: unsigned integers for address arithmetic, 2's complement integers for integer arithmetic, 16-bit binary strings for logical operations, floating point numbers for scientific computation, and ASCII codes for interaction with input and output devices. It is important that every instruction be provided with source operands of the data type that the instruction requires. For example, an ALU requires operands that are 2's complement integers to perform an ADD. If the ALU were supplied with floating point operands, the ALU would produce garbage results. It is not uncommon in high-level language programs to find an instruction of the form A=R+I where R (floating point) and I (2's complement integer) are represented in different data types. If the operation is to be performed by a floating point adder, then we have a problem with I. To handle the problem, one must first convert the value I from its original data type (2's complement integer) to the data type required by the functional unit performing the operation (floating point). For those programming in some high level language, the compiler generally produces the code to do that conversion so the programmer does not even have to think about it. Even in our \"character count problem\" way back in Chapter 5, we had to deal with data type conversion. Our program entered a character from the keyboard, scanned a file counting the number of occurrences of that character, and then displayed the count on the monitor. Recall that before we could display our final count on the monitor, we had to convert our 2's complement integer to an ASCII code. Why? Because when we were counting, we were performing arithmetic",
    "497": "the problem, one must first convert the value I from its original data type (2's complement integer) to the data type required by the functional unit performing the operation (floating point). For those programming in some high level language, the compiler generally produces the code to do that conversion so the programmer does not even have to think about it. Even in our \"character count problem\" way back in Chapter 5, we had to deal with data type conversion. Our program entered a character from the keyboard, scanned a file counting the number of occurrences of that character, and then displayed the count on the monitor. Recall that before we could display our final count on the monitor, we had to convert our 2's complement integer to an ASCII code. Why? Because when we were counting, we were performing arithmetic on 2's complement integers. But when we were displaying, we needed to represent our count as an ASCII code. You remember we restricted our program to work only on files where the total count was not greater than 9 so our conversion from a 2's complement integer to an ASCII code could be obtained by simply adding x30 to the 2's complement integer to get the ASCII code. For example, The 2's complement representation for 6 (in one byte) is 00000110, or x06. The ASCII code for 6, on the other hand, is 00110110, or x36. That was a severe limitation to put on our count, restricting it to a single decimal digit. But that was chapter 5 and now we are in chapter 10! If our number is represented by more than one decimal digit, simply adding x30 does not work. For example, consider the two decimal digit number 25. If we enter 25 via the keyboard, we input the ASCII code x32, followed by the ASCII code x35. The bit stream is 0011001000110101. To perform arithmetic on this integer, we must first convert it to 0000000000011001, the 2's complement integer representation of 25. Displaying the result of some",
    "498": "2's complement integer to get the ASCII code. For example, The 2's complement representation for 6 (in one byte) is 00000110, or x06. The ASCII code for 6, on the other hand, is 00110110, or x36. That was a severe limitation to put on our count, restricting it to a single decimal digit. But that was chapter 5 and now we are in chapter 10! If our number is represented by more than one decimal digit, simply adding x30 does not work. For example, consider the two decimal digit number 25. If we enter 25 via the keyboard, we input the ASCII code x32, followed by the ASCII code x35. The bit stream is 0011001000110101. To perform arithmetic on this integer, we must first convert it to 0000000000011001, the 2's complement integer representation of 25. Displaying the result of some arithmetic computation on the monitor causes a similar problem. To do that, we must first convert the result of the arithmetic (a 2's complement integer) to an ASCII string. In this section, we develop routines to convert integers consisting of more than one decimal digit from a string of ASCII codes to 2's complement, and from 2's complement to a string of ASCII codes. §.§ Example: A Bogus Program: 2 + 3 = e Before we get into the actual conversion routines, it is worth looking at a simple, concrete example that illustrates their importance. Figure <ref> shows how we can get into trouble if we do not pay attention to the data types that we are working with. Suppose we want to enter two single digit integers from the keyboard, add them, and display the result on the monitor. At first blush, we write the simple program of Figure <ref>. What happens? [fontsize=911] 01 TRAP x23 ; Input from the keyboard. 02 ADD R1,R0,#0 ; Make room for another input. 03 TRAP x23 ; Input another character. 04 ADD R0,R1,R0 ; Add the two inputs. 05 TRAP x21 ; Display result on the monitor. 06 TRAP x25 ; Halt.",
    "499": "string of ASCII codes. §.§ Example: A Bogus Program: 2 + 3 = e Before we get into the actual conversion routines, it is worth looking at a simple, concrete example that illustrates their importance. Figure <ref> shows how we can get into trouble if we do not pay attention to the data types that we are working with. Suppose we want to enter two single digit integers from the keyboard, add them, and display the result on the monitor. At first blush, we write the simple program of Figure <ref>. What happens? [fontsize=911] 01 TRAP x23 ; Input from the keyboard. 02 ADD R1,R0,#0 ; Make room for another input. 03 TRAP x23 ; Input another character. 04 ADD R0,R1,R0 ; Add the two inputs. 05 TRAP x21 ; Display result on the monitor. 06 TRAP x25 ; Halt. ADDITION without paying attention to data types Suppose the first digit entered via the keyboard is a 2 and the second digit entered via the keyboard is a 3. What will be displayed on the monitor before the program terminates? The value loaded into R0 as a result of entering a 2 is the ASCII code for 2, which is x0032. When the 3 is entered, the ASCII code for 3, which is x0033, is loaded into R0 (after the ASCII code for 2 is moved to R1, of course). Thus, the ADD instruction adds the two binary strings x0032 and x0033, producing x0065. When that value is displayed on the monitor, it is treated as an ASCII code. Since x0065 is the ASCII code for a lower case e, a lower case e is displayed on the monitor. The reason we did not get 5 (which, at last calculation, is the correct result when adding 2 + 3) is that (a) we didn't convert the two input characters from ASCII to 2's complement integers before performing the addition and (b) we didn't convert the result back to ASCII before displaying it on the monitor. Exercise: Correct Figure <ref> so",
    "500": "x0032. When the 3 is entered, the ASCII code for 3, which is x0033, is loaded into R0 (after the ASCII code for 2 is moved to R1, of course). Thus, the ADD instruction adds the two binary strings x0032 and x0033, producing x0065. When that value is displayed on the monitor, it is treated as an ASCII code. Since x0065 is the ASCII code for a lower case e, a lower case e is displayed on the monitor. The reason we did not get 5 (which, at last calculation, is the correct result when adding 2 + 3) is that (a) we didn't convert the two input characters from ASCII to 2's complement integers before performing the addition and (b) we didn't convert the result back to ASCII before displaying it on the monitor. Exercise: Correct Figure <ref> so that it will add two single-digit positive integers and produce the correct single-digit positive sum. Assume that the two digits being added do in fact produce a single-digit sum. §.§ Input data (ASCII to Binary) Figure <ref> shows the ASCII representation of the three-decimal-digit integer 295, stored as an ASCII string in three consecutive LC-3 memory locations, starting at ASCIIBUFF. R1 contains the number of decimal digits in the positive integer. Our ASCII to Binary subroutine restricts integers to the range 0 to 999. < g r a p h i c s > The ASCII representation of 295 stored in consecutive memory locations ASCIIBUFF is the address of the first memory location of a sequence of four memory locations that we have allocated (a) to store the ASCII codes of decimal digits entered from the keyboard, and (b) to store the ASCII codes corresponding to the result of arithmetic operations in preparation for writing it (the result) to the monitor. You might ask why, in Figure <ref>, we used a whole 16-bit word to store the ASCII code of each decimal digit when a byte would have been enough. In fact, typically, one does store each ASCII code in",
    "501": "R1 contains the number of decimal digits in the positive integer. Our ASCII to Binary subroutine restricts integers to the range 0 to 999. < g r a p h i c s > The ASCII representation of 295 stored in consecutive memory locations ASCIIBUFF is the address of the first memory location of a sequence of four memory locations that we have allocated (a) to store the ASCII codes of decimal digits entered from the keyboard, and (b) to store the ASCII codes corresponding to the result of arithmetic operations in preparation for writing it (the result) to the monitor. You might ask why, in Figure <ref>, we used a whole 16-bit word to store the ASCII code of each decimal digit when a byte would have been enough. In fact, typically, one does store each ASCII code in a single byte of memory. In this example, we decided to give each ASCII character its own word of memory in order to simplify the algorithm. Since we are restricting input to positive integers consisting of at most three decimal digits, you might also ask why we are allocating four words of memory to ASCIIBUFF. Wouldn't three words be enough? For input yes, but you will see in Section 10.1.3 that in preparation for output, we will need one more word for the sign (positive or negative) of the result, since the result of the arithmetic could be negative. Figure <ref> shows the flowchart for a subroutine that converts the ASCII representation of an integer, stored in Figure <ref>, into a binary integer. < g r a p h i c s > Flowchart, subroutine for ASCII-to-binary conversion The subroutine systematically takes each digit, converts it from its ASCII code to its binary code by stripping away all but the last four bits, and then uses those four bits to index into a table of 10 binary values. Since we are restricting conversion to integers consisting of at most three decimal digits, only two tables are needed, one for the",
    "502": "For input yes, but you will see in Section 10.1.3 that in preparation for output, we will need one more word for the sign (positive or negative) of the result, since the result of the arithmetic could be negative. Figure <ref> shows the flowchart for a subroutine that converts the ASCII representation of an integer, stored in Figure <ref>, into a binary integer. < g r a p h i c s > Flowchart, subroutine for ASCII-to-binary conversion The subroutine systematically takes each digit, converts it from its ASCII code to its binary code by stripping away all but the last four bits, and then uses those four bits to index into a table of 10 binary values. Since we are restricting conversion to integers consisting of at most three decimal digits, only two tables are needed, one for the tens digit and one for the hundreds digit. Each entry in each table corresponds to the value of one of the 10 digits. For example, the entry for index 6 in the hundreds table is the value #600, which is in binary 0000001001011000. That value is then added to R0. R0 is used to accumulate the contributions of all the digits. The result is returned in R0. Question: If we wanted to be able to convert four decimal-digit integers, would we need a table of thousands digits? Or, is there a way to convert larger numbers represented as larger decimal strings into their binary form without requiring a table of thousands digits, ten-thousands digits, etc.? Exercise: [Challenging] Suppose the decimal number is arbitrarily long. Rather than store a table of 10 values for the thousands-place digit, another table for the 10 ten-thousands-place digit, and so on, design an algorithm to do the conversion without requiring any tables at all. See Exercise 10.20. Figure <ref> shows the LC-3 code that implements this subroutine. There are two points that we need to make about the subroutines in Chapter 10, which are all part of our calculator simulation, described fully in Section 10.3.",
    "503": "digits. The result is returned in R0. Question: If we wanted to be able to convert four decimal-digit integers, would we need a table of thousands digits? Or, is there a way to convert larger numbers represented as larger decimal strings into their binary form without requiring a table of thousands digits, ten-thousands digits, etc.? Exercise: [Challenging] Suppose the decimal number is arbitrarily long. Rather than store a table of 10 values for the thousands-place digit, another table for the 10 ten-thousands-place digit, and so on, design an algorithm to do the conversion without requiring any tables at all. See Exercise 10.20. Figure <ref> shows the LC-3 code that implements this subroutine. There are two points that we need to make about the subroutines in Chapter 10, which are all part of our calculator simulation, described fully in Section 10.3. First, they can not be assembled individually, and second (because of that), we need to be sure that no label is used more than once. Why cannot the subroutine of Figure 10.4 be assembled by itself? Answer: Line 36 specifies a .FILL having the value ASCIIBUFF, but there is no location in the subroutine labeled ASCIIBUFF. Therefore, trying to assemble the subroutine by itself will fail. We could have used .EXTERNAL, discussed briefly in Chapter 7, to enable the subroutines to be assembled individually, but we chose to not do that, preferring to assemble the entire calculator-simulator program including its 11 subroutines as a single entity. As you would expect, line 43 in the code of Figure 10.15 contains the label ASCIIBUFF. Second, if we are to assemble the main program and all the subroutines as a single unit, we need to be sure to not use the same label in more than one subroutine. Note that in Figure 10.4, most labels start with \"AtoB_.\" As expected, the same pattern of labeling is used in the rest of the subroutines. [fontsize=911] 01 ; 02 ; This subroutine takes an ASCII string of up to three decimal digits and 03 ;",
    "504": "the subroutine by itself will fail. We could have used .EXTERNAL, discussed briefly in Chapter 7, to enable the subroutines to be assembled individually, but we chose to not do that, preferring to assemble the entire calculator-simulator program including its 11 subroutines as a single entity. As you would expect, line 43 in the code of Figure 10.15 contains the label ASCIIBUFF. Second, if we are to assemble the main program and all the subroutines as a single unit, we need to be sure to not use the same label in more than one subroutine. Note that in Figure 10.4, most labels start with \"AtoB_.\" As expected, the same pattern of labeling is used in the rest of the subroutines. [fontsize=911] 01 ; 02 ; This subroutine takes an ASCII string of up to three decimal digits and 03 ; converts it into a binary number. R0 is used to collect the result. 04 ; R1 keeps track of how many digits are left to process. ASCIIBUFF 05 ; contains the most significant digit in the ASCII string. 06 ; 07 ASCIItoBinary ST R1,AtoB_Save1 08 ST R2,AtoB_Save2 09 ST R3,AtoB_Save3 0A ST R4,AtoB_Save4 0B AND R0,R0,#0 ; R0 will be used for our result. 0C ADD R1,R1,#0 ; Test number of digits. 0D BRz AtoB_Done ; There are no digits, result is 0. 0E ; 0F LD R2,AtoB_ASCIIBUFF ; R2 points to ASCIIBUFF 10 ADD R2,R2,R1 11 ADD R2,R2,#-1 ; R2 now points to \"ones\" digit. 12 ; 13 LDR R4,R2,#0 ; R4 <– \"ones\" digit 14 AND R4,R4,x000F ; Strip off the ASCII template. 15 ADD R0,R0,R4 ; Add ones contribution. 16 ; 17 ADD R1,R1,#-1 18 BRz AtoB_Done ; The original number had one digit. 19 ADD R2,R2,#-1 ; R2 now points to \"tens\" digit. 1A ; 1B LDR R4,R2,#0 ; R4 <– \"tens\" digit 1C AND R4,R4,x000F ; Strip off ASCII template. 1D LEA R3,LookUp10 ; LookUp10 is BASE of tens values. 1E ADD R3,R3,R4 ; R3 points to the right tens value. 1F LDR R4,R3,#0 20",
    "505": "used for our result. 0C ADD R1,R1,#0 ; Test number of digits. 0D BRz AtoB_Done ; There are no digits, result is 0. 0E ; 0F LD R2,AtoB_ASCIIBUFF ; R2 points to ASCIIBUFF 10 ADD R2,R2,R1 11 ADD R2,R2,#-1 ; R2 now points to \"ones\" digit. 12 ; 13 LDR R4,R2,#0 ; R4 <– \"ones\" digit 14 AND R4,R4,x000F ; Strip off the ASCII template. 15 ADD R0,R0,R4 ; Add ones contribution. 16 ; 17 ADD R1,R1,#-1 18 BRz AtoB_Done ; The original number had one digit. 19 ADD R2,R2,#-1 ; R2 now points to \"tens\" digit. 1A ; 1B LDR R4,R2,#0 ; R4 <– \"tens\" digit 1C AND R4,R4,x000F ; Strip off ASCII template. 1D LEA R3,LookUp10 ; LookUp10 is BASE of tens values. 1E ADD R3,R3,R4 ; R3 points to the right tens value. 1F LDR R4,R3,#0 20 ADD R0,R0,R4 ; Add tens contribution to total. ASCII-to-binary conversion subroutine 36pc[fontsize=911] 21 ; 22 ADD R1,R1,#-1 23 BRz AtoB_Done ; The original number had two digits. 24 ADD R2,R2,#-1 ; R2 now points to \"hundreds\" digit. 25 ; 26 LDR R4,R2,#0 ; R4 <– \"hundreds\" digit 27 AND R4,R4,x000F ; Strip off ASCII template. 28 LEA R3,LookUp100 ; LookUp100 is hundreds BASE. 29 ADD R3,R3,R4 ; R3 points to hundreds value. 2A LDR R4,R3,#0 2B ADD R0,R0,R4 ; Add hundreds contribution to total. 2C ; 2D AtoB_Done LD R1,AtoB_Save1 2E LD R2,AtoB_Save2 2F LD R3,AtoB_Save3 30 LD R4,AtoB_Save4 31 RET 32 ; 33 AtoB_ASCIIBUFF .FILL ASCIIBUFF 34 AtoB_Save1 .BLKW #1 35 AtoB_Save2 .BLKW #1 36 AtoB_Save3 .BLKW #1 37 AtoB_Save4 .BLKW #1 38 LookUp10 .FILL #0 39 .FILL #10 3A .FILL #20 3B .FILL #30 3C .FILL #40 3D .FILL #50 3E .FILL #60 3F .FILL #70 40 .FILL #80 41 .FILL #90 42 ; 43 LookUp100 .FILL #0 44 .FILL #100 45 .FILL #200 46 .FILL #300 47 .FILL #400 48 .FILL #500 49 .FILL #600 4A .FILL #700 4B .FILL #800 4C .FILL #900 ASCII-to-binary conversion subroutine ( continued) §.§ Display result (Binary to ASCII) To display",
    "506": "is hundreds BASE. 29 ADD R3,R3,R4 ; R3 points to hundreds value. 2A LDR R4,R3,#0 2B ADD R0,R0,R4 ; Add hundreds contribution to total. 2C ; 2D AtoB_Done LD R1,AtoB_Save1 2E LD R2,AtoB_Save2 2F LD R3,AtoB_Save3 30 LD R4,AtoB_Save4 31 RET 32 ; 33 AtoB_ASCIIBUFF .FILL ASCIIBUFF 34 AtoB_Save1 .BLKW #1 35 AtoB_Save2 .BLKW #1 36 AtoB_Save3 .BLKW #1 37 AtoB_Save4 .BLKW #1 38 LookUp10 .FILL #0 39 .FILL #10 3A .FILL #20 3B .FILL #30 3C .FILL #40 3D .FILL #50 3E .FILL #60 3F .FILL #70 40 .FILL #80 41 .FILL #90 42 ; 43 LookUp100 .FILL #0 44 .FILL #100 45 .FILL #200 46 .FILL #300 47 .FILL #400 48 .FILL #500 49 .FILL #600 4A .FILL #700 4B .FILL #800 4C .FILL #900 ASCII-to-binary conversion subroutine ( continued) §.§ Display result (Binary to ASCII) To display the result of a computation on the monitor, we must first convert the 2's complement integer result into an ASCII string. Figure <ref> shows the subroutine for converting a 2's complement integer stored in R0 into an ASCII string stored in the four consecutive memory locations starting at ASCIIBUFF. The value initially in R0 is restricted to the range -999 to +999. After the subroutine completes execution, ASCIIBUFF contains the sign (+ or -) of the value initially stored in R0, followed by three locations that contain the ASCII codes corresponding to the decimal digits representing its magnitude. 36pc[fontsize=911] 01 ; This subroutine converts a 2's complement integer within the range 02 ; -999 to +999 (located in R0) into an ASCII character string consisting 03 ; of a sign digit, followed by three decimal digits, and stores the 04 ; character string into the four memory locations starting at ASCIIBUFF 05 ; (see Figure 10.4). 06 ; 07 BinarytoASCII ST R0,BtoA_Save0 08 ST R1,BtoA_Save1 09 ST R2,BtoA_Save2 0A ST R3,BtoA_Save3 0B LD R1,BtoA_ASCIIBUFF ; R1 keeps track of output string. 0C ADD R0,R0,#0 ; R0 contains the binary value. 0D BRn NegSign ; 0E LD R2,ASCIIplus ; First store",
    "507": "to +999. After the subroutine completes execution, ASCIIBUFF contains the sign (+ or -) of the value initially stored in R0, followed by three locations that contain the ASCII codes corresponding to the decimal digits representing its magnitude. 36pc[fontsize=911] 01 ; This subroutine converts a 2's complement integer within the range 02 ; -999 to +999 (located in R0) into an ASCII character string consisting 03 ; of a sign digit, followed by three decimal digits, and stores the 04 ; character string into the four memory locations starting at ASCIIBUFF 05 ; (see Figure 10.4). 06 ; 07 BinarytoASCII ST R0,BtoA_Save0 08 ST R1,BtoA_Save1 09 ST R2,BtoA_Save2 0A ST R3,BtoA_Save3 0B LD R1,BtoA_ASCIIBUFF ; R1 keeps track of output string. 0C ADD R0,R0,#0 ; R0 contains the binary value. 0D BRn NegSign ; 0E LD R2,ASCIIplus ; First store the ASCII plus sign. 0F STR R2,R1,#0 10 BRnzp Begin100 11 NegSign LD R2,ASCIIminus ; First store ASCII minus sign. 12 STR R2,R1,#0 13 NOT R0,R0 ; Convert the number to absolute 14 ADD R0,R0,#1 ; value; it is easier to work with. 15 ; 16 Begin100 LD R2,ASCIIoffset ; Prepare for \"hundreds\" digit. 17 ; 18 LD R3,Neg100 ; Determine the hundreds digit. 19 Loop100 ADD R0,R0,R3 1A BRn End100 1B ADD R2,R2,#1 1C BRnzp Loop100 1D ; 1E End100 STR R2,R1,#1 ; Store ASCII code for hundreds digit. 1F LD R3,Pos100 20 ADD R0,R0,R3 ; Correct R0 for one-too-many subtracts. 21 ; 22 LD R2,ASCIIoffset ; Prepare for \"tens\" digit. 23 ; 24 Loop10 ADD R0,R0,#-10 ; Determine the tens digit. 25 BRn End10 26 ADD R2,R2,#1 27 BRnzp Loop10 28 ; 29 End10 STR R2,R1,#2 ; Store ASCII code for tens digit. 2A ADD R0,R0,#10 ; Correct R0 for one-too-many subtracts. 2B Begin1 LD R2,ASCIIoffset ; Prepare for \"ones\" digit. 2C ADD R2,R2,R0 2D STR R2,R1,#3 2E LD R0,BtoA_Save0 2F LD R1,BtoA_Save1 30 LD R2,BtoA_Save2 31 LD R3,BtoA_Save3 32 RET 33 ; 34 ASCIIplus .FILL x002B 35 ASCIIminus .FILL x002D 36 ASCIIoffset .FILL x0030 37 Neg100 .FILL",
    "508": "Determine the hundreds digit. 19 Loop100 ADD R0,R0,R3 1A BRn End100 1B ADD R2,R2,#1 1C BRnzp Loop100 1D ; 1E End100 STR R2,R1,#1 ; Store ASCII code for hundreds digit. 1F LD R3,Pos100 20 ADD R0,R0,R3 ; Correct R0 for one-too-many subtracts. 21 ; 22 LD R2,ASCIIoffset ; Prepare for \"tens\" digit. 23 ; 24 Loop10 ADD R0,R0,#-10 ; Determine the tens digit. 25 BRn End10 26 ADD R2,R2,#1 27 BRnzp Loop10 28 ; 29 End10 STR R2,R1,#2 ; Store ASCII code for tens digit. 2A ADD R0,R0,#10 ; Correct R0 for one-too-many subtracts. 2B Begin1 LD R2,ASCIIoffset ; Prepare for \"ones\" digit. 2C ADD R2,R2,R0 2D STR R2,R1,#3 2E LD R0,BtoA_Save0 2F LD R1,BtoA_Save1 30 LD R2,BtoA_Save2 31 LD R3,BtoA_Save3 32 RET 33 ; 34 ASCIIplus .FILL x002B 35 ASCIIminus .FILL x002D 36 ASCIIoffset .FILL x0030 37 Neg100 .FILL #-100 38 Pos100 .FILL #100 39 BtoA_Save0 .BLKW #1 3A BtoA_Save1 .BLKW #1 3B BtoA_Save2 .BLKW #1 3C BtoA_Save3 .BLKW #1 3D BtoA_ASCIIBUFF .FILL ASCIIBUFF Binary-to-ASCII conversion subroutine The subroutine works as follows: First, the sign of the result to be displayed is determined, and the ASCII code for + or - is stored in ASCIIBUFF. The result (in R0) is replaced by its absolute value. The algorithm determines the hundreds-place digit by repeatedly subtracting #100 from R0 until the result goes negative. This is next repeated for the tens-place digit. The value left is the ones digit. Exercise: This subroutine always produces a string of four characters independent of the sign and magnitude of the integer being converted. Devise an algorithm that eliminates unnecessary characters, that is, eliminate leading zeros and eliminate a leading + sign. See Exercise 10.22. § ARITHMETIC USING A STACK §.§ The Stack as Temporary Storage You know that the LC-3 ADD instruction takes two source operands which are stored in registers, performs an addition, and stores the result into one of the LC-3's eight general purpose registers. We call the register where the result is stored the destination register. The eight general purpose registers",
    "509": "is replaced by its absolute value. The algorithm determines the hundreds-place digit by repeatedly subtracting #100 from R0 until the result goes negative. This is next repeated for the tens-place digit. The value left is the ones digit. Exercise: This subroutine always produces a string of four characters independent of the sign and magnitude of the integer being converted. Devise an algorithm that eliminates unnecessary characters, that is, eliminate leading zeros and eliminate a leading + sign. See Exercise 10.22. § ARITHMETIC USING A STACK §.§ The Stack as Temporary Storage You know that the LC-3 ADD instruction takes two source operands which are stored in registers, performs an addition, and stores the result into one of the LC-3's eight general purpose registers. We call the register where the result is stored the destination register. The eight general purpose registers R0 to R7 comprise the temporary storage that allows operate instructions like ADD to access both source registers and the destination register much more quickly than if the computer had to access memory for the operands. Because the three locations are specified explicitly, ADD R0,R1,R2 we call the LC-3 a three-address machine. Most desktop and laptop computers are either three-address machines like the LC-3, or two-address machines like the x86 ISA that is implemented in many of your laptop and desktop computers. In a two-address machine, two locations are specified explicitly. An example of an x86 ADD instruction is ADD EAX,EBX where EAX and EBX are two of the eight general purpose registers in the x86 ISA. In this case, EAX serves as both the location of one of the source operands and the location of the destination operand. With a two-address machine, one of the source registers is overwritten with the result of the operation. There are also ISAs that do not use general purpose registers at all to store either source operands or the results of operate instructions. Most common of these are called stack machines because a stack is used for temporary storage. Most calculators, including the",
    "510": "machines like the LC-3, or two-address machines like the x86 ISA that is implemented in many of your laptop and desktop computers. In a two-address machine, two locations are specified explicitly. An example of an x86 ADD instruction is ADD EAX,EBX where EAX and EBX are two of the eight general purpose registers in the x86 ISA. In this case, EAX serves as both the location of one of the source operands and the location of the destination operand. With a two-address machine, one of the source registers is overwritten with the result of the operation. There are also ISAs that do not use general purpose registers at all to store either source operands or the results of operate instructions. Most common of these are called stack machines because a stack is used for temporary storage. Most calculators, including the one we will simulate in Section 10.3, use a stack for temporary storage, rather than a set of general purpose registers. Source operands are obtained by popping the top two elements from the stack. The result (i.e., the destination operand) is subsequently pushed onto the stack. Since the computer always pops and pushes operands from the stack, no addresses need to be specified explicitly. Therefore, stack machines are sometimes referred to as zero-address machines. The instruction would simply be ADD and the computer would know where to find the operands. For a calculator, that is convenient because a person can cause an ADD to be performed by simply pressing the + button on the calculator. Note that the pop, push, and add are not part of the ISA of the computer, and therefore not available to the programmer. They are control signals that the hardware uses to make the actual pop, push, and add occur. The control signals are part of the microarchitecture, similar to the load enable signals and mux select signals we discussed in Chapters 4 and 5. As is the case with LC-3 instructions LD and ST, and control signals PCMUX and LD.MDR, the programmer simply instructs",
    "511": "to be specified explicitly. Therefore, stack machines are sometimes referred to as zero-address machines. The instruction would simply be ADD and the computer would know where to find the operands. For a calculator, that is convenient because a person can cause an ADD to be performed by simply pressing the + button on the calculator. Note that the pop, push, and add are not part of the ISA of the computer, and therefore not available to the programmer. They are control signals that the hardware uses to make the actual pop, push, and add occur. The control signals are part of the microarchitecture, similar to the load enable signals and mux select signals we discussed in Chapters 4 and 5. As is the case with LC-3 instructions LD and ST, and control signals PCMUX and LD.MDR, the programmer simply instructs the computer to ADD, and the microarchitecture does the rest. §.§ An Example Suppose we want to evaluate (A+B)·(C+D), where A contains 25, B contains 17, C contains 3, and D contains 2, and store the result in E. If the LC-3 had a multiply instruction (we would probably call it MUL), we could use the following program: LD R0,A LD R1,B ADD R0,R0,R1 LD R2,C LD R3,D ADD R2,R2,R3 MUL R0,R0,R2 ST R0,E With a calculator, we would execute the following eight operations: (1) push 25 (2) push 17 (3) add (4) push 3 (5) push 2 (6) add (7) multiply (8) pop E with the final result popped (i.e., 210) being the result of the computation, Figure <ref> shows a snapshot of the stack after each of the eight operations. Note that in this example we have allocated memory locations x3FFB to x3FFF for our stack, and the Stack Pointer is initially at x4000, indicating that there is nothing initially on the stack. < g r a p h i c s > Stack usage during the computation of (25+17)· (3+2) In Section 10.3, we write a program that causes the LC-3 (with keyboard and monitor) to act",
    "512": "LD R1,B ADD R0,R0,R1 LD R2,C LD R3,D ADD R2,R2,R3 MUL R0,R0,R2 ST R0,E With a calculator, we would execute the following eight operations: (1) push 25 (2) push 17 (3) add (4) push 3 (5) push 2 (6) add (7) multiply (8) pop E with the final result popped (i.e., 210) being the result of the computation, Figure <ref> shows a snapshot of the stack after each of the eight operations. Note that in this example we have allocated memory locations x3FFB to x3FFF for our stack, and the Stack Pointer is initially at x4000, indicating that there is nothing initially on the stack. < g r a p h i c s > Stack usage during the computation of (25+17)· (3+2) In Section 10.3, we write a program that causes the LC-3 (with keyboard and monitor) to act like such a calculator. We say the LC-3 simulates the calculator when it executes that program. To do this, our program will need subroutines to perform the various arithmetic operations. §.§ OpAdd, OpMult, and OpNeg The program we write in Section 10.3 to simulate a calculator will need three subroutines to be able to perform addition, subtraction, and multiplication. They are: * OpAdd, which will pop two values from the stack, add them, and push the result onto the stack. * OpMult, which will pop two values from the stack, multiply them, and push the result onto the stack. * OpNeg, which will pop the top value, form its 2's complement negative value, and push the result onto the stack. This will allow us to subtract two numbers A minus B by first forming -B and then adding the result to A. The OpAdd Subroutine Figure <ref> shows the flowchart of the OpAdd Subroutine. Basically, it attempts to pop two values off the stack and, if successful, add them. If the result is within the range of acceptable values (that is, an integer between -999 and +999), then the result is pushed onto the stack. < g r a p",
    "513": "are: * OpAdd, which will pop two values from the stack, add them, and push the result onto the stack. * OpMult, which will pop two values from the stack, multiply them, and push the result onto the stack. * OpNeg, which will pop the top value, form its 2's complement negative value, and push the result onto the stack. This will allow us to subtract two numbers A minus B by first forming -B and then adding the result to A. The OpAdd Subroutine Figure <ref> shows the flowchart of the OpAdd Subroutine. Basically, it attempts to pop two values off the stack and, if successful, add them. If the result is within the range of acceptable values (that is, an integer between -999 and +999), then the result is pushed onto the stack. < g r a p h i c s > Flowchart for OpAdd algorithm There are two things that could prevent OpAdd from completing successfully: Fewer than two values are available on the stack for source operands, or the result is out of range. In both cases, the stack is put back to the way it was at the start of the OpAdd subroutine. If the first pop is unsuccessful, the stack is not changed since the POP routine leaves the stack as it was. If the second of the two pops reports back unsuccessfully, the stack pointer is decremented, which effectively returns the first value popped to the top of the stack. If the result is outside the range of acceptable values, then the stack pointer is decremented twice, returning both values to the top of the stack. The OpAdd subroutine is shown in Figure <ref>. 36pc[fontsize=911] 01 ; 02 ; Subroutine to pop the top two elements from the stack, 03 ; add them, and push the sum onto the stack. R6 is 04 ; the stack pointer. 05 ; 06 OpAdd ST R0,OpAdd_Save0 07 ST R1,OpAdd_Save1 08 ST R5,OpAdd_Save5 09 ST R7,OpAdd_Save7 0A JSR POP ; Get first source operand. 0B ADD",
    "514": "the first pop is unsuccessful, the stack is not changed since the POP routine leaves the stack as it was. If the second of the two pops reports back unsuccessfully, the stack pointer is decremented, which effectively returns the first value popped to the top of the stack. If the result is outside the range of acceptable values, then the stack pointer is decremented twice, returning both values to the top of the stack. The OpAdd subroutine is shown in Figure <ref>. 36pc[fontsize=911] 01 ; 02 ; Subroutine to pop the top two elements from the stack, 03 ; add them, and push the sum onto the stack. R6 is 04 ; the stack pointer. 05 ; 06 OpAdd ST R0,OpAdd_Save0 07 ST R1,OpAdd_Save1 08 ST R5,OpAdd_Save5 09 ST R7,OpAdd_Save7 0A JSR POP ; Get first source operand. 0B ADD R5,R5,#0 ; Test if POP was successful. 0C BRp OpAdd_Exit ; Branch if not successful. 0D ADD R1,R0,#0 ; Make room for second operand. 0E JSR POP ; Get second source operand. 0F ADD R5,R5,#0 ; Test if POP was successful. 10 BRp OpAdd_Restore1 ; Not successful, put back first. 11 ADD R0,R0,R1 ; THE Add. 12 JSR RangeCheck ; Check size of result. 13 ADD R5,R5,#0 ; Check R5 for success/failure. 14 BRp OpAdd_Restore2 ; Out of range, restore both. 15 JSR PUSH ; Push sum on the stack. 16 BRnzp OpAdd_Exit ; On to the next task... 17 OpAdd_Restore2 ADD R6,R6,#-1 ; Decrement stack pointer. 18 OpAdd_Restore1 ADD R6,R6,#-1 ; Decrement stack pointer. 19 OpAdd_Exit LD R0,OpAdd_Save0 1A LD R1,OpAdd_Save1 1B LD R5,OpAdd_Save5 1C LD R7,OpAdd_Save7 1D RET 1E OpAdd_Save0 .BLKW #1 1F OpAdd_Save1 .BLKW #1 20 OpAdd_Save5 .BLKW #1 21 OpAdd_Save7 .BLKW #1 The OpAdd Subroutine Note that the OpAdd subroutine calls the RangeCheck subroutine. This is a simple test to be sure the result of the computation is within what can successfully be stored in a single stack location. For our purposes, we restrict values to integers in the range -999 to +999. This will come",
    "515": "Check size of result. 13 ADD R5,R5,#0 ; Check R5 for success/failure. 14 BRp OpAdd_Restore2 ; Out of range, restore both. 15 JSR PUSH ; Push sum on the stack. 16 BRnzp OpAdd_Exit ; On to the next task... 17 OpAdd_Restore2 ADD R6,R6,#-1 ; Decrement stack pointer. 18 OpAdd_Restore1 ADD R6,R6,#-1 ; Decrement stack pointer. 19 OpAdd_Exit LD R0,OpAdd_Save0 1A LD R1,OpAdd_Save1 1B LD R5,OpAdd_Save5 1C LD R7,OpAdd_Save7 1D RET 1E OpAdd_Save0 .BLKW #1 1F OpAdd_Save1 .BLKW #1 20 OpAdd_Save5 .BLKW #1 21 OpAdd_Save7 .BLKW #1 The OpAdd Subroutine Note that the OpAdd subroutine calls the RangeCheck subroutine. This is a simple test to be sure the result of the computation is within what can successfully be stored in a single stack location. For our purposes, we restrict values to integers in the range -999 to +999. This will come in handy in Section 10.3 when we design our home-brew calculator. The flowchart for the RangeCheck subroutine is shown in Figure <ref>. The LC-3 program that implements this subroutine is shown in Figure <ref>. < g r a p h i c s > The RangeCheck algorithm flowchart [fontsize=911] 01 ; 02 ; Subroutine to check that a value is 03 ; between -999 and +999. 04 ; 05 RangeCheck LD R5,Neg999 06 ADD R5,R0,R5 ; Recall that R0 contains the 07 BRp BadRange ; result being checked. 08 LD R5,Pos999 09 ADD R5,R0,R5 0A BRn BadRange 0B AND R5,R5,#0 ; R5 <– success 0C RET 0D BadRange ST R0,RangeCheck_Save0 0E LEA R0,RangeErrorMsg 0F TRAP x22 ; Output character string 10 AND R5,R5,#0 ; 11 ADD R5,R5,#1 ; R5 <– failure 12 LD R0,RangeCheck_Save0 13 RET 14 Neg999 .FILL #-999 15 Pos999 .FILL #999 16 RangeErrorMsg .FILL x000A 17 .STRINGZ \"Error: Number is out of range.\" 18 RangeCheck_Save0 .BLKW #1 The RangeCheck Subroutine The OpMult Subroutine Figure <ref> shows the flowchart of the OpMult subroutine, and Figure <ref> shows the LC-3 program that implements it. Similar to the OpAdd subroutine, the OpMult subroutine attempts to pop two values off the",
    "516": "03 ; between -999 and +999. 04 ; 05 RangeCheck LD R5,Neg999 06 ADD R5,R0,R5 ; Recall that R0 contains the 07 BRp BadRange ; result being checked. 08 LD R5,Pos999 09 ADD R5,R0,R5 0A BRn BadRange 0B AND R5,R5,#0 ; R5 <– success 0C RET 0D BadRange ST R0,RangeCheck_Save0 0E LEA R0,RangeErrorMsg 0F TRAP x22 ; Output character string 10 AND R5,R5,#0 ; 11 ADD R5,R5,#1 ; R5 <– failure 12 LD R0,RangeCheck_Save0 13 RET 14 Neg999 .FILL #-999 15 Pos999 .FILL #999 16 RangeErrorMsg .FILL x000A 17 .STRINGZ \"Error: Number is out of range.\" 18 RangeCheck_Save0 .BLKW #1 The RangeCheck Subroutine The OpMult Subroutine Figure <ref> shows the flowchart of the OpMult subroutine, and Figure <ref> shows the LC-3 program that implements it. Similar to the OpAdd subroutine, the OpMult subroutine attempts to pop two values off the stack and, if successful, multiplies them. Since the LC-3 does not have a multiply instruction, multiplication is performed as we have done in the past as a sequence of adds. Lines 17 to 19 of Figure <ref> contain the crux of the actual multiply. If the result is within the range of acceptable values, then the result is pushed onto the stack. < g r a p h i c s > Flowchart for the OpMult Subroutine [fontsize=911] 01 ; 02 ; Two values are popped from the stack, multiplied, and if 03 ; their product is within the acceptable range, the result 04 ; is pushed onto the stack. R6 is the stack pointer. 05 ; 06 OpMult ST R0,OpMult_Save0 07 ST R1,OpMult_Save1 08 ST R2,OpMult_Save2 09 ST R3,OpMult_Save3 0A ST R5,OpMult_Save5 0B ST R7,OpMult_Save7 0C AND R3,R3,#0 ; R3 holds sign of multiplier. 0D JSR POP ; Get first source from stack. 0E ADD R5,R5,#0 ; Test for successful POP. 0F BRp OpMult_Exit ; Failure 10 ADD R1,R0,#0 ; Make room for next POP. 11 JSR POP ; Get second source operand. 12 ADD R5,R5,#0 ; Test for successful POP. 13 BRp OpMult_Restore1 ; Failure; restore first POP.",
    "517": "the stack. < g r a p h i c s > Flowchart for the OpMult Subroutine [fontsize=911] 01 ; 02 ; Two values are popped from the stack, multiplied, and if 03 ; their product is within the acceptable range, the result 04 ; is pushed onto the stack. R6 is the stack pointer. 05 ; 06 OpMult ST R0,OpMult_Save0 07 ST R1,OpMult_Save1 08 ST R2,OpMult_Save2 09 ST R3,OpMult_Save3 0A ST R5,OpMult_Save5 0B ST R7,OpMult_Save7 0C AND R3,R3,#0 ; R3 holds sign of multiplier. 0D JSR POP ; Get first source from stack. 0E ADD R5,R5,#0 ; Test for successful POP. 0F BRp OpMult_Exit ; Failure 10 ADD R1,R0,#0 ; Make room for next POP. 11 JSR POP ; Get second source operand. 12 ADD R5,R5,#0 ; Test for successful POP. 13 BRp OpMult_Restore1 ; Failure; restore first POP. 14 ADD R2,R0,#0 ; Moves multiplier, tests sign. 15 BRzp PosMultiplier 16 ADD R3,R3,#1 ; Sets FLAG: Multiplier is neg. 17 NOT R2,R2 18 ADD R2,R2,#1 ; R2 contains -(multiplier). 19 PosMultiplier AND R0,R0,#0 ; Clear product register. 1A ADD R2,R2,#0 1B BRz PushMult ; Multiplier = 0, Done. 1C ; 1D MultLoop ADD R0,R0,R1 ; THE actual \"multiply\" 1E ADD R2,R2,#-1 ; Iteration Control 1F BRp MultLoop 20 ; 21 JSR RangeCheck 22 ADD R5,R5,#0 ; R5 contains success/failure. 23 BRp OpMult_Restore2 24 ; 25 ADD R3,R3,#0 ; Test for negative multiplier. 26 BRz PushMult 27 NOT R0,R0 ; Adjust for 28 ADD R0,R0,#1 ; sign of result. 29 PushMult JSR PUSH ; Push product on the stack. 2A BRnzp OpMult_Exit 2B OpMult_Restore2 ADD R6,R6,#-1 ; Adjust stack pointer. 2C OpMult_Restore1 ADD R6,R6,#-1 ; Adjust stack pointer. 2D OpMult_Exit LD R0,OpMult_Save0 2E LD R1,OpMult_Save1 2F LD R2,OpMult_Save2 30 LD R3,OpMult_Save3 31 LD R5,OpMult_Save5 32 LD R7,OpMult_Save7 33 RET 34 OpMult_Save0 .BLKW #1 35 OpMult_Save1 .BLKW #1 36 OpMult_Save2 .BLKW #1 37 OpMult_Save3 .BLKW #1 38 OpMult_Save5 .BLKW #1 39 OpMult_Save7 .BLKW #1 The OpMult Subroutine If the second of the two pops reports back unsuccessfully, the stack pointer is",
    "518": "ADD R2,R2,#-1 ; Iteration Control 1F BRp MultLoop 20 ; 21 JSR RangeCheck 22 ADD R5,R5,#0 ; R5 contains success/failure. 23 BRp OpMult_Restore2 24 ; 25 ADD R3,R3,#0 ; Test for negative multiplier. 26 BRz PushMult 27 NOT R0,R0 ; Adjust for 28 ADD R0,R0,#1 ; sign of result. 29 PushMult JSR PUSH ; Push product on the stack. 2A BRnzp OpMult_Exit 2B OpMult_Restore2 ADD R6,R6,#-1 ; Adjust stack pointer. 2C OpMult_Restore1 ADD R6,R6,#-1 ; Adjust stack pointer. 2D OpMult_Exit LD R0,OpMult_Save0 2E LD R1,OpMult_Save1 2F LD R2,OpMult_Save2 30 LD R3,OpMult_Save3 31 LD R5,OpMult_Save5 32 LD R7,OpMult_Save7 33 RET 34 OpMult_Save0 .BLKW #1 35 OpMult_Save1 .BLKW #1 36 OpMult_Save2 .BLKW #1 37 OpMult_Save3 .BLKW #1 38 OpMult_Save5 .BLKW #1 39 OpMult_Save7 .BLKW #1 The OpMult Subroutine If the second of the two pops reports back unsuccessfully, the stack pointer is decremented, which effectively returns the first value popped to the top of the stack. If the result is outside the range of acceptable values, which as before will be indicated by a 1 in R5, then the stack pointer is decremented twice, returning both values to the top of the stack. The OpNeg Subroutine To perform subtraction with the top two elements on the stack, we first replace the top element on the stack with its negative, and then use OpADD. That is, if the top of the stack contains A, and the second element on the stack contains B, we can push B-A on the stack by first negating the top of the stack and then performing OpAdd. The subroutine OpNeg for computing the negative of the element on the top of the stack is shown in Figure <ref>. [fontsize=911] 01 ; Subroutine to pop the top of the stack, form its negative, 02 ; and push the result onto the stack. 03 ; 04 OpNeg ST R0,OpNeg_Save0 05 ST R5,OpNeg_Save5 06 ST R7,OpNeg_Save7 07 JSR POP ; Get the source operand. 08 ADD R5,R5,#0 ; Test for successful pop 09 BRp OpNeg_Exit ; Branch if failure. 0A NOT",
    "519": "two elements on the stack, we first replace the top element on the stack with its negative, and then use OpADD. That is, if the top of the stack contains A, and the second element on the stack contains B, we can push B-A on the stack by first negating the top of the stack and then performing OpAdd. The subroutine OpNeg for computing the negative of the element on the top of the stack is shown in Figure <ref>. [fontsize=911] 01 ; Subroutine to pop the top of the stack, form its negative, 02 ; and push the result onto the stack. 03 ; 04 OpNeg ST R0,OpNeg_Save0 05 ST R5,OpNeg_Save5 06 ST R7,OpNeg_Save7 07 JSR POP ; Get the source operand. 08 ADD R5,R5,#0 ; Test for successful pop 09 BRp OpNeg_Exit ; Branch if failure. 0A NOT R0,R0 0B ADD R0,R0,#1 ; Form the negative of source. 0C JSR PUSH ; Push result onto the stack. 0D OpNeg_Exit LD R0,OpNeg_Save0 0E LD R5,OpNeg_Save5 0F LD R7,OpNeg_Save7 10 RET 11 OpNeg_Save0 .BLKW #1 12 OpNeg_Save5 .BLKW #1 13 OpNeg_Save7 .BLKW #1 The OpNeg Subroutine § THE CALCULATOR §.§ Functionality We are now ready to specify all the code for our calculator. As we already said, our calculator is not very sophisticated by today's standards. It will allow a user to enter positive integers consisting of not more than three decimal digits, perform basic arithmetic (addition, subtraction, and multiplication) on these integers, and display the decimal result (which will also be limited to at most three decimal digits). We will use the keyboard to tell the calculator what to do. We can enter positive integers having up to three decimal digits, the arithmetic operators + (for ADD), * (for MUL), and - (for Negative), and three additional commands D (to display the result of the calculation on the monitor), C (to erase all values entered), and X (to turn off the calculator). The calculator algorithm works as follows: We use the keyboard to input commands and decimal values. We",
    "520": "for our calculator. As we already said, our calculator is not very sophisticated by today's standards. It will allow a user to enter positive integers consisting of not more than three decimal digits, perform basic arithmetic (addition, subtraction, and multiplication) on these integers, and display the decimal result (which will also be limited to at most three decimal digits). We will use the keyboard to tell the calculator what to do. We can enter positive integers having up to three decimal digits, the arithmetic operators + (for ADD), * (for MUL), and - (for Negative), and three additional commands D (to display the result of the calculation on the monitor), C (to erase all values entered), and X (to turn off the calculator). The calculator algorithm works as follows: We use the keyboard to input commands and decimal values. We use the monitor to display results. We use a stack to hold source operands for performing arithmetic operations and the results of those arithmetic operations, as described in Section <ref>. Values entered and displayed are restricted to three decimal digits, that is, only values between -999 and +999, inclusive. Figure <ref> is a flowchart that provides an overview of our algorithm that simulates a calculator. Simulation of the calculator starts with initialization, which includes setting R6, the stack pointer, to an empty stack. Then the user sitting at the keyboard is prompted with: \"Enter a Command.\" < g r a p h i c s > The calculator, overview The following commands are available to the user. * X Exit the simulation. * D Display the value at the top of the stack. * C Clear all values from the stack. * + Pop the top two elements A,B off the stack and push A+B. * * Pop the top two elements A,B off the stack and push A*B. * - Pop the top element A off the stack and push \"minus\" A. * Enter or LF Push the value typed on the keyboard onto the top of the stack.",
    "521": "algorithm that simulates a calculator. Simulation of the calculator starts with initialization, which includes setting R6, the stack pointer, to an empty stack. Then the user sitting at the keyboard is prompted with: \"Enter a Command.\" < g r a p h i c s > The calculator, overview The following commands are available to the user. * X Exit the simulation. * D Display the value at the top of the stack. * C Clear all values from the stack. * + Pop the top two elements A,B off the stack and push A+B. * * Pop the top two elements A,B off the stack and push A*B. * - Pop the top element A off the stack and push \"minus\" A. * Enter or LF Push the value typed on the keyboard onto the top of the stack. If the user wants to enter a number, he/she types the number (up to three decimal digits) followed by <Enter> or <Line Feed (LF)>. Input is echoed, and the calculator simulation systematically tests the character to identify the user's command. Depending on the user's command, the calculator calls the appropriate subroutine to carry out the work specified. After the work is carried out, the subroutine returns, followed by a prompt for another command. The calculator simulation continues in this way until the user presses X, signaling that the user is finished with the calculator. For example, to calculate (51 - 49) * (172 + 205) - (17 * 2) and display the result 720 on the monitor, one types the following sequence of keys on the keyboard: 5,1,LF,4,9,LF,-,+,1,7,2,LF,2,0,5,LF,+,*,1,7,LF,2,LF,*,-,+,D. §.§ Code Twelve routines comprise the calculator simulation. Figure <ref> is the main algorithm, supported by eleven subroutines. Note the three global labels, StackMax, StackBase, and ASCIIBUFF are all part of the main algorithm, shown in Figure 10.15. They provide the symbol table entries needed by the subroutines that reference those locations. Note also that the stack has been allocated ten entries in the main algorithm, and R6, the Stack Pointer is",
    "522": "is carried out, the subroutine returns, followed by a prompt for another command. The calculator simulation continues in this way until the user presses X, signaling that the user is finished with the calculator. For example, to calculate (51 - 49) * (172 + 205) - (17 * 2) and display the result 720 on the monitor, one types the following sequence of keys on the keyboard: 5,1,LF,4,9,LF,-,+,1,7,2,LF,2,0,5,LF,+,*,1,7,LF,2,LF,*,-,+,D. §.§ Code Twelve routines comprise the calculator simulation. Figure <ref> is the main algorithm, supported by eleven subroutines. Note the three global labels, StackMax, StackBase, and ASCIIBUFF are all part of the main algorithm, shown in Figure 10.15. They provide the symbol table entries needed by the subroutines that reference those locations. Note also that the stack has been allocated ten entries in the main algorithm, and R6, the Stack Pointer is initialized to an empty stack in line 05. 36pc[fontsize=910] 01 ; 02 ; The Calculator, Main Algorithm 03 ; 04 LEA R6,StackBase ; Initialize the Stack Pointer. 05 ADD R6,R6,#1 ; R6 = StackBase + 1 –> empty stack 06 07 NewCommand LEA R0,PromptMsg 08 PUTS 09 GETC 0A OUT 0B ; 0C ; Check the command 0D ; 0E TestX LD R1,NegX ; Check for X. 0F ADD R1,R1,R0 10 BRnp TestC 11 HALT 12 ; 13 TestC LD R1,NegC ; Check for C. 14 ADD R1,R1,R0 15 BRnp TestAdd 16 JSR OpClear ; See Figure 10.20 17 BRnzp NewCommand 18 ; 19 TestAdd LD R1,NegPlus ; Check for + 1A ADD R1,R1,R0 1B BRnp TestMult 1C JSR OpAdd ; See Figure 10.8 1D BRnzp NewCommand 1E ; 1F TestMult LD R1,NegMult ; Check for * 20 ADD R1,R1,R0 21 BRnp TestMinus 22 JSR OpMult ; See Figure 10.12 23 BRnzp NewCommand 24 ; 25 TestMinus LD R1,NegMinus ; Check for - 26 ADD R1,R1,R0 27 BRnp TestD 28 JSR OpNeg ; See Figure 10.13 29 BRnzp NewCommand 2A ; 2B TestD LD R1,NegD ; Check for D 2C ADD R1,R1,R0 2D BRnp EnterNumber 2E JSR OpDisplay ; See",
    "523": "TestX LD R1,NegX ; Check for X. 0F ADD R1,R1,R0 10 BRnp TestC 11 HALT 12 ; 13 TestC LD R1,NegC ; Check for C. 14 ADD R1,R1,R0 15 BRnp TestAdd 16 JSR OpClear ; See Figure 10.20 17 BRnzp NewCommand 18 ; 19 TestAdd LD R1,NegPlus ; Check for + 1A ADD R1,R1,R0 1B BRnp TestMult 1C JSR OpAdd ; See Figure 10.8 1D BRnzp NewCommand 1E ; 1F TestMult LD R1,NegMult ; Check for * 20 ADD R1,R1,R0 21 BRnp TestMinus 22 JSR OpMult ; See Figure 10.12 23 BRnzp NewCommand 24 ; 25 TestMinus LD R1,NegMinus ; Check for - 26 ADD R1,R1,R0 27 BRnp TestD 28 JSR OpNeg ; See Figure 10.13 29 BRnzp NewCommand 2A ; 2B TestD LD R1,NegD ; Check for D 2C ADD R1,R1,R0 2D BRnp EnterNumber 2E JSR OpDisplay ; See Figure 10.19 2F BRnzp NewCommand 30 ; 31 ; Then we must be entering an integer 32 ; 33 EnterNumber JSR PushValue ; See Figure 10.16 34 BRnzp NewCommand 35 ; 36 PromptMsg .FILL x000A 37 .STRINGZ \"Enter a command:\" 38 NegX .FILL xFFA8 39 NegC .FILL xFFBD 3A NegPlus .FILL xFFD5 3B NegMinus .FILL xFFD3 3C NegMult .FILL xFFD6 3D NegD .FILL xFFBC 3E 3F ; Globals 40 StackMax .BLKW #9 41 StackBase .BLKW #1 42 ASCIIBUFF .BLKW #4 43 .FILL x0000 ; ASCIIBUFF sentinel The calculator's main algorithm Figure <ref> takes an ASCII string of characters terminating by a LF, checks to be sure it corresponds to a string of not more than three decimal digits, and if so, converts it to a binary number, and pushes the binary number onto the top of the stack. Figure <ref> provides the ASCII-to-binary conversion routine. Figure <ref> pops the entry on the top of the stack, converts it to an ASCII character string, and displays the ASCII string on the monitor. Figure <ref> provides the binary-to-ASCII conversion routine. Figures <ref> (OpAdd), <ref> (OpMult), and <ref> (OpNeg) supply the basic arithmetic algorithms using a stack. Figures <ref> and <ref> contain the",
    "524": "3D NegD .FILL xFFBC 3E 3F ; Globals 40 StackMax .BLKW #9 41 StackBase .BLKW #1 42 ASCIIBUFF .BLKW #4 43 .FILL x0000 ; ASCIIBUFF sentinel The calculator's main algorithm Figure <ref> takes an ASCII string of characters terminating by a LF, checks to be sure it corresponds to a string of not more than three decimal digits, and if so, converts it to a binary number, and pushes the binary number onto the top of the stack. Figure <ref> provides the ASCII-to-binary conversion routine. Figure <ref> pops the entry on the top of the stack, converts it to an ASCII character string, and displays the ASCII string on the monitor. Figure <ref> provides the binary-to-ASCII conversion routine. Figures <ref> (OpAdd), <ref> (OpMult), and <ref> (OpNeg) supply the basic arithmetic algorithms using a stack. Figures <ref> and <ref> contain the basic POP and PUSH routines Finally, Figure <ref> clears the stack. [fontsize=910] 01 ; This subroutine takes a sequence of not more than three decimal digits 02 ; typed by the user, converts its ASCII string to a binary value using the 03 ; ASCIItoBinary subroutine, and pushes the binary value onto the stack. 04 ; Anything else typed results in an error message. 05 ; 06 PushValue ST R0,PushValue_Save0 07 ST R1,PushValue_Save1 08 ST R2,PushValue_Save2 09 ST R7,PushValue_Save7 0A LD R1,PushValue_ASCIIBUFF ; R1 points to string being 0B LD R2,MaxDigits ; generated. 0C ; 0D ValueLoop ADD R3,R0,x-0A ; Test for line feed, x0A 0E BRz GoodInput 0F ADD R2,R2,#0 10 BRz TooLargeInput 11 LD R3,NEGASCII0 12 ADD R3,R0,R3 13 BRn NotInteger 14 LD R3,NEGASCII9 15 ADD R3,R0,R3 16 BRp NotInteger 17 ADD R2,R2,#-1 ; Still room for more digits. 18 STR R0,R1,#0 ; Store last character read. 19 ADD R1,R1,#1 1A GETC 1B OUT ; Echo it. 1C BRnzp ValueLoop 1D ; 1E GoodInput LD R2,PushValue_ASCIIBUFF 1F NOT R2,R2 20 ADD R2,R2,#1 21 ADD R1,R1,R2 ; R1 now contains no. of char. 22 BRz NoDigit 23 JSR ASCIItoBinary 24 JSR PUSH 25 BRnzp PushValue_Done The calculator's PushValue routine",
    "525": "in an error message. 05 ; 06 PushValue ST R0,PushValue_Save0 07 ST R1,PushValue_Save1 08 ST R2,PushValue_Save2 09 ST R7,PushValue_Save7 0A LD R1,PushValue_ASCIIBUFF ; R1 points to string being 0B LD R2,MaxDigits ; generated. 0C ; 0D ValueLoop ADD R3,R0,x-0A ; Test for line feed, x0A 0E BRz GoodInput 0F ADD R2,R2,#0 10 BRz TooLargeInput 11 LD R3,NEGASCII0 12 ADD R3,R0,R3 13 BRn NotInteger 14 LD R3,NEGASCII9 15 ADD R3,R0,R3 16 BRp NotInteger 17 ADD R2,R2,#-1 ; Still room for more digits. 18 STR R0,R1,#0 ; Store last character read. 19 ADD R1,R1,#1 1A GETC 1B OUT ; Echo it. 1C BRnzp ValueLoop 1D ; 1E GoodInput LD R2,PushValue_ASCIIBUFF 1F NOT R2,R2 20 ADD R2,R2,#1 21 ADD R1,R1,R2 ; R1 now contains no. of char. 22 BRz NoDigit 23 JSR ASCIItoBinary 24 JSR PUSH 25 BRnzp PushValue_Done The calculator's PushValue routine 36pc[fontsize=911] 26 NoDigit LEA R0,NoDigitMsg 27 PUTS 28 BRnzp PushValue_Done 29 NotInteger GETC ; Spin until carriage return. 2A OUT 2B ADD R3,R0,x-0A ; Test for line feed, x0A 2C BRnp NotInteger 2D LEA R0,NotIntegerMsg 2E PUTS 2F BRnzp PushValue_Done 30 TooLargeInput GETC ; Spin until carriage return. 31 OUT 32 ADD R3,R0,x-0A ; Test for line feed, x0A 33 BRnp TooLargeInput 34 LEA R0,TooManyDigits 35 PUTS 36 PushValue_Done LD R0,PushValue_Save0 37 LD R1,PushValue_Save1 38 LD R2,PushValue_Save2 39 LD R7,PushValue_Save7 3A RET 3B TooManyDigits .FILL x000A 3C .STRINGZ \"Too many digits\" 3D NoDigitMsg .FILL x000A 3E .STRINGZ \"No number entered\" 3F NotIntegerMsg .FILL x000A 40 .STRINGZ \"Not an integer\" 41 MaxDigits .FILL x0003 42 NegASCII0 .FILL x-30 43 NegASCII9 .FILL x-39 44 PushValue_ASCIIBUFF .FILL ASCIIBUFF 45 PushValue_Save0 .BLKW #1 46 PushValue_Save1 .BLKW #1 47 PushValue_Save2 .BLKW #1 48 PushValue_Save7 .BLKW #1 The calculator's PushValue routine (continued) 36pc[fontsize=910] 01 ; This subroutine POPs a value from the stack and puts it in 02 ; R0 before returning to the calling program. R5 is used to 03 ; report success (R5 = 0) or failure (R5 = 1) of the POP operation. 04 POP LD R0,POP_StackBase 05 NOT R0,R0 ; R0 =",
    "526": "BRnp TooLargeInput 34 LEA R0,TooManyDigits 35 PUTS 36 PushValue_Done LD R0,PushValue_Save0 37 LD R1,PushValue_Save1 38 LD R2,PushValue_Save2 39 LD R7,PushValue_Save7 3A RET 3B TooManyDigits .FILL x000A 3C .STRINGZ \"Too many digits\" 3D NoDigitMsg .FILL x000A 3E .STRINGZ \"No number entered\" 3F NotIntegerMsg .FILL x000A 40 .STRINGZ \"Not an integer\" 41 MaxDigits .FILL x0003 42 NegASCII0 .FILL x-30 43 NegASCII9 .FILL x-39 44 PushValue_ASCIIBUFF .FILL ASCIIBUFF 45 PushValue_Save0 .BLKW #1 46 PushValue_Save1 .BLKW #1 47 PushValue_Save2 .BLKW #1 48 PushValue_Save7 .BLKW #1 The calculator's PushValue routine (continued) 36pc[fontsize=910] 01 ; This subroutine POPs a value from the stack and puts it in 02 ; R0 before returning to the calling program. R5 is used to 03 ; report success (R5 = 0) or failure (R5 = 1) of the POP operation. 04 POP LD R0,POP_StackBase 05 NOT R0,R0 ; R0 = -(addr. of StackBase + 1) 06 ADD R0,R0,R6 ; R6 = StackPointer 07 BRz Underflow 08 LDR R0,R6,#0 ; The actual POP 09 ADD R6,R6,#1 ; Adjust StackPointer 0A AND R5,R5,#0 ; R5 <– success 0B RET 0C Underflow LEA R0,UnderflowMsg 0D PUTS ; Print error message. 0E AND R5,R5,#0 0F ADD R5,R5,#1 ; R5 <– failure 10 RET 11 UnderflowMsg .FILL x000A 12 .STRINGZ \"Error: Too Few Values on the Stack.\" 13 POP_StackBase .FILL StackBase The calculator's POP routine 36pc[fontsize=910] 01 ; This subroutine PUSHes on the stack the value stored in R0. 02 ; R5 is used to report success (R5 = 0) or failure (R5 = 1) of 03 ; the PUSH operation. 04 PUSH ST R1,PUSH_Save1 ; R1 is needed by this routine. 05 LD R1,PUSH_StackMax 06 NOT R1,R1 07 ADD R1,R1,#1 ; R1 = - addr. of StackMax 08 ADD R1,R1,R6 ; R6 = StackPointer 09 BRz Overflow 0A ADD R6,R6,#-1 ; Adjust StackPointer for PUSH. 0B STR R0,R6,#0 ; The actual PUSH 0C LD R1,PUSH_Save1 ; Restore R1. 0D AND R5,R5,#0 ; R5 <– success 0E RET 0F Overflow LEA R0,OverflowMsg 10 PUTS 11 LD R1,PUSH_Save1 ; Restore R1. 12 AND R5,R5,#0 13 ADD",
    "527": "UnderflowMsg .FILL x000A 12 .STRINGZ \"Error: Too Few Values on the Stack.\" 13 POP_StackBase .FILL StackBase The calculator's POP routine 36pc[fontsize=910] 01 ; This subroutine PUSHes on the stack the value stored in R0. 02 ; R5 is used to report success (R5 = 0) or failure (R5 = 1) of 03 ; the PUSH operation. 04 PUSH ST R1,PUSH_Save1 ; R1 is needed by this routine. 05 LD R1,PUSH_StackMax 06 NOT R1,R1 07 ADD R1,R1,#1 ; R1 = - addr. of StackMax 08 ADD R1,R1,R6 ; R6 = StackPointer 09 BRz Overflow 0A ADD R6,R6,#-1 ; Adjust StackPointer for PUSH. 0B STR R0,R6,#0 ; The actual PUSH 0C LD R1,PUSH_Save1 ; Restore R1. 0D AND R5,R5,#0 ; R5 <– success 0E RET 0F Overflow LEA R0,OverflowMsg 10 PUTS 11 LD R1,PUSH_Save1 ; Restore R1. 12 AND R5,R5,#0 13 ADD R5,R5,#1 ; R5 <– failure 14 RET 15 PUSH_Save1 .BLKW #1 16 OverflowMsg .FILL x000A 17 .STRINGZ \"Error: Stack is Full.\" 18 PUSH_StackMax .FILL StackMax The calculator's PUSH routine 36pc[fontsize=910] 01 ; This subroutine calls BinarytoASCII to convert the 2's complement 02 ; number on the top of the stack into an ASCII character string, and 03 ; then calls PUTS to display that number on the screen. 04 OpDisplay ST R0,OpDisplay_Save0 05 ST R5,OpDisplay_Save5 06 ST R7,OpDisplay_Save7 07 JSR POP ; R0 gets the value to be displayed. 08 ADD R5,R5,#0 09 BRp OpDisplay_DONE ; POP failed, nothing on the stack. 0A JSR BinarytoASCII 0B LD R0,NewlineChar 0C OUT 0D LD R0,OpDisplay_ASCIIBUFF 0E PUTS 0F ADD R6,R6,#-1 ; Push displayed number back on stack. 10 OpDisplay_DONE LD R0,OpDisplay_Save0 11 LD R5,OpDisplay_Save5 12 LD R7,OpDisplay_Save7 13 RET 14 NewlineChar .FILL x000A 15 OpDisplay_ASCIIBUFF .FILL ASCIIBUFF 16 OpDisplay_Save0 .BLKW #1 17 OpDisplay_Save5 .BLKW #1 18 OpDisplay_Save7 .BLKW #1 The calculator's display routine [fontsize=911] 01 ; 02 ; This routine clears the stack by resetting the stack pointer (R6). 03 ; 04 OpClear LD R6,OpClear_StackBase ; Initialize the Stack Pointer. 05 ADD R6,R6,#1 ; R6 = StackBase + 1 –> empty stack",
    "528": "PUTS to display that number on the screen. 04 OpDisplay ST R0,OpDisplay_Save0 05 ST R5,OpDisplay_Save5 06 ST R7,OpDisplay_Save7 07 JSR POP ; R0 gets the value to be displayed. 08 ADD R5,R5,#0 09 BRp OpDisplay_DONE ; POP failed, nothing on the stack. 0A JSR BinarytoASCII 0B LD R0,NewlineChar 0C OUT 0D LD R0,OpDisplay_ASCIIBUFF 0E PUTS 0F ADD R6,R6,#-1 ; Push displayed number back on stack. 10 OpDisplay_DONE LD R0,OpDisplay_Save0 11 LD R5,OpDisplay_Save5 12 LD R7,OpDisplay_Save7 13 RET 14 NewlineChar .FILL x000A 15 OpDisplay_ASCIIBUFF .FILL ASCIIBUFF 16 OpDisplay_Save0 .BLKW #1 17 OpDisplay_Save5 .BLKW #1 18 OpDisplay_Save7 .BLKW #1 The calculator's display routine [fontsize=911] 01 ; 02 ; This routine clears the stack by resetting the stack pointer (R6). 03 ; 04 OpClear LD R6,OpClear_StackBase ; Initialize the Stack Pointer. 05 ADD R6,R6,#1 ; R6 = StackBase + 1 –> empty stack 06 RET 07 OpClear_StackBase .FILL StackBase The OpClear routine 10.1 Describe, in your own words, how the Multiply step of the OpMult algorithm in Figure 10.14 works. How many instructions are executed to perform the Multiply step? Express your answer in terms of n, the value of the multiplier. ( Note: If an instruction executes five times, it contributes 5 to the total count.) Write a program fragment that performs the Multiply step in fewer instructions if the value of the multiplier is less than 25. How many? 10.2 Correct Figure <ref> so that it will add two single-digit positive integers and produce a single-digit positive sum. Assume that the two digits being added do in fact produce a single-digit sum. 10.3 Modify Figure <ref>, assuming that the input numbers are one-digit positive hex numbers. Assume that the two hex digits being added together do in fact produce a single hex-digit sum. 10.4 Figure <ref> provides an algorithm for converting ASCII strings to binary values. Suppose the decimal number is arbitrarily long. Rather than store a table of 10 values for the thousands-place digit, another table for the 10 ten-thousands-place digit, and so on, design an algorithm to do the",
    "529": "to the total count.) Write a program fragment that performs the Multiply step in fewer instructions if the value of the multiplier is less than 25. How many? 10.2 Correct Figure <ref> so that it will add two single-digit positive integers and produce a single-digit positive sum. Assume that the two digits being added do in fact produce a single-digit sum. 10.3 Modify Figure <ref>, assuming that the input numbers are one-digit positive hex numbers. Assume that the two hex digits being added together do in fact produce a single hex-digit sum. 10.4 Figure <ref> provides an algorithm for converting ASCII strings to binary values. Suppose the decimal number is arbitrarily long. Rather than store a table of 10 values for the thousands-place digit, another table for the 10 ten-thousands-place digit, and so on, design an algorithm to do the conversion without resorting to any tables whatsoever. 10.5 The code in Figure <ref> converts a decimal number represented as ASCII digits into binary. Extend this code to also convert a hexadecimal number represented in ASCII into binary. If the number is preceded by an x, then the subsequent ASCII digits (three at most) represent a hex number; otherwise it is decimal. 10.6 The algorithm of Figure <ref> always produces a string of four characters independent of the sign and magnitude of the integer being converted. Devise an algorithm that eliminates unnecessary characters in common representations, that is, an algorithm that does not store leading 0s nor a leading + sign. 10.7 What does the following LC-3 program do? .ORIG x3000 LEA R6, STACKBASE LEA R0, PROMPT TRAP x22 ; PUTS AND R1, R1, #0 LOOP TRAP x20 ; IN TRAP x21 ADD R3, R0, #-10 ; Check for newline BRz INPUTDONE JSR PUSH ADD R1, R1, #1 BRnzp LOOP INPUTDONE ADD R1, R1, #0 BRz DONE LOOP2 JSR POP TRAP x21 ADD R1, R1, #-1 BRp LOOP2 DONE TRAP x25 ; HALT PUSH ADD R6, R6, #-2 STR R0, R6, #0 RET POP LDR R0, R6, #0 ADD R6, R6,",
    "530": "decimal. 10.6 The algorithm of Figure <ref> always produces a string of four characters independent of the sign and magnitude of the integer being converted. Devise an algorithm that eliminates unnecessary characters in common representations, that is, an algorithm that does not store leading 0s nor a leading + sign. 10.7 What does the following LC-3 program do? .ORIG x3000 LEA R6, STACKBASE LEA R0, PROMPT TRAP x22 ; PUTS AND R1, R1, #0 LOOP TRAP x20 ; IN TRAP x21 ADD R3, R0, #-10 ; Check for newline BRz INPUTDONE JSR PUSH ADD R1, R1, #1 BRnzp LOOP INPUTDONE ADD R1, R1, #0 BRz DONE LOOP2 JSR POP TRAP x21 ADD R1, R1, #-1 BRp LOOP2 DONE TRAP x25 ; HALT PUSH ADD R6, R6, #-2 STR R0, R6, #0 RET POP LDR R0, R6, #0 ADD R6, R6, #2 RET PROMPT .STRINGZ “Please enter a sentence: ” STACKSPAC .BLKW #50 STACKBASE .FILL #0 .END 10.8STAR The calculator program assumes that if the user did not type one of the characters X,C,+,-,*,D, then it must be pushing a value and so executes BRnzp PushValue. Modify the program so it is more rubust, that is, if the user typed something other than a digit, the main program would load R0 with the ascii code for X, and branch to Test. If the user typed a digit, the main program would branch to PushValue. 10.9STAR Improve the robustness by modifying PushValue to make sure all the characers typed are digits. ../art/ch09/,../art/designelements/,../art/designelements/UnNumberedArt/makechapterhead#1 @ (0,0) (432,-577) < g r a p h i c s > (428,-577)1@9.52667in(381.5,-181) < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > 1212chapter 1212chapter 7212 3032#1 36.4pc4@ CHAPTER: I/O Up to now we have completely ignored the details of input and output, that is, how the computer actually",
    "531": "other than a digit, the main program would load R0 with the ascii code for X, and branch to Test. If the user typed a digit, the main program would branch to PushValue. 10.9STAR Improve the robustness by modifying PushValue to make sure all the characers typed are digits. ../art/ch09/,../art/designelements/,../art/designelements/UnNumberedArt/makechapterhead#1 @ (0,0) (432,-577) < g r a p h i c s > (428,-577)1@9.52667in(381.5,-181) < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > 1212chapter 1212chapter 7212 3032#1 36.4pc4@ CHAPTER: I/O Up to now we have completely ignored the details of input and output, that is, how the computer actually gets information from the keyboard (input), and how the computer actually delivers information to the monitor (output). Instead we have relied on the TRAP instruction (for example, TRAP x23 for input and TRAP x21 for output) to accomplish these tasks. The TRAP instruction enables us to tell the operating system what we need done by means of a trap vector, and we trust the operating system to do it for us. The more generic term for our TRAP instruction is system call because the TRAP instruction is calling on the operating system to do something for us while allowing us to remain completely clueless as to how it gets done. Now we are ready to examine how input and output actually work in the LC-3, what happens when the user program makes a system call by invoking the TRAP instruction, and how it all works under the control of the operating system. We will start with the actual physical structures that are required to cause input and output to occur. But before we do that, it is useful to say a few words about the operating system and understand a few basic concepts that have not been important so far,",
    "532": "and we trust the operating system to do it for us. The more generic term for our TRAP instruction is system call because the TRAP instruction is calling on the operating system to do something for us while allowing us to remain completely clueless as to how it gets done. Now we are ready to examine how input and output actually work in the LC-3, what happens when the user program makes a system call by invoking the TRAP instruction, and how it all works under the control of the operating system. We will start with the actual physical structures that are required to cause input and output to occur. But before we do that, it is useful to say a few words about the operating system and understand a few basic concepts that have not been important so far, but become very important when considering what the operating system needs to do its job. You may be familiar with Microsoft's various flavors of Windows, Apple's MacOS, and Linux. These are all examples of operating systems. They all have the same goal: to optimize the use of all the resources of the computer system while making sure that no software does harmful things to any program or data that it has no right to mess with. To better understand their job, we need to understand the notions of privilege and priority and the layout of the memory address space (i.e., the regions of memory and the purpose of each). § PRIVILEGE, PRIORITY, AND THE MEMORY ADDRESS SPACE §.§ Privilege and Priority Two very different (we often say orthogonal) concepts associated with computer processing are privilege and priority. §.§.§ Privilege Privilege is all about the right to do something, such as execute a particular instruction or access a particular memory location. Not all computer programs have the right to execute all instructions. For example, if a computer system is shared among many users and the ISA contains a HALT instruction, we would not want any random program to execute that HALT",
    "533": "does harmful things to any program or data that it has no right to mess with. To better understand their job, we need to understand the notions of privilege and priority and the layout of the memory address space (i.e., the regions of memory and the purpose of each). § PRIVILEGE, PRIORITY, AND THE MEMORY ADDRESS SPACE §.§ Privilege and Priority Two very different (we often say orthogonal) concepts associated with computer processing are privilege and priority. §.§.§ Privilege Privilege is all about the right to do something, such as execute a particular instruction or access a particular memory location. Not all computer programs have the right to execute all instructions. For example, if a computer system is shared among many users and the ISA contains a HALT instruction, we would not want any random program to execute that HALT instruction and stop the computer. If we did, we would have some pretty disgruntled users on our hands. Similarly, some memory locations are only available to the operating system. We would not want some random program to interfere with the data structures or code that are part of the operating system, which would in all likelihood cause the entire system to crash. In order to make sure neither of these two things happen, we designate every computer program as either privileged or unprivileged. We often say Supervisor privilege to indicate privileged. Programs that have Supervisor privilege can execute all instructions and can access all of memory. Unprivileged programs can not. We say a program is executing in Supervisor mode to indicate privileged, or User mode to indicate unprivileged. §.§.§ Priority Priority is all about the urgency of a program to execute. Every program is assigned a priority, specifying its urgency as compared to all other programs. This allows programs of greater urgency to interrupt programs of lesser urgency. For example, programs written by random users may be assigned a priority of 0. The keyboard may be asigned a priority of 4, and the fact that the computer is plugged into",
    "534": "to crash. In order to make sure neither of these two things happen, we designate every computer program as either privileged or unprivileged. We often say Supervisor privilege to indicate privileged. Programs that have Supervisor privilege can execute all instructions and can access all of memory. Unprivileged programs can not. We say a program is executing in Supervisor mode to indicate privileged, or User mode to indicate unprivileged. §.§.§ Priority Priority is all about the urgency of a program to execute. Every program is assigned a priority, specifying its urgency as compared to all other programs. This allows programs of greater urgency to interrupt programs of lesser urgency. For example, programs written by random users may be assigned a priority of 0. The keyboard may be asigned a priority of 4, and the fact that the computer is plugged into a source of energy like a wall outlet may be assigned a priority of 6. If that is the case, a random user program would be interrupted if someone sitting at a keybord wanted to execute a program that caused data to be input into the computer. And that program would be interrupted if someone pulled the power cord out of the wall outlet causing the computer to quickly lose its source of energy. In such an event, we would want the computer to execute some operating system program that is provided specifically to handle that situation. §.§.§ Two orthogonal notions We said privilege and priority are two orthogoanal notions, meaning they have nothing to do with each other. We humans sometimes have a problem with that as we think of fire trucks that have the privilege of ignoring traffic lights because they have the urgency to reach the fire. In our daily lives we often are given privileges because of our greater sense of urgency. Not the case with computer systems. For example, we can have a user program that is tied to a physics experiment that needs to interrupt the computer at a specific instance of time to",
    "535": "of the wall outlet causing the computer to quickly lose its source of energy. In such an event, we would want the computer to execute some operating system program that is provided specifically to handle that situation. §.§.§ Two orthogonal notions We said privilege and priority are two orthogoanal notions, meaning they have nothing to do with each other. We humans sometimes have a problem with that as we think of fire trucks that have the privilege of ignoring traffic lights because they have the urgency to reach the fire. In our daily lives we often are given privileges because of our greater sense of urgency. Not the case with computer systems. For example, we can have a user program that is tied to a physics experiment that needs to interrupt the computer at a specific instance of time to record information being generated by the physics experiment. If the user program does not pre-empt the program running at that instant of time, the data generated by the experiment may be lost. This is a user program so it does not have Supervisor privilege. But it does have a greater urgency, so it does have a higher priority. Another example, the system administrator who wants to execute diagnostic programs that access all memory locations and execute all instructions as part of some standard preventive maintenance. The diagnostic program needs Supervisor privilege to execute all instructions and access all memory locations. But it has no sense of urgency. Whether this happens at 1am or 2am is irrelevant, compared to the urgency of other programs that need access to the computer system exactly when they need it. The diagnostic program has privilege but no priority. Finally, an example showing that even in human activity one can have priority but not privilege. Our friend Bob works in the basement of one of those New York City skyscapers. He is about to go to the Men's Room when his manager tells him to take a message immediately to the Vice President on the 88th",
    "536": "the system administrator who wants to execute diagnostic programs that access all memory locations and execute all instructions as part of some standard preventive maintenance. The diagnostic program needs Supervisor privilege to execute all instructions and access all memory locations. But it has no sense of urgency. Whether this happens at 1am or 2am is irrelevant, compared to the urgency of other programs that need access to the computer system exactly when they need it. The diagnostic program has privilege but no priority. Finally, an example showing that even in human activity one can have priority but not privilege. Our friend Bob works in the basement of one of those New York City skyscapers. He is about to go to the Men's Room when his manager tells him to take a message immediately to the Vice President on the 88th floor, and bring back a response. So Bob delays his visit to the Men's Room and takes the elevator to the 88th floor. The Vice President keeps him waiting, causing Bob to be concerned he might have an accident. Finally, the Vice President gives his response, and Bob pushes the button to summon the elevator to take him back to the basement, in pain because he needs to go to the Men's Room. While waiting for the elevator, another Vice President appears, unlocks the Executive Men's Room and enters. Bob is in pain, but he can not enter the Executive Men's Room. Although he certainly has the priority, he does not have the privilege! §.§.§ the Processor Status Register (PSR) Each program executing on the computer is assigned a privilege and a priority. Figure <ref> shows the Processor Status Register (PSR), which contains that assignment. Each program has associated with it two very importnat registers. The Program Counter (PC) you are very familiar with. The PSR is shown below: 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 1|c|0pt10ptPr0pt10pt 3c 1c| 1c 1cPL n 1c| 3c 2c 1|cN 1|c|Z 1c|P 2lPriv 4c 2cPriority",
    "537": "the basement, in pain because he needs to go to the Men's Room. While waiting for the elevator, another Vice President appears, unlocks the Executive Men's Room and enters. Bob is in pain, but he can not enter the Executive Men's Room. Although he certainly has the priority, he does not have the privilege! §.§.§ the Processor Status Register (PSR) Each program executing on the computer is assigned a privilege and a priority. Figure <ref> shows the Processor Status Register (PSR), which contains that assignment. Each program has associated with it two very importnat registers. The Program Counter (PC) you are very familiar with. The PSR is shown below: 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 1|c|0pt10ptPr0pt10pt 3c 1c| 1c 1cPL n 1c| 3c 2c 1|cN 1|c|Z 1c|P 2lPriv 4c 2cPriority 5c 3ccond codes PSR Processsor Status Register (PSR) Bit[15] specifies the privilege, where PSR[15]=0 means Supervisor privilege, and PSR[15]=1 means unprivileged. Bits[10:8] specifies the priority level (PL) of the program. The highest priority level is 7 (PL7), the lowest is PL0. The PSR also contains the current values of the condition codes, as shown in Figure <ref>. We will see in Section 9.4 why it is important that the condition codes are included in the PSR. §.§ Organization of Memory Figure <ref> shows the layout of the LC-3 memory. < g r a p h i c s > Regions of Memory You know that the LC-3 has a 16 bit address space; ergo, memory locations from x0000 to xFFFF. Locations x0000 to x2FFF are privileged memory locations. They contain the various data structures and code of the operating system. They require Supervisor privilege to access. They are referred to as System Space. Locations x3000 to xFDFF are unprivileged memory locations. Supervisor privilege is not required to access these memory locations. All user programs and data use this region of memory. The region is often referred to as User Space. Addresses xFE00 to xFFFF do not correspond to memory locations",
    "538": "in Section 9.4 why it is important that the condition codes are included in the PSR. §.§ Organization of Memory Figure <ref> shows the layout of the LC-3 memory. < g r a p h i c s > Regions of Memory You know that the LC-3 has a 16 bit address space; ergo, memory locations from x0000 to xFFFF. Locations x0000 to x2FFF are privileged memory locations. They contain the various data structures and code of the operating system. They require Supervisor privilege to access. They are referred to as System Space. Locations x3000 to xFDFF are unprivileged memory locations. Supervisor privilege is not required to access these memory locations. All user programs and data use this region of memory. The region is often referred to as User Space. Addresses xFE00 to xFFFF do not correspond to memory locations at all. That is, the last address of a memory location is xFDFF. Addresses xFE00 to xFFFF are used to identify registers that take part in input and output functions, and some special registers associated with the processor. For example, the PSR is assigned address xFFFC, and the processor's Master Control Register (MCR) is assigned address xFFFE. The benefit of assigning addresses from the memory address space will be discussed in Section 9.2.1.2. The set of addresses from xFE00 to xFFFF is usually referred to as the I/O Page since most of the addresses are used for identifying registers that take part in input or output functions. Access to those registers requires Supervisor privilege. Finally, note that Figure <ref> shows two stacks, a Supervisor Stack in system space and a User Stack in user space. The Supervisor Stack is controlled by the operating system, and requires Supervisor privilege to access. The User Stack is controlled by the user program and does not require privilege to access. Each has a stack pointer, Supervisor Stack Pointer (SSP) and User Stack Pointer (USP), to indicate the top of the stack. Since a program can only execute in Supervisor mode or User mode at",
    "539": "assigning addresses from the memory address space will be discussed in Section 9.2.1.2. The set of addresses from xFE00 to xFFFF is usually referred to as the I/O Page since most of the addresses are used for identifying registers that take part in input or output functions. Access to those registers requires Supervisor privilege. Finally, note that Figure <ref> shows two stacks, a Supervisor Stack in system space and a User Stack in user space. The Supervisor Stack is controlled by the operating system, and requires Supervisor privilege to access. The User Stack is controlled by the user program and does not require privilege to access. Each has a stack pointer, Supervisor Stack Pointer (SSP) and User Stack Pointer (USP), to indicate the top of the stack. Since a program can only execute in Supervisor mode or User mode at any one time, only one of the two stacks is active at any one time. Register 6 is generally used as the stack pointer (SP) for the active stack. Two registers, Saved_SSP and Saved_USP are provided to save the SP not in use. When privilege changes, for example, from Supervisor mode to User mode, the SP is stored in Saved_SSP, and the SP is loaded from Saved_USP. § INPUT/OUTPUT Input and output devices (keyboards, monitors, disks, or kiosks at the shopping mall) all handle input or output data using registers that are tailored to the needs of each particular input or output device. Even the simplest I/O devices usually need at least two registers: one to hold the data being transferred between the device and the computer, and one to indicate status information about the device. An example of status information is whether the device is available or is it still busy processing the most recent I/O task. device register §.§ Some basic characteristics of I/O All I/O activity is controlled by instructions in the computer's ISA. Does the ISA need special instructions for dealing with I/O? Does the I/O device execute at the same speed as the computer, and",
    "540": "and the SP is loaded from Saved_USP. § INPUT/OUTPUT Input and output devices (keyboards, monitors, disks, or kiosks at the shopping mall) all handle input or output data using registers that are tailored to the needs of each particular input or output device. Even the simplest I/O devices usually need at least two registers: one to hold the data being transferred between the device and the computer, and one to indicate status information about the device. An example of status information is whether the device is available or is it still busy processing the most recent I/O task. device register §.§ Some basic characteristics of I/O All I/O activity is controlled by instructions in the computer's ISA. Does the ISA need special instructions for dealing with I/O? Does the I/O device execute at the same speed as the computer, and if not what manages the difference in speeds? Is the transfer of information between the computer and the I/O device initiated by a program executing in the computer or is it initiated by the I/O device? Answers to these questions form some of the basic characteristics of I/O activity. §.§.§ Memory-Mapped I/O vs Special I/O Instructions An instruction that interacts with an input or output device register must identify the particular input or output device register with which it is interacting. Two schemes have been used in the past. Some computers use special input and output instructions. Most computers prefer to use the same data movement instructions that are used to move data in and out of memory. The very old PDP-8 (from Digital Equipment Corporation, more than 60 years ago—1965) is an example of a computer that used special input and output instructions. The 12-bit PDP-8 instruction contained a 3-bit opcode. If the opcode was 110, an I/O instruction was indicated. The remaining nine bits of the PDP-8 instruction identified which I/O device register and what operation was to be performed. Most computer designers prefer not to specify an additional set of instructions for dealing with input and output.",
    "541": "with an input or output device register must identify the particular input or output device register with which it is interacting. Two schemes have been used in the past. Some computers use special input and output instructions. Most computers prefer to use the same data movement instructions that are used to move data in and out of memory. The very old PDP-8 (from Digital Equipment Corporation, more than 60 years ago—1965) is an example of a computer that used special input and output instructions. The 12-bit PDP-8 instruction contained a 3-bit opcode. If the opcode was 110, an I/O instruction was indicated. The remaining nine bits of the PDP-8 instruction identified which I/O device register and what operation was to be performed. Most computer designers prefer not to specify an additional set of instructions for dealing with input and output. They use the same data movement instructions that are used for loading and storing data between memory and the general purpose registers. For example, a load instruction (LD, LDI, or LDR), in which the source address is that of an input device register, is an input instruction. Similarly, a store instruction (ST, STI, or STR) in which the destination address is that of an output device register is an output instruction. Since programmers use the same data movement instructions that are used for memory, every input device register and every output device register must be uniquely identified in the same way that memory locations are uniquely identified. Therefore, each device register is assigned an address from the memory address space of the ISA. That is, the I/O device registers are mapped to a set of addresses that are allocated to I/O device registers rather than to memory locations. Hence the name memory-mapped I/O. memory-mapped I/O The original PDP-11 ISA had a 16-bit address space. All addresses wherein bits [15:13] = 111 were allocated to I/O device registers. That is, of the 2^16 addresses, only 57,344 corresponded to memory locations. The remaining 2^13 were memory-mapped I/O addresses. The LC-3 uses memory-mapped",
    "542": "is that of an output device register is an output instruction. Since programmers use the same data movement instructions that are used for memory, every input device register and every output device register must be uniquely identified in the same way that memory locations are uniquely identified. Therefore, each device register is assigned an address from the memory address space of the ISA. That is, the I/O device registers are mapped to a set of addresses that are allocated to I/O device registers rather than to memory locations. Hence the name memory-mapped I/O. memory-mapped I/O The original PDP-11 ISA had a 16-bit address space. All addresses wherein bits [15:13] = 111 were allocated to I/O device registers. That is, of the 2^16 addresses, only 57,344 corresponded to memory locations. The remaining 2^13 were memory-mapped I/O addresses. The LC-3 uses memory-mapped I/O. As we discussed in Section 9.1.2, addresses x0000 to xFDFF refer to actual memory locations. Addresses xFE00 to xFFFF are reserved for input/output device registers. Table A.3 lists the memory-mapped addresses of the LC-3 device registers that have been assigned so far. Future uses and future sales of LC-3 microprocessors may require the expansion of device register address assignments as new and exciting applications emerge! §.§.§ Asynchronous vs Synchronous Most I/O is carried out at speeds very much slower than the speed of the processor. A typist, typing on a keyboard, loads an input device register with one ASCII code every time he/she types a character. A computer can read the contents of that device register every time it executes a load instruction, where the operand address is the memory-mapped address of that input device register. Many of today's microprocessors execute instructions under the control of a clock that operates well in excess of 2 GHz. Even for a microprocessor operating at only 2 GHz, a clock cycle lasts only 0.5 nanoseconds. Suppose a processor executed one instruction at a time, and it took the processor 10 clock cycles to execute the instruction that reads the input device register",
    "543": "as new and exciting applications emerge! §.§.§ Asynchronous vs Synchronous Most I/O is carried out at speeds very much slower than the speed of the processor. A typist, typing on a keyboard, loads an input device register with one ASCII code every time he/she types a character. A computer can read the contents of that device register every time it executes a load instruction, where the operand address is the memory-mapped address of that input device register. Many of today's microprocessors execute instructions under the control of a clock that operates well in excess of 2 GHz. Even for a microprocessor operating at only 2 GHz, a clock cycle lasts only 0.5 nanoseconds. Suppose a processor executed one instruction at a time, and it took the processor 10 clock cycles to execute the instruction that reads the input device register and stores its contents. At that rate, the processor could read the contents of the input device register once every 5 nanoseconds. Unfortunately, people do not type fast enough to keep this processor busy full-time reading characters. Question: How fast would a person have to type to supply input characters to the processor at the maximum rate the processor can receive them? We could mitigate this speed disparity by designing hardware that would accept typed characters at some slower fixed rate. For example, we could design a piece of hardware that accepts one character every 200 million cycles. This would require a typing speed of 100 words/minute, assuming words on average consisted of 5 letters, which is certainly doable. Unfortunately, it would also require that the typist work in lockstep with the computer's clock. That is not acceptable since the typing speed (even of the same typist) varies from moment to moment. What's the point? The point is that I/O devices usually operate at speeds very different from that of a microprocessor, and not in lockstep. We call this latter characteristic asynchronous. Most interaction between a processor asynchronous I/O and I/O is asynchronous. To control processing in an asynchronous world",
    "544": "receive them? We could mitigate this speed disparity by designing hardware that would accept typed characters at some slower fixed rate. For example, we could design a piece of hardware that accepts one character every 200 million cycles. This would require a typing speed of 100 words/minute, assuming words on average consisted of 5 letters, which is certainly doable. Unfortunately, it would also require that the typist work in lockstep with the computer's clock. That is not acceptable since the typing speed (even of the same typist) varies from moment to moment. What's the point? The point is that I/O devices usually operate at speeds very different from that of a microprocessor, and not in lockstep. We call this latter characteristic asynchronous. Most interaction between a processor asynchronous I/O and I/O is asynchronous. To control processing in an asynchronous world requires some protocol or handshakingprotocolhandshaking mechanism. So it is with our keyboard and monitor. In the case of the keyboard, we will need a 1-bit status register, called a flag, to indicate if someone has or has not typed a character. In the case of the monitor, we will need a 1-bit status register to indicate whether or not the most recent character sent to the monitor has been displayed, and so the monitor can be given another character to display. These flags are the simplest form of synchronization. A single synchronization flag, called the Ready bit, is enough to synchronize the output of the typist who can type characters at the rate of 100 words/minute with the input to a processor that can accept these characters at the rate of 200 million characters/second. Each time the typist types a character, the Ready bit is set to 1. Each time the computer reads a character, it clears the Ready bit. By examining the Ready bit before reading a character, the computer can tell whether it has already read the last character typed. If the Ready bit is clear, no characters have been typed since the last time the computer read",
    "545": "most recent character sent to the monitor has been displayed, and so the monitor can be given another character to display. These flags are the simplest form of synchronization. A single synchronization flag, called the Ready bit, is enough to synchronize the output of the typist who can type characters at the rate of 100 words/minute with the input to a processor that can accept these characters at the rate of 200 million characters/second. Each time the typist types a character, the Ready bit is set to 1. Each time the computer reads a character, it clears the Ready bit. By examining the Ready bit before reading a character, the computer can tell whether it has already read the last character typed. If the Ready bit is clear, no characters have been typed since the last time the computer read a character, and so no additional read would take place. When the computer detects that the Ready bit is set, it could only have been caused by a new character being typed, so the computer would know to again read a character. The single Ready bit provides enough handshaking to ensure that the asynchronous transfer of information between the typist and the microprocessor can be carried out accurately. If the typist could type at a constant speed, and we did have a piece of hardware that would accept typed characters at precise intervals (for example, one character every 200 million cycles), then we would not need the Ready bit. The computer would simply know, after 200 million cycles of doing other stuff, that the typist had typed exactly one more character, and the computer would read that character. In this hypothetical situation, the typist would be typing in lockstep with the processor, and no additional synchronization would be needed. We would say the computer and typist were operating synchronously. That is, the input activity was synchronous. synchronous I/O §.§.§ Interrupt-driven vs Polling The processor, which is computing, and the typist, who is typing, are two separate entities. Each is doing",
    "546": "and the microprocessor can be carried out accurately. If the typist could type at a constant speed, and we did have a piece of hardware that would accept typed characters at precise intervals (for example, one character every 200 million cycles), then we would not need the Ready bit. The computer would simply know, after 200 million cycles of doing other stuff, that the typist had typed exactly one more character, and the computer would read that character. In this hypothetical situation, the typist would be typing in lockstep with the processor, and no additional synchronization would be needed. We would say the computer and typist were operating synchronously. That is, the input activity was synchronous. synchronous I/O §.§.§ Interrupt-driven vs Polling The processor, which is computing, and the typist, who is typing, are two separate entities. Each is doing its own thing. Still, they need to interact, that is, the data that is typed has to get into the computer. The issue of interrupt-driven versus polling is the issue of who controls the interaction. Does the processor do its own thing until being interrupted by an announcement from the keyboard, “Hey, a key has been struck. The ASCII code is in the input device register. You need to read it.” This is called interrupt-driven I/O, where the keyboard controls the interaction. Or, does the processor control the interaction, specifically by interrogating (usually, again and again) the Ready bit until it (the processor) detects that the Ready bit is set. At that point, the processor knows it is time to read the device register. This second type of interaction when the processor is in charge is called polling, since the Ready bit is polled by the processor, asking if any key has been struck. Section <ref> describes how polling works. Section <ref> explains interrupt-driven I/O. §.§ Input from the Keyboard §.§.§ Basic Input Registers (KBDR and KBSR) We have already noted that in order to handle character input from the keyboard, we need two things: a data register that contains",
    "547": "is in the input device register. You need to read it.” This is called interrupt-driven I/O, where the keyboard controls the interaction. Or, does the processor control the interaction, specifically by interrogating (usually, again and again) the Ready bit until it (the processor) detects that the Ready bit is set. At that point, the processor knows it is time to read the device register. This second type of interaction when the processor is in charge is called polling, since the Ready bit is polled by the processor, asking if any key has been struck. Section <ref> describes how polling works. Section <ref> explains interrupt-driven I/O. §.§ Input from the Keyboard §.§.§ Basic Input Registers (KBDR and KBSR) We have already noted that in order to handle character input from the keyboard, we need two things: a data register that contains the character to be input, and a synchronization mechanism to let the processor know that input has occurred. The synchronization mechanism is contained in the status register associated with the keyboard. These two registers are called the keyboard data register (KBDR) and the KBDRKeyboard Data Register keyboard status register (KBSR). They are assigned addresses from the memory KBSRKeyboard Status Register address space. As shown in Table A.3, address xFE02 is assigned to the KBDR; address xFE00 is assigned to the KBSR. < g r a p h i c s > Keyboard device registers Even though a character needs only eight bits and the synchronization mechanism needs only one bit, it is easier to assign 16 bits (like all memory addresses in the LC-3) to each. In the case of KBDR, bits [7:0] are used for the data, and bits [15:8] contain x00. In the case of KBSR, bit [15] contains the synchronization mechanism, that is, the Ready bit. Figure <ref> shows the two device registers needed by the keyboard. §.§.§ The Basic Input Service Routine basic input service routine KBSR[15] controls the synchronization of the slow keyboard and the fast processor. When a key on the keyboard is struck,",
    "548": "address space. As shown in Table A.3, address xFE02 is assigned to the KBDR; address xFE00 is assigned to the KBSR. < g r a p h i c s > Keyboard device registers Even though a character needs only eight bits and the synchronization mechanism needs only one bit, it is easier to assign 16 bits (like all memory addresses in the LC-3) to each. In the case of KBDR, bits [7:0] are used for the data, and bits [15:8] contain x00. In the case of KBSR, bit [15] contains the synchronization mechanism, that is, the Ready bit. Figure <ref> shows the two device registers needed by the keyboard. §.§.§ The Basic Input Service Routine basic input service routine KBSR[15] controls the synchronization of the slow keyboard and the fast processor. When a key on the keyboard is struck, the ASCII code for that key is loaded into KBDR[7:0] and the electronic circuits associated with the keyboard automatically set KBSR[15] to 1. When the LC-3 reads KBDR, the electronic circuits associated with the keyboard automatically clear KBSR[15], allowing another key to be struck. If KBSR[15] = 1, the ASCII code corresponding to the last key struck has not yet been read, and so the keyboard is disabled; that is, no key can be struck until the last key is read. If input/output is controlled by the processor (i.e., via polling), then a program can repeatedly test KBSR[15] until it notes that the bit is set. At that point, the processor can load the ASCII code contained in KBDR into one of the LC-3 registers. Since the processor only loads the ASCII code if KBSR[15] is 1, there is no danger of reading a single typed character multiple times. Furthermore, since the keyboard is disabled until the previous code is read, there is no danger of the processor missing characters that were typed. In this way, KBSR[15] provides the mechanism to guarantee that each key typed will be loaded exactly once. The following input routine loads R0 with the ASCII",
    "549": "been read, and so the keyboard is disabled; that is, no key can be struck until the last key is read. If input/output is controlled by the processor (i.e., via polling), then a program can repeatedly test KBSR[15] until it notes that the bit is set. At that point, the processor can load the ASCII code contained in KBDR into one of the LC-3 registers. Since the processor only loads the ASCII code if KBSR[15] is 1, there is no danger of reading a single typed character multiple times. Furthermore, since the keyboard is disabled until the previous code is read, there is no danger of the processor missing characters that were typed. In this way, KBSR[15] provides the mechanism to guarantee that each key typed will be loaded exactly once. The following input routine loads R0 with the ASCII code that has been entered through the keyboard and then moves on to the NEXT_TASK in the program. 01 START LDI R1, A ; Test for 02 BRzp START ; character input 03 LDI R0, B 04 BRnzp NEXT_TASK ; Go to the next task 05 A .FILL xFE00 ; Address of KBSR 06 B .FILL xFE02 ; Address of KBDR As long as KBSR[15] is 0, no key has been struck since the last time the processor read the data register. Lines 01 and 02 comprise a loop that tests bit [15] of KBSR. Note the use of the LDI instruction, which loads R1 with the contents of xFE00, the memory-mapped address of KBSR. If the Ready bit, bit [15], is clear, BRzp will branch to START and another iteration of the loop. When someone strikes a key, KBDR will be loaded with the ASCII code of that key and the Ready bit of KBSR will be set. This will cause the branch to fall through and the instruction at line 03 will be executed. Again, note the use of the LDI instruction, which this time loads R0 with the contents of xFE02, the memory-mapped address of KBDR. The",
    "550": "KBDR As long as KBSR[15] is 0, no key has been struck since the last time the processor read the data register. Lines 01 and 02 comprise a loop that tests bit [15] of KBSR. Note the use of the LDI instruction, which loads R1 with the contents of xFE00, the memory-mapped address of KBSR. If the Ready bit, bit [15], is clear, BRzp will branch to START and another iteration of the loop. When someone strikes a key, KBDR will be loaded with the ASCII code of that key and the Ready bit of KBSR will be set. This will cause the branch to fall through and the instruction at line 03 will be executed. Again, note the use of the LDI instruction, which this time loads R0 with the contents of xFE02, the memory-mapped address of KBDR. The input routine is now done, so the program branches unconditionally to its NEXT_TASK. §.§.§ Implementation of Memory-Mapped Input Figure <ref> shows the additional data path required to implement memory-mapped input. You are already familiar, from Chapter 5, with the data path required to carry out the EXECUTE phase of the load instructions. Essentially three steps are required: < g r a p h i c s > Memory-mapped input * The MAR is loaded with the address of the memory location to be read. * Memory is read, resulting in MDR being loaded with the contents at the specified memory location. * The destination register (DR) is loaded with the contents of MDR. In the case of memory-mapped input, the same set of steps are carried out, except instead of MAR being loaded with the address of a memory location, MAR is loaded with the address of a device register. Instead of the address control logic enabling memory to read, the address control logic selects the corresponding device register to provide input to the MDR. §.§ Output to the Monitor §.§.§ Basic Output Registers (DDR and DSR) Output works in a way very similar to input, with DDR and DSR",
    "551": "a p h i c s > Memory-mapped input * The MAR is loaded with the address of the memory location to be read. * Memory is read, resulting in MDR being loaded with the contents at the specified memory location. * The destination register (DR) is loaded with the contents of MDR. In the case of memory-mapped input, the same set of steps are carried out, except instead of MAR being loaded with the address of a memory location, MAR is loaded with the address of a device register. Instead of the address control logic enabling memory to read, the address control logic selects the corresponding device register to provide input to the MDR. §.§ Output to the Monitor §.§.§ Basic Output Registers (DDR and DSR) Output works in a way very similar to input, with DDR and DSR replacing the roles of KBDR and KBSR, respectively. DDR stands for Display Data Register, which drives the monitor display. DSR stands for Display Status Register. In the LC-3, DDR is assigned address xFE06. DSR is assigned address xFE04. < g r a p h i c s > Monitor device registers As is the case with input, even though an output character needs only eight bits and the synchronization mechanism needs only one bit, it is easier to assign 16 bits (like all memory addresses in the LC-3) to each output device register. In the case of DDR, bits [7:0] are used for data, and bits [15:8] contain x00. In the case of DSR, bit [15] contains the synchronization mechanism, that is, the Ready bit. Figure <ref> shows the two device registers needed by the monitor. §.§.§ The Basic Output Service Routine basic output service routine DSR[15] controls the synchronization of the fast processor and the slow monitor display. When the LC-3 transfers an ASCII code to DDR[7:0] for outputting, the electronics of the monitor automatically clear DSR[15] as the processing of the contents of DDR[7:0] begins. DSRDisplay Status RegisterDDRDisplay Data Register When the monitor finishes processing the character on",
    "552": "output character needs only eight bits and the synchronization mechanism needs only one bit, it is easier to assign 16 bits (like all memory addresses in the LC-3) to each output device register. In the case of DDR, bits [7:0] are used for data, and bits [15:8] contain x00. In the case of DSR, bit [15] contains the synchronization mechanism, that is, the Ready bit. Figure <ref> shows the two device registers needed by the monitor. §.§.§ The Basic Output Service Routine basic output service routine DSR[15] controls the synchronization of the fast processor and the slow monitor display. When the LC-3 transfers an ASCII code to DDR[7:0] for outputting, the electronics of the monitor automatically clear DSR[15] as the processing of the contents of DDR[7:0] begins. DSRDisplay Status RegisterDDRDisplay Data Register When the monitor finishes processing the character on the screen, it (the monitor) automatically sets DSR[15]. This is a signal to the processor that it (the processor) can transfer another ASCII code to DDR for outputting. As long as DSR[15] is clear, the monitor is still processing the previous character, so the monitor is disabled as far as additional output from the processor is concerned. If input/output is controlled by the processor (i.e., via polling), a program can repeatedly test DSR[15] until it notes that the bit is set, indicating that it is OK to write a character to the screen. At that point, the processor can store the ASCII code for the character it wishes to write into DDR[7:0], setting up the transfer of that character to the monitor's display. The following routine causes the ASCII code contained in R0 to be displayed on the monitor: 01 START LDI R1, A ; Test to see if 02 BRzp START ; output register is ready 03 STI R0, B 04 BRnzp NEXT_TASK 05 A .FILL xFE04 ; Address of DSR 06 B .FILL xFE06 ; Address of DDR Like the routine for KBDR and KBSR in Section <ref>, lines 01 and 02 repeatedly poll DSR[15] to see if",
    "553": "controlled by the processor (i.e., via polling), a program can repeatedly test DSR[15] until it notes that the bit is set, indicating that it is OK to write a character to the screen. At that point, the processor can store the ASCII code for the character it wishes to write into DDR[7:0], setting up the transfer of that character to the monitor's display. The following routine causes the ASCII code contained in R0 to be displayed on the monitor: 01 START LDI R1, A ; Test to see if 02 BRzp START ; output register is ready 03 STI R0, B 04 BRnzp NEXT_TASK 05 A .FILL xFE04 ; Address of DSR 06 B .FILL xFE06 ; Address of DDR Like the routine for KBDR and KBSR in Section <ref>, lines 01 and 02 repeatedly poll DSR[15] to see if the monitor electronics is finished with the last character shipped by the processor. Note the use of LDI and the indirect access to xFE04, the memory-mapped address of DSR. As long as DSR[15] is clear, the monitor electronics is still processing this character, and BRzp branches to START for another iteration of the loop. When the monitor electronics finishes with the last character shipped by the processor, it automatically sets DSR[15] to 1, which causes the branch to fall through and the instruction at line 03 to be executed. Note the use of the STI instruction, which stores R0 into xFE06, the memory-mapped address of DDR. The write to DDR also clears DSR[15], disabling for the moment DDR from further output. The monitor electronics takes over and writes the character to the screen. Since the output routine is now done, the program unconditionally branches (line 04) to its NEXT_TASK. §.§.§ Implementation of Memory-Mapped Output Figure <ref> shows the additional data path required to implement memory-mapped output. As we discussed previously with respect to memory-mapped input, the mechanisms for handling the device registers provide very little additional complexity to what already exists for handling memory accesses. < g r a p",
    "554": "the last character shipped by the processor, it automatically sets DSR[15] to 1, which causes the branch to fall through and the instruction at line 03 to be executed. Note the use of the STI instruction, which stores R0 into xFE06, the memory-mapped address of DDR. The write to DDR also clears DSR[15], disabling for the moment DDR from further output. The monitor electronics takes over and writes the character to the screen. Since the output routine is now done, the program unconditionally branches (line 04) to its NEXT_TASK. §.§.§ Implementation of Memory-Mapped Output Figure <ref> shows the additional data path required to implement memory-mapped output. As we discussed previously with respect to memory-mapped input, the mechanisms for handling the device registers provide very little additional complexity to what already exists for handling memory accesses. < g r a p h i c s > Memory-mapped output In Chapter 5, you became familiar with the process of carrying out the EXECUTE phase of the store instructions. * The MAR is loaded with the address of the memory location to be written. * The MDR is loaded with the data to be written to memory. * Memory is written, resulting in the contents of MDR being stored in the specified memory location. In the case of memory-mapped output, the same steps are carried out, except instead of MAR being loaded with the address of a memory location, MAR is loaded with the address of a device register. Instead of the address control logic enabling memory to write, the address control logic asserts the load enable signal of DDR. Memory-mapped output also requires the ability to read output device registers. You saw in Section <ref> that before the DDR could be loaded, the Ready bit had to be in state 1, indicating that the previous character had already finished being written to the screen. The LDI and BRzp instructions on lines 01 and 02 perform that test. To do this the LDI reads the output device register DSR, and BRzp tests bit",
    "555": "the contents of MDR being stored in the specified memory location. In the case of memory-mapped output, the same steps are carried out, except instead of MAR being loaded with the address of a memory location, MAR is loaded with the address of a device register. Instead of the address control logic enabling memory to write, the address control logic asserts the load enable signal of DDR. Memory-mapped output also requires the ability to read output device registers. You saw in Section <ref> that before the DDR could be loaded, the Ready bit had to be in state 1, indicating that the previous character had already finished being written to the screen. The LDI and BRzp instructions on lines 01 and 02 perform that test. To do this the LDI reads the output device register DSR, and BRzp tests bit [15]. If the MAR is loaded with xFE04 (the memory-mapped address of the DSR), the address control logic selects DSR as the input to the MDR, where it is subsequently loaded into R1 and the condition codes are set. §.§.§ Example: Keyboard Echo When we type at the keyboard, it is helpful to know exactly what characters we have typed. We can get this echo capability easily (without any sophisticated electronics) by simply combining the two routines we have discussed. The result: the key typed at the keyboard is displayed on the monitor. 01 START LDI R1, KBSR ; Test for character input 02 BRzp START 03 LDI R0, KBDR 04 ECHO LDI R1, DSR ; Test output register ready 05 BRzp ECHO 06 STI R0, DDR 07 BRnzp NEXT_TASK 08 KBSR .FILL xFE00 ; Address of KBSR 09 KBDR .FILL xFE02 ; Address of KBDR 0A DSR .FILL xFE04 ; Address of DSR 0B DDR .FILL xFE06 ; Address of DDR §.§ A More Sophisticated Input Routine In the example of Section <ref>, the input routine would be a part of a program being executed by the computer. Presumably, the program requires character input from the keyboard. But how",
    "556": "We can get this echo capability easily (without any sophisticated electronics) by simply combining the two routines we have discussed. The result: the key typed at the keyboard is displayed on the monitor. 01 START LDI R1, KBSR ; Test for character input 02 BRzp START 03 LDI R0, KBDR 04 ECHO LDI R1, DSR ; Test output register ready 05 BRzp ECHO 06 STI R0, DDR 07 BRnzp NEXT_TASK 08 KBSR .FILL xFE00 ; Address of KBSR 09 KBDR .FILL xFE02 ; Address of KBDR 0A DSR .FILL xFE04 ; Address of DSR 0B DDR .FILL xFE06 ; Address of DDR §.§ A More Sophisticated Input Routine In the example of Section <ref>, the input routine would be a part of a program being executed by the computer. Presumably, the program requires character input from the keyboard. But how does the person sitting at the keyboard know when to type a character? Sitting there, the person may wonder whether or not the program is actually running, or if perhaps the computer is busy doing something else. To let the person sitting at the keyboard know that the program is waiting for input from the keyboard, the computer typically prints a message on the monitor. Such a message is often referred to as a prompt. The symbol that is prompt displayed by your operating system (for example, % or C:) or by your editor (for example, :) are examples of prompts. The program fragment shown in Figure <ref> obtains keyboard input via polling as we have shown in Section <ref>. It also includes a prompt to let the person sitting at the keyboard know when it is time to type a key. Let's examine this program fragment. [fontsize=911] 01 START ST R1,SaveR1 ; Save registers needed 02 ST R2,SaveR2 ; by this routine 03 ST R3,SaveR3 04 ; 05 LD R2,Newline 06 L1 LDI R3,DSR 07 BRzp L1 ; Loop until monitor is ready 08 STI R2,DDR ; Move cursor to new clean line 09 ; 0A LEA R1,Prompt ;",
    "557": "a message on the monitor. Such a message is often referred to as a prompt. The symbol that is prompt displayed by your operating system (for example, % or C:) or by your editor (for example, :) are examples of prompts. The program fragment shown in Figure <ref> obtains keyboard input via polling as we have shown in Section <ref>. It also includes a prompt to let the person sitting at the keyboard know when it is time to type a key. Let's examine this program fragment. [fontsize=911] 01 START ST R1,SaveR1 ; Save registers needed 02 ST R2,SaveR2 ; by this routine 03 ST R3,SaveR3 04 ; 05 LD R2,Newline 06 L1 LDI R3,DSR 07 BRzp L1 ; Loop until monitor is ready 08 STI R2,DDR ; Move cursor to new clean line 09 ; 0A LEA R1,Prompt ; Starting address of prompt string 0B Loop LDR R0,R1,#0 ; Write the input prompt 0C BRz Input ; End of prompt string 0D L2 LDI R3,DSR 0E BRzp L2 ; Loop until monitor is ready 0F STI R0,DDR ; Write next prompt character 10 ADD R1,R1,#1 ; Increment prompt pointer 11 BRnzp Loop ; Get next prompt character 12 ; 13 Input LDI R3,KBSR 14 BRzp Input ; Poll until a character is typed 15 LDI R0,KBDR ; Load input character into R0 16 L3 LDI R3,DSR 17 BRzp L3 ; Loop until monitor is ready 18 STI R0,DDR ; Echo input character 19 ; 1A L4 LDI R3,DSR 1B BRzp L4 ; Loop until monitor is ready 1C STI R2,DDR ; Move cursor to new clean line 1D LD R1,SaveR1 ; Restore registers 1E LD R2,SaveR2 ; to original values 1F LD R3,SaveR3 20 BRnzp NEXT_TASK ; Do the program's next task 21 ; 22 SaveR1 .BLKW 1 ; Memory for registers saved 23 SaveR2 .BLKW 1 24 SaveR3 .BLKW 1 25 DSR .FILL xFE04 26 DDR .FILL xFE06 27 KBSR .FILL xFE00 28 KBDR .FILL xFE02 29 Newline .FILL x000A ; ASCII code for newline 2A Prompt .STRINGZ",
    "558": "13 Input LDI R3,KBSR 14 BRzp Input ; Poll until a character is typed 15 LDI R0,KBDR ; Load input character into R0 16 L3 LDI R3,DSR 17 BRzp L3 ; Loop until monitor is ready 18 STI R0,DDR ; Echo input character 19 ; 1A L4 LDI R3,DSR 1B BRzp L4 ; Loop until monitor is ready 1C STI R2,DDR ; Move cursor to new clean line 1D LD R1,SaveR1 ; Restore registers 1E LD R2,SaveR2 ; to original values 1F LD R3,SaveR3 20 BRnzp NEXT_TASK ; Do the program's next task 21 ; 22 SaveR1 .BLKW 1 ; Memory for registers saved 23 SaveR2 .BLKW 1 24 SaveR3 .BLKW 1 25 DSR .FILL xFE04 26 DDR .FILL xFE06 27 KBSR .FILL xFE00 28 KBDR .FILL xFE02 29 Newline .FILL x000A ; ASCII code for newline 2A Prompt .STRINGZ “Input a character>”The more sophisticated input routine You are already familiar with lines 13 through 19 and lines 25 through 28, which correspond to the code in Section <ref> for inputting a character via the keyboard and echoing it on the monitor. You are also familiar with the need to save and restore registers if those registers are needed by instructions in the input routine. Lines 01 through 03 save R1, R2, and R3, lines 1D through 1F restore R1, R2, and R3, and lines 22 through 24 set aside memory locations for those register values. This leaves lines 05 through 08, 0A through 11, 1A through 1C, 29 and 2A. These lines serve to alert the person sitting at the keyboard that it is time to type a character. Lines 05 through 08 write the ASCII code x0A to the monitor. This is the ASCII code for a new line. Most ASCII codes correspond to characters that are visible on the screen. A few, like x0A, are control characters. They cause an action to occur. Specifically, the ASCII code x0A causes the cursor to move to the far left of the next line on the screen. Thus the name",
    "559": "instructions in the input routine. Lines 01 through 03 save R1, R2, and R3, lines 1D through 1F restore R1, R2, and R3, and lines 22 through 24 set aside memory locations for those register values. This leaves lines 05 through 08, 0A through 11, 1A through 1C, 29 and 2A. These lines serve to alert the person sitting at the keyboard that it is time to type a character. Lines 05 through 08 write the ASCII code x0A to the monitor. This is the ASCII code for a new line. Most ASCII codes correspond to characters that are visible on the screen. A few, like x0A, are control characters. They cause an action to occur. Specifically, the ASCII code x0A causes the cursor to move to the far left of the next line on the screen. Thus the name Newline. Before attempting to write x0A, however, as is always the case, DSR[15] is tested (line 6) to see if DDR can accept a character. If DSR[15] is clear, the monitor is busy, and the loop (lines 06 and 07) is repeated. When DSR[15] is 1, the conditional branch (line 7) is not taken, and (line 8) x0A is written to DDR for outputting. Lines 0A through 11 cause the prompt to be written to the screen. The prompt is specified by the .STRINGZ pseudo-op on line 2A and is stored in 19 memory locations—18 ASCII codes, one per memory location, corresponding to the 18 characters in the prompt, and the terminating sentinel x0000. Line 0C iteratively tests to see if the end of the string has been reached (by detecting x0000), and if not, once DDR is free, line 0F writes the next character in the input prompt into DDR. When x0000 is detected, the entire input prompt has been written to the screen and the program branches to the code that handles the actual keyboard input (starting at line 13). After the person at the keyboard types a character and it has been echoed (lines 13 to 19),",
    "560": "to DDR for outputting. Lines 0A through 11 cause the prompt to be written to the screen. The prompt is specified by the .STRINGZ pseudo-op on line 2A and is stored in 19 memory locations—18 ASCII codes, one per memory location, corresponding to the 18 characters in the prompt, and the terminating sentinel x0000. Line 0C iteratively tests to see if the end of the string has been reached (by detecting x0000), and if not, once DDR is free, line 0F writes the next character in the input prompt into DDR. When x0000 is detected, the entire input prompt has been written to the screen and the program branches to the code that handles the actual keyboard input (starting at line 13). After the person at the keyboard types a character and it has been echoed (lines 13 to 19), the program writes one more new line (lines 1A through 1C) before branching to its NEXT_TASK. §.§ Implementation of Memory-Mapped I/O, Revisited We showed in Figures <ref> and <ref> partial implementations of the data path to handle (separately) memory-mapped input and memory-mapped output. We have also learned that in order to support interrupt-driven I/O, the two status registers must be writeable as well as readable. Figure <ref> (also shown as Figure C.3 of Appendix C) shows the data path necessary to support the full range of features we have discussed for the I/O device registers. The Address Control Logic block controls the input or output operation. Note that there are three inputs to this block. MIO.EN indicates whether a data movement from/to memory or I/O is to take place this clock cycle. MAR contains the address of the memory location or the memory-mapped address of an I/O device register. R.W indicates whether a load or a store is to take place. Depending on the values of these three inputs, the Address Control Logic does nothing (MIO.EN = 0), or provides the control signals to direct the transfer of data between the MDR and the memory or between the MDR and",
    "561": "writeable as well as readable. Figure <ref> (also shown as Figure C.3 of Appendix C) shows the data path necessary to support the full range of features we have discussed for the I/O device registers. The Address Control Logic block controls the input or output operation. Note that there are three inputs to this block. MIO.EN indicates whether a data movement from/to memory or I/O is to take place this clock cycle. MAR contains the address of the memory location or the memory-mapped address of an I/O device register. R.W indicates whether a load or a store is to take place. Depending on the values of these three inputs, the Address Control Logic does nothing (MIO.EN = 0), or provides the control signals to direct the transfer of data between the MDR and the memory or between the MDR and one of the I/O registers. < g r a p h i c s > Relevant data path implementation of memory-mapped I/0 If R.W indicates a load, the transfer is from memory or I/O device to the MDR. The Address Control Logic block provides the select lines to INMUX to source the appropriate I/O device register or memory (depending on MAR) and also enables the memory if MAR contains the address of a memory location. If R.W indicates a store, the contents of the MDR are written either to memory or to one of the device registers. The Address Control Logic either enables a write to memory or it asserts the load enable line of the device register specified by the contents of the MAR. § OPERATING SYSTEM SERVICE ROUTINES (LC-3 TRAP ROUTINES) §.§ Introduction Recall Figure <ref> of the previous section. In order for the program to successfully obtain input from the keyboard, it was necessary for the programmer to know several things: * The hardware data registers for both the monitor and the keyboard: the monitor so a prompt could be displayed, and the keyboard so the program would know where to get the input character. * The",
    "562": "MAR) and also enables the memory if MAR contains the address of a memory location. If R.W indicates a store, the contents of the MDR are written either to memory or to one of the device registers. The Address Control Logic either enables a write to memory or it asserts the load enable line of the device register specified by the contents of the MAR. § OPERATING SYSTEM SERVICE ROUTINES (LC-3 TRAP ROUTINES) §.§ Introduction Recall Figure <ref> of the previous section. In order for the program to successfully obtain input from the keyboard, it was necessary for the programmer to know several things: * The hardware data registers for both the monitor and the keyboard: the monitor so a prompt could be displayed, and the keyboard so the program would know where to get the input character. * The hardware status registers for both the monitor and the keyboard: the monitor so the program would know when it was OK to display the next character in the input prompt, and the keyboard so the program would know when someone had struck a key. * The asynchronous nature of keyboard input relative to the executing program. This is beyond the knowledge of most application programmers. In fact, in the real world, if application programmers (or user programmers, as they are sometimes called) had to understand I/O at this level, there would be much less I/O and far fewer programmers in the business. There is another problem with allowing user programs to perform I/O activity by directly accessing KBDR and KBSR. I/O activity involves the use of device registers that are shared by many programs. This means that if a user programmer were allowed to access the hardware registers, and he/she messed up, it could create havoc for other user programs. Thus, in general it is ill-advised to give user programmers access to these registers. That is why the the addresses of hardware registers are part of the privileged memory address space, and accessible only to programs that have Supervisor privilege.",
    "563": "knowledge of most application programmers. In fact, in the real world, if application programmers (or user programmers, as they are sometimes called) had to understand I/O at this level, there would be much less I/O and far fewer programmers in the business. There is another problem with allowing user programs to perform I/O activity by directly accessing KBDR and KBSR. I/O activity involves the use of device registers that are shared by many programs. This means that if a user programmer were allowed to access the hardware registers, and he/she messed up, it could create havoc for other user programs. Thus, in general it is ill-advised to give user programmers access to these registers. That is why the the addresses of hardware registers are part of the privileged memory address space, and accessible only to programs that have Supervisor privilege. The simpler solution as well as the safer solution to the problem of user programs requiring I/O involves the TRAP instruction and the operating system, which of course has Supervisor privilege. We were first introduced to the TRAP instruction in Chapter 4 as a way to get the operating system to halt the computer. In Chapter 5 we saw that a user program could use the TRAP instruction to get the operating system to do I/O tasks for it (the user program). In fact a great benefit of the TRAP instruction, which we have already pointed out, is that it allows the user programmer to not have to know the gory details of I/O discussed earlier in this chapter. In addition, it protects user programs from the consequences of other inept user programmers. Figure <ref> shows a user program that, upon reaching location x4000, needs an I/O task performed. The user program uses the TRAP instruction to request the operating system to perform the task on behalf of the user program. The operating system takes control of the computer, handles the request specified by the TRAP instruction, and then returns control back to the user program at location x4001. As",
    "564": "a user program could use the TRAP instruction to get the operating system to do I/O tasks for it (the user program). In fact a great benefit of the TRAP instruction, which we have already pointed out, is that it allows the user programmer to not have to know the gory details of I/O discussed earlier in this chapter. In addition, it protects user programs from the consequences of other inept user programmers. Figure <ref> shows a user program that, upon reaching location x4000, needs an I/O task performed. The user program uses the TRAP instruction to request the operating system to perform the task on behalf of the user program. The operating system takes control of the computer, handles the request specified by the TRAP instruction, and then returns control back to the user program at location x4001. As we said at the start of this chapter, we usually refer to the request made by the user program as a system call or a service call.service callsystem call < g r a p h i c s > Invoking an OS service routine using the TRAP instruction §.§ The trap mechanism The trap mechanism involves several elements: * A set of service routines executed on behalf of user programs by the operating system. These are part of the operating system and start at arbitrary addresses in System space. The LC-3 was designed so that up to 256 service routines can be specified. Table A.2 in Appendix A contains the LC-3's current complete list of operating system service routines. * A table of the starting addresses of these 256 service routines. This table is stored in memory locations x0000 to x00FF. The table is referred to by various names by various companies. One company calls this table the System Control Block. AnotherSystem Control BlockTrap Vector Table company calls it the Trap Vector Table. Figure <ref> shows the Trap Vector Table of the LC-3, with specific starting addresses highlighted. Among the starting addresses are the one for the character output service",
    "565": "set of service routines executed on behalf of user programs by the operating system. These are part of the operating system and start at arbitrary addresses in System space. The LC-3 was designed so that up to 256 service routines can be specified. Table A.2 in Appendix A contains the LC-3's current complete list of operating system service routines. * A table of the starting addresses of these 256 service routines. This table is stored in memory locations x0000 to x00FF. The table is referred to by various names by various companies. One company calls this table the System Control Block. AnotherSystem Control BlockTrap Vector Table company calls it the Trap Vector Table. Figure <ref> shows the Trap Vector Table of the LC-3, with specific starting addresses highlighted. Among the starting addresses are the one for the character output service routine (memory location x0420), which is stored in memory location x0021, the one for the keyboard input service routine (location x04A0), stored in location x0023, and the one for the machine halt service routine (location x0520), stored in location x0025. < g r a p h i c s > The Trap Vector Table * The TRAP instruction. When a user program wishes to have the operating system execute a specific service routine on behalf of the user program, and then return control to the user program, the user program uses the TRAP instruction (as we have been doing since chapter 4). * A linkage back to the user program. The service routine must have a mechanism for returning control to the user program. §.§ The TRAP Instruction TRAP instruction The TRAP instruction causes the service routine to execute by (1) changing the PC to the starting address of the relevant service routine on the basis of its trap vector, and (2) providing a way to get back to the program that executed the TRAP instruction. The “way back” is referred to as a linkage. As you know, the TRAP instruction is made up of two parts: the TRAP opcode",
    "566": "user program wishes to have the operating system execute a specific service routine on behalf of the user program, and then return control to the user program, the user program uses the TRAP instruction (as we have been doing since chapter 4). * A linkage back to the user program. The service routine must have a mechanism for returning control to the user program. §.§ The TRAP Instruction TRAP instruction The TRAP instruction causes the service routine to execute by (1) changing the PC to the starting address of the relevant service routine on the basis of its trap vector, and (2) providing a way to get back to the program that executed the TRAP instruction. The “way back” is referred to as a linkage. As you know, the TRAP instruction is made up of two parts: the TRAP opcode 1111 and the trap vector (bits [7:0]), which identifies the service routine the user program wants the operating system to execute on its behalf. Bits [11:8] must be zero. In the following example, the trap vector is x23. 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 1|c-1pt1 1c-1pt1 1c-1pt1 1c-1pt1 1|c-1pt0 1c-1pt0 1c-1pt0 1c-1pt0 1|c-1pt0 1c-1pt0 1c-1pt1 1c-1pt0 1c-1pt0 1c-1pt0 1c-1pt1 1c|-1pt1 4cTRAP 4c 8ctrap vector The EXECUTE phase of the TRAP instruction's instruction cycle does three things: * The PSR and PC are both pushed onto the system stack. Since the PC was incremented during the FETCH phase of the TRAP instruction's instruction cycle, the return linkage is automatically saved in the PC. When control returns to the user program, the PC will automatically be pointing to the instruction following the TRAP instruction. Note that the program requesting the trap service routine can be running either in Supervisor mode or in User mode. If in User mode, R6, the stack pointer, is pointing to the user stack. Before the PSR and PC can be pushed onto the system stack, the current contents of R6 must be stored in Saved_USP, and the",
    "567": "1c-1pt0 1c-1pt0 1|c-1pt0 1c-1pt0 1c-1pt1 1c-1pt0 1c-1pt0 1c-1pt0 1c-1pt1 1c|-1pt1 4cTRAP 4c 8ctrap vector The EXECUTE phase of the TRAP instruction's instruction cycle does three things: * The PSR and PC are both pushed onto the system stack. Since the PC was incremented during the FETCH phase of the TRAP instruction's instruction cycle, the return linkage is automatically saved in the PC. When control returns to the user program, the PC will automatically be pointing to the instruction following the TRAP instruction. Note that the program requesting the trap service routine can be running either in Supervisor mode or in User mode. If in User mode, R6, the stack pointer, is pointing to the user stack. Before the PSR and PC can be pushed onto the system stack, the current contents of R6 must be stored in Saved_USP, and the contents of Saved_SSP loaded into R6. * PSR[15] is set to 0, since the service routine is going to require Supervisor privilege to execute. PSR[10:8] are left unchanged since the priority of the TRAP routine is the same as the priority of the program that requested it. * The 8-bit trap vector is zero-extended to 16 bits to form an address which corresponds to a location in the Trap Vector Table. For the trap vector x23, that address is x0023. Memory location x0023 contains x04A0, the starting address of the TRAP x23 service routine. The PC is loaded with x04A0, completing the instruction cycle. Since the PC contains x04A0, processing continues at memory address x04A0. Location x04A0 is the starting address of the operating system service routine to input a character from the keyboard. We say the trap vector “points” to the starting address of the TRAP routine. Thus, TRAP x23 causes the operating system to start executing the keyboard input service routine. §.§ The RTI Instruction: to return control to the calling program The only thing left to show is a mechanism for returning control to the calling program, once the trap service routine has finished execution. This is",
    "568": "address which corresponds to a location in the Trap Vector Table. For the trap vector x23, that address is x0023. Memory location x0023 contains x04A0, the starting address of the TRAP x23 service routine. The PC is loaded with x04A0, completing the instruction cycle. Since the PC contains x04A0, processing continues at memory address x04A0. Location x04A0 is the starting address of the operating system service routine to input a character from the keyboard. We say the trap vector “points” to the starting address of the TRAP routine. Thus, TRAP x23 causes the operating system to start executing the keyboard input service routine. §.§ The RTI Instruction: to return control to the calling program The only thing left to show is a mechanism for returning control to the calling program, once the trap service routine has finished execution. This is accomplished by the Return from Trap or Interrupt (RTI) instruction: 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 1|c-1pt1 1c-1pt0 1c-1pt0 1c-1pt0 1|c-1pt0 1c-1pt0 1c-1pt0 1 c-1pt0 1c-1pt0 1c-1pt0 1 c-1pt0 1c-1pt0 1c-1pt0 1c-1pt0 1c-1pt0 1c|-1pt0 4cRTI 3c 3c 6c The RTI instruction (opcode = 1000, with no operands) pops the the top two values on the system stack into the PC and PSR. Since the PC contains the address following the address of the TRAP instruction, control returns to the user program at the correct address. Finally, once the PSR has been popped off the system stack, PSR[15] must be examined to see whether the processor was running in User mode or Supervisor mode when the TRAP instruction was executed. If in User mode, the stack pointers need to be adjusted to reflect that now back in User mode, the relevant stack in use is the User Stack. This is done by loading the Saved­SSP with the current contents of R6, and loading R6 with the contents of Saved_USP. Figure <ref> shows the LC-3 using the TRAP instruction and the RTI instruction to implement the example of Figure <ref>. The flow",
    "569": "top two values on the system stack into the PC and PSR. Since the PC contains the address following the address of the TRAP instruction, control returns to the user program at the correct address. Finally, once the PSR has been popped off the system stack, PSR[15] must be examined to see whether the processor was running in User mode or Supervisor mode when the TRAP instruction was executed. If in User mode, the stack pointers need to be adjusted to reflect that now back in User mode, the relevant stack in use is the User Stack. This is done by loading the Saved­SSP with the current contents of R6, and loading R6 with the contents of Saved_USP. Figure <ref> shows the LC-3 using the TRAP instruction and the RTI instruction to implement the example of Figure <ref>. The flow of control goes from (A) within a user program that needs a character input from the keyboard, to (B) the operating system service routine that performs that task on behalf of the user program, back to the user program (C) that presumably uses the information contained in the input character. < g r a p h i c s > Flow of control from a user program to an OS service routine and back §.§ A Summary of the trap service routine process As we know, the computer continually executes its instruction cycle (FETCH, DECODE, etc.) on sequentially located instructions until the flow of control is changed by changing the contents of the PC during the EXECUTE phase of the current instruction. In that way, the next FETCH will be at a redirected address. The TRAP instruction with trap vector x23 in our user program does exactly that. Execution of TRAP x23 causes the PSR and incremented PC to be pushed onto the system stack and the contents of memory location x0023 (which, in this case, contains x04A0) to be loaded into the PC. The dashed line on Figure <ref> show the use of the trap vector x23 to obtain",
    "570": "Flow of control from a user program to an OS service routine and back §.§ A Summary of the trap service routine process As we know, the computer continually executes its instruction cycle (FETCH, DECODE, etc.) on sequentially located instructions until the flow of control is changed by changing the contents of the PC during the EXECUTE phase of the current instruction. In that way, the next FETCH will be at a redirected address. The TRAP instruction with trap vector x23 in our user program does exactly that. Execution of TRAP x23 causes the PSR and incremented PC to be pushed onto the system stack and the contents of memory location x0023 (which, in this case, contains x04A0) to be loaded into the PC. The dashed line on Figure <ref> show the use of the trap vector x23 to obtain the starting address of the trap service routine from the Trap Vector Table. The next instruction cycle starts with the FETCH of the contents of x04A0, which is the first instruction of the relevant operating system service routine. The trap service routine executes to completion, ending with the RTI instruction, which loads the PC and PSR with the top two elements on the system stack, i.e., the PSR and incremented PC that were pushed during execution of the TRAP instruction. Since the PC was incremented prior to being pushed onto the system stack, it contains the address of the instruction following the TRAP instruction in the calling program, and the user program resumes execution by fetching the instruction following the TRAP instruction. The following program is provided to illustrate the use of the TRAP instruction. It can also be used to amuse the average four-year-old! Write a game program to do the following: A person is sitting at a keyboard. Each time the person types a capital letter, the program outputs the lowercase version of that letter. If the person types a 7, the program terminates. The following LC-3 assembly language program will do the job. 01 .ORIG x3000 02",
    "571": "elements on the system stack, i.e., the PSR and incremented PC that were pushed during execution of the TRAP instruction. Since the PC was incremented prior to being pushed onto the system stack, it contains the address of the instruction following the TRAP instruction in the calling program, and the user program resumes execution by fetching the instruction following the TRAP instruction. The following program is provided to illustrate the use of the TRAP instruction. It can also be used to amuse the average four-year-old! Write a game program to do the following: A person is sitting at a keyboard. Each time the person types a capital letter, the program outputs the lowercase version of that letter. If the person types a 7, the program terminates. The following LC-3 assembly language program will do the job. 01 .ORIG x3000 02 LD R2,TERM ; Load -7 03 LD R3,ASCII ; Load ASCII difference 04 AGAIN TRAP x23 ; Request keyboard input 05 ADD R1,R2,R0 ; Test for terminating 06 BRz EXIT ; character 07 ADD R0,R0,R3 ; Change to lowercase 08 TRAP x21 ; Output to the monitor 09 BRnzp AGAIN ; ... and do it again! 0A TERM .FILL xFFC9 ; FFC9 is negative of ASCII 7 0B ASCII .FILL x0020 0C EXIT TRAP x25 ; Halt 0D .END The program executes as follows: The program first loads constants xFFC9 and x0020 into R2 and R3. The constant xFFC9, which is the negative of the ASCII code for 7, is used to test the character typed at the keyboard to see if the four-year-old wants to continue playing. The constant x0020 is the zero-extended difference between the ASCII code for a capital letter and the ASCII code for that same letter's lowercase representation. For example, the ASCII code for A is x41; the ASCII code for a is x61. The ASCII codes for Z and z are x5A and x7A, respectively. Then TRAP x23 is executed, which invokes the keyboard input service routine. When the service routine is finished, control",
    "572": "; FFC9 is negative of ASCII 7 0B ASCII .FILL x0020 0C EXIT TRAP x25 ; Halt 0D .END The program executes as follows: The program first loads constants xFFC9 and x0020 into R2 and R3. The constant xFFC9, which is the negative of the ASCII code for 7, is used to test the character typed at the keyboard to see if the four-year-old wants to continue playing. The constant x0020 is the zero-extended difference between the ASCII code for a capital letter and the ASCII code for that same letter's lowercase representation. For example, the ASCII code for A is x41; the ASCII code for a is x61. The ASCII codes for Z and z are x5A and x7A, respectively. Then TRAP x23 is executed, which invokes the keyboard input service routine. When the service routine is finished, control returns to the application program (at line 05), and R0 contains the ASCII code of the character typed. The ADD and BRz instructions test for the terminating character 7. If the character typed is not a 7, the ASCII uppercase/lowercase difference (x0020) is added to the input ASCII code, storing the result in R0. Then a TRAP to the monitor output service routine is called. This causes the lowercase representation of the same letter to be displayed on the monitor. When control returns to the application program (this time at line 09), an unconditional BR to AGAIN is executed, and another request for keyboard input appears. The correct operation of the program in this example assumes that the person sitting at the keyboard only types capital letters and the value 7. What if the person types a $? A better solution to Example 9.1 would be a program that tests the character typed to be sure it really is a capital letter from among the 26 capital letters in the alphabet or the single digit 7, and if it is not, takes corrective action. Question: Augment this program to add the test for bad data. That is, write a program",
    "573": "output service routine is called. This causes the lowercase representation of the same letter to be displayed on the monitor. When control returns to the application program (this time at line 09), an unconditional BR to AGAIN is executed, and another request for keyboard input appears. The correct operation of the program in this example assumes that the person sitting at the keyboard only types capital letters and the value 7. What if the person types a $? A better solution to Example 9.1 would be a program that tests the character typed to be sure it really is a capital letter from among the 26 capital letters in the alphabet or the single digit 7, and if it is not, takes corrective action. Question: Augment this program to add the test for bad data. That is, write a program that will type the lowercase representation of any capital letter typed and will terminate if anything other than a capital letter is typed. See Exercise 9.6. §.§ Trap Routines for Handling I/O With the constructs just provided, the input routine described in Figure <ref> can be slightly modified to be the input service routine shown in Figure <ref>. Two changes are needed: (1) We add the appropriate .ORIG and .END pseudo-ops. .ORIG specifies the starting address of the input service routine—the address found at location x0023 in the Trap Vector Table. And (2) we terminate the input service routine with the RTI instruction rather than the BR NEXT_TASK, as is done on line 20 in Figure <ref>. We use RTI because the service routine is invoked by TRAP x23. It is not part of the user program, as was the case in Figure <ref>. 36pc[fontsize=910] 01 ; Service Routine for Keyboard Input 02 ; 03 .ORIG x04A0 04 START ST R1,SaveR1 ; Save the values in the registers 05 ST R2,SaveR2 ; that are used so that they 06 ST R3,SaveR3 ; can be restored before RET 07 ; 08 LD R2,Newline 09 L1 LDI R3,DSR ; Check DDR –",
    "574": "are needed: (1) We add the appropriate .ORIG and .END pseudo-ops. .ORIG specifies the starting address of the input service routine—the address found at location x0023 in the Trap Vector Table. And (2) we terminate the input service routine with the RTI instruction rather than the BR NEXT_TASK, as is done on line 20 in Figure <ref>. We use RTI because the service routine is invoked by TRAP x23. It is not part of the user program, as was the case in Figure <ref>. 36pc[fontsize=910] 01 ; Service Routine for Keyboard Input 02 ; 03 .ORIG x04A0 04 START ST R1,SaveR1 ; Save the values in the registers 05 ST R2,SaveR2 ; that are used so that they 06 ST R3,SaveR3 ; can be restored before RET 07 ; 08 LD R2,Newline 09 L1 LDI R3,DSR ; Check DDR – is it free? 0A BRzp L1 0B STI R2,DDR ; Move cursor to new clean line 0C ; 0D LEA R1,Prompt ; Prompt is starting address 0E ; of prompt string 1F Loop LDR R0,R1,#0 ; Get next prompt character 10 BRz Input ; Check for end of prompt string 11 L2 LDI R3,DSR 12 BRzp L2 13 STI R0,DDR ; Write next character of 14 ; prompt string 15 ADD R1,R1,#1 ; Increment prompt pointer 16 BRnzp Loop 17 ; 18 Input LDI R3,KBSR ; Has a character been typed? 19 BRzp Input 1A LDI R0,KBDR ; Load it into R0 1B L3 LDI R3,DSR 1C BRzp L3 1D STI R0,DDR ; Echo input character 1E ; to the monitor 1F ; 20 L4 LDI R3,DSR 21 BRzp L4 22 STI R2,DDR ; Move cursor to new clean line 23 LD R1,SaveR1 ; Service routine done, restore 24 LD R2,SaveR2 ; original values in registers. 25 LD R3,SaveR3 26 RTI ; Return from Trap 27 ; 28 SaveR1 .BLKW 1 29 SaveR2 .BLKW 1 2A SaveR3 .BLKW 1 2B DSR .FILL xFE04 2C DDR .FILL xFE06 2D KBSR .FILL xFE00 2E KBDR .FILL xFE02 2F Newline .FILL x000A ;",
    "575": "; Write next character of 14 ; prompt string 15 ADD R1,R1,#1 ; Increment prompt pointer 16 BRnzp Loop 17 ; 18 Input LDI R3,KBSR ; Has a character been typed? 19 BRzp Input 1A LDI R0,KBDR ; Load it into R0 1B L3 LDI R3,DSR 1C BRzp L3 1D STI R0,DDR ; Echo input character 1E ; to the monitor 1F ; 20 L4 LDI R3,DSR 21 BRzp L4 22 STI R2,DDR ; Move cursor to new clean line 23 LD R1,SaveR1 ; Service routine done, restore 24 LD R2,SaveR2 ; original values in registers. 25 LD R3,SaveR3 26 RTI ; Return from Trap 27 ; 28 SaveR1 .BLKW 1 29 SaveR2 .BLKW 1 2A SaveR3 .BLKW 1 2B DSR .FILL xFE04 2C DDR .FILL xFE06 2D KBSR .FILL xFE00 2E KBDR .FILL xFE02 2F Newline .FILL x000A ; ASCII code for newline 30 Prompt .STRINGZ \"Input a character>\" 31 .END Character input service routine The output routine of Section <ref> can be modified in a similar way, as shown in Figure <ref>. The results are input (Figure <ref>) and output (Figure <ref>) service routines that can be invoked simply and safely by the TRAP instruction with the appropriate trap vector. In the case of input, upon completion of TRAP x23, R0 contains the ASCII code of the keyboard character typed. In the case of output, the initiating program must load R0 with the ASCII code of the character it wishes displayed on the monitor and then invoke TRAP x21. [fontsize=910] 01 .ORIG x0420 ; System call starting address 02 ST R1, SaveR1 ; R1 will be used to poll the DSR 03 ; hardware 04 ; Write the character 05 TryWrite LDI R1, DSR ; Get status 06 BRzp TryWrite ; Bit 15 on says display is ready 07 WriteIt STI R0, DDR ; Write character 08 09 ; return from trap 0A Return LD R1, SaveR1 ; Restore registers 0B RTI ; Return from trap 0C DSR .FILL xFE04 ; Address of display status register 0D DDR",
    "576": "trap vector. In the case of input, upon completion of TRAP x23, R0 contains the ASCII code of the keyboard character typed. In the case of output, the initiating program must load R0 with the ASCII code of the character it wishes displayed on the monitor and then invoke TRAP x21. [fontsize=910] 01 .ORIG x0420 ; System call starting address 02 ST R1, SaveR1 ; R1 will be used to poll the DSR 03 ; hardware 04 ; Write the character 05 TryWrite LDI R1, DSR ; Get status 06 BRzp TryWrite ; Bit 15 on says display is ready 07 WriteIt STI R0, DDR ; Write character 08 09 ; return from trap 0A Return LD R1, SaveR1 ; Restore registers 0B RTI ; Return from trap 0C DSR .FILL xFE04 ; Address of display status register 0D DDR .FILL xFE06 ; Address of display data register 0E SaveR1 .BLKW 1 0F .END Character output service routine §.§ A Trap Routine for Halting the Computer Recall from Section 4.5 that the RUN latch is ANDed with the crystal oscillator to produce the clock that controls the operation of the computer. We noted that if that 1-bit latch was cleared, the output of the AND gate would be 0, stopping the clock. Years ago, most ISAs had a HALT instruction for stopping the clock. Given how infrequently that instruction is executed, it seems wasteful to devote an opcode to it. In many modern computers, the RUN latch is cleared by a TRAP routine. In the LC-3, the RUN latch is bit [15] of the Master Control Register (MCR), which is memory-mapped to location xFFFE. Figure <ref> shows the trap service routine for halting the processor, i.e., for stopping the clock. [style=infigure] 01 .ORIG x0520 ; Where this routine resides 02 ST R1, SaveR1 ; R1: a temp for MC register 03 ST R0, SaveR0 ; R0 is used as working space 04 05 ; print message that machine is halting 06 07 LD R0, ASCIINewLine 08 TRAP x21 09 LEA",
    "577": "the output of the AND gate would be 0, stopping the clock. Years ago, most ISAs had a HALT instruction for stopping the clock. Given how infrequently that instruction is executed, it seems wasteful to devote an opcode to it. In many modern computers, the RUN latch is cleared by a TRAP routine. In the LC-3, the RUN latch is bit [15] of the Master Control Register (MCR), which is memory-mapped to location xFFFE. Figure <ref> shows the trap service routine for halting the processor, i.e., for stopping the clock. [style=infigure] 01 .ORIG x0520 ; Where this routine resides 02 ST R1, SaveR1 ; R1: a temp for MC register 03 ST R0, SaveR0 ; R0 is used as working space 04 05 ; print message that machine is halting 06 07 LD R0, ASCIINewLine 08 TRAP x21 09 LEA R0, Message 0A TRAP x22 0B LD R0, ASCIINewLine 0C TRAP x21 0D ; 0E ; clear bit 15 at xFFFE to stop the machine 0F ; 10 LDI R1, MCR ; Load MC register into R1 11 LD R0, MASK ; R0 = x7FFF 12 AND R0, R1, R0 ; Mask to clear the top bit 13 STI R0, MCR ; Store R0 into MC register 14 ; 15 ; return from HALT routine. 16 ; (how can this routine return if the machine is halted above?) 17 ; 18 LD R1, SaveR1 ; Restore registers 19 LD R0, SaveR0 1A RTI 1B ; 1C ; Some constants 1D ; 1E ASCIINewLine .FILL x000A 1F SaveR0 .BLKW 1 20 SaveR1 .BLKW 1 21 Message .STRINGZ \"Halting the machine.\" 22 MCR .FILL xFFFE ; Address of MCR 23 MASK .FILL x7FFF ; Mask to clear the top bit 24 .END HALT service routine for the LC-3 First (lines 02 and 03), registers R1, and R0 are saved. R1 and R0 are saved because they are needed by the service routine. Then (lines 07 through 0C), the banner Halting the machine is displayed on the monitor. Finally (lines 10 through 13),",
    "578": "MCR ; Store R0 into MC register 14 ; 15 ; return from HALT routine. 16 ; (how can this routine return if the machine is halted above?) 17 ; 18 LD R1, SaveR1 ; Restore registers 19 LD R0, SaveR0 1A RTI 1B ; 1C ; Some constants 1D ; 1E ASCIINewLine .FILL x000A 1F SaveR0 .BLKW 1 20 SaveR1 .BLKW 1 21 Message .STRINGZ \"Halting the machine.\" 22 MCR .FILL xFFFE ; Address of MCR 23 MASK .FILL x7FFF ; Mask to clear the top bit 24 .END HALT service routine for the LC-3 First (lines 02 and 03), registers R1, and R0 are saved. R1 and R0 are saved because they are needed by the service routine. Then (lines 07 through 0C), the banner Halting the machine is displayed on the monitor. Finally (lines 10 through 13), the RUN latch (MCR[15]) is cleared by ANDing the MCR with[-2.3pc] 0111111111111111. That is, MCR[14:0] remains unchanged, but MCR[15] is cleared. Question: What instruction (or trap service routine) can be used to start the clock? Hint: This is a trick question! :-) §.§ The Trap routine for character input (one last time) Let's look again at the keyboard input service routine of Figure <ref>. In particular, let's look at the three-line sequence that occurs at symbolic addresses L1, L2, L3, and L4: LABEL LDI R3,DSR BRzp LABEL STI Reg,DDR Can the JSR/RET mechanism enable us to replace these four occurrences of the same sequence with a single subroutine? Answer: Yes, almost. Figure <ref>, our “improved” keyboard input service routine, contains JSR WriteChar at lines 04, 0A, 10, and 13, and the four-instruction subroutine WriteChar LDI R3,DSR BRzp WriteChar STI R2,DDR RET at lines 1A through 1D. Note the RET instruction (aka JMP R7) that is needed to terminate the subroutine. [fontsize=89] 01 .ORIG x04A0 02 START JSR SaveReg 03 LD R2,Newline 04 JSR WriteChar 05 LEA R1,PROMPT 06 ; 07 ; 08 Loop LDR R2,R1,#0 ; Get next prompt char 09 BRz Input 0A JSR WriteChar 0B ADD R1,R1,#1 0C",
    "579": "routine of Figure <ref>. In particular, let's look at the three-line sequence that occurs at symbolic addresses L1, L2, L3, and L4: LABEL LDI R3,DSR BRzp LABEL STI Reg,DDR Can the JSR/RET mechanism enable us to replace these four occurrences of the same sequence with a single subroutine? Answer: Yes, almost. Figure <ref>, our “improved” keyboard input service routine, contains JSR WriteChar at lines 04, 0A, 10, and 13, and the four-instruction subroutine WriteChar LDI R3,DSR BRzp WriteChar STI R2,DDR RET at lines 1A through 1D. Note the RET instruction (aka JMP R7) that is needed to terminate the subroutine. [fontsize=89] 01 .ORIG x04A0 02 START JSR SaveReg 03 LD R2,Newline 04 JSR WriteChar 05 LEA R1,PROMPT 06 ; 07 ; 08 Loop LDR R2,R1,#0 ; Get next prompt char 09 BRz Input 0A JSR WriteChar 0B ADD R1,R1,#1 0C BRnzp Loop 0D ; 0E Input JSR ReadChar 0F ADD R2,R0,#0 ; Move char to R2 for writing 10 JSR WriteChar ; Echo to monitor 11 ; 12 LD R2, Newline 13 JSR WriteChar 14 JSR RestoreReg 15 RTI ; RTI terminates the trap routine 16 ; 17 Newline .FILL x000A 18 PROMPT .STRINGZ \"Input a character>\" 19 ; 1A WriteChar LDI R3,DSR 1B BRzp WriteChar 1C STI R2,DDR 1D RET ; JMP R7 terminates subroutine 1E DSR .FILL xFE04 1F DDR .FILL xFE06 20 ; 21 ReadChar LDI R3,KBSR 22 BRzp ReadChar 23 LDI R0,KBDR 24 RET 25 KBSR .FILL xFE00 26 KBDR .FILL xFE02 27 ; 28 SaveReg ST R1,SaveR1 29 ST R2,SaveR2 2A ST R3,SaveR3 2B ST R4,SaveR4 2C ST R5,SaveR5 2D ST R6,SaveR6 2E RET 2F ; 30 RestoreReg LD R1,SaveR1 31 LD R2,SaveR2 32 LD R3,SaveR3 33 LD R4,SaveR4 34 LD R5,SaveR5 35 LD R6,SaveR6 36 RET 37 SaveR1 .FILL x0000 38 SaveR2 .FILL x0000 39 SaveR3 .FILL x0000 3A SaveR4 .FILL x0000 3B SaveR5 .FILL x0000 3C SaveR6 .FILL x0000 3D .END The LC-3 trap service routine for character input (our final answer!) Note the hedging: almost. In the original sequences starting at L2",
    "580": "WriteChar LDI R3,DSR 1B BRzp WriteChar 1C STI R2,DDR 1D RET ; JMP R7 terminates subroutine 1E DSR .FILL xFE04 1F DDR .FILL xFE06 20 ; 21 ReadChar LDI R3,KBSR 22 BRzp ReadChar 23 LDI R0,KBDR 24 RET 25 KBSR .FILL xFE00 26 KBDR .FILL xFE02 27 ; 28 SaveReg ST R1,SaveR1 29 ST R2,SaveR2 2A ST R3,SaveR3 2B ST R4,SaveR4 2C ST R5,SaveR5 2D ST R6,SaveR6 2E RET 2F ; 30 RestoreReg LD R1,SaveR1 31 LD R2,SaveR2 32 LD R3,SaveR3 33 LD R4,SaveR4 34 LD R5,SaveR5 35 LD R6,SaveR6 36 RET 37 SaveR1 .FILL x0000 38 SaveR2 .FILL x0000 39 SaveR3 .FILL x0000 3A SaveR4 .FILL x0000 3B SaveR5 .FILL x0000 3C SaveR6 .FILL x0000 3D .END The LC-3 trap service routine for character input (our final answer!) Note the hedging: almost. In the original sequences starting at L2 and L3, the STI instruction forwards the contents of R0 (not R2) to the DDR. We can fix that easily enough, as follows: In line 08 of Figure <ref>, we use LDR R2,R1,#0 instead of LDR R0,R1,#0 This causes each character in the prompt to be loaded into R2. The subroutine Writechar forwards each character from R2 to the DDR. In line 0F of Figure <ref>, we insert the instruction ADD R2,R0,#0 in order to move the keyboard input (which is in R0) into R2. The subroutine Writechar forwards it from R2 to the DDR. Note that R0 still contains the keyboard input. Furthermore, since no subsequent instruction in the service routine loads R0, R0 still contains the keyboard input after control returns to the user program. In line 12 of Figure <ref>, we insert the instruction LD R2,Newline in order to move the “newline” character into R2. The subroutine Writechar forwards it from R2 to the DDR. Figure <ref> is the actual LC-3 trap service routine provided for keyboard input. §.§ PUTS: Writing a Character String to the Monitor Before we leave the example of Figure <ref>, note the code on lines 08 through 0C. This fragment of the",
    "581": "In line 0F of Figure <ref>, we insert the instruction ADD R2,R0,#0 in order to move the keyboard input (which is in R0) into R2. The subroutine Writechar forwards it from R2 to the DDR. Note that R0 still contains the keyboard input. Furthermore, since no subsequent instruction in the service routine loads R0, R0 still contains the keyboard input after control returns to the user program. In line 12 of Figure <ref>, we insert the instruction LD R2,Newline in order to move the “newline” character into R2. The subroutine Writechar forwards it from R2 to the DDR. Figure <ref> is the actual LC-3 trap service routine provided for keyboard input. §.§ PUTS: Writing a Character String to the Monitor Before we leave the example of Figure <ref>, note the code on lines 08 through 0C. This fragment of the service routine is used to write the sequence of characters Input a character to the monitor. A sequence of characters is often strings referred to as a string of characters or a character string. This fragment is also present in Figure <ref>, with the result that Halting the machine is written to the monitor. In fact, it is so often the case that a user program needs to write a string of characters to the monitor that this function is given its own trap service routine in the LC-3 operating system. Thus, if a user program requires a character string to be written to the monitor, it need only provide (in R0) the starting address of the character string, and then invoke TRAP x22. In LC-3 assembly language this TRAP is called PUTS. PUTS (or TRAP x22) causes control to be passed to the operating system, and the trap routine shown in Figure <ref> is executed. Note that PUTS is the code of lines 08 through 0C of Figure <ref>, with a few minor adjustments. 36pc[fontsize=910] 01 ; This service routine writes a NULL-terminated string to the console. 02 ; It services the PUTS service call (TRAP x22). 03 ;",
    "582": "the case that a user program needs to write a string of characters to the monitor that this function is given its own trap service routine in the LC-3 operating system. Thus, if a user program requires a character string to be written to the monitor, it need only provide (in R0) the starting address of the character string, and then invoke TRAP x22. In LC-3 assembly language this TRAP is called PUTS. PUTS (or TRAP x22) causes control to be passed to the operating system, and the trap routine shown in Figure <ref> is executed. Note that PUTS is the code of lines 08 through 0C of Figure <ref>, with a few minor adjustments. 36pc[fontsize=910] 01 ; This service routine writes a NULL-terminated string to the console. 02 ; It services the PUTS service call (TRAP x22). 03 ; Inputs: R0 is a pointer to the string to print. 04 ; 05 .ORIG x0460 06 ST R0, SaveR0 ; Save registers that 07 ST R1, SaveR1 ; are needed by this 08 ST R3, SaveR3 ; trap service routine 09 ; 0A ; Loop through each character in the array 0B ; 0C Loop LDR R1, R0, #0 ; Retrieve the character(s) 0D BRz Return ; If it is 0, done 0E L2 LDI R3,DSR 0F BRzp L2 10 STI R1, DDR ; Write the character 11 ADD R0, R0, #1 ; Increment pointer 12 BRnzp Loop ; Do it all over again 13 ; 14 ; Return from the request for service call 15 Return LD R3, SaveR3 16 LD R1, SaveR1 17 LD R0, SaveR0 18 RTI 19 ; 1A ; Register locations 1B DSR .FILL xFE04 1C DDR .FILL xFE06 1D SaveR0 .FILL x0000 1E SaveR1 .FILL x0000 1F SaveR3 .FILL x0000 20 .END The LC-3 PUTS service routine § INTERRUPTS AND INTERRUPT-DRIVEN I/O interrupt-driven I/O In Section <ref>, we noted that interaction between the processor and an I/O device can be controlled by the processor (i.e., polling) or it can be controlled by the I/O",
    "583": "Retrieve the character(s) 0D BRz Return ; If it is 0, done 0E L2 LDI R3,DSR 0F BRzp L2 10 STI R1, DDR ; Write the character 11 ADD R0, R0, #1 ; Increment pointer 12 BRnzp Loop ; Do it all over again 13 ; 14 ; Return from the request for service call 15 Return LD R3, SaveR3 16 LD R1, SaveR1 17 LD R0, SaveR0 18 RTI 19 ; 1A ; Register locations 1B DSR .FILL xFE04 1C DDR .FILL xFE06 1D SaveR0 .FILL x0000 1E SaveR1 .FILL x0000 1F SaveR3 .FILL x0000 20 .END The LC-3 PUTS service routine § INTERRUPTS AND INTERRUPT-DRIVEN I/O interrupt-driven I/O In Section <ref>, we noted that interaction between the processor and an I/O device can be controlled by the processor (i.e., polling) or it can be controlled by the I/O device (i.e., interrupt driven). In Sections <ref>, <ref>, and <ref>, we have studied several examples of polling. In each case, the processor tested the Ready bit of the status register again and again, and when the Ready bit was finally 1, the processor branched to the instruction that did the input or output operation. We are now ready to study the case where the interaction is controlled by the I/O device. §.§ What Is Interrupt-Driven I/O? The essence of interrupt-driven I/O is the notion that an I/O device that may or may not have anything to do with the program that is running can (1) force the running program to stop, (2) have the processor execute a program that carries out the needs of the I/O device, and then (3) have the stopped program resume execution as if nothing had happened. These three stages of the instruction execution flow are shown in Figure <ref>. [fontsize=913] . . . Program A is executing instruction n Program A is executing instruction n+1 Program A is executing instruction n+2 [fontsize=911,formatcom=] 1: Interrupt signal is detected 1: Program A is put into suspended animation 1: PC is loaded with the starting address of Program",
    "584": "the case where the interaction is controlled by the I/O device. §.§ What Is Interrupt-Driven I/O? The essence of interrupt-driven I/O is the notion that an I/O device that may or may not have anything to do with the program that is running can (1) force the running program to stop, (2) have the processor execute a program that carries out the needs of the I/O device, and then (3) have the stopped program resume execution as if nothing had happened. These three stages of the instruction execution flow are shown in Figure <ref>. [fontsize=913] . . . Program A is executing instruction n Program A is executing instruction n+1 Program A is executing instruction n+2 [fontsize=911,formatcom=] 1: Interrupt signal is detected 1: Program A is put into suspended animation 1: PC is loaded with the starting address of Program B 2: Program B starts satisying I/O device's needs 2: Program B continues satisfying I/O device's needs 2: Program B continues satisfying I/O device's needs 2: Program B finishes satisfying I/O device's needs 3: Program A is brought back to life [fontsize=911] Program A is executing instruction n+3 Program A is executing instruction n+4 . . . Instruction execution flow for interrupt-driven I/O As far as Program A is concerned, the work carried out and the results computed are no different from what would have been the case if the interrupt had never happened; that is, as if the instruction execution flow had been the following: [fontsize=910,formatcom=] . . . Program A is executing instruction n Program A is executing instruction n+1 Program A is executing instruction n+2 Program A is executing instruction n+3 Program A is executing instruction n+4 . . . §.§ Why Have Interrupt-Driven I/O? As is undoubtedly clear, polling requires the processor to waste a lot of time spinning its wheels, re-executing again and again the LDI and BR instructions until the Ready bit is set. With interrupt-driven I/O, none of that testing and branching has to go on. Interrupt-driven I/O allows the processor to spend",
    "585": "for interrupt-driven I/O As far as Program A is concerned, the work carried out and the results computed are no different from what would have been the case if the interrupt had never happened; that is, as if the instruction execution flow had been the following: [fontsize=910,formatcom=] . . . Program A is executing instruction n Program A is executing instruction n+1 Program A is executing instruction n+2 Program A is executing instruction n+3 Program A is executing instruction n+4 . . . §.§ Why Have Interrupt-Driven I/O? As is undoubtedly clear, polling requires the processor to waste a lot of time spinning its wheels, re-executing again and again the LDI and BR instructions until the Ready bit is set. With interrupt-driven I/O, none of that testing and branching has to go on. Interrupt-driven I/O allows the processor to spend its time doing what is hopefully useful work, executing some other program perhaps, until it is notified that some I/O device needs attention. example example mathmargin@ to 13@ to 7pc1012 Example 9.5117.5pc by 3@ 1.5pcafterheadingafterindentfalse Suppose we are asked to write a program that takes a sequence of 100 characters typed on a keyboard and processes the information contained in those 100 characters. Assume the characters are typed at the rate of 80 words/minute, which corresponds to one character every 0.125 seconds. Assume the processing of the 100-character sequence takes 12.49999 seconds, and that our program is to perform this process on 1,000 consecutive sequences. How long will it take our program to complete the task? (Why did we pick 12.49999? To make the numbers come out nice, of course.) :-) We could obtain each character input by polling, as in Section <ref>. If we did, we would waste a lot of time waiting for the “next” character to be typed. It would take 100· 0.125 or 12.5 seconds to get a 100-character sequence. On the other hand, if we use interrupt-driven I/O, the processor does not waste any time re-executing the LDI and BR instructions while waiting for a",
    "586": "those 100 characters. Assume the characters are typed at the rate of 80 words/minute, which corresponds to one character every 0.125 seconds. Assume the processing of the 100-character sequence takes 12.49999 seconds, and that our program is to perform this process on 1,000 consecutive sequences. How long will it take our program to complete the task? (Why did we pick 12.49999? To make the numbers come out nice, of course.) :-) We could obtain each character input by polling, as in Section <ref>. If we did, we would waste a lot of time waiting for the “next” character to be typed. It would take 100· 0.125 or 12.5 seconds to get a 100-character sequence. On the other hand, if we use interrupt-driven I/O, the processor does not waste any time re-executing the LDI and BR instructions while waiting for a character to be typed. Rather, the processor can be busy working on the previous 100-character sequence that was typed, except for those very small fractions of time when it is interrupted by the I/O device to read the next character typed. Let's say that to read the next character typed requires executing a 10-instruction program that takes on the average 0.00000001 seconds to execute each instruction. That means 0.0000001 seconds for each character typed, or 0.00001 seconds for the entire 100-character sequence. That is, with interrupt-driven I/O, since the processor is only needed when characters are actually being read, the time required for each 100-character sequence is 0.00001 seconds, instead of 12.50000 seconds. The remaining 12.49999 of every 12.50000 seconds, the processor is available to do useful work. For example, it can process the previous 100-character sequence. The bottom line: With polling, the time to complete the entire task for each sequence is 24.9999 seconds, 12.5 seconds to obtain the 100 characters + 12.49999 seconds to process them. With interrupt-driven I/O, the time to complete the entire task for each sequence after the first is 12.5 seconds, 0.00001 seconds to obtain the characters + 12.49999 seconds to process them. For",
    "587": "0.00000001 seconds to execute each instruction. That means 0.0000001 seconds for each character typed, or 0.00001 seconds for the entire 100-character sequence. That is, with interrupt-driven I/O, since the processor is only needed when characters are actually being read, the time required for each 100-character sequence is 0.00001 seconds, instead of 12.50000 seconds. The remaining 12.49999 of every 12.50000 seconds, the processor is available to do useful work. For example, it can process the previous 100-character sequence. The bottom line: With polling, the time to complete the entire task for each sequence is 24.9999 seconds, 12.5 seconds to obtain the 100 characters + 12.49999 seconds to process them. With interrupt-driven I/O, the time to complete the entire task for each sequence after the first is 12.5 seconds, 0.00001 seconds to obtain the characters + 12.49999 seconds to process them. For 1,000 sequences, that is the difference between 7 hours and 3 1/2 hours. §.§ Two parts to the process There are two parts to interrupt-driven I/O: * the mechanism that enables an I/O device to interrupt the processor, and * the mechanism that handles the interrupt request. §.§ Part I: Causing the interrupt to occur Several things must be true for an I/O device to actually interrupt the program that is running: * The I/O device must want service. * The device must have the right to request the service. * The device request must be more urgent than what the processor is currently doing. If all three elements are present, the processor stops executing the program that is running and takes care of the interrupt. §.§.§ The Interrupt Signal from the Device For an I/O device to generate an interrupt request, the device must want service, and it must have the right to request that service. The device must want service We have discussed that already in the study of polling. It is the Ready bit of the KBSR or the DSR. That is, if the I/O device is the keyboard, it wants service if someone has typed a",
    "588": "for an I/O device to actually interrupt the program that is running: * The I/O device must want service. * The device must have the right to request the service. * The device request must be more urgent than what the processor is currently doing. If all three elements are present, the processor stops executing the program that is running and takes care of the interrupt. §.§.§ The Interrupt Signal from the Device For an I/O device to generate an interrupt request, the device must want service, and it must have the right to request that service. The device must want service We have discussed that already in the study of polling. It is the Ready bit of the KBSR or the DSR. That is, if the I/O device is the keyboard, it wants service if someone has typed a character. If the I/O device is the monitor, it wants service (i.e., the next character to output) if the associated electronic circuits have successfully completed the display of the last character. In both cases, the I/O device wants service when the corresponding Ready bit is set. The device must have the right to request that service This is the interrupt enable bit, which can be set or cleared by the processor (usually by the operating system), depending on whether or not the processor wants to give the I/O device the right to request service. In most I/O devices, this interrupt enable (IE) bit is part of the device status register. In the KBSR and DSR shown in Figure <ref>, the IE bit is bit [14]. interrupt enable The interrupt request signal from the I/O device is the logical AND of the IE bit and the Ready bit, as is also shown in Figure <ref>. < g r a p h i c s > Interrupt enable bits and their use If the interrupt enable bit (bit [14]) is clear, it does not matter whether the Ready bit is set; the I/O device will not be able to interrupt the processor",
    "589": "enable bit, which can be set or cleared by the processor (usually by the operating system), depending on whether or not the processor wants to give the I/O device the right to request service. In most I/O devices, this interrupt enable (IE) bit is part of the device status register. In the KBSR and DSR shown in Figure <ref>, the IE bit is bit [14]. interrupt enable The interrupt request signal from the I/O device is the logical AND of the IE bit and the Ready bit, as is also shown in Figure <ref>. < g r a p h i c s > Interrupt enable bits and their use If the interrupt enable bit (bit [14]) is clear, it does not matter whether the Ready bit is set; the I/O device will not be able to interrupt the processor because it (the I/O device) has not been given the right to interrupt the processor. In that case, the program will have to poll the I/O device to determine if it is ready. If bit [14] is set, then interrupt-driven I/O is enabled. In that case, as soon as someone types a key (or as soon as the monitor has finished processing the last character), bit [15] is set. In this case, the device wants service and it has been given the right to request service. The AND gate is asserted, causing an interrupt request to be generated from the I/O device. §.§.§ The urgency of the request The third element in the list of things that must be true for an I/O device to actually interrupt the processor is that the request must be more urgent than the program that is currently executing. Recall from Section 9.1.1.2 that each program runs at a specified level of urgency called its priority level. To interrupt the running program, the device must have a higher priority than the program that is currently running. Actually, there may be many devices that want to interrupt the processor at a specific time. To succeed, the",
    "590": "finished processing the last character), bit [15] is set. In this case, the device wants service and it has been given the right to request service. The AND gate is asserted, causing an interrupt request to be generated from the I/O device. §.§.§ The urgency of the request The third element in the list of things that must be true for an I/O device to actually interrupt the processor is that the request must be more urgent than the program that is currently executing. Recall from Section 9.1.1.2 that each program runs at a specified level of urgency called its priority level. To interrupt the running program, the device must have a higher priority than the program that is currently running. Actually, there may be many devices that want to interrupt the processor at a specific time. To succeed, the device must have a higher priority level than all other demands for use of the processor. Almost all computers have a set of priority levels that programs can run at. As we have already noted, the LC-3 has eight priority levels, PL0, .. PL7. The higher the number, the more urgent the program. The PL of a program is usually the same as the PL (i.e., urgency) of the request to run that program. If a program is running at one PL, and a higher-level PL request wants the computer, the lower-priority program suspends processing until the higher-PL program executes and satisfies its more urgent request. For example, a computer's payroll program may run overnight, and at PL0. It has all night to finish—not terribly urgent. A program that corrects for a nuclear plant current surge may run at PL6. We are perfectly happy to let the payroll wait while the nuclear power correction keeps us from being blown to bits. For our I/O device to successfully stop the processor and start an interrupt-driven I/O request, the priority of the request must be higher than the priority of the program it wishes to interrupt. For example, we would not normally",
    "591": "the same as the PL (i.e., urgency) of the request to run that program. If a program is running at one PL, and a higher-level PL request wants the computer, the lower-priority program suspends processing until the higher-PL program executes and satisfies its more urgent request. For example, a computer's payroll program may run overnight, and at PL0. It has all night to finish—not terribly urgent. A program that corrects for a nuclear plant current surge may run at PL6. We are perfectly happy to let the payroll wait while the nuclear power correction keeps us from being blown to bits. For our I/O device to successfully stop the processor and start an interrupt-driven I/O request, the priority of the request must be higher than the priority of the program it wishes to interrupt. For example, we would not normally want to allow a keyboard interrupt from a professor checking e-mail to interrupt the nuclear power correction program. §.§.§ The INT signal To stop the processor from continuing execution of its currently running program and service an interrupt request, the INT signal must be asserted. Figure <ref> shows what is required to assert the INT signal. Figure <ref> shows the status registers of several devices operating at various priority levels (PL). Any device that has bits [14] and [15] both set asserts its interrupt request signal. The interrupt request signals are input to a priority encoder, a combinational logic structure that selects the highest priority request from all those asserted. If the PL of that request is higher than the PL of the currently executing program, the INT signal is asserted. < g r a p h i c s > Generation of the INT signal §.§.§ The Test for INT Finally, the test to enable the processor to stop and handle the interrupt. Recall from Chapter 4 that the instruction cycle continually sequences through the phases of the instruction cycle (FETCH, DECODE, EVALUATE ADDRESS, FETCH OPERAND, EXECUTE, and STORE RESULT). Each instruction changes the state of the computer, and",
    "592": "status registers of several devices operating at various priority levels (PL). Any device that has bits [14] and [15] both set asserts its interrupt request signal. The interrupt request signals are input to a priority encoder, a combinational logic structure that selects the highest priority request from all those asserted. If the PL of that request is higher than the PL of the currently executing program, the INT signal is asserted. < g r a p h i c s > Generation of the INT signal §.§.§ The Test for INT Finally, the test to enable the processor to stop and handle the interrupt. Recall from Chapter 4 that the instruction cycle continually sequences through the phases of the instruction cycle (FETCH, DECODE, EVALUATE ADDRESS, FETCH OPERAND, EXECUTE, and STORE RESULT). Each instruction changes the state of the computer, and that change is completed at the end of the instruction cycle for that intruction. That is, in the last clock cycle before the computer returns to the FETCH phase for the next instruction, the computer is put in the state caused by the complete execution of the current intruction. Interrupts can happen at any time. They are asynchronous to the synchronous finite state machine controlling the computer. For example, the interrupt signal could occur when the instruction cycle is in its FETCH OPERAND phase. If we stopped the currently executing program when the instruction cycle was in its FETCH OPERAND phase, we would have to keep track of what part of the current instruction has executed and what part of the current instruction still has work to do. It makes much more sense to ignore interrupt signals except when we are at an instruction boundary; that is, the current instruction has completed, and the next instruction has not yet started. Doing that means we do not have to worry about partially executed instructions, since the state of the computer is the state created by the completion of the current instruction, period! The additional logic to test for the interrupt signal",
    "593": "synchronous finite state machine controlling the computer. For example, the interrupt signal could occur when the instruction cycle is in its FETCH OPERAND phase. If we stopped the currently executing program when the instruction cycle was in its FETCH OPERAND phase, we would have to keep track of what part of the current instruction has executed and what part of the current instruction still has work to do. It makes much more sense to ignore interrupt signals except when we are at an instruction boundary; that is, the current instruction has completed, and the next instruction has not yet started. Doing that means we do not have to worry about partially executed instructions, since the state of the computer is the state created by the completion of the current instruction, period! The additional logic to test for the interrupt signal is to augment the last state of the instruction cycle for each instruction with a test. Instead of always going from the last state of one instruction cycle to the first state of the FETCH phase of the next instruction, the next state depends on the INT signal. If INT is not asserted, then it is business as usual, with the control unit returning to the FETCH phase to start processing the next instruction. If INT is asserted, then the next state is the first state of Part II, handling the interrupt request. §.§ Part II: Handling the interrupt request Handling the interrupt request goes through three stages, as shown in Figure <ref>: 1. Initiate the interrupt (three lines numbered 1 in Figure <ref>. 2. Service the interrupt (four lines numbered 2 in Figure <ref>. 3. Return from the interrupt (one line numbered 3 in Figure <ref>. We will discuss each. §.§.§ Initiate the Interrupt Since the INT signal was asserted, the processor does not return to the first state of the FETCH phase of the next instruction cycle, but rather begins a sequence of actions to initiate the interrupt. The processor must do two things, (1) save the state",
    "594": "the control unit returning to the FETCH phase to start processing the next instruction. If INT is asserted, then the next state is the first state of Part II, handling the interrupt request. §.§ Part II: Handling the interrupt request Handling the interrupt request goes through three stages, as shown in Figure <ref>: 1. Initiate the interrupt (three lines numbered 1 in Figure <ref>. 2. Service the interrupt (four lines numbered 2 in Figure <ref>. 3. Return from the interrupt (one line numbered 3 in Figure <ref>. We will discuss each. §.§.§ Initiate the Interrupt Since the INT signal was asserted, the processor does not return to the first state of the FETCH phase of the next instruction cycle, but rather begins a sequence of actions to initiate the interrupt. The processor must do two things, (1) save the state of the interrupted program so it can pick up where it left off after the requirements of the interrupt have been completed, and (2) load the state of the higher priority interrupting program so it can start satisfying its request. Save the State of the Interrupted Program The state of a program is a snapshot of the contents of all the program's resources. It includes the contents of the memory locations that are part of the program and the contents of all the general purpose registers. It also includes the PC and PSR. Recall from Figure 9.1 in Section 9.1.1.4 that a program's PSR specifies the privilege level and priority level of that program. PSR[15] indicates whether the program is running in privileged (Supervisor) or unprivileged (User) mode. PSR[10:8] specifies the program's priority level (PL), from PL0 (lowest) to PL7 (highest). Also, PSR[2:0] is used to store the condition codes. PSR[2] is the N bit, PSR[1] is the Z bit, and PSR[0] is the P bit. The first step in initiating the interrupt is to save enough of the state of the program that is running so it can continue where it left off after the I/O device request has",
    "595": "the program's resources. It includes the contents of the memory locations that are part of the program and the contents of all the general purpose registers. It also includes the PC and PSR. Recall from Figure 9.1 in Section 9.1.1.4 that a program's PSR specifies the privilege level and priority level of that program. PSR[15] indicates whether the program is running in privileged (Supervisor) or unprivileged (User) mode. PSR[10:8] specifies the program's priority level (PL), from PL0 (lowest) to PL7 (highest). Also, PSR[2:0] is used to store the condition codes. PSR[2] is the N bit, PSR[1] is the Z bit, and PSR[0] is the P bit. The first step in initiating the interrupt is to save enough of the state of the program that is running so it can continue where it left off after the I/O device request has been satisfied. That means, in the case of the LC-3, saving the PC and the PSR. The PC must be saved since it knows which instruction should be executed next when the interrupted program resumes execution. The condition codes (the N, Z, and P flags) must be saved since they may be needed by a subsequent conditional branch instruction after the program resumes execution. The priority level of the interrupted program must be saved because it specifies the urgency of the interrupted program with respect to all other programs. When the interrupted program resumes execution, it is important to know what priority level programs can interrupt it and which ones can not. Finally, the privilege level of the program must be saved since it specifies what processor resources the interrupted program can and can not access. Although many computers save the contents of the general purpose registers, we will not since we will assume that the service routine will always save the contents of any general purpose register that it needs before using it, and then restore it before returning to the interrupted program. The only state information the LC-3 saves are the PC and PSR. The LC-3 saves this",
    "596": "the program resumes execution. The priority level of the interrupted program must be saved because it specifies the urgency of the interrupted program with respect to all other programs. When the interrupted program resumes execution, it is important to know what priority level programs can interrupt it and which ones can not. Finally, the privilege level of the program must be saved since it specifies what processor resources the interrupted program can and can not access. Although many computers save the contents of the general purpose registers, we will not since we will assume that the service routine will always save the contents of any general purpose register that it needs before using it, and then restore it before returning to the interrupted program. The only state information the LC-3 saves are the PC and PSR. The LC-3 saves this state information on the Supervisor Stack in the same way the PC and PSR are saved when a TRAP instruction is executed. That is, before the interrupt service routine starts, if the interrupted program is in User mode, the User Stack Pointer (USP) is stored in Saved_USP, and R6 is loaded with the Supervisor Stack Pointer (SSP) from Saved_SSP. Then the PSR and PC of the interrupted program are pushed onto the Supervisor Stack, where they remain unmolested while the service routine executes. Load the State of the Interrupt Service Routine Once the state of the interrupted program has been safely saved on the Supervisor Stack, the second step is to load the PC and PSR of the interrupt service routine. Interrupt service routines are similar to the trap service routines we have already discussed. They are program fragments stored in System Space. They service interrupt requests. Most processors use the mechanism of vectored interrupts. You are familiar with this notion from your study of the trap vector contained in the TRAP instruction. In the case of interrupts, the 8-bit vector is provided by the device that is requesting the processor be interrupted. That is, the I/O device transmits to",
    "597": "the PSR and PC of the interrupted program are pushed onto the Supervisor Stack, where they remain unmolested while the service routine executes. Load the State of the Interrupt Service Routine Once the state of the interrupted program has been safely saved on the Supervisor Stack, the second step is to load the PC and PSR of the interrupt service routine. Interrupt service routines are similar to the trap service routines we have already discussed. They are program fragments stored in System Space. They service interrupt requests. Most processors use the mechanism of vectored interrupts. You are familiar with this notion from your study of the trap vector contained in the TRAP instruction. In the case of interrupts, the 8-bit vector is provided by the device that is requesting the processor be interrupted. That is, the I/O device transmits to the processor an 8-bit interrupt vector along with its interrupt request signal and its priority level. The interrupt vector corresponding to the highest priority interrupt request is the one supplied to the processor. It is designated INTV. If the interrupt is taken, the processor expands the 8-bit interrupt vector (INTV) to form a 16-bit address, which is an entry into the Interrupt Vector Table. You know that the Trap Vector Table consists of memory locations x0000 to x00FF, each containing the starting address of a trap service routine. The Interrupt Vector Table consists of memory locations x0100 to x01FF, each containing the starting address of an interrupt service routine. The processor loads the PC with the contents of the location in the Interrupt Vector Table corresponding to the address formed by expanding the interrupt vector INTV. For example, the LC-3 keyboard could interrupt the processor every time a key is pressed by someone sitting at the keyboard. The keyboard interrupt vector would indicate the location in the interrupt vector table that contains the starting address of the keyboard interupt service routine. The PSR is loaded as follows: Since no instructions in the service routine have yet executed, PSR[2:0] contains no",
    "598": "the Interrupt Vector Table. You know that the Trap Vector Table consists of memory locations x0000 to x00FF, each containing the starting address of a trap service routine. The Interrupt Vector Table consists of memory locations x0100 to x01FF, each containing the starting address of an interrupt service routine. The processor loads the PC with the contents of the location in the Interrupt Vector Table corresponding to the address formed by expanding the interrupt vector INTV. For example, the LC-3 keyboard could interrupt the processor every time a key is pressed by someone sitting at the keyboard. The keyboard interrupt vector would indicate the location in the interrupt vector table that contains the starting address of the keyboard interupt service routine. The PSR is loaded as follows: Since no instructions in the service routine have yet executed, PSR[2:0] contains no meaningful information. We arbitratily initially load it with 010. Since the interrupt service routine runs in privileged mode, PSR[15] is set to 0. PSR[10:8] is set to the priority level associated with the interrupt request. This completes the initiation phase and the interrupt service routine is ready to execute. §.§.§ Service the Interrupt Since the PC contains the starting address of the interrupt service routine, the service routine will execute, and the requirements of the I/O device will be serviced. §.§.§ Return from the Interrupt The last instruction in every interrupt service routine is RTI, return from trap or interrupt. When the processor finally accesses the RTI instruction, all the requirements of the I/O device have been taken care of. Like the return from a trap routine discussed in Section 9.3.4, execution of the RTI instruction (opcode = 1000) for an interrupt service routine consists simply of popping the PC and the PSR from the Supervisor Stack (where they have been resting peacefully) and restoring them to their rightful places in the processor. The condition codes are now restored to what they were when the program was interrupted, in case they are needed by a subsequent BR instruction in the",
    "599": "of the interrupt service routine, the service routine will execute, and the requirements of the I/O device will be serviced. §.§.§ Return from the Interrupt The last instruction in every interrupt service routine is RTI, return from trap or interrupt. When the processor finally accesses the RTI instruction, all the requirements of the I/O device have been taken care of. Like the return from a trap routine discussed in Section 9.3.4, execution of the RTI instruction (opcode = 1000) for an interrupt service routine consists simply of popping the PC and the PSR from the Supervisor Stack (where they have been resting peacefully) and restoring them to their rightful places in the processor. The condition codes are now restored to what they were when the program was interrupted, in case they are needed by a subsequent BR instruction in the interrupted program. PSR[15] and PSR[10:8] now reflect the privilege level and priority level of the about-to-be-resumed program. If the privilege level of the interrupted program is unprivileged, the stack pointers must be adjusted, i.e., the Supervisor Stack Pointer saved, and the User Stack Pointer loaded into R6. The PC is restored to the address of the instruction that would have been executed next if the program had not been interrupted. With all these things as they were before the interrupt occurred, the program can resume as if nothing had happened. §.§ An Example We complete the discussion of interrupt-driven I/O with an example. Suppose program A is executing when I/O device B, having a PL higher than that of A, requests service. During the execution of the service routine for I/O device B, a still more urgent device C requests service. Figure <ref> shows the execution flow that must take place. < g r a p h i c s > Execution flow for interrupt-driven I/O Program A consists of instructions in locations x3000 to x3010 and was in the middle of executing the ADD instruction at x3006, when device B sent its interrupt request signal and accompanying interrupt vector",
    "600": "been executed next if the program had not been interrupted. With all these things as they were before the interrupt occurred, the program can resume as if nothing had happened. §.§ An Example We complete the discussion of interrupt-driven I/O with an example. Suppose program A is executing when I/O device B, having a PL higher than that of A, requests service. During the execution of the service routine for I/O device B, a still more urgent device C requests service. Figure <ref> shows the execution flow that must take place. < g r a p h i c s > Execution flow for interrupt-driven I/O Program A consists of instructions in locations x3000 to x3010 and was in the middle of executing the ADD instruction at x3006, when device B sent its interrupt request signal and accompanying interrupt vector xF1, causing INT to be asserted. Note that the interrupt service routine for device B is stored in locations x6200 to x6210; x6210 contains the RTI instruction. Note that the service routine for B was in the middle of executing the AND instruction at x6202, when device C sent its interrupt request signal and accompanying interrupt vector xF2. Since the request associated with device C is of a higher priority than that of device B, INT is again asserted. Note that the interrupt service routine for device C is stored in locations x6300 to x6315; x6315 contains the RTI instruction. Let us examine the order of execution by the processor. Figure <ref> shows several snapshots of the contents of the Supervisor Stack and the PC during the execution of this example. < g r a p h i c s > Snapshots of the contents of the Supervisor Stack and the PC during interrupt-driven I/O The processor executes as follows: Figure <ref>a shows the Supervisor Stack and the PC before program A fetches the instruction at x3006. Note that the stack pointer is shown as Saved_SSP, not R6. Since the interrupt has not yet occurred, R6 is pointing to the",
    "601": "request associated with device C is of a higher priority than that of device B, INT is again asserted. Note that the interrupt service routine for device C is stored in locations x6300 to x6315; x6315 contains the RTI instruction. Let us examine the order of execution by the processor. Figure <ref> shows several snapshots of the contents of the Supervisor Stack and the PC during the execution of this example. < g r a p h i c s > Snapshots of the contents of the Supervisor Stack and the PC during interrupt-driven I/O The processor executes as follows: Figure <ref>a shows the Supervisor Stack and the PC before program A fetches the instruction at x3006. Note that the stack pointer is shown as Saved_SSP, not R6. Since the interrupt has not yet occurred, R6 is pointing to the current contents of the User Stack, which are not shown! The INT signal (caused by an interrupt from device B) is detected at the end of execution of the instruction in x3006. Since the state of program A must be saved on the Supervisor Stack, the first step is to start using the Supervisor Stack. This is done by saving R6 in the Saved.UPC register, and loading R6 with the contents of the Saved_SSP register. The PSR of program A, which includes the condition codes produced by the ADD instruction, is pushed on the Supervisor Stack. Then the address x3007, the PC for the next instruction to be executed in program A is pushed on the stack. The interrupt vector associated with device B is expanded to 16 bits x01F1, and the contents of x01F1 (x6200) is loaded into the PC. Figure <ref>b shows the stack and PC at this point. The service routine for device B executes until a higher priority interupt is detected at the end of execution of the instruction at x6202. The PSR of the service routine for B, which includes the condition codes produced by the AND instruction at x6202, and the address x6203 are",
    "602": "R6 in the Saved.UPC register, and loading R6 with the contents of the Saved_SSP register. The PSR of program A, which includes the condition codes produced by the ADD instruction, is pushed on the Supervisor Stack. Then the address x3007, the PC for the next instruction to be executed in program A is pushed on the stack. The interrupt vector associated with device B is expanded to 16 bits x01F1, and the contents of x01F1 (x6200) is loaded into the PC. Figure <ref>b shows the stack and PC at this point. The service routine for device B executes until a higher priority interupt is detected at the end of execution of the instruction at x6202. The PSR of the service routine for B, which includes the condition codes produced by the AND instruction at x6202, and the address x6203 are pushed on the stack. The interrupt vector associated with device C is expanded to 16 bits (x01F2), and the contents of x01F2 (x6300) are loaded into the PC. Figure <ref>c shows the Supervisor Stack and PC at this point. Assume the interrupt service routine for device C executes to completion, finishing with the RTI instruction in x6315. The Supervisor Stack is popped twice, restoring the PC to x6203 and the PSR of the service routine for device B, including the condition codes produced by the AND instruction in x6202. Figure <ref>d shows the stack and PC at this point. The interrupt service routine for device B resumes execution at x6203 and runs to completion, finishing with the RTI instruction in x6210. The Supervisor Stack is popped twice, restoring the PC to x3007 and the PSR of program A, including the condition codes produced by the ADD instruction in x3006. Finally, since program A is in User Mode, the contents of R6 are stored in Saved_SSP and R6 is loaded with the contents of Saved_USP. Figure <ref>e shows the Supervisor Stack and PC at this point. Program A resumes execution with the instruction at x3007. §.§ Not just I/O devices We",
    "603": "is popped twice, restoring the PC to x6203 and the PSR of the service routine for device B, including the condition codes produced by the AND instruction in x6202. Figure <ref>d shows the stack and PC at this point. The interrupt service routine for device B resumes execution at x6203 and runs to completion, finishing with the RTI instruction in x6210. The Supervisor Stack is popped twice, restoring the PC to x3007 and the PSR of program A, including the condition codes produced by the ADD instruction in x3006. Finally, since program A is in User Mode, the contents of R6 are stored in Saved_SSP and R6 is loaded with the contents of Saved_USP. Figure <ref>e shows the Supervisor Stack and PC at this point. Program A resumes execution with the instruction at x3007. §.§ Not just I/O devices We have discussed the processing of interrupts in the context of I/O devices that have higher priority than the program that is running and therefore can stop that program to enable its interrupt service routine to execute. We must point out that not all interrupts deal with I/O devices. Any event that has a higher priority and is external to the program that is running can interrupt the computer. It does so by supplying its INT signal, its INTV vector and its priority level. If it is the highest priority event that wishes to interrupt the computer, it does so in the same way that I/O devices do as described above. There are many examples of such events that have nothing to do with I/O devices. For example, a timer interrupt interrupts the program that is running in order to note the passage of a unit of time. The machine check interrupt calls attention to the fact that some part of the computer system is not functioning properly. The power failure interrupt notifies the computer that for example someone has yanked the power cord out of its receptacle. Unfortunately, we will have to put off dealing with all of these until",
    "604": "program that is running can interrupt the computer. It does so by supplying its INT signal, its INTV vector and its priority level. If it is the highest priority event that wishes to interrupt the computer, it does so in the same way that I/O devices do as described above. There are many examples of such events that have nothing to do with I/O devices. For example, a timer interrupt interrupts the program that is running in order to note the passage of a unit of time. The machine check interrupt calls attention to the fact that some part of the computer system is not functioning properly. The power failure interrupt notifies the computer that for example someone has yanked the power cord out of its receptacle. Unfortunately, we will have to put off dealing with all of these until later in your coursework. § POLLING REVISTED, NOW THAT WE KNOW ABOUT INTERRUPTS §.§ The problem Recall our discussion of polling: We continually test the Ready bit in the relevant status register, and if it is not set, we branch back to again test the Ready bit. For example, suppose we are writing a character string to the monitor, and we are using polling to determine when the monitor has successfully written the current characer so we can dispatch the next character. We take it for granted that the three instruction sequence LDI (to load the ready bit of the DSR), BRzp (to test it and fall through if the device is ready), and STI (to store the next character in the DDR) acts as an atomic unit. But what if we interrupts enabled at the same time. That is, if an interrupt occurred within that LDI, BRzp, STI sequence (say, just before the STI instruction), it could easily be the case that the LDI instruction indicated the DDR was ready, the BRzp instruction did not branch back, but by the time the interrupt service routine completed so the STI could write to the DDR, the DDR may no longer",
    "605": "we are using polling to determine when the monitor has successfully written the current characer so we can dispatch the next character. We take it for granted that the three instruction sequence LDI (to load the ready bit of the DSR), BRzp (to test it and fall through if the device is ready), and STI (to store the next character in the DDR) acts as an atomic unit. But what if we interrupts enabled at the same time. That is, if an interrupt occurred within that LDI, BRzp, STI sequence (say, just before the STI instruction), it could easily be the case that the LDI instruction indicated the DDR was ready, the BRzp instruction did not branch back, but by the time the interrupt service routine completed so the STI could write to the DDR, the DDR may no longer be ready. The computer would execute the STI but the write would not happen. A simple, but somewhat contrived example :-), will illustrate the problem. Suppose you are executing a \"for\" loop ten times, where each time the loop body prints to the monitor a particualr character. Polling is used to determine that the monitor is ready before writing the next character to the DDR. Since the loop body executes ten times, this should result in the character printed on the monitor ten times. Suppose you also have keyboard interrupts enabled, and the keyboard service routine echoes the character typed. Suppose the loop body executes as follows: LDI loads the ready bit, BRzp falls through since the monitor is ready, and STI stores the character in DDR. In the middle of this sequence, before the STI can execute, someone types a key. The keyboard interrupt occurs, the character typed is echoed, i.e., written to the DDR, and the keyboard interrupt service routine completes. The interrupted loop body then takes over and \"knows\" the monitor is ready so it executes the STI. ...except the monitor is not ready because it has not completed the write of the keyboard service routine! The",
    "606": "next character to the DDR. Since the loop body executes ten times, this should result in the character printed on the monitor ten times. Suppose you also have keyboard interrupts enabled, and the keyboard service routine echoes the character typed. Suppose the loop body executes as follows: LDI loads the ready bit, BRzp falls through since the monitor is ready, and STI stores the character in DDR. In the middle of this sequence, before the STI can execute, someone types a key. The keyboard interrupt occurs, the character typed is echoed, i.e., written to the DDR, and the keyboard interrupt service routine completes. The interrupted loop body then takes over and \"knows\" the monitor is ready so it executes the STI. ...except the monitor is not ready because it has not completed the write of the keyboard service routine! The STI of the loop body writes but since DDR is not ready, the write does not occur. The final result: only nine characers get written, not ten. The problem becomes more serious if the string written is in code, and the missing write prevents the code from being decyphered. A simple way to handle this would be to disable all interrupts while polling was going on. But consider the consequences. Suppose the polling was required for a long time. If we disable interrupts while polling is going on, interrupts would be disabled for that very long time, unacceptable in an environment where one is concerned about the time between a higher priority interrupt occurring and it getting service. §.§ The solution A better solution is shown in Figure <ref>. The sequence we want to make non-interruptable is shown on lines 0F to 11. We accomplish this by first loading R1 with the PSR in line 09 and R2 with the PSR having interrupts disabled in line 0A. PSR[14] is the interrupt enable bit for all interrupts associated with this program. Note that PSR is memory mapped to xFFFC. We enable interupts by storing R1 in PSR (line 0D), followed immediately",
    "607": "interrupts while polling was going on. But consider the consequences. Suppose the polling was required for a long time. If we disable interrupts while polling is going on, interrupts would be disabled for that very long time, unacceptable in an environment where one is concerned about the time between a higher priority interrupt occurring and it getting service. §.§ The solution A better solution is shown in Figure <ref>. The sequence we want to make non-interruptable is shown on lines 0F to 11. We accomplish this by first loading R1 with the PSR in line 09 and R2 with the PSR having interrupts disabled in line 0A. PSR[14] is the interrupt enable bit for all interrupts associated with this program. Note that PSR is memory mapped to xFFFC. We enable interupts by storing R1 in PSR (line 0D), followed immediately by disabling interrupts by storing R2 in PSR (line 0E). With interrupts disabled we execute the three instruction sequence LDI, BRzp, and LDI (lines 0F, 10, and 11) if the status register indicates that the device is ready. If the device is not ready, BRzp (line 10) takes the computer back to line 0D where interrupts are again enabled. In this way, interrupts are disabled again and again, but each time only long enough to execute the three instruction sequence LDI, BRzp, STI (in lines 0F, 10, 0D), afterwhich interrupts are enabled again. The result: an interrupt would have to wait for the three instruction sequence LDI, BRzp, STI to execute, rather than for the entire polling process to complete. [fontsize=911] 01 .ORIG x0420 02 ADD R6,R6,#-1 03 STR R1,R6,#0 04 ADD R6,R6,#-1 05 STR R2,R6,#0 06 ADD R6,R6,#-1 07 STR R3,R6,#0 ; Save R1,R2,R3 on the stack 08 ; 09 LDI R1, PSR 0A LD R2,INTMASK 0B AND R2,R1,R2 ; R1=original PSR, R2=PSR with interrupts disabled 0C 0D POLL STI R1,PSR ; enable interrupts (if they were enabled to begin 0E STI R2,PSR ; disable interrupts 0F LDI R3,DSR 10 BRzp POLL ; Poll the DSR 11 STI R0,DDR",
    "608": "this way, interrupts are disabled again and again, but each time only long enough to execute the three instruction sequence LDI, BRzp, STI (in lines 0F, 10, 0D), afterwhich interrupts are enabled again. The result: an interrupt would have to wait for the three instruction sequence LDI, BRzp, STI to execute, rather than for the entire polling process to complete. [fontsize=911] 01 .ORIG x0420 02 ADD R6,R6,#-1 03 STR R1,R6,#0 04 ADD R6,R6,#-1 05 STR R2,R6,#0 06 ADD R6,R6,#-1 07 STR R3,R6,#0 ; Save R1,R2,R3 on the stack 08 ; 09 LDI R1, PSR 0A LD R2,INTMASK 0B AND R2,R1,R2 ; R1=original PSR, R2=PSR with interrupts disabled 0C 0D POLL STI R1,PSR ; enable interrupts (if they were enabled to begin 0E STI R2,PSR ; disable interrupts 0F LDI R3,DSR 10 BRzp POLL ; Poll the DSR 11 STI R0,DDR ; Store the character into the DDR 12 STI R1,PSR ; Restore original PSR 13 14 LDR R3,R6,#0 15 ADD R6,R6,#1 16 LDR R2,R6,#0 17 ADD R6,R6,#1 18 LDR R1,R6,#0 19 ADD R6,R6,#1 ; Restore R3,R2,and R1 from the stack 1A 1B RTI 1C 1D INTMASK .FILL xBFFF 1E PSR .FILL xFFFC 1F DSR .FILL xFE04 20 DDR .FILL xFE06 21 22 .END Polling AND allowing interrupts 9.1 a. What is a device register? b. What is a device data register? c. What is a device status register? 9.2 Why is a Ready bit not needed if synchronous I/O is used? 9.3 In Section 9.2.1.3, the statement is made that a typist would have trouble supplying keyboard input to a 300-MHz processor at the maximum rate (one character every 33 nanoseconds) that the processor can accept it. Assume an average word (including spaces between words) consists of six characters. How many words/minute would the typist have to type in order to exceed the processor's ability to handle the input? 9.4 Are the following interactions usually synchronous or asynchronous? a. Between a remote control and a television set b. Between the mailcarrier and you, via a mailbox c. Between a mouse",
    "609": "21 22 .END Polling AND allowing interrupts 9.1 a. What is a device register? b. What is a device data register? c. What is a device status register? 9.2 Why is a Ready bit not needed if synchronous I/O is used? 9.3 In Section 9.2.1.3, the statement is made that a typist would have trouble supplying keyboard input to a 300-MHz processor at the maximum rate (one character every 33 nanoseconds) that the processor can accept it. Assume an average word (including spaces between words) consists of six characters. How many words/minute would the typist have to type in order to exceed the processor's ability to handle the input? 9.4 Are the following interactions usually synchronous or asynchronous? a. Between a remote control and a television set b. Between the mailcarrier and you, via a mailbox c. Between a mouse and your PC Under what conditions would each of them be synchronous? Under what conditions would each of them be asynchronous? 9.5 What is the purpose of bit [15] in the KBSR? 9.6 What problem could occur if a program does not check the Ready bit of the KBSR before reading the KBDR? 9.7 Which of the following combinations describe the system described in Section 9.2.2.2? a. Memory mapped and interrupt driven b. Memory mapped and polling c. Special opcode for I/O and interrupt driven d. Special opcode for I/O and polling 9.8 Write a program that checks the initial value in memory location x4000 to see if it is a valid ASCII code and if it is a valid ASCII code, prints the character. If the value in x4000 is not a valid ASCII code, the program prints nothing. 9.9 What problem is likely to occur if the keyboard hardware does not check the KBSR before writing to the KBDR? 9.10 What problem could occur if the display hardware does not check the DSR before writing to the DDR? 9.11 Which is more efficient, interrupt-driven I/O or polling? Explain. 9.12 Adam H. decided to design a variant of the",
    "610": "the system described in Section 9.2.2.2? a. Memory mapped and interrupt driven b. Memory mapped and polling c. Special opcode for I/O and interrupt driven d. Special opcode for I/O and polling 9.8 Write a program that checks the initial value in memory location x4000 to see if it is a valid ASCII code and if it is a valid ASCII code, prints the character. If the value in x4000 is not a valid ASCII code, the program prints nothing. 9.9 What problem is likely to occur if the keyboard hardware does not check the KBSR before writing to the KBDR? 9.10 What problem could occur if the display hardware does not check the DSR before writing to the DDR? 9.11 Which is more efficient, interrupt-driven I/O or polling? Explain. 9.12 Adam H. decided to design a variant of the LC-3 that did not need a keyboard status register. Instead, he created a readable/writable keyboard data and status register (KBDSR), which contains the same data as the KBDR. With the KBDSR, a program requiring keyboard input would wait until a nonzero value appeared in the KBDSR. The nonzero value would be the ASCII value of the last key press. Then the program would write a zero into the KBDSR indicating that it had read the key press. Modify the basic input service of Section 8.2.2 to implement Adam's scheme. 9.13 Some computer engineering students decided to revise the LC-3 for their senior project. In designing the LC-4, they decided to conserve on device registers by combining the KBSR and the DSR into one status register: the IOSR (the input/output status register). IOSR[15] is the keyboard device Ready bit and IOSR[14] is the display device Ready bit. What are the implications for programs wishing to do I/O? Is this a poor design decision? 9.14 An LC-3 Load instruction specifies the address xFE02. How do we know whether to load from the KBDR or from memory location xFE02? 9.15 Name some of the advantages of doing I/O through a TRAP routine instead",
    "611": "the program would write a zero into the KBDSR indicating that it had read the key press. Modify the basic input service of Section 8.2.2 to implement Adam's scheme. 9.13 Some computer engineering students decided to revise the LC-3 for their senior project. In designing the LC-4, they decided to conserve on device registers by combining the KBSR and the DSR into one status register: the IOSR (the input/output status register). IOSR[15] is the keyboard device Ready bit and IOSR[14] is the display device Ready bit. What are the implications for programs wishing to do I/O? Is this a poor design decision? 9.14 An LC-3 Load instruction specifies the address xFE02. How do we know whether to load from the KBDR or from memory location xFE02? 9.15 Name some of the advantages of doing I/O through a TRAP routine instead of writing the routine yourself each time you would like your program to perform I/O. 9.16 a. How many trap service routines can be implemented in the LC-3? Why? b. Why must a RET instruction be used to return from a TRAP routine? Why won't a BR (Unconditional Branch) instruction work instead? c. How many accesses to memory are made during the processing of a TRAP instruction? Assume the TRAP is already in the IR. 9.17 Refer to Figure <ref>, the HALT service routine. a. What starts the clock after the machine is HALTed? Hint: How can the HALT service routine return after bit [15] of the machine control register is cleared? b. Which instruction actually halts the machine? c. What is the first instruction executed when the machine is started again? d. Where will the RET of the HALT routine return to? 9.18 Consider the following LC-3 assembly language program: .ORIG x3000 L1 LEA R1, L1 AND R2, R2, x0 ADD R2, R2, x2 LD R3, P1 L2 LDR R0, R1, xC OUT ADD R3, R3, #-1 BRz GLUE ADD R1, R1, R2 BR L2 GLUE HALT P1 .FILL xB .STRINGZ \"HBoeoakteSmtHaotren!s\" .END a. After this program is assembled",
    "612": "during the processing of a TRAP instruction? Assume the TRAP is already in the IR. 9.17 Refer to Figure <ref>, the HALT service routine. a. What starts the clock after the machine is HALTed? Hint: How can the HALT service routine return after bit [15] of the machine control register is cleared? b. Which instruction actually halts the machine? c. What is the first instruction executed when the machine is started again? d. Where will the RET of the HALT routine return to? 9.18 Consider the following LC-3 assembly language program: .ORIG x3000 L1 LEA R1, L1 AND R2, R2, x0 ADD R2, R2, x2 LD R3, P1 L2 LDR R0, R1, xC OUT ADD R3, R3, #-1 BRz GLUE ADD R1, R1, R2 BR L2 GLUE HALT P1 .FILL xB .STRINGZ \"HBoeoakteSmtHaotren!s\" .END a. After this program is assembled and loaded, what binary pattern is stored in memory location x3005? b. Which instruction (provide a memory address) is executed after instruction x3005 is executed? c. Which instruction (provide a memory address) is executed prior to instruction x3006? d. What is the output of this program? 9.19 The following LC-3 program is assembled and then executed. There are no assemble time or run-time errors. What is the output of this program? Assume all registers are initialized to 0 before the program executes. .ORIG x3000 LEA R0, LABEL STR R1, R0, #3 TRAP x22 TRAP x25 LABEL .STRINGZ \"FUNKY\" LABEL2 .STRINGZ \"HELLO WORLD\" .END 9.6 The correct operation of the program in Example 9.1 assumes that the person sitting at the keyboard only types capital letters and the value 7. What if the person types a $? A better program would be one that tests the character typed to be sure it really is a capital letter from among the 26 capital letters in the alphabet, and if it is not, takes corrective action. Your job: Augment the program of Example 9.1 to add a test for bad data. That is, write a program that will type the lowercase representation of",
    "613": "time or run-time errors. What is the output of this program? Assume all registers are initialized to 0 before the program executes. .ORIG x3000 LEA R0, LABEL STR R1, R0, #3 TRAP x22 TRAP x25 LABEL .STRINGZ \"FUNKY\" LABEL2 .STRINGZ \"HELLO WORLD\" .END 9.6 The correct operation of the program in Example 9.1 assumes that the person sitting at the keyboard only types capital letters and the value 7. What if the person types a $? A better program would be one that tests the character typed to be sure it really is a capital letter from among the 26 capital letters in the alphabet, and if it is not, takes corrective action. Your job: Augment the program of Example 9.1 to add a test for bad data. That is, write a program that will type the lowercase representation of any capital letter typed and will terminate if anything other than a capital letter is typed. 9.19 Assume that an integer greater than 2 and less than 32,768 is deposited in memory location A by another module before the program below is executed. .ORIG x3000 AND R4, R4, #0 LD R0, A NOT R5, R0 ADD R5, R5, #2 ADD R1, R4, #2 ; REMOD JSR MOD BRz STORE0 ; ADD R7, R1, R5 BRz STORE1 ADD R1, R1, #1 BR REMOD ; STORE1 ADD R4, R4, #1 STORE0 ST R4, RESULT TRAP x25 ; MOD ADD R2, R0, #0 NOT R3, R1 ADD R3, R3, #1 DEC ADD R2, R2, R3 BRp DEC RET ; A .BLKW 1 RESULT .BLKW 1 .END In 20 words or fewer, what does the above program do? 9.20 Recall the machine busy example. Suppose the bit pattern indicating which machines are busy and which are free is stored in memory location x4001. Write subroutines that do the following. a. Check if no machines are busy, and return 1 if none are busy. b. Check if all machines are busy, and return 1 if all are busy. c. Check how many machines are busy,",
    "614": "R1, R4, #2 ; REMOD JSR MOD BRz STORE0 ; ADD R7, R1, R5 BRz STORE1 ADD R1, R1, #1 BR REMOD ; STORE1 ADD R4, R4, #1 STORE0 ST R4, RESULT TRAP x25 ; MOD ADD R2, R0, #0 NOT R3, R1 ADD R3, R3, #1 DEC ADD R2, R2, R3 BRp DEC RET ; A .BLKW 1 RESULT .BLKW 1 .END In 20 words or fewer, what does the above program do? 9.20 Recall the machine busy example. Suppose the bit pattern indicating which machines are busy and which are free is stored in memory location x4001. Write subroutines that do the following. a. Check if no machines are busy, and return 1 if none are busy. b. Check if all machines are busy, and return 1 if all are busy. c. Check how many machines are busy, and return the number of busy machines. d. Check how many machines are free, and return the number of free machines. e. Check if a certain machine number, passed as an argument in R5, is busy, and return 1 if that machine is busy. f. Return the number of a machine that is not busy. 9.21 The starting address of the trap routine is stored at the address specified in the TRAP instruction. Why isn't the first instruction of the trap routine stored at that address instead? Assume each trap service routine requires at most 16 instructions. Modify the semantics of the LC-3 TRAP instruction so that the trap vector provides the starting address of the service routine. 9.22 Following is part of a program that was fed to the LC-3 assembler. The program is supposed to read a series of input lines from the console into a buffer, search for a particular character, and output the number of times that character occurs in the text. The input text is terminated by an EOT and is guaranteed to be no more than 1,000 characters in length. After the text has been input, the program reads the character to count. The",
    "615": "the trap routine is stored at the address specified in the TRAP instruction. Why isn't the first instruction of the trap routine stored at that address instead? Assume each trap service routine requires at most 16 instructions. Modify the semantics of the LC-3 TRAP instruction so that the trap vector provides the starting address of the service routine. 9.22 Following is part of a program that was fed to the LC-3 assembler. The program is supposed to read a series of input lines from the console into a buffer, search for a particular character, and output the number of times that character occurs in the text. The input text is terminated by an EOT and is guaranteed to be no more than 1,000 characters in length. After the text has been input, the program reads the character to count. The subroutine labeled COUNT that actually does the counting was written by another person and is located at address x3500. When called, the subroutine expects the address of the buffer to be in R5 and the address of the character to count to be in R6. The buffer should have a NULL to mark the end of the text. It returns the count in R6. The OUTPUT subroutine that converts the binary count to ASCII digits and displays them was also written by another person and is at address x3600. It expects the number to print to be in R6. Here is the code that reads the input and calls COUNT: .ORIG x3000 LEA R1, BUFFER G_TEXT TRAP x20 ; Get input text ADD R2, R0, x-4 BRz G_CHAR STR R0, R1, #0 ADD R1, R1, #1 BRnzp G_TEXT G_CHAR STR R2, R1, #0 ; x0000 terminates buffer TRAP x20 ; Get character to count ST R0, S_CHAR LEA R5, BUFFER LEA R6, S_CHAR LD R4, CADDR JSRR R4 ; Count character LD R4, OADDR JSRR R4 ; Convert R6 and display TRAP x25 CADDR .FILL x3500 ; Address of COUNT OADDR .FILL x3600 ; Address of OUTPUT BUFFER .BLKW 1001",
    "616": "the count in R6. The OUTPUT subroutine that converts the binary count to ASCII digits and displays them was also written by another person and is at address x3600. It expects the number to print to be in R6. Here is the code that reads the input and calls COUNT: .ORIG x3000 LEA R1, BUFFER G_TEXT TRAP x20 ; Get input text ADD R2, R0, x-4 BRz G_CHAR STR R0, R1, #0 ADD R1, R1, #1 BRnzp G_TEXT G_CHAR STR R2, R1, #0 ; x0000 terminates buffer TRAP x20 ; Get character to count ST R0, S_CHAR LEA R5, BUFFER LEA R6, S_CHAR LD R4, CADDR JSRR R4 ; Count character LD R4, OADDR JSRR R4 ; Convert R6 and display TRAP x25 CADDR .FILL x3500 ; Address of COUNT OADDR .FILL x3600 ; Address of OUTPUT BUFFER .BLKW 1001 S_CHAR .FILL x0000 .END There is a problem with this code. What is it, and how might it be fixed? (The problem is not that the code for and is missing.) 9.23 Consider the following LC-3 assembly language program: .ORIG x3000 LEA R0,DATA AND R1,R1,#0 ADD R1,R1,#9 LOOP1 ADD R2,R0,#0 ADD R3,R1,#0 LOOP2 JSR SUB1 ADD R4,R4,#0 BRzp LABEL JSR SUB2 LABEL ADD R2,R2,#1 ADD R3,R3,#-1 BRP LOOP2 ADD R1,R1,#-1 BRp LOOP1 HALT DATA .BLKW 10 x0000 SUB1 LDR R5,R2,#0 NOT R5,R5 ADD R5,R5,#1 LDR R6,R2,#1 ADD R4,R5,R6 RET SUB2 LDR R4,R2,#0 LDR R5,R2,#1 STR R4,R2,#1 STR R5,R2,#0 RET .END Assuming that the memory locations at DATA get filled in before the program executes, what is the relationship between the final values at DATA and the initial values at DATA? 9.24 The following program is supposed to print the number 5 on the screen. It does not work. Why? Answer in no more than ten words, please. .ORIG x3000 JSR A OUT BRnzp DONE A AND R0,R0,#0 ADD R0,R0,#5 JSR B RET DONE HALT ASCII .FILL x0030 B LD R1,ASCII ADD R0,R0,R1 RET .END 9.25 Figure <ref> shows a service routine to stop the computer by clearing the RUN latch,",
    "617": "SUB2 LABEL ADD R2,R2,#1 ADD R3,R3,#-1 BRP LOOP2 ADD R1,R1,#-1 BRp LOOP1 HALT DATA .BLKW 10 x0000 SUB1 LDR R5,R2,#0 NOT R5,R5 ADD R5,R5,#1 LDR R6,R2,#1 ADD R4,R5,R6 RET SUB2 LDR R4,R2,#0 LDR R5,R2,#1 STR R4,R2,#1 STR R5,R2,#0 RET .END Assuming that the memory locations at DATA get filled in before the program executes, what is the relationship between the final values at DATA and the initial values at DATA? 9.24 The following program is supposed to print the number 5 on the screen. It does not work. Why? Answer in no more than ten words, please. .ORIG x3000 JSR A OUT BRnzp DONE A AND R0,R0,#0 ADD R0,R0,#5 JSR B RET DONE HALT ASCII .FILL x0030 B LD R1,ASCII ADD R0,R0,R1 RET .END 9.25 Figure <ref> shows a service routine to stop the computer by clearing the RUN latch, bit [15] of the Machine Control Register. The latch is cleared by the instruction in line 14, and the computer stops. What purpose is served by the instructions on lines 19 through 1C? 9.26 Suppose we define a new service routine starting at memory location x4000. This routine reads in a character and echoes it to the screen. Suppose memory location x0072 contains the value x4000. The service routine is shown below. .ORIG x4000 ST R7, SaveR7 GETC OUT LD R7, SaveR7 RET SaveR7 .FILL x0000 a. Identify the instruction that will invoke this routine. b. Will this service routine work? Explain. 9.27 The two code sequences a and b are assembled separately. There are two errors that will be caught at assemble time or at link time. Identify the bugs and describe why the bug will cause an error, and whether it will be detected at assemble time or link time. a. .ORIG x3500 SQRT ADD R0, R0, #0 ; code to perform square ; root function and ; return the result in R0 RET .END b. .EXTERNAL SQRT .ORIG x3000 LD R0,VALUE JSR SQRT ST R0,DEST HALT VALUE .FILL x30000 DEST .FILL x0025 .END 9.28 Shown below is",
    "618": "location x0072 contains the value x4000. The service routine is shown below. .ORIG x4000 ST R7, SaveR7 GETC OUT LD R7, SaveR7 RET SaveR7 .FILL x0000 a. Identify the instruction that will invoke this routine. b. Will this service routine work? Explain. 9.27 The two code sequences a and b are assembled separately. There are two errors that will be caught at assemble time or at link time. Identify the bugs and describe why the bug will cause an error, and whether it will be detected at assemble time or link time. a. .ORIG x3500 SQRT ADD R0, R0, #0 ; code to perform square ; root function and ; return the result in R0 RET .END b. .EXTERNAL SQRT .ORIG x3000 LD R0,VALUE JSR SQRT ST R0,DEST HALT VALUE .FILL x30000 DEST .FILL x0025 .END 9.28 Shown below is a partially constructed program. The program asks the user his/her name and stores the sentence “Hello, name” as a string starting from the memory location indicated by the symbol HELLO. The program then outputs that sentence to the screen. The program assumes that the user has finished entering his/her name when he/she presses the Enter key, whose ASCII code is x0A. The name is restricted to be not more than 25 characters. Assuming that the user enters Onur followed by a carriage return when prompted to enter his/her name, the output of the program looks exactly like: Please enter your name: Onur Hello, Onur Insert instructions at (a)–(d) that will complete the program. .ORIG x3000 LEA R1,HELLO AGAIN LDR R2,R1,#0 BRz NEXT ADD R1,R1,#1 BR AGAIN NEXT LEA R0,PROMPT TRAP x22 ; PUTS ———— (a) AGAIN2 TRAP x20 ; GETC TRAP x21 ; OUT ADD R2,R0,R3 BRz CONT ———— (b) ———— (c) BR AGAIN2 CONT AND R2,R2,#0 ———— (d) LEA R0, HELLO TRAP x22 ; PUTS TRAP x25 ; HALT NEGENTER .FILL xFFF6 ; -x0A PROMPT .STRINGZ \"Please enter your name: \" HELLO .STRINGZ \"Hello, \" .BLKW #25 .END 9.29 The program below, when complete, should print the following to",
    "619": "x0A. The name is restricted to be not more than 25 characters. Assuming that the user enters Onur followed by a carriage return when prompted to enter his/her name, the output of the program looks exactly like: Please enter your name: Onur Hello, Onur Insert instructions at (a)–(d) that will complete the program. .ORIG x3000 LEA R1,HELLO AGAIN LDR R2,R1,#0 BRz NEXT ADD R1,R1,#1 BR AGAIN NEXT LEA R0,PROMPT TRAP x22 ; PUTS ———— (a) AGAIN2 TRAP x20 ; GETC TRAP x21 ; OUT ADD R2,R0,R3 BRz CONT ———— (b) ———— (c) BR AGAIN2 CONT AND R2,R2,#0 ———— (d) LEA R0, HELLO TRAP x22 ; PUTS TRAP x25 ; HALT NEGENTER .FILL xFFF6 ; -x0A PROMPT .STRINGZ \"Please enter your name: \" HELLO .STRINGZ \"Hello, \" .BLKW #25 .END 9.29 The program below, when complete, should print the following to the monitor: ABCFGH Insert instructions at (a)–(d) that will complete the program. .ORIG x3000 LEA R1, TESTOUT BACK_1 LDR R0, R1, #0 BRz NEXT_1 TRAP x21 ———— (a) BRnzp BACK_1 ; NEXT_1 LEA R1, TESTOUT BACK_2 LDR R0, R1, #0 BRz NEXT_2 JSR SUB_1 ADD R1, R1, #1 BRnzp BACK_2 ; NEXT_2 ———— (b) ; SUB_1 ———— (c) K LDI R2, DSR ———— (d) STI R0, DDR RET DSR .FILL xFE04 DDR .FILL xFE06 TESTOUT .STRINGZ \"ABC\" .END 9.30 A local company has decided to build a real LC-3 computer. In order to make the computer work in a network, four interrupt-driven I/O devices are connected. To request service, a device asserts its interrupt request signal (IRQ). This causes a bit to get set in a special LC-3 memory-mapped interrupt control register called INTCTL which is mapped to address xFF00. The INTCTL register is shown below. When a device requests service, the INT signal in the LC-3 data path is asserted. The LC-3 interrupt service routine determines which device has requested service and calls the appropriate subroutine for that device. If more than one device asserts its IRQ signal at the same time, only the subroutine for the highest priority",
    "620": "R2, DSR ———— (d) STI R0, DDR RET DSR .FILL xFE04 DDR .FILL xFE06 TESTOUT .STRINGZ \"ABC\" .END 9.30 A local company has decided to build a real LC-3 computer. In order to make the computer work in a network, four interrupt-driven I/O devices are connected. To request service, a device asserts its interrupt request signal (IRQ). This causes a bit to get set in a special LC-3 memory-mapped interrupt control register called INTCTL which is mapped to address xFF00. The INTCTL register is shown below. When a device requests service, the INT signal in the LC-3 data path is asserted. The LC-3 interrupt service routine determines which device has requested service and calls the appropriate subroutine for that device. If more than one device asserts its IRQ signal at the same time, only the subroutine for the highest priority device is executed. During execution of the subroutine, the corresponding bit in INTCTL is cleared. < g r a p h i c s > The following labels are used to identify the first instruction of each device subroutine: HARDDISK ETHERNET PRINTER CDROM For example, if the highest priority device requesting service is the printer, the interrupt service routine will call the printer subroutine with the following instruction: JSR PRINTER Finish the code in the LC-3 interrupt service routine for the following priority scheme by filling in the spaces labeled (a)–(k). The lower the number, the higher the priority of the device. 1. Hard disk 2. Ethernet card 3. Printer 4. CD-ROM [fontsize=910,formatcom=] LDI R1, INTCTL DEV0 LD R2, —— (a) AND R2, R2, R1 BRnz DEV1 JSR ———- (b) —————- (c) ; DEV1 LD R2, —— (d) AND R2, R2, R1 BRnz DEV2 JSR ———- (e) —————- (f) ; DEV2 LD R2, —— (g) AND R2, R2, R1 BRnz DEV3 JSR ———- (h) —————- (i) ; DEV3 JSR ———– (j) ; END —————- (k) INTCTL .FILL xFF00 MASK8 .FILL x0008 MASK4 .FILL x0004 MASK2 .FILL x0002 MASK1 .FILL x0001 9.31 Interrupt-driven I/O: a. What does the following LC-3 program",
    "621": "call the printer subroutine with the following instruction: JSR PRINTER Finish the code in the LC-3 interrupt service routine for the following priority scheme by filling in the spaces labeled (a)–(k). The lower the number, the higher the priority of the device. 1. Hard disk 2. Ethernet card 3. Printer 4. CD-ROM [fontsize=910,formatcom=] LDI R1, INTCTL DEV0 LD R2, —— (a) AND R2, R2, R1 BRnz DEV1 JSR ———- (b) —————- (c) ; DEV1 LD R2, —— (d) AND R2, R2, R1 BRnz DEV2 JSR ———- (e) —————- (f) ; DEV2 LD R2, —— (g) AND R2, R2, R1 BRnz DEV3 JSR ———- (h) —————- (i) ; DEV3 JSR ———– (j) ; END —————- (k) INTCTL .FILL xFF00 MASK8 .FILL x0008 MASK4 .FILL x0004 MASK2 .FILL x0002 MASK1 .FILL x0001 9.31 Interrupt-driven I/O: a. What does the following LC-3 program do? .ORIG x3000 LD R3, A STI R3, KBSR AGAIN LD R0, B TRAP x21 BRnzp AGAIN A .FILL x4000 B .FILL x0032 KBSR .FILL xFE00 .END b. If someone strikes a key, the program will be interrupted and the keyboard interrupt service routine will be executed as shown below. What does the keyboard interrupt service routine do? .ORIG x1000 LDI R0, KBDR TRAP x21 TRAP x21 RTI KBDR .FILL xFE02 .END Note: RTI is an instruction that enables the computer to return to executing the program that was interrupted. It will be studied in Chapter 10. The only thing you need to know about it now is that it loads the PC with the address of the instruction that was about to be fetched when the interrupt occurred. c. Finally, suppose the program of part a started executing, and someone sitting at the keyboard struck a key. What would you see on the screen? d. In part c, how many times is the digit typed shown on the screen? Why is the correct answer: \"I can not say for sure.\" 9.32 What does the following LC-3 program do? .ORIG x3000 LD R0,ASCII LD R1,NEG AGAIN LDI R2,DSR BRzp AGAIN",
    "622": "LDI R0, KBDR TRAP x21 TRAP x21 RTI KBDR .FILL xFE02 .END Note: RTI is an instruction that enables the computer to return to executing the program that was interrupted. It will be studied in Chapter 10. The only thing you need to know about it now is that it loads the PC with the address of the instruction that was about to be fetched when the interrupt occurred. c. Finally, suppose the program of part a started executing, and someone sitting at the keyboard struck a key. What would you see on the screen? d. In part c, how many times is the digit typed shown on the screen? Why is the correct answer: \"I can not say for sure.\" 9.32 What does the following LC-3 program do? .ORIG x3000 LD R0,ASCII LD R1,NEG AGAIN LDI R2,DSR BRzp AGAIN STI R0,DDR ADD R0,R0,#1 ADD R2,R0,R1 BRnp AGAIN HALT ASCII .FILL x0041 NEG .FILL xFFB6 ; -x004A DSR .FILL xFE04 DDR .FILL xFE06 .END 9.33 During the initiation of the interrupt service routine, the N, Z, and P condition codes are saved on the stack. Show by means of a simple example how incorrect results would be generated if the condition codes were not saved. 9.34 In the example of Section 9.4.n, what are the contents of locations x01F1 and x01F2? They are part of a larger structure. Provide a name for that structure. ( Hint: See Table A.3.) 9.35 Expand the example of Section 9.4.n to include an interrupt by a still more urgent device D while the service routine of device C is executing the instruction at x6310. Assume device D's interrupt vector is xF3. Assume the interrupt service routine is stored in locations x6400 to x6412. Show the contents of the stack and PC at each relevant point in the execution flow. 9.36 Suppose device D in Exercise 9.35 has a lower priority than device C but a higher priority than device B. Rework Exercise 10.12 with this new wrinkle. 9.37 Write an interrupt handler to accept",
    "623": "condition codes were not saved. 9.34 In the example of Section 9.4.n, what are the contents of locations x01F1 and x01F2? They are part of a larger structure. Provide a name for that structure. ( Hint: See Table A.3.) 9.35 Expand the example of Section 9.4.n to include an interrupt by a still more urgent device D while the service routine of device C is executing the instruction at x6310. Assume device D's interrupt vector is xF3. Assume the interrupt service routine is stored in locations x6400 to x6412. Show the contents of the stack and PC at each relevant point in the execution flow. 9.36 Suppose device D in Exercise 9.35 has a lower priority than device C but a higher priority than device B. Rework Exercise 10.12 with this new wrinkle. 9.37 Write an interrupt handler to accept keyboard input as follows: A buffer is allocated to memory locations x4000 through x40FE. The interrupt handler must accept the next character typed and store it in the next “empty” location in the buffer. Memory location x40FF is used as a pointer to the next available empty buffer location. If the buffer is full (i.e., if a character has been stored in location x40FE), the interrupt handler must display on the screen: “Character cannot be accepted; input buffer full.” 9.38 Consider the interrupt handler of Exercise 9.37. The buffer is modified as follows: The buffer is allocated to memory locations x4000 through x40FC. Location x40FF contains, as before, the address of the next available empty location in the buffer. Location x40FE contains the address of the oldest character in the buffer. Location x40FD contains the number of characters in the buffer. Other programs can remove characters from the buffer. Modify the interrupt handler so that, after x40FC is filled, the next location filled is x4000, assuming the character in x4000 has been previously removed. As before, if the buffer is full, the interrupt handler must display on the screen: “Character cannot be accepted; input buffer full.” 9.39 Consider the modified",
    "624": "stored in location x40FE), the interrupt handler must display on the screen: “Character cannot be accepted; input buffer full.” 9.38 Consider the interrupt handler of Exercise 9.37. The buffer is modified as follows: The buffer is allocated to memory locations x4000 through x40FC. Location x40FF contains, as before, the address of the next available empty location in the buffer. Location x40FE contains the address of the oldest character in the buffer. Location x40FD contains the number of characters in the buffer. Other programs can remove characters from the buffer. Modify the interrupt handler so that, after x40FC is filled, the next location filled is x4000, assuming the character in x4000 has been previously removed. As before, if the buffer is full, the interrupt handler must display on the screen: “Character cannot be accepted; input buffer full.” 9.39 Consider the modified interrupt handler of Exercise 9.38, used in conjunction with a program that removes characters from the buffer. Can you think of any problem that might prevent the interrupt handler that is adding characters to the buffer and the program that is removing characters from the buffer from working correctly together? 9.40 Suppose the keyboard interrupt vector is x34 and the keyboard interrupt service routine starts at location x1000. What can you infer about the contents of any memory location from the above statement? 9.41 Two students wrote interrupt service routines for an assignment. Both service routines did exactly the same work, but the first student accidentally used RET at the end of his routine, while the second student correctly used RTI. There are three errors that arose in the first student's program due to his mistake. Describe any two of them. 9.42STAR Since ASCII codes consist of 8 bits each, we can store two ASCII codes in one word of LC-3 memory. If a user types 2n characters on the keyboard, followed by the ENTER key, the subroutine PACK on the next page will store the corresponding ASCII codes into n sequential memory locations, two per memory location, starting at",
    "625": "keyboard interrupt service routine starts at location x1000. What can you infer about the contents of any memory location from the above statement? 9.41 Two students wrote interrupt service routines for an assignment. Both service routines did exactly the same work, but the first student accidentally used RET at the end of his routine, while the second student correctly used RTI. There are three errors that arose in the first student's program due to his mistake. Describe any two of them. 9.42STAR Since ASCII codes consist of 8 bits each, we can store two ASCII codes in one word of LC-3 memory. If a user types 2n characters on the keyboard, followed by the ENTER key, the subroutine PACK on the next page will store the corresponding ASCII codes into n sequential memory locations, two per memory location, starting at location A. You may assume that a user never enters an odd number of characters. Your job: Fill in the blanks in the program. If a user types the string Please help! followed by the <ENTER> key, what does the program do? [t]0.5 .ORIG x7020 PACK ST R7, SAVER7 ST R6, SAVER6 ST R4, SAVER4 ST R3, SAVER3 LEA R6, A ; R6 is the pointer AND R4, R4, #0 ADD R4, R4, #8 ; R4 is our counter AND R3, R3, #0 LEA R0, PROMPT TRAP x22 POLL ————— (a) BRzp POLL ————— (b) LD R0, NEG_LF ADD R0, R7, R0 ————— (c) ADD R4, R4, #0 BRz NOSHIFT SHIFT ADD R7, R7, R7 ADD R4, R4, #-1 BRp SHIFT ADD R3, R7, #0 BRnzp POLL NOSHIFT ADD R3, R3, R7 ————— (d) ADD R6, R6, #1 ADD R4, R4, #8 BRnzp POLL DONE LD R7, SAVER7 LD R6, SAVER6 LD R4, SAVER4 LD R3, SAVER3 LEA R0, A ; Returns a pointer to the characters RET KBSR .FILL xFE00 KBDR .FILL xFE02 NEG_LF .FILL xFFF6 PROMPT .STINGZ \"Please enter a string: \" A .BLKW #5 SAVER7 .BLKW #1 SAVER6 .BLKW #1 SAVER4 .BLKW #1 SAVER3 .BLKW #1 .END",
    "626": "A ; R6 is the pointer AND R4, R4, #0 ADD R4, R4, #8 ; R4 is our counter AND R3, R3, #0 LEA R0, PROMPT TRAP x22 POLL ————— (a) BRzp POLL ————— (b) LD R0, NEG_LF ADD R0, R7, R0 ————— (c) ADD R4, R4, #0 BRz NOSHIFT SHIFT ADD R7, R7, R7 ADD R4, R4, #-1 BRp SHIFT ADD R3, R7, #0 BRnzp POLL NOSHIFT ADD R3, R3, R7 ————— (d) ADD R6, R6, #1 ADD R4, R4, #8 BRnzp POLL DONE LD R7, SAVER7 LD R6, SAVER6 LD R4, SAVER4 LD R3, SAVER3 LEA R0, A ; Returns a pointer to the characters RET KBSR .FILL xFE00 KBDR .FILL xFE02 NEG_LF .FILL xFFF6 PROMPT .STINGZ \"Please enter a string: \" A .BLKW #5 SAVER7 .BLKW #1 SAVER6 .BLKW #1 SAVER4 .BLKW #1 SAVER3 .BLKW #1 .END 9.43STAR We want to support 8 input keyboards instead of 1. To do this we need 8 ready bits in KBSR, and 8 separate KBDRs. We will use the 8 odd-numbered bits in the KBSR as ready bits for the 8 keyboards, as shown below. We will set the other 8 bits in the KBSR to 0. < g r a p h i c s > The 8 memory-mapped keyboard data registers and their corresponding ready bits are as follows: FE04: KBSR FE06: KBDR1, Ready bit is KBSR[1] FE08: KBDR2, Ready bit is KBSR[3] FE0A: KBDR3, Ready bit is KBSR[5] FE0C: KBDR4, Ready bit is KBSR[7] FE0E: KBDR5, Ready bit is KBSR[9] FE10: KBDR6, Ready bit is KBSR[11] FE12: KBDR7, Ready bit is KBSR[13] FE14: KBDR8, Ready bit is KBSR[15] We wish to write a program that polls the keyboards and loads the ASCII code typed by the highest priority keyboard into R0. That is, if someone had previously typed a key on keyboard 1, we want to load the ASCII code in KBDR1 into R0. If no key was typed on keyboard 1, but a key had been typed on keyboard 2, we want to load the ASCII",
    "627": "a p h i c s > The 8 memory-mapped keyboard data registers and their corresponding ready bits are as follows: FE04: KBSR FE06: KBDR1, Ready bit is KBSR[1] FE08: KBDR2, Ready bit is KBSR[3] FE0A: KBDR3, Ready bit is KBSR[5] FE0C: KBDR4, Ready bit is KBSR[7] FE0E: KBDR5, Ready bit is KBSR[9] FE10: KBDR6, Ready bit is KBSR[11] FE12: KBDR7, Ready bit is KBSR[13] FE14: KBDR8, Ready bit is KBSR[15] We wish to write a program that polls the keyboards and loads the ASCII code typed by the highest priority keyboard into R0. That is, if someone had previously typed a key on keyboard 1, we want to load the ASCII code in KBDR1 into R0. If no key was typed on keyboard 1, but a key had been typed on keyboard 2, we want to load the ASCII code in KBDR2 into R0. ...and so on. That is, KB1 has higher priority than KB2, which has higher priority than KB3, which has higher priority than KB4, etc. KB8 has the lowest priority. The following program will do the job AFTER you fill in the missing instructions. Your job: fill in the missing instructions. 9.44STAR The following program pushes elements onto a stack with JSR PUSH and pops elements off of the stack with JSR POP. [t]0.5 .ORIG X3000 LEA R6, STACK_BASE X TRAP x20 ;GETC TRAP x21 ;OUT ADD R1, R0, x-0A ;x0A is ASCII code for line feed, ;x-0A is the negative of x0A BRz Y JSR PUSH BRnzp X Y LEA R2, STACK_BASE NOT R2, R2 ADD R2, R2, #1 ADD R3, R2, R6 BRz DONE JSR POP TRAP x21 ;OUT BRnzp Y DONE TRAP x25 ;HALT STACK .BLKW 5 STACK_BASE .FILL x0FFF PUSH ADD R6, R6, #-1 STR R0, R6, #0 RET POP LDR R0, R6, #0 ADD R6, R6, #1 RET .END What will appear on the screen if a user, sitting at a keyboard, typed the three keys a, b, c, followed by the Enterkey? What will happen if a user, sitting at",
    "628": "elements onto a stack with JSR PUSH and pops elements off of the stack with JSR POP. [t]0.5 .ORIG X3000 LEA R6, STACK_BASE X TRAP x20 ;GETC TRAP x21 ;OUT ADD R1, R0, x-0A ;x0A is ASCII code for line feed, ;x-0A is the negative of x0A BRz Y JSR PUSH BRnzp X Y LEA R2, STACK_BASE NOT R2, R2 ADD R2, R2, #1 ADD R3, R2, R6 BRz DONE JSR POP TRAP x21 ;OUT BRnzp Y DONE TRAP x25 ;HALT STACK .BLKW 5 STACK_BASE .FILL x0FFF PUSH ADD R6, R6, #-1 STR R0, R6, #0 RET POP LDR R0, R6, #0 ADD R6, R6, #1 RET .END What will appear on the screen if a user, sitting at a keyboard, typed the three keys a, b, c, followed by the Enterkey? What will happen if a user, sitting at a keyboard, typed the eight keys a, b, c, d, e, f, g, h, followed by the Enterkey? 9.45 We wish to add a new TRAP service routine, which will be called by the instruction TRAP x9A. The new trap routine will wait for someone to type a lower case letter, then echo on the screen the corresponding capital letter. Assume the user will not type anything except a lower case letter. The assembly language code for this trap service routine is shown below: .ORIG x2055 —————– (a) ST R1, SaveR1 ST R0, SaveR0 TRAP x20 LD R1, A —————– (b) TRAP x21 —————– (c) LD R1, SaveR1 LD R0, SaveR0 JMP R7 SaveR1 .BLKW 1 SaveR0 .BLKW 1 A .FILL ———— (d) ____ .BLKW ; (e) a missing label .END In order for TRAP x9A to call this service routine, what memory location must contain what value. Address: Fill in the missing information in the assembly language program. i.e, the three missing instructions, the one missing label, and the operand of the .FILL pseudo-op. 9.46 A programmer wrote the following program which was assembled and executed. Execution started with PC at x3000. .ORIG x3000 LEA R0, Message TRAP x01",
    "629": "Assume the user will not type anything except a lower case letter. The assembly language code for this trap service routine is shown below: .ORIG x2055 —————– (a) ST R1, SaveR1 ST R0, SaveR0 TRAP x20 LD R1, A —————– (b) TRAP x21 —————– (c) LD R1, SaveR1 LD R0, SaveR0 JMP R7 SaveR1 .BLKW 1 SaveR0 .BLKW 1 A .FILL ———— (d) ____ .BLKW ; (e) a missing label .END In order for TRAP x9A to call this service routine, what memory location must contain what value. Address: Fill in the missing information in the assembly language program. i.e, the three missing instructions, the one missing label, and the operand of the .FILL pseudo-op. 9.46 A programmer wrote the following program which was assembled and executed. Execution started with PC at x3000. .ORIG x3000 LEA R0, Message TRAP x01 TRAP x22 ; What is the output here? TRAP x25 Message .STRINGZ \"Cat in the hat.\" .END Assume that the Trap Vector Table includes the following entries in addition to the ones we have previously used: Memory Address Memory Contents x0000 x0100 x0001 x0102 x0002 x0107 x0003 x010A Assume further that additional trap service routines have been loaded previously in memory as specified below: .ORIG x0100 LD R7, SaveR7 RET ST R7, SaveR7 TRAP x02 AND R1, R1, #0 STR R1, R0, #3 RET AND R1, R1, #0 STR R1, R0, #5 TRAP x00 RET SaveR7 .BLKW #1 .END What is the result of execution of this program? 9.47STAR The state machine shown below will produce an output sequence if it receives an input sequence. The intial state is S0. < g r a p h i c s > For example, the input sequence 100 produces the output sequence bac. We have written a program that simulates this state machine. Inputs are requested from the keyboard, and the corresponding outputs are shown on the screen. For example, for the input sequence shown above, the monitor would display INPUT (either 0 or 1): 1 OUTPUT: b INPUT (either 0 or",
    "630": "memory as specified below: .ORIG x0100 LD R7, SaveR7 RET ST R7, SaveR7 TRAP x02 AND R1, R1, #0 STR R1, R0, #3 RET AND R1, R1, #0 STR R1, R0, #5 TRAP x00 RET SaveR7 .BLKW #1 .END What is the result of execution of this program? 9.47STAR The state machine shown below will produce an output sequence if it receives an input sequence. The intial state is S0. < g r a p h i c s > For example, the input sequence 100 produces the output sequence bac. We have written a program that simulates this state machine. Inputs are requested from the keyboard, and the corresponding outputs are shown on the screen. For example, for the input sequence shown above, the monitor would display INPUT (either 0 or 1): 1 OUTPUT: b INPUT (either 0 or 1): 0 OUTPUT: a INPUT (either 0 or 1): 0 OUTPUT: c Complete the program that simulates the state machine, by filling in each blank with one missing line of LC-3 assembly language code. You can assume the person at the keyboard can type a 1 or a 0 without error (i.e., you do not have to test for wrong input). .ORIG x3000 LEA R6, S0 Loop —————— (a) TRAP x22 TRAP x20 ; inputs a character TRAP x21 LD R1, NEGASCII ADD R0, R0, R1 —————— (b) LDR R6, R6,#0 LD R0, NEWLINE TRAP x21 LEA R0, OUTPUT TRAP x22 —————— (c) TRAP x21 LD R0, NEWLINE TRAP x21 BRnzp LOOP S0 .FILL S2 .FILL S1 .FILL x0061 S1 .FILL S0 .FILL S2 .FILL x0062 S2 .FILL ______ (d) .FILL ______ (e) .FILL ______ (f) NEGASCII .FILL xFFD0 ; the value -48 OUTPUT .STRINGZ \"OUTPUT:\" INPUT .STRINGZ \"INPUT (either 0 or 1):\" NEWLINE .FILL x000A .END 9.48STAR Up to now, we have only had one output device, the monitor, with xFE04 and xFE06 used to address its two device registers. We now introduce a second output device, a light that requires a single device register, to which we assign",
    "631": "input). .ORIG x3000 LEA R6, S0 Loop —————— (a) TRAP x22 TRAP x20 ; inputs a character TRAP x21 LD R1, NEGASCII ADD R0, R0, R1 —————— (b) LDR R6, R6,#0 LD R0, NEWLINE TRAP x21 LEA R0, OUTPUT TRAP x22 —————— (c) TRAP x21 LD R0, NEWLINE TRAP x21 BRnzp LOOP S0 .FILL S2 .FILL S1 .FILL x0061 S1 .FILL S0 .FILL S2 .FILL x0062 S2 .FILL ______ (d) .FILL ______ (e) .FILL ______ (f) NEGASCII .FILL xFFD0 ; the value -48 OUTPUT .STRINGZ \"OUTPUT:\" INPUT .STRINGZ \"INPUT (either 0 or 1):\" NEWLINE .FILL x000A .END 9.48STAR Up to now, we have only had one output device, the monitor, with xFE04 and xFE06 used to address its two device registers. We now introduce a second output device, a light that requires a single device register, to which we assign the address xFE08. Storing a 1 in xFE08 turns the light on, storing a 0 in xFE08 turns the light off. An Aggie decided to write a program which would control this light by a keyboard interrupt as follows: Pressing the key 0 would turn the light off. Pressing the key 1 would cause the light to flash on and off repeatedly. Shown below is the Aggie's code, and his Keyboard interrupt service routine. The DELAY subroutine was inserted in his program in order to separate the turning on and off of the light by one second in order to make the on-off behavior visible to the naked eye. The DELAY subroutine does not modify any registers. Unfortunately, per usual, the Aggie made a mistake in his program, and things do not work as he intended. So, he decided to debug his program (see the next page). He set three breakpoints, at x1500, at x1506, and at x300F. He initialized the PC to x3000, the keyboard IE bit to 1, and memory location x0180 to x1500. Then he hit the Run button, which stopped executing when the PC reached x1500. He hit the Run button three more times, each time",
    "632": "off repeatedly. Shown below is the Aggie's code, and his Keyboard interrupt service routine. The DELAY subroutine was inserted in his program in order to separate the turning on and off of the light by one second in order to make the on-off behavior visible to the naked eye. The DELAY subroutine does not modify any registers. Unfortunately, per usual, the Aggie made a mistake in his program, and things do not work as he intended. So, he decided to debug his program (see the next page). He set three breakpoints, at x1500, at x1506, and at x300F. He initialized the PC to x3000, the keyboard IE bit to 1, and memory location x0180 to x1500. Then he hit the Run button, which stopped executing when the PC reached x1500. He hit the Run button three more times, each time the computer stopping when the PC reached a breakpoint. While the program was running, he pressed a key on the keyboard EXACTLY ONCE. The table below shows the data in various registers and memory locations each time a breakpoint was encountered. Note: Assume, when an interrupt is initiated, the PSR is pushed onto the system stack before the PC. Complete the table. Initial Breakpoint 1 Breakpoint 2 Breakpoint 3 Breakpoint 4 PC x3000 x1500 x1506 x1506 x300F R0 x1234 x0030 R6 x3000 R7 x1234 M[x2FFC] x0000 M[x2FFD] x0000 M[x2FFE] x0000 x300D M[x2FFF] x0000 x8001 M[x4000] x0031 M[xFE00] x4000 9.49STAR The following user program (priority 0) is assembled and loaded into memory. Before this code executes, two things happen: (a) another program loads a value into W, and (b) a breakpoint is set at the address DONE. Then the run switch is hit and the program starts executing. Before the computer stops due to the breakpoint, several interrupts occur and their corresponding service routines are executed. Finally, the LC-3 stops due to the breakpoint. We examine the memory shown, and R6, the supervisor stack pointer. 2-2 Memory 2-2 x2FF8 x0601 2-2 x2FF9 x0601 2-2 x2FFA x0500 2-2 x2FFB x0504 2-2 x2FFC",
    "633": "the table. Initial Breakpoint 1 Breakpoint 2 Breakpoint 3 Breakpoint 4 PC x3000 x1500 x1506 x1506 x300F R0 x1234 x0030 R6 x3000 R7 x1234 M[x2FFC] x0000 M[x2FFD] x0000 M[x2FFE] x0000 x300D M[x2FFF] x0000 x8001 M[x4000] x0031 M[xFE00] x4000 9.49STAR The following user program (priority 0) is assembled and loaded into memory. Before this code executes, two things happen: (a) another program loads a value into W, and (b) a breakpoint is set at the address DONE. Then the run switch is hit and the program starts executing. Before the computer stops due to the breakpoint, several interrupts occur and their corresponding service routines are executed. Finally, the LC-3 stops due to the breakpoint. We examine the memory shown, and R6, the supervisor stack pointer. 2-2 Memory 2-2 x2FF8 x0601 2-2 x2FF9 x0601 2-2 x2FFA x0500 2-2 x2FFB x0504 2-2 x2FFC x0204 2-2 x2FFD x0201 2-2 x2FFE x8004 2-2 x2FFF x8002 2-2 x3000 x8010 2-2 x3001 x8012 2-2 2-22-2 R6 x3000 2-2 What does the user program write to the monitor? How do you know that? 9.50STAR Your job in this problem will be to add the missing instructions to a program that detects palindromes. Recall a palindrome is a string of characters that are identical when read from left to right or from right to left. For example, racecar and 112282211. In this program, we will have no spaces and no capital letters in our input string – just a string of lower case letters. The program will make use of both a stack and a queue. The subroutines for accessing the stack and queue are shown below. Recall that elements are PUSHed (added) and POPped (removed) from the stack. Elements are ENQUEUEd (added) to the back of a queue, and DEQUEUEd (removed) from the front of the queue. [c].6 .ORIG x3050 PUSH ADD R6, R6, #-1 STR R0, R6, #0 RET POP LDR R0, R6, #0 ADD R6, R6, #1 RET STACK .BLKW #20 .END [c].4 .ORIG x3080 ENQUEUE ADD R5, R5, #1 STR R0, R5, #0 RET DEQUEUE",
    "634": "of characters that are identical when read from left to right or from right to left. For example, racecar and 112282211. In this program, we will have no spaces and no capital letters in our input string – just a string of lower case letters. The program will make use of both a stack and a queue. The subroutines for accessing the stack and queue are shown below. Recall that elements are PUSHed (added) and POPped (removed) from the stack. Elements are ENQUEUEd (added) to the back of a queue, and DEQUEUEd (removed) from the front of the queue. [c].6 .ORIG x3050 PUSH ADD R6, R6, #-1 STR R0, R6, #0 RET POP LDR R0, R6, #0 ADD R6, R6, #1 RET STACK .BLKW #20 .END [c].4 .ORIG x3080 ENQUEUE ADD R5, R5, #1 STR R0, R5, #0 RET DEQUEUE LDR R0, R4, #0 ADD R4, R4, #1 RET QUEUE .BLKW #20 .END The program is carried out in two phases. Phase 1 enables a user to input a character string one keyboard character at a time. The character string is terminated when the user types the enter key (line feed). In Phase 1, the ASCII code of each character input is pushed on a stack, and its negative value is inserted at the back of a queue. Inserting an element at the back of a queue we call enqueuing. In Phase 2, the characters on the stack and in the queue are examined by removing them, one by one from their respective data structures (i.e., stack and queue). If the string is a palindrome, the program stores a 1 in memory location RESULT. If not, the program stores a zero in memory location RESULT. The PUSH and POP routines for the stack as well as the ENQUEUE and DEQUEUE routines for the queue are shown below. You may assume the user never inputs more than 20 characters. [t]0.5 .ORIG X3000 LEA R4, QUEUE LEA R5, QUEUE ADD R5, R5, #-1 LEA R6, ENQUEUE ; Initialize SP LD R1, ENTER",
    "635": "input is pushed on a stack, and its negative value is inserted at the back of a queue. Inserting an element at the back of a queue we call enqueuing. In Phase 2, the characters on the stack and in the queue are examined by removing them, one by one from their respective data structures (i.e., stack and queue). If the string is a palindrome, the program stores a 1 in memory location RESULT. If not, the program stores a zero in memory location RESULT. The PUSH and POP routines for the stack as well as the ENQUEUE and DEQUEUE routines for the queue are shown below. You may assume the user never inputs more than 20 characters. [t]0.5 .ORIG X3000 LEA R4, QUEUE LEA R5, QUEUE ADD R5, R5, #-1 LEA R6, ENQUEUE ; Initialize SP LD R1, ENTER AND R3, R3, #0 —————— (a) TRAP x22 PHASE1 TRAP x20 —————— (b) BRz PHASE2 JSR PUSH —————— (c) —————— (d) JSR ENQUEUE ADD R3, R3, #1 BRnzp PHASE1 ; PHASE2 JSR POP —————— (e) JSR DEQUEUE ADD R1, R0, R1 BRnp FALSE —————— (f) —————— (g) BRnzp PHASE2 ; TRUE AND R0, R0, #0 ADD R0, R0, #1 ST R0, RESULT HALT FALSE AND R0, R0, #0 ST R0, RESULT HALT RESULT .BLKW #1 ENTER .FILL x-0A PROMPT .STRINGZ \"Enter an input string: \" .END 9.51STAR Now that the keyboard interrupt is old stuff for you, it is time to introduce two interrupts for the LC-3: INTA and INTB. The necessary hardware has been added to allow them to happen. INTA has priority 2 and an interrupt vector of x50. INTB has priority 4 and an interrupt vector of x60. Recall that the priority is specified in bits[10:8] of the PSR. In fact, the full PSR specification is: 1c15 1c14 1c13 1c12 1c11 1c10 1c9 1c8 1c7 1c6 1c5 1c4 1c3 1c2 1c1 1c0 2-17 PSR: 1|c|Pr 0 0 0 0 3 c| Priority 0 0 0 0 0 N Z P 2-17 where PSR[15] = 0 (supervisor mode),",
    "636": "R0, RESULT HALT FALSE AND R0, R0, #0 ST R0, RESULT HALT RESULT .BLKW #1 ENTER .FILL x-0A PROMPT .STRINGZ \"Enter an input string: \" .END 9.51STAR Now that the keyboard interrupt is old stuff for you, it is time to introduce two interrupts for the LC-3: INTA and INTB. The necessary hardware has been added to allow them to happen. INTA has priority 2 and an interrupt vector of x50. INTB has priority 4 and an interrupt vector of x60. Recall that the priority is specified in bits[10:8] of the PSR. In fact, the full PSR specification is: 1c15 1c14 1c13 1c12 1c11 1c10 1c9 1c8 1c7 1c6 1c5 1c4 1c3 1c2 1c1 1c0 2-17 PSR: 1|c|Pr 0 0 0 0 3 c| Priority 0 0 0 0 0 N Z P 2-17 where PSR[15] = 0 (supervisor mode), 1 (user mode). PSR[14:11] = 0000 PSR[10:8] = priority, 0 (lowest) to 7 (highest). PSR[7:3] = 00000 PSR[2:0] = condition codes for N,Z,P In this problem you are given the user program and the two interrupt service routines. The user program starts executing at cycle 1 and runs at priority 0. User program: .ORIG x3000 AND R0,R0,#0 ADD R0,R0,#5 LD R1,COUNT NOT R0,R0 ADD R0,R0,#1 AGAIN ADD R2,R0,R1 BRz DONE ADD R1,R1,#-1 BRnzp AGAIN DONE TRAP x25 COUNT .FILL x000F .END INTA Service Routine: .ORIG x1000 AND R5,R4,#0 ADD R5,R5,#-1 LD R3,VAL ADD R3,R3,R5 ST R3,VAL RTI VAL .BLKW 1 .END INTB Service Routine: .ORIG x2000 LDI R4,VAL2 NOT R4,R4 ADD R4,R4,#1 STI R4,VAL2 RTI VAL2 .FILL xFE08 .END Assume both interrupts are enabled. Assume 22 cycles are needed to initiate an interrupt when you are in user mode; that is, from the time the test is taken until the interrupt service routine starts executing. Assume it takes 21 cycles if you are in privileged (supervisor) mode. You already know from problem 1 the number of cycles individual instructions take. In order to support INTA and INTB, the interrupt vector table must have entries. Show the addresses of these entries",
    "637": "R1,COUNT NOT R0,R0 ADD R0,R0,#1 AGAIN ADD R2,R0,R1 BRz DONE ADD R1,R1,#-1 BRnzp AGAIN DONE TRAP x25 COUNT .FILL x000F .END INTA Service Routine: .ORIG x1000 AND R5,R4,#0 ADD R5,R5,#-1 LD R3,VAL ADD R3,R3,R5 ST R3,VAL RTI VAL .BLKW 1 .END INTB Service Routine: .ORIG x2000 LDI R4,VAL2 NOT R4,R4 ADD R4,R4,#1 STI R4,VAL2 RTI VAL2 .FILL xFE08 .END Assume both interrupts are enabled. Assume 22 cycles are needed to initiate an interrupt when you are in user mode; that is, from the time the test is taken until the interrupt service routine starts executing. Assume it takes 21 cycles if you are in privileged (supervisor) mode. You already know from problem 1 the number of cycles individual instructions take. In order to support INTA and INTB, the interrupt vector table must have entries. Show the addresses of these entries and the contents of those memory locations. Memory address Content Suppose INTA requests service at cycle 30 and INTB requests service at cycle 68. In which cycle does each service routine start executing? The table below shows the contents of a section of memory (locations x2FFA to x3002) before the user program starts executing. Show the contents of these locations and the contents of the Stack Pointer in cycle 100. 2-3 Initial At the end of cycle 100 2-3 x2FFA x0001 2-3 x2FFB x0010 2-3 x2FFC x0100 2-3 x2FFD x1000 2-3 x2FFE x1100 2-3 x2FFF x1110 2-3 x3000 x5020 2-3 x3001 x1025 2-3 x3002 x2207 2-3 Stack x3000 Pointer 2-3 9.52STAR Consider a two player game where the players must think quickly each time it is their turn to make a move. Each player has a total allotted amount of time to make all his/her moves. Two clocks display the remaining time for each player. While a player is thinking of his/her move, his clock counts down. If time runs out, the other player wins. As soon as a player makes his/her move, he hits a button, which serves to stop counting down his clock and start counting down the",
    "638": "and the contents of the Stack Pointer in cycle 100. 2-3 Initial At the end of cycle 100 2-3 x2FFA x0001 2-3 x2FFB x0010 2-3 x2FFC x0100 2-3 x2FFD x1000 2-3 x2FFE x1100 2-3 x2FFF x1110 2-3 x3000 x5020 2-3 x3001 x1025 2-3 x3002 x2207 2-3 Stack x3000 Pointer 2-3 9.52STAR Consider a two player game where the players must think quickly each time it is their turn to make a move. Each player has a total allotted amount of time to make all his/her moves. Two clocks display the remaining time for each player. While a player is thinking of his/her move, his clock counts down. If time runs out, the other player wins. As soon as a player makes his/her move, he hits a button, which serves to stop counting down his clock and start counting down the other player's clock. The program on the next page implements this mechanism. The main program keeps track of the time remaining for each player by decrementing the proper counter once per second while the player is thinking. When a player's counter reaches zero, a message is printed on the screen declaring the winner. When a player hits the button, an interrupt is taken. The interrupt service routine takes such action as to enable the main program (after returning from the interrupt) to start decrementing the other counter. The interrupt vector for the button is x35. The priority level of the button is #2. Assume that the operating system has set the Interrupt Enable bit of the button to enable it to interrupt. Assume the main program runs at priority #1 and executes in user mode. In order for the interrupt service routine to be executed when the button is pushed, what memory location must contain what value? Assume a player hits the button while the instruction at line 16 is being executed. What two values (in hex) will be pushed on the stack? Fill in the missing instructions in the user program. This program has a bug that will only",
    "639": "interrupt is taken. The interrupt service routine takes such action as to enable the main program (after returning from the interrupt) to start decrementing the other counter. The interrupt vector for the button is x35. The priority level of the button is #2. Assume that the operating system has set the Interrupt Enable bit of the button to enable it to interrupt. Assume the main program runs at priority #1 and executes in user mode. In order for the interrupt service routine to be executed when the button is pushed, what memory location must contain what value? Assume a player hits the button while the instruction at line 16 is being executed. What two values (in hex) will be pushed on the stack? Fill in the missing instructions in the user program. This program has a bug that will only occur if an interrupt is taken at an inappropriate time. Write down the line number of an instruction such that if the button is pressed while that instruction is executing, unintended behavior will result. How could we fix this bug? ; Interrupt Service Routine .ORIG x1550 NOT R0, R0 RTI .END ; User Program .ORIG x3000 AND R0, R0, #0 ; Line 1 LD R1, TIME ; Line 2 LD R2, TIME ; Line 3 NEXT ——————– (a) ——————– (b) BRn P2_DEC ; Line 6 ADD R1, R1, #-1 ; Line 7 ——————- (c) LEA R0, P2WINS ; Line 9 BRnzp END ; Line 10 P2_DEC ADD R2, R2, #-1 ; Line 11 ——————- (d) LEA R0, P1WINS ; Line 13 END PUTS ; Line 14 HALT ; Line 15 COUNT LD R3, SECOND ; Line 16 LOOP ADD R3, R3, #-1 ; Line 17 BRp LOOP ; Line 18 ——————- (e) TIME .FILL #300 SECOND .FILL #25000 ; 1 second P1WINS .STRINGZ \"Player 1 Wins.\" P2WINS .STRINGZ \"Player 2 Wins.\" .END 9.53STAR A program is running in privilege mode (PSR[1]] = 0). We set a breakpoint at location x2000. The operator immediately pushes the run button. What are the",
    "640": "; Line 1 LD R1, TIME ; Line 2 LD R2, TIME ; Line 3 NEXT ——————– (a) ——————– (b) BRn P2_DEC ; Line 6 ADD R1, R1, #-1 ; Line 7 ——————- (c) LEA R0, P2WINS ; Line 9 BRnzp END ; Line 10 P2_DEC ADD R2, R2, #-1 ; Line 11 ——————- (d) LEA R0, P1WINS ; Line 13 END PUTS ; Line 14 HALT ; Line 15 COUNT LD R3, SECOND ; Line 16 LOOP ADD R3, R3, #-1 ; Line 17 BRp LOOP ; Line 18 ——————- (e) TIME .FILL #300 SECOND .FILL #25000 ; 1 second P1WINS .STRINGZ \"Player 1 Wins.\" P2WINS .STRINGZ \"Player 2 Wins.\" .END 9.53STAR A program is running in privilege mode (PSR[1]] = 0). We set a breakpoint at location x2000. The operator immediately pushes the run button. What are the subsequent MAR/MDR values? MAR MDR x8000 x1050 x0004 xBCAE x2800 x2C04 x1052 x3C4D x2C0A chap10../art/ch08/,../art/designelements/,../art/designelements/UnNumberedArt/makechapterhead#1 @ (0,0) (432,-577) < g r a p h i c s > (428,-577)1@9.52667in(381.5,-181) < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > < g r a p h i c s > 1212chapter 1212chapter 7212 3032#1 36.4pc4@ CHAPTER: DATA STRUCTURES Up to now, each item of information we have processed with the computer has been a single value – either an integer, a floating point number, or an ASCII character. The real world is filled with items of information far more complex than simple, single numbers. A company's organization chart and a list of items arranged in alphabetical order are two examples. We call these complex items of information abstract data types, or more colloquially: data structures. In this chapter, we will study three abstract data types: stacks, queues, and character strings. We will write programs to solve problems that require expressing information according to its structure. There are other abstract data types",
    "641": "g r a p h i c s > < g r a p h i c s > 1212chapter 1212chapter 7212 3032#1 36.4pc4@ CHAPTER: DATA STRUCTURES Up to now, each item of information we have processed with the computer has been a single value – either an integer, a floating point number, or an ASCII character. The real world is filled with items of information far more complex than simple, single numbers. A company's organization chart and a list of items arranged in alphabetical order are two examples. We call these complex items of information abstract data types, or more colloquially: data structures. In this chapter, we will study three abstract data types: stacks, queues, and character strings. We will write programs to solve problems that require expressing information according to its structure. There are other abstract data types to be sure, but we will leave those for Chapter 15, after we have introduced you to the C programming language. Before we get to stacks, queues, and character strings, however, we introduce a new concept that will prove very useful in manipulating data structures: subroutines, or what is also called functions. § SUBROUTINES It is often useful to be able to invoke a program fragment multiple times within the same program without having to specify its details in the sourrce program each time it is needed. Also, in the real world of computer software development, it is often (usually?) the case that one software engineer writes a program that requires such fragments and another software engineer writes the fragments. Or, one might require a fragment that has been supplied by the manufacturer or by some independent software supplier. It is almost always the case that collections of such fragments are available to user programmers to free them from having to write their own. These collections are referred to as libraries. An example is the Math Library, which consists of fragmentslibraries that compute such functions as square root, sine, and arctangent. In fact, because the Math Library exists, user programmers",
    "642": "able to invoke a program fragment multiple times within the same program without having to specify its details in the sourrce program each time it is needed. Also, in the real world of computer software development, it is often (usually?) the case that one software engineer writes a program that requires such fragments and another software engineer writes the fragments. Or, one might require a fragment that has been supplied by the manufacturer or by some independent software supplier. It is almost always the case that collections of such fragments are available to user programmers to free them from having to write their own. These collections are referred to as libraries. An example is the Math Library, which consists of fragmentslibraries that compute such functions as square root, sine, and arctangent. In fact, because the Math Library exists, user programmers can get the computer to compute those functions without even having to know how to write a program fragment to do it! For all of these reasons, it is good to have a way to use program fragments efficiently. Such program fragments are called subroutines, or alternatively, procedures, or in C terminology, functions.subroutineprocedurefunction Figure <ref> provides a simple illustration of a part of a program, call it \"piece-of-code-A,\" containing fragments that must be executed multiple times within piece-of-code-A. Figure <ref> will be studied in detail in Chapter 9, but for now, let's ignore everything about it except the 3-instruction sequences starting at symbolic addresses L1, L2, L3, and L4. [fontsize=911] 01 START ST R1,SaveR1 ; Save registers needed 02 ST R2,SaveR2 ; by this routine 03 ST R3,SaveR3 04 ; 05 LD R2,Newline 06 L1 LDI R3,DSR 07 BRzp L1 ; Loop until monitor is ready 08 STI R2,DDR ; Move cursor to new clean line 09 ; 0A LEA R1,Prompt ; Starting address of prompt string 0B Loop LDR R0,R1,#0 ; Write the input prompt 0C BRz Input ; End of prompt string 0D L2 LDI R3,DSR 0E BRzp L2 ; Loop until monitor is ready 0F STI R0,DDR",
    "643": "a part of a program, call it \"piece-of-code-A,\" containing fragments that must be executed multiple times within piece-of-code-A. Figure <ref> will be studied in detail in Chapter 9, but for now, let's ignore everything about it except the 3-instruction sequences starting at symbolic addresses L1, L2, L3, and L4. [fontsize=911] 01 START ST R1,SaveR1 ; Save registers needed 02 ST R2,SaveR2 ; by this routine 03 ST R3,SaveR3 04 ; 05 LD R2,Newline 06 L1 LDI R3,DSR 07 BRzp L1 ; Loop until monitor is ready 08 STI R2,DDR ; Move cursor to new clean line 09 ; 0A LEA R1,Prompt ; Starting address of prompt string 0B Loop LDR R0,R1,#0 ; Write the input prompt 0C BRz Input ; End of prompt string 0D L2 LDI R3,DSR 0E BRzp L2 ; Loop until monitor is ready 0F STI R0,DDR ; Write next prompt character 10 ADD R1,R1,#1 ; Increment prompt pointer 11 BRnzp Loop ; Get next prompt character 12 ; 13 Input LDI R3,KBSR 14 BRzp Input ; Poll until a character is typed 15 LDI R0,KBDR ; Load input character into R0 16 L3 LDI R3,DSR 17 BRzp L3 ; Loop until monitor is ready 18 STI R0,DDR ; Echo input character 19 ; 1A L4 LDI R3,DSR 1B BRzp L4 ; Loop until monitor is ready 1C STI R2,DDR ; Move cursor to new clean line 1D LD R1,SaveR1 ; Restore registers 1E LD R2,SaveR2 ; to original values 1F LD R3,SaveR3 20 JMP R7 ; Do the program's next task 21 ; 22 SaveR1 .BLKW 1 ; Memory for registers saved 23 SaveR2 .BLKW 1 24 SaveR3 .BLKW 1 25 DSR .FILL xFE04 26 DDR .FILL xFE06 27 KBSR .FILL xFE00 28 KBDR .FILL xFE02 29 Newline .FILL x000A ; ASCII code for newline 2A Prompt .STRINGZ “Input a character>”Instruction sequence (Piece-of-code-A) we will study in detail in Chapter 9 Each of these four 3-instruction sequences do the following: label LDI R3,DSR BRzp label STI Reg,DDR Each of the four instances uses a different label",
    "644": "R0,DDR ; Echo input character 19 ; 1A L4 LDI R3,DSR 1B BRzp L4 ; Loop until monitor is ready 1C STI R2,DDR ; Move cursor to new clean line 1D LD R1,SaveR1 ; Restore registers 1E LD R2,SaveR2 ; to original values 1F LD R3,SaveR3 20 JMP R7 ; Do the program's next task 21 ; 22 SaveR1 .BLKW 1 ; Memory for registers saved 23 SaveR2 .BLKW 1 24 SaveR3 .BLKW 1 25 DSR .FILL xFE04 26 DDR .FILL xFE06 27 KBSR .FILL xFE00 28 KBDR .FILL xFE02 29 Newline .FILL x000A ; ASCII code for newline 2A Prompt .STRINGZ “Input a character>”Instruction sequence (Piece-of-code-A) we will study in detail in Chapter 9 Each of these four 3-instruction sequences do the following: label LDI R3,DSR BRzp label STI Reg,DDR Each of the four instances uses a different label (L1, L2, L3, L4) but that is not a problem since in each instance the only purpose of the label is to branch back from the BRzp instruction to the LDI instruction. Two of the four program fragments store the contents of R0 and the other two store the contents of R2, but that is easy to take care of, as we will see. The main point is that, aside from the small nuisance of which register is being used for the source of the STI instruction, the four program fragments do exactly the same thing, and it is wasteful to require the programmer to write the code four times. The subroutine call/return mechanism enables the programmer to write the code only once. §.§ The Call/Return Mechanism The Call/Return mechanism allows us to execute this one 3-instruction sequence multiple times by requiring us to include it as a subroutine in our program only once. Figure <ref> shows the instruction execution flow for a program with and without subroutines. < g r a p h i c s > Instruction execution flow with/without subroutines Note in Figure <ref>, that without subroutines, the programmer has to provide the same code A after",
    "645": "as we will see. The main point is that, aside from the small nuisance of which register is being used for the source of the STI instruction, the four program fragments do exactly the same thing, and it is wasteful to require the programmer to write the code four times. The subroutine call/return mechanism enables the programmer to write the code only once. §.§ The Call/Return Mechanism The Call/Return mechanism allows us to execute this one 3-instruction sequence multiple times by requiring us to include it as a subroutine in our program only once. Figure <ref> shows the instruction execution flow for a program with and without subroutines. < g r a p h i c s > Instruction execution flow with/without subroutines Note in Figure <ref>, that without subroutines, the programmer has to provide the same code A after X, after Y, and after Z. With subroutines, the programmer has to provide the code A only once. The programmer uses the Call/Return mechanism to direct the computer each time via the Call instruction to the code A, and after the computer has executed the code A, to the Return instruction to the proper next instruction to be executed in the program. We refer to the program that contains the call as the caller, and the subroutine that contains the return as the callee. The Call/Return mechanism consists of two instructions. The first instruction JSR(R) is in the caller program and does two things: it loads the PC with the starting address of the subroutine and it loads R7 with the address immediately after the address of the JSR(R) instruction. The address immediately after the address of the JSR(R) instruction is the address to come back to after executing the subroutine. We call the address we come back to the return linkage. The second instruction JMP R7 is the last instruction in the subroutine (i.e., in the callee program). It loads the PC with the contents of R7, the address just after the address of the JSR instruction, completing the",
    "646": "the program. We refer to the program that contains the call as the caller, and the subroutine that contains the return as the callee. The Call/Return mechanism consists of two instructions. The first instruction JSR(R) is in the caller program and does two things: it loads the PC with the starting address of the subroutine and it loads R7 with the address immediately after the address of the JSR(R) instruction. The address immediately after the address of the JSR(R) instruction is the address to come back to after executing the subroutine. We call the address we come back to the return linkage. The second instruction JMP R7 is the last instruction in the subroutine (i.e., in the callee program). It loads the PC with the contents of R7, the address just after the address of the JSR instruction, completing the round trip flow of control from the caller to the callee and back. §.§ JSR(R) – the instruction that calls the subroutine The LC-3 specifies one control instruction for calling subroutines, its opcode is 0100. The instruction uses one of two addressing modes for computing the starting address of the subroutine, PC-relative addressing or Base Register addressing. The LC-3 assembly language provides two different mnemonic names for the opcode, JSR and JSRR, depending on which addressing mode is used. As was said above, JSR(R) instruction does two things. Like all control instructions, it loads the PC, overwriting the incremented PC that was loaded during the FETCH phase of JSR(R) instruction. In this case the starting address of the subroutine is computed, and loaded into the PC. The second thing the JSR(R) instruction does is save the return address in R7. The return address is the incremented PC, which is the address of the instruction following the JSR(R) instruction in the calling program. The JSR(R) instruction consists of three parts. 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 4|cOpcode 1|cA 11|c|-1ptAddress evaluation bits Bits [15:12] contain the opcode, 0100. Bit [11] specifies the",
    "647": "language provides two different mnemonic names for the opcode, JSR and JSRR, depending on which addressing mode is used. As was said above, JSR(R) instruction does two things. Like all control instructions, it loads the PC, overwriting the incremented PC that was loaded during the FETCH phase of JSR(R) instruction. In this case the starting address of the subroutine is computed, and loaded into the PC. The second thing the JSR(R) instruction does is save the return address in R7. The return address is the incremented PC, which is the address of the instruction following the JSR(R) instruction in the calling program. The JSR(R) instruction consists of three parts. 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 4|cOpcode 1|cA 11|c|-1ptAddress evaluation bits Bits [15:12] contain the opcode, 0100. Bit [11] specifies the addressing mode, the value 1 if the addressing mode is PC-relative, and the value 0 if the addressing mode is Base Register addressing. Bits [10:0] contain information that is used to obtain the starting address of the subroutine. The only difference between JSR and JSRR is the addressing mode that is used for evaluating the starting address of the subroutine. JSR The JSR instruction computes the target address of the subroutine by sign-extending the 11-bit offset (bits [10:0]) of the instruction to 16 bits and adding that to the incremented PC. This addressing mode is almost identical to the addressing mode of another control instruction, the BR instruction, except 11 bits of PCoffset are used, rather than nine bits as is the case for BR. If the following JSR instruction is stored in location x4200, its execution will cause the PC to be loaded with x3E05 (i.e., xFC04 + x4201) and R7 to be loaded with x4201. 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 1|c-1pt0 1c-1pt1 1c-1pt0 1c-1pt0 1|c-1pt1 1|c-1pt1 1c-1pt0 1c-1pt0 1c-1pt0 1c-1pt0 1c-1pt0 1c-1pt0 1c-1pt0 1c-1pt1 1c-1pt0 1c|-1pt0 4cJSR 1cA 11cPCoffset11 JSRR The JSRR instruction is exactly like the",
    "648": "JSR The JSR instruction computes the target address of the subroutine by sign-extending the 11-bit offset (bits [10:0]) of the instruction to 16 bits and adding that to the incremented PC. This addressing mode is almost identical to the addressing mode of another control instruction, the BR instruction, except 11 bits of PCoffset are used, rather than nine bits as is the case for BR. If the following JSR instruction is stored in location x4200, its execution will cause the PC to be loaded with x3E05 (i.e., xFC04 + x4201) and R7 to be loaded with x4201. 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 1|c-1pt0 1c-1pt1 1c-1pt0 1c-1pt0 1|c-1pt1 1|c-1pt1 1c-1pt0 1c-1pt0 1c-1pt0 1c-1pt0 1c-1pt0 1c-1pt0 1c-1pt0 1c-1pt1 1c-1pt0 1c|-1pt0 4cJSR 1cA 11cPCoffset11 JSRR The JSRR instruction is exactly like the JSR instruction except for the addressing mode. JSRR obtains the starting address of the subroutine in exactly the same way the JMP instruction does, that is, bits [8:6] identifies the Base Register, whose contents are loaded into the PC. If the following JSRR instruction is stored in location x420A, and if R5 contains x3002, the execution of the JSRR will cause R7 to be loaded with x420B, and the PC to be loaded with x3002.[-26pt] Question: What important feature does the JSRR instruction provide that the JSR instruction does not provide? 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 1|c-1pt0 1c-1pt1 1c-1pt0 1c-1pt0 1|c-1pt0 1|c-1pt0 1c-1pt0 1|c-1pt1 1c-1pt0 1c-1pt1 1|c-1pt0 1c-1pt0 1c-1pt0 1c-1pt0 1c-1pt0 1c|-1pt0 4cJSRR 1cA 2c 3cBaseR 6c §.§ Saving and Restoring Registers saving and restoring register We have known for a long time that every time an instruction loads a value into a register, the value that was previously in that register is lost. Thus, we need to save the value in a register * if that value will be destroyed by some subsequent instruction, and * if we will need it after that subsequent instruction. This can be",
    "649": "cause R7 to be loaded with x420B, and the PC to be loaded with x3002.[-26pt] Question: What important feature does the JSRR instruction provide that the JSR instruction does not provide? 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 1|c-1pt0 1c-1pt1 1c-1pt0 1c-1pt0 1|c-1pt0 1|c-1pt0 1c-1pt0 1|c-1pt1 1c-1pt0 1c-1pt1 1|c-1pt0 1c-1pt0 1c-1pt0 1c-1pt0 1c-1pt0 1c|-1pt0 4cJSRR 1cA 2c 3cBaseR 6c §.§ Saving and Restoring Registers saving and restoring register We have known for a long time that every time an instruction loads a value into a register, the value that was previously in that register is lost. Thus, we need to save the value in a register * if that value will be destroyed by some subsequent instruction, and * if we will need it after that subsequent instruction. This can be a problem when dealing with subroutines. Let's examine again the piece of code in Figure <ref>. Suppose this piece of code is a subroutine called by the instruction JSR START in some caller program, which we will call CALLER. Suppose before CALLER executes JSR START, it computes values that it loads into R1, R2, and R3. In our subroutine starting at START, the instruction on line 05 loads a value into R2, the instruction on line 06 loads a value into R3, and the instruction on line 0A loads a value into R1. What would happen if CALLER needed those values after returning from the subroutine that begins at START. Too bad! Since the subroutine destroyed the values in R1, R2, and R3 by executing the instructions in lines 05, 06, and 0A, those values are lost to CALLER when it resumes execution after the JMP R7 instruction on line 20 of the subroutine. Of course this is unacceptable. We prevent it from happening during the first part of our subroutine, i.e., during initialization. In lines 01, 02, and 03, the contents of R1, R2, and R3 are stored in memory locations SaveR1, SaveR2, and SaveR3. Three locations in the",
    "650": "at START, the instruction on line 05 loads a value into R2, the instruction on line 06 loads a value into R3, and the instruction on line 0A loads a value into R1. What would happen if CALLER needed those values after returning from the subroutine that begins at START. Too bad! Since the subroutine destroyed the values in R1, R2, and R3 by executing the instructions in lines 05, 06, and 0A, those values are lost to CALLER when it resumes execution after the JMP R7 instruction on line 20 of the subroutine. Of course this is unacceptable. We prevent it from happening during the first part of our subroutine, i.e., during initialization. In lines 01, 02, and 03, the contents of R1, R2, and R3 are stored in memory locations SaveR1, SaveR2, and SaveR3. Three locations in the subroutine (lines 22, 23, and 24) have been set aside for the purpose of saving those register values. And, in lines 1D, 1E, and 1F (just before the JMP R7 instruction) the values stored there are put back into R1, R2, and R3. That is, before the subroutine uses R1, R2, and R3 for its own use, the subroutine saves the values put there by the calling program. And, before the subroutine returns to the calling program, those values are put back (i.e., restored) where the calling program has a right to expect them. We call this technique callee save because the subroutine (i.e., the callee) saves and restores the registers. It makes sense to have the subroutine save the registers because the subroutine knows which registers it needs to do the work of the subroutine. There really is no reason to burden the person writing the caller program to know which registers the subroutine needs. We could of course have the caller program save all the registers before JSR START, and then the subroutine would not have to bother saving any of them. Some programs do that, and in fact, some ISAs have JSR instructions that do that as",
    "651": "the values put there by the calling program. And, before the subroutine returns to the calling program, those values are put back (i.e., restored) where the calling program has a right to expect them. We call this technique callee save because the subroutine (i.e., the callee) saves and restores the registers. It makes sense to have the subroutine save the registers because the subroutine knows which registers it needs to do the work of the subroutine. There really is no reason to burden the person writing the caller program to know which registers the subroutine needs. We could of course have the caller program save all the registers before JSR START, and then the subroutine would not have to bother saving any of them. Some programs do that, and in fact, some ISAs have JSR instructions that do that as part of the execution of the JSR instruction. But, if we wish to eliminate unnecessary saves and restores, we can do so in this case by having the callee save only the registers it needs. We should also point out that since JMP START loads the return linkage in R7, whatever was in R7 is destroyed by the execution of the JMP START instruction. Therefore, if the calling program had stored a value in R7 before calling the subroutine at START, and needed that value after returning from the subroutine, the caller program would have to save and restore R7. Why should the caller program save and restore R7? Because the caller program knows that the contents of R7 will be destroyed by execution of JMP START. We call this caller save because the calling program saves and restores the register value. The message is this: If a value in a register will be needed after something else is stored in that register, we must save it before the something else happens and restore it before we can subsequently use it. We save a register value by storing it in memory; we restore it by loading it back into the",
    "652": "the JMP START instruction. Therefore, if the calling program had stored a value in R7 before calling the subroutine at START, and needed that value after returning from the subroutine, the caller program would have to save and restore R7. Why should the caller program save and restore R7? Because the caller program knows that the contents of R7 will be destroyed by execution of JMP START. We call this caller save because the calling program saves and restores the register value. The message is this: If a value in a register will be needed after something else is stored in that register, we must save it before the something else happens and restore it before we can subsequently use it. We save a register value by storing it in memory; we restore it by loading it back into the register. The save/restore problem can be handled either by the calling program before the JSR occurs or by the subroutine. We will see in Section 9.3 that the same problem exists for another class of calling/called routines, those due to system calls. In summary, We use the term caller-save if the calling program handles the problem.caller-save We use the term callee-save if the called program handles the callee-save problem. The appropriate one to handle the problem is the one that knows which registers will be destroyed by subsequent actions. The callee knows which registers it needs to do the job of the called program. Therefore, before it starts, it saves those registers with a sequence of stores. After it finishes, it restores those registers with a sequence of loads. And it sets aside memory locations to save those register values. The caller knows what damage will be done by instructions under its control. It knows that each instance of a JSR instruction will destroy what is in R7. So, before the JSR instruction is executed, R7 is saved. After the caller program resumes execution (upon completion of the subroutine), R7 is restored. §.§ Library Routines We noted early in this",
    "653": "callee-save if the called program handles the callee-save problem. The appropriate one to handle the problem is the one that knows which registers will be destroyed by subsequent actions. The callee knows which registers it needs to do the job of the called program. Therefore, before it starts, it saves those registers with a sequence of stores. After it finishes, it restores those registers with a sequence of loads. And it sets aside memory locations to save those register values. The caller knows what damage will be done by instructions under its control. It knows that each instance of a JSR instruction will destroy what is in R7. So, before the JSR instruction is executed, R7 is saved. After the caller program resumes execution (upon completion of the subroutine), R7 is restored. §.§ Library Routines We noted early in this section that there are many uses for the Call/Return mechanism, among them the ability of a user program to call library subroutines that are usually delivered as part of the computer system. Libraries are provided as a convenience to the user programmer. They are legitimately advertised as productivity enhancers since they allow the application programmer to use them without having to know or learn much of their inner details. For example, it is often the case that a programmer knows what a square root is (we abbreviate SQRT), and may need to use sqrt(x) for some value x but does not have a clue as to how to write a program to perform sqrt, and probably would rather not have to learn how. A simple example illustrates the point: We have lost our key and need to get into our apartment. We can lean a ladder up against the wall so that the ladder touches the bottom of our open window, 24 feet above the ground. There is a 10-foot flower bed on the ground along the edge of the wall, so we need to keep the base of the ladder outside the flower bed. How big a ladder do",
    "654": "to know or learn much of their inner details. For example, it is often the case that a programmer knows what a square root is (we abbreviate SQRT), and may need to use sqrt(x) for some value x but does not have a clue as to how to write a program to perform sqrt, and probably would rather not have to learn how. A simple example illustrates the point: We have lost our key and need to get into our apartment. We can lean a ladder up against the wall so that the ladder touches the bottom of our open window, 24 feet above the ground. There is a 10-foot flower bed on the ground along the edge of the wall, so we need to keep the base of the ladder outside the flower bed. How big a ladder do we need so that we can lean it against the wall and climb through the window? Or, stated less colorfully: If the sides of a right triangle are 24 feet and 10 feet, how big is the hypotenuse (see Figure <ref>)? < g r a p h i c s > Solving for the length of the hypotenuse We remember from high school that Pythagoras answered that one for us: c^2 = a^2 + b^2 Knowing a and b, we can easily solve for c by taking the square root of the sum of a^2 and b^2. Taking the sum is not hard—the LC-3 ADD instruction can do that job. The square is also not hard; we can multiply two numbers by a sequence of additions. But how does one get the square root? The structure of our solution is shown in Figure <ref>. [fontsize=910] 01 ... 02 ... 03 LD R0,SIDE1 04 BRz S1 05 JSR SQUARE 06 S1 ADD R1,R0,#0 07 LD R0,SIDE2 08 BRz S2 09 JSR SQUARE 0A S2 ADD R0,R0,R1 0B JSR SQRT 0C ST R0,HYPOT 0D BRnzp NEXT_TASK 0E SQUARE ADD R2,R0,#0 0F ADD R3,R0,#0 10 AGAIN ADD R2,R2,#-1 11 BRz DONE 12 ADD",
    "655": "from high school that Pythagoras answered that one for us: c^2 = a^2 + b^2 Knowing a and b, we can easily solve for c by taking the square root of the sum of a^2 and b^2. Taking the sum is not hard—the LC-3 ADD instruction can do that job. The square is also not hard; we can multiply two numbers by a sequence of additions. But how does one get the square root? The structure of our solution is shown in Figure <ref>. [fontsize=910] 01 ... 02 ... 03 LD R0,SIDE1 04 BRz S1 05 JSR SQUARE 06 S1 ADD R1,R0,#0 07 LD R0,SIDE2 08 BRz S2 09 JSR SQUARE 0A S2 ADD R0,R0,R1 0B JSR SQRT 0C ST R0,HYPOT 0D BRnzp NEXT_TASK 0E SQUARE ADD R2,R0,#0 0F ADD R3,R0,#0 10 AGAIN ADD R2,R2,#-1 11 BRz DONE 12 ADD R0,R0,R3 13 BRnzp AGAIN 14 DONE RET 15 SQRT ... ; R0 <– SQRT(R0) 16 ... ; 17 ... ; How do we write this subroutine? 18 ... ; 19 ... ; 1A RET 1B SIDE1 .BLKW 1 1C SIDE2 .BLKW 1 1D HYPOT .BLKW 1 1E ... 1F ... A program fragment to compute the hypotenuse of a right triangle The subroutine SQRT has yet to be written. If it were not for the Math Library, the programmer would have to pick up a math book (or get someone to do it for him/her), check out the Newton-Raphson method, and produce the missing subroutine. However, with the Math Library, the problem pretty much goes away. Since the Math Library supplies a number of subroutines (including SQRT), the user programmer can continue to be ignorant of the likes of Newton-Raphson. The user still needs to know the label of the target address of the library routine that performs the square root function, where to put the argument x, and where to expect the result SQRT(x). But these are easy conventions that can be obtained from the documentation associated with the Math Library. If the library routine starts at address SQRT,",
    "656": "triangle The subroutine SQRT has yet to be written. If it were not for the Math Library, the programmer would have to pick up a math book (or get someone to do it for him/her), check out the Newton-Raphson method, and produce the missing subroutine. However, with the Math Library, the problem pretty much goes away. Since the Math Library supplies a number of subroutines (including SQRT), the user programmer can continue to be ignorant of the likes of Newton-Raphson. The user still needs to know the label of the target address of the library routine that performs the square root function, where to put the argument x, and where to expect the result SQRT(x). But these are easy conventions that can be obtained from the documentation associated with the Math Library. If the library routine starts at address SQRT, and the argument is provided in R0 to the library routine, and the result is obtained in R0 from the library routine, Figure <ref> reduces to Figure <ref>. [fontsize=910,commandchars= {}] 01 ... 02 ... 03 .EXTERNAL SQRT 04 ... 05 ... 06 LD R0,SIDE1 07 BRz S1 08 JSR SQUARE 09 S1 ADD R1,R0,#0 0A LD R0,SIDE2 0B BRz S2 0C JSR SQUARE 0D S2 ADD R0,R0,R1 ; R0 contains argument x 0E LD R4,BASE ; BASE contains starting address of SQRT routine 0F JSRR R4 10 ST R0,HYPOT 11 BRnzp NEXT_TASK 12 SQUARE ADD R2,R0,#0 13 ADD R3,R0,#0 14 AGAIN ADD R2,R2,#-1 15 BRz DONE 16 ADD R0,R0,R3 17 BRnzp AGAIN 18 DONE RET 19 BASE .FILL SQRT 1A SIDE1 .BLKW 1 1B SIDE2 .BLKW 1 1C HYPOT .BLKW 1 1D ... 1E ... The program fragment of Figure <ref>, using a library routine Two things are worth noting: * Thing 1—The programmer no longer has to worry about how to compute the square root function. The library routine does that for us. * Thing 2—The pseudo-op .EXTERNAL. We already saw in Section 7.4.2 that.EXTERNAL this pseudo-op tells the assembler that the label (SQRT), which is needed to assemble",
    "657": "0C JSR SQUARE 0D S2 ADD R0,R0,R1 ; R0 contains argument x 0E LD R4,BASE ; BASE contains starting address of SQRT routine 0F JSRR R4 10 ST R0,HYPOT 11 BRnzp NEXT_TASK 12 SQUARE ADD R2,R0,#0 13 ADD R3,R0,#0 14 AGAIN ADD R2,R2,#-1 15 BRz DONE 16 ADD R0,R0,R3 17 BRnzp AGAIN 18 DONE RET 19 BASE .FILL SQRT 1A SIDE1 .BLKW 1 1B SIDE2 .BLKW 1 1C HYPOT .BLKW 1 1D ... 1E ... The program fragment of Figure <ref>, using a library routine Two things are worth noting: * Thing 1—The programmer no longer has to worry about how to compute the square root function. The library routine does that for us. * Thing 2—The pseudo-op .EXTERNAL. We already saw in Section 7.4.2 that.EXTERNAL this pseudo-op tells the assembler that the label (SQRT), which is needed to assemble the .FILL pseudo-op in line 19, will be supplied by some other program fragment (i.e., module) and will be combined with this program fragment (i.e., module) when the executable image is produced. Theexecutable image executable image is the binary module that actually executes. The executable image is produced at link time.link timelinker This notion of combining multiple modules at link time to produce an executable image is the normal case. Figure <ref> illustrates the process. You will see concrete examples of this when we work with the programming language C in the second half of this course. 36pc < g r a p h i c s > An executable image constructed from multiple files Most application software requires library routines from various libraries. It would be very inefficient for the typical programmer to produce all of them—assuming the typical programmer were able to produce such routines in the first place. We have mentioned routines from the Math Library. There are also a number of preprocessing routines for producing pretty graphic images. There are other routines for a number of other tasks where it would make no sense at all to have the programmer write them from scratch. It is",
    "658": "time to produce an executable image is the normal case. Figure <ref> illustrates the process. You will see concrete examples of this when we work with the programming language C in the second half of this course. 36pc < g r a p h i c s > An executable image constructed from multiple files Most application software requires library routines from various libraries. It would be very inefficient for the typical programmer to produce all of them—assuming the typical programmer were able to produce such routines in the first place. We have mentioned routines from the Math Library. There are also a number of preprocessing routines for producing pretty graphic images. There are other routines for a number of other tasks where it would make no sense at all to have the programmer write them from scratch. It is much easier to require only (1) appropriate documentation so that the interface between the library routine and the program that calls that routine is clear, and (2) the use of the proper pseudo-ops such as .EXTERNAL in the source program. The linker can then produce an executable image at link time from the separately assembled modules. § THE STACK Now we are ready to study some data structures. The first and most important data structure is the stack. §.§ The Stack—An Abstract Data Type Throughout your future interaction with computers (use – software, or design – hardware), you will encounter the storage mechanism known as a stack again and again. Stacks can be implemented in stack many different ways, and we will get to that momentarily. But first, it is important to know that the concept of a stack has nothing to do with how it is implemented. The concept of a stack is the specification of how it is to be accessed. That is, the defining notion of a stack is that the last thing you stored in the stack is the first thing you remove from it. That is what makes a stack different from everything else in",
    "659": "we are ready to study some data structures. The first and most important data structure is the stack. §.§ The Stack—An Abstract Data Type Throughout your future interaction with computers (use – software, or design – hardware), you will encounter the storage mechanism known as a stack again and again. Stacks can be implemented in stack many different ways, and we will get to that momentarily. But first, it is important to know that the concept of a stack has nothing to do with how it is implemented. The concept of a stack is the specification of how it is to be accessed. That is, the defining notion of a stack is that the last thing you stored in the stack is the first thing you remove from it. That is what makes a stack different from everything else in the[-20pt] world. Simply put: Last In, First Out, or LIFO. Last In, First OutLIFO In the terminology of computer programming languages, we say the stack is an example of an abstract data type. That is, an abstract data type is a abstract data type storage mechanism that is defined by the operations performed on it and not at all by the specific manner in which it is implemented. In this section, you will see stacks implemented as sequential locations in memory. §.§ Two Example Implementations A coin holder in the armrest next to the driver of an automobile is an example of a stack. The first quarter you take to pay the highway toll is the last quarter you added to the stack of quarters. As you add quarters, you push the earlier quarters down into the coin holder. Figure <ref> shows the behavior of a coin holder. Initially, as shown in Figure <ref>a, the coin holder is empty. The first highway toll is 75 cents, and you give the toll collector a dollar. He gives you 25 cents change, a 1995 quarter, which you insert into the coin holder. The coin holder appears as shown in Figure <ref>b. <",
    "660": "the specific manner in which it is implemented. In this section, you will see stacks implemented as sequential locations in memory. §.§ Two Example Implementations A coin holder in the armrest next to the driver of an automobile is an example of a stack. The first quarter you take to pay the highway toll is the last quarter you added to the stack of quarters. As you add quarters, you push the earlier quarters down into the coin holder. Figure <ref> shows the behavior of a coin holder. Initially, as shown in Figure <ref>a, the coin holder is empty. The first highway toll is 75 cents, and you give the toll collector a dollar. He gives you 25 cents change, a 1995 quarter, which you insert into the coin holder. The coin holder appears as shown in Figure <ref>b. < g r a p h i c s > A coin holder in an automobile armrest—example of a stack There are special terms for the insertion and removal of elements from a stack. We say we push an element onto the stack when we insert it. We say we pop an element from the stack when we pushpop remove it. The second highway toll is $4.25, and you give the toll collector $5.00. She gives you 75 cents change, which you insert into the coin holder: first a 1982 quarter, then a 1998 quarter, and finally, a 1996 quarter. Now the coin holder is as shown in Figure <ref>c. The third toll is 50 cents, and you remove (pop) the top two quarters from the coin holder: the 1996 quarter first and then the 1998 quarter. The coin holder is then as shown in Figure <ref>d. The coin holder is an example of a stack, precisely because it obeys the LIFO requirement. Each time you insert a quarter, you do so at the top. Each time you remove a quarter, you do so from the top. The last coin you inserted is the first coin you remove. Therefore, it is",
    "661": "The second highway toll is $4.25, and you give the toll collector $5.00. She gives you 75 cents change, which you insert into the coin holder: first a 1982 quarter, then a 1998 quarter, and finally, a 1996 quarter. Now the coin holder is as shown in Figure <ref>c. The third toll is 50 cents, and you remove (pop) the top two quarters from the coin holder: the 1996 quarter first and then the 1998 quarter. The coin holder is then as shown in Figure <ref>d. The coin holder is an example of a stack, precisely because it obeys the LIFO requirement. Each time you insert a quarter, you do so at the top. Each time you remove a quarter, you do so from the top. The last coin you inserted is the first coin you remove. Therefore, it is a stack. Another implementation of a stack, sometimes referred to as a computer hardware stack, is shown in Figure <ref>. Its behavior resembles that of the coin holder we just described. It consists of some number of hardware registers, each of which can store a value. The example of Figure <ref> contains five registers. As each value is added to the stack or removed from the stack, the values already on the stack move. < g r a p h i c s > A stack, implemented in hardware—data entries move In Figure <ref>a, the stack is initially shown as empty. Access is always via the first element, which is labeled TOP. If the value 18 is pushed on to the stack, we have Figure <ref>b. If the three values, 31, 5, and 12, are pushed (in that order), the result is as shown in Figure <ref>c. Finally, if two values are popped from the stack, we have Figure <ref>d. A distinguishing feature of the stack of Figure <ref> is that, like the quarters in the coin holder, as each value is added or removed, all the other values already on the stack move. §.§ Implementation in Memory By far",
    "662": "the stack or removed from the stack, the values already on the stack move. < g r a p h i c s > A stack, implemented in hardware—data entries move In Figure <ref>a, the stack is initially shown as empty. Access is always via the first element, which is labeled TOP. If the value 18 is pushed on to the stack, we have Figure <ref>b. If the three values, 31, 5, and 12, are pushed (in that order), the result is as shown in Figure <ref>c. Finally, if two values are popped from the stack, we have Figure <ref>d. A distinguishing feature of the stack of Figure <ref> is that, like the quarters in the coin holder, as each value is added or removed, all the other values already on the stack move. §.§ Implementation in Memory By far the most common implementation of a stack in a computer is as shown in Figure <ref>. This stack consists of a sequence of memory locations along with a mechanism, called the stack pointer,, stack pointer which keeps track of the top of the stack. We use R6 to contain the address of the top of the stack. That is, in the LC-3, R6 is the stack pointer. In Figure <ref>, five memory locations (x3FFF to x3FFB) are provided for the stack. The actual locations comprising the stack at any single instant of time are the consecutive locations from x3FFF to the location specified in R6, i.e., the top of the stack. For example, in Figure <ref>c, the stack consists of the contents of locations x3FFF, x3FFE, x3FFD, and x3FFC. 36pc < g r a p h i c s > A stack, implemented in memory—data entries do not move Figure <ref>a shows an initially empty stack. Since there are no values on the stack, the stack pointer contains the address x4000, the address of the memory location just after the memory locations reserved for the stack. Why this makes sense will be clear after we show the actual code for",
    "663": "the LC-3, R6 is the stack pointer. In Figure <ref>, five memory locations (x3FFF to x3FFB) are provided for the stack. The actual locations comprising the stack at any single instant of time are the consecutive locations from x3FFF to the location specified in R6, i.e., the top of the stack. For example, in Figure <ref>c, the stack consists of the contents of locations x3FFF, x3FFE, x3FFD, and x3FFC. 36pc < g r a p h i c s > A stack, implemented in memory—data entries do not move Figure <ref>a shows an initially empty stack. Since there are no values on the stack, the stack pointer contains the address x4000, the address of the memory location just after the memory locations reserved for the stack. Why this makes sense will be clear after we show the actual code for pushing values onto and popping values off of the stack. Figure <ref>b shows the stack after pushing the value 18. Note that the stack pointer contains the address x3FFF, which is the new top of the stack. Figure <ref>c shows the stack after pushing the values 31, 5, and 12, in that order. Note that the values inserted into the stack are stored in memory locations having decreasing addresses. We say the stack grows toward zero. Finally, Figure <ref>d shows the stack after popping the top two elements off the stack. Note that those two elements (the values 5 and 12) that were popped are still present in memory locations x3FFD and x3FFC. However, as we will see momentarily, those values 5 and 12 cannot be accessed from memory, as long as every access to memory is controlled by the stack mechanism. Note also that, unlike the coin holder and computer hardware stack implementations discussed in the previous section, when values are pushed and popped to and from a stack implemented in sequential memory locations, the data already stored on the stack does not physically move. Push We push a value onto the stack by executing the two-instruction sequence PUSH",
    "664": "stack are stored in memory locations having decreasing addresses. We say the stack grows toward zero. Finally, Figure <ref>d shows the stack after popping the top two elements off the stack. Note that those two elements (the values 5 and 12) that were popped are still present in memory locations x3FFD and x3FFC. However, as we will see momentarily, those values 5 and 12 cannot be accessed from memory, as long as every access to memory is controlled by the stack mechanism. Note also that, unlike the coin holder and computer hardware stack implementations discussed in the previous section, when values are pushed and popped to and from a stack implemented in sequential memory locations, the data already stored on the stack does not physically move. Push We push a value onto the stack by executing the two-instruction sequence PUSH ADD R6,R6,#-1 STR R0,R6,#0 In Figure <ref>a, R6 contains x4000, indicating that the stack is empty. To push the value 18 onto the stack, we decrement R6, the stack pointer, so the address in R6 (i.e., address x3FFF) corresponds to the location where we want to store the value we are pushing onto the stack. The actual push is done by first loading 18 into R0, and then executing STR R0,R6,#0. This stores the contents of R0 into memory location x3FFF. That is, to push a value onto the stack, we first load that value into R0. Then we decrement R6, which contained the previous top of the stack. Then we execute STR R0,R6,#0, which stores the contents of R0 into the memory location whose address is in R6. The three values 31, 5, and 12 are pushed onto the stack by loading each in turn into R0, and then executing the two-instruction sequence. In Figure <ref>c, R6 (the stack pointer) contains x3FFC, indicating that the top of the stack is location x3FFC and that 12 was the last value pushed. Pop To pop a value from the stack, the value is read and the stack pointer is incremented. The",
    "665": "by first loading 18 into R0, and then executing STR R0,R6,#0. This stores the contents of R0 into memory location x3FFF. That is, to push a value onto the stack, we first load that value into R0. Then we decrement R6, which contained the previous top of the stack. Then we execute STR R0,R6,#0, which stores the contents of R0 into the memory location whose address is in R6. The three values 31, 5, and 12 are pushed onto the stack by loading each in turn into R0, and then executing the two-instruction sequence. In Figure <ref>c, R6 (the stack pointer) contains x3FFC, indicating that the top of the stack is location x3FFC and that 12 was the last value pushed. Pop To pop a value from the stack, the value is read and the stack pointer is incremented. The following two-instruction sequence POP LDR R0,R6,#0 ADD R6,R6,#1 pops the value contained in the top of the stack and loads it into R0. The stack pointer (R6) is incremented to indicate that the old value at the top of the stack has been popped and is no longer on the stack, and we have a new value at the top of the stack. If the stack were as shown in Figure <ref>c and we executed the sequence twice, we would pop two values from the stack. In this case, we would first remove the 12, and then the 5. Assuming the purpose of popping two values is to use those two values, we would, of course, have to move the 12 from R0 to some other location before calling POP a second time. Note that after 12 and 5 are popped, R6 contains x3FFE, indicating that 12 and 5 are no longer on the stack and that the top of the stack is 31. Figure <ref>d shows the stack after that sequence of operations. Note that the values 12 and 5 are still stored in memory locations x3FFD and x3FFC, respectively. However, since the stack requires that we push by",
    "666": "of the stack. If the stack were as shown in Figure <ref>c and we executed the sequence twice, we would pop two values from the stack. In this case, we would first remove the 12, and then the 5. Assuming the purpose of popping two values is to use those two values, we would, of course, have to move the 12 from R0 to some other location before calling POP a second time. Note that after 12 and 5 are popped, R6 contains x3FFE, indicating that 12 and 5 are no longer on the stack and that the top of the stack is 31. Figure <ref>d shows the stack after that sequence of operations. Note that the values 12 and 5 are still stored in memory locations x3FFD and x3FFC, respectively. However, since the stack requires that we push by executing the PUSH sequence and pop by executing the POP sequence, we cannot read the values 12 and 5 if we obey the rules. The fancy name for \"the rules\" is the stack protocol. stack protocol Underflow What happens if we now attempt to pop three values from the stack? Since only two values remain on the stack, we would have a problem. Attempting to pop items that have not been previously pushed results in an underflowunderflow situation. In our example, we can test for underflow by comparing the stack pointer with x4000, which would be the contents of R6 if there were nothing left on the stack to pop. If UNDERFLOW is the label of a routine that handles the underflow condition, our resulting POP sequence would be POP LD R1,EMPTY ADD R2,R6,R1 ; Compare stack BRz UNDERFLOW ; pointer with x4000. ; LDR R0,R6,#0 ADD R6,R6,#1 ; RET EMPTY .FILL xC000 ; EMPTY <– negative of x4000 Rather than have the POP routine immediately jump to the UNDERFLOW routine if the POP is unsuccessful, it is often useful to have the POP routine return to the calling program with the underflow information contained in a register. We will",
    "667": "have a problem. Attempting to pop items that have not been previously pushed results in an underflowunderflow situation. In our example, we can test for underflow by comparing the stack pointer with x4000, which would be the contents of R6 if there were nothing left on the stack to pop. If UNDERFLOW is the label of a routine that handles the underflow condition, our resulting POP sequence would be POP LD R1,EMPTY ADD R2,R6,R1 ; Compare stack BRz UNDERFLOW ; pointer with x4000. ; LDR R0,R6,#0 ADD R6,R6,#1 ; RET EMPTY .FILL xC000 ; EMPTY <– negative of x4000 Rather than have the POP routine immediately jump to the UNDERFLOW routine if the POP is unsuccessful, it is often useful to have the POP routine return to the calling program with the underflow information contained in a register. We will use R5 to provide success/failure information. Figure <ref> is a flowchart showing how the POP routine could be augmented, using R5 to report this success/failure information. < g r a p h i c s > POP routine, including test for underflow Upon return from the POP routine, the calling program would examine R5 to determine whether the POP completed successfully (R5 = 0), or not (R5 = 1). =1 Note that since the POP routine reports success or failure in R5, whatever was stored in R5 before the POP routine was called is lost. Thus, it is the job of the calling program to save the contents of R5 before the JSR instruction is executed if the value stored there will be needed later. Recall from Section 8.1.3 that this is an example of a caller-save situation. The resulting POP routine is shown in the following instruction sequence. POP AND R5,R5,#0 LD R1,EMPTY ADD R2,R6,R1 BRz Failure LDR R0,R6,#0 ADD R6,R6,#1 RET Failure ADD R5,R5,#1 RET EMPTY .FILL xC000 ; EMPTY <– -x4000 Overflow What happens when we run out of available space and we try to push a value onto the stack? Since we cannot store values where",
    "668": "successfully (R5 = 0), or not (R5 = 1). =1 Note that since the POP routine reports success or failure in R5, whatever was stored in R5 before the POP routine was called is lost. Thus, it is the job of the calling program to save the contents of R5 before the JSR instruction is executed if the value stored there will be needed later. Recall from Section 8.1.3 that this is an example of a caller-save situation. The resulting POP routine is shown in the following instruction sequence. POP AND R5,R5,#0 LD R1,EMPTY ADD R2,R6,R1 BRz Failure LDR R0,R6,#0 ADD R6,R6,#1 RET Failure ADD R5,R5,#1 RET EMPTY .FILL xC000 ; EMPTY <– -x4000 Overflow What happens when we run out of available space and we try to push a value onto the stack? Since we cannot store values where there is no space, we have an overflow situation. We can test for overflow by overflow comparing the stack pointer with (in the example of Figure <ref>) x3FFB. If they are equal, we have no place to push another value onto the stack. If OVERFLOW is the label of a routine that handles the overflow condition, our resulting PUSH sequence would be PUSH LD R1,MAX ADD R2,R6,R1 BRz OVERFLOW ; ADD R6,R6,#-1 STR R0,R6,#0 ; RET MAX .FILL xC005 ; MAX <– negative of x3FFB =1 In the same way that it is useful to have the POP routine return to the calling program with success/failure information, rather than immediately jumping to the UNDERFLOW routine, it is useful to have the PUSH routine act similarly. We augment the PUSH routine with instructions to store 0 (success) or 1 (failure) in R5, depending on whether or not the push completed successfully. Upon return from the PUSH routine, the calling program would examine R5 to determine whether the PUSH completed successfully (R5 = 0) or not (R5 = 1). Note again that since the PUSH routine reports success or failure in R5, we have another example of a caller-save situation. That is,",
    "669": "would be PUSH LD R1,MAX ADD R2,R6,R1 BRz OVERFLOW ; ADD R6,R6,#-1 STR R0,R6,#0 ; RET MAX .FILL xC005 ; MAX <– negative of x3FFB =1 In the same way that it is useful to have the POP routine return to the calling program with success/failure information, rather than immediately jumping to the UNDERFLOW routine, it is useful to have the PUSH routine act similarly. We augment the PUSH routine with instructions to store 0 (success) or 1 (failure) in R5, depending on whether or not the push completed successfully. Upon return from the PUSH routine, the calling program would examine R5 to determine whether the PUSH completed successfully (R5 = 0) or not (R5 = 1). Note again that since the PUSH routine reports success or failure in R5, we have another example of a caller-save situation. That is, since whatever was stored in R5 before the PUSH routine was called is lost, it is the job of the calling program to save the contents of R5 before the JSR instruction is executed if the value stored in R5 will be needed later. The resulting PUSH routine is shown in the following instruction sequence. PUSH AND R5,R5,#0 LD R1,MAX ADD R2,R6,R1 BRz Failure ADD R6,R6,#-1 STR R0,R6,#0 RET Failure ADD R5,R5,#1 RET MAX .FILL xC005 ; MAX <– -x3FFB §.§ The Complete Picture The POP and PUSH routines allow us to use memory locations x3FFF through x3FFB as a five-entry stack. If we wish to push a value onto the stack, we simply load that value into R0 and execute JSR PUSH. To pop a value from the stack into R0, we simply execute JSR POP. If we wish to change the location or the size of the stack, we adjust BASE and MAX accordingly. Before leaving this topic, we should be careful to clean up an important detail that we discussed in Section 8.1.3. The subroutines PUSH and POP make use of R1 and R2, and there is no reason why the calling program would know that. Therefore,",
    "670": "ADD R2,R6,R1 BRz Failure ADD R6,R6,#-1 STR R0,R6,#0 RET Failure ADD R5,R5,#1 RET MAX .FILL xC005 ; MAX <– -x3FFB §.§ The Complete Picture The POP and PUSH routines allow us to use memory locations x3FFF through x3FFB as a five-entry stack. If we wish to push a value onto the stack, we simply load that value into R0 and execute JSR PUSH. To pop a value from the stack into R0, we simply execute JSR POP. If we wish to change the location or the size of the stack, we adjust BASE and MAX accordingly. Before leaving this topic, we should be careful to clean up an important detail that we discussed in Section 8.1.3. The subroutines PUSH and POP make use of R1 and R2, and there is no reason why the calling program would know that. Therefore, it is the job of the subroutine (callee-save) to save R1 and R2 before using them, and restoring them before returning to the calling program. The PUSH and POP routines also write to R5. But, as we have already pointed out, the calling program knows that the subroutine will report success or failure in R5, so it is the job of the calling program to save R5 before executing the JSR instruction if the value stored in R5 will be needed later. As discussed in Section 8.1.3, this is an example of caller-save. The final code for our PUSH and POP operations is shown in Figure <ref>. 36pc[fontsize=911] 01 ; 02 ; Subroutines for carrying out the PUSH and POP functions. This 03 ; program works with a stack consisting of memory locations x3FFF 04 ; through x3FFB. R6 is the stack pointer. 05 ; 06 POP AND R5,R5,#0 ; R5 <– success 07 ST R1,Save1 ; Save registers that 08 ST R2,Save2 ; are needed by POP 09 LD R1,EMPTY ; EMPTY contains -x4000 0B ADD R2,R6,R1 ; Compare stack pointer to x4000 0C BRz fail_exit ; Branch if stack is empty 0D ; 0E LDR R0,R6,#0 ; The",
    "671": "of the calling program to save R5 before executing the JSR instruction if the value stored in R5 will be needed later. As discussed in Section 8.1.3, this is an example of caller-save. The final code for our PUSH and POP operations is shown in Figure <ref>. 36pc[fontsize=911] 01 ; 02 ; Subroutines for carrying out the PUSH and POP functions. This 03 ; program works with a stack consisting of memory locations x3FFF 04 ; through x3FFB. R6 is the stack pointer. 05 ; 06 POP AND R5,R5,#0 ; R5 <– success 07 ST R1,Save1 ; Save registers that 08 ST R2,Save2 ; are needed by POP 09 LD R1,EMPTY ; EMPTY contains -x4000 0B ADD R2,R6,R1 ; Compare stack pointer to x4000 0C BRz fail_exit ; Branch if stack is empty 0D ; 0E LDR R0,R6,#0 ; The actual \"pop\" 0F ADD R6,R6,#1 ; Adjust stack pointer 10 BRnzp success_exit 11 ; 12 PUSH AND R5,R5,#0 13 ST R1,Save1 ; Save registers that 14 ST R2,Save2 ; are needed by PUSH 15 LD R1,FULL ; FULL contains -x3FFB 16 ADD R2,R6,R1 ; Compare stack pointer to x3FFB 17 BRz fail_exit ; Branch if stack is full 18 ; 19 ADD R6,R6,#-1 ; Adjust stack pointer 1A STR R0,R6,#0 ; The actual \"push\" 1B success_exit LD R2,Save2 ; Restore original 1C LD R1,Save1 ; register values 1D RET 1E ; 1F fail_exit LD R2,Save2 ; Restore original 20 LD R1,Save1 ; register values 21 ADD R5,R5,#1 ; R5 <– failure 22 RET 23 ; 24 EMPTY .FILL xC000 ; EMPTY contains -x4000 25 FULL .FILL xC005 ; FULL contains -x3FFB 26 Save1 .FILL x0000 27 Save2 .FILL x0000 The stack protocol § RECURSION, A POWERFUL TECHNIQUE WHEN USED APPROPRIATELY Recursion is a mechanism for expressing a function in terms of itself. Some have referred to it as picking oneself up by one's bootstraps, since at first blush, it looks like magic – which, of course, it isn't. When used appropriately, the expressive power of recursion is going to save",
    "672": "19 ADD R6,R6,#-1 ; Adjust stack pointer 1A STR R0,R6,#0 ; The actual \"push\" 1B success_exit LD R2,Save2 ; Restore original 1C LD R1,Save1 ; register values 1D RET 1E ; 1F fail_exit LD R2,Save2 ; Restore original 20 LD R1,Save1 ; register values 21 ADD R5,R5,#1 ; R5 <– failure 22 RET 23 ; 24 EMPTY .FILL xC000 ; EMPTY contains -x4000 25 FULL .FILL xC005 ; FULL contains -x3FFB 26 Save1 .FILL x0000 27 Save2 .FILL x0000 The stack protocol § RECURSION, A POWERFUL TECHNIQUE WHEN USED APPROPRIATELY Recursion is a mechanism for expressing a function in terms of itself. Some have referred to it as picking oneself up by one's bootstraps, since at first blush, it looks like magic – which, of course, it isn't. When used appropriately, the expressive power of recursion is going to save us a lot of headaches. When used whimsically, recursion is going to require unnecessary activity, resulting in longer execution time and wasted energy. The mechanism is so important that we will study it in greater detail later in the book after we have raised the level of abstraction to programming in a high level language. However, since a critical concept needed to understand the implementation of recursion is the stack, which we have just studied, it is useful to show by means of examples just when using recursion is warranted and when using it is not a good idea. We will examine two ill-advised uses of recursion. We will also examine a problem where using the expressive power of recursion is very helpful. §.§ Bad example Number 1: Factorial The simplest example to illustrate recursion is the function factorial. The equation n! = n * (n-1)! says it all. We are expressing factorial in terms of factorial! How we can write a program to do this we will see momentarily. Assume the subroutine FACT (Factorial) is supplied with a positive integer n in R0, and returns with the value n! in R0. (We will save 0! for an exercise at",
    "673": "needed to understand the implementation of recursion is the stack, which we have just studied, it is useful to show by means of examples just when using recursion is warranted and when using it is not a good idea. We will examine two ill-advised uses of recursion. We will also examine a problem where using the expressive power of recursion is very helpful. §.§ Bad example Number 1: Factorial The simplest example to illustrate recursion is the function factorial. The equation n! = n * (n-1)! says it all. We are expressing factorial in terms of factorial! How we can write a program to do this we will see momentarily. Assume the subroutine FACT (Factorial) is supplied with a positive integer n in R0, and returns with the value n! in R0. (We will save 0! for an exercise at the end of the chapter.) Figure <ref> shows a pictorial view of the recursive subroutine. We represent the subroutine FACT as a hexagon, and inside the hexagon is another instance of the hexagon! We call the subroutine recursive because inside the FACT subroutine is an instruction JSR FACT. < g r a p h i c s > Flow chart for a recursive FACTORIAL subroutine The subroutine first tests to see if n=1. If so, we are done, since (1)! =1. It is important to emphasize that every recursive subroutine must have such an initial test to see if we should execute the recursive call. Without this test, the subroutine would call itself (JSR FACT) an infinite number of times! Clearly, that can not be correct. The answer is to provide a test before the recursive JSR instruction. In the case of the subroutine FACT, if R0 is 1, we are done, since 1! = 1. If n is not equal 1, we save the value in R1, so we can store n in R1, load R0 with n-1 and JSR FACT. When FACT returns with (n-1)! in R0, we multiply it by n (which was stored in R1), producing",
    "674": "for a recursive FACTORIAL subroutine The subroutine first tests to see if n=1. If so, we are done, since (1)! =1. It is important to emphasize that every recursive subroutine must have such an initial test to see if we should execute the recursive call. Without this test, the subroutine would call itself (JSR FACT) an infinite number of times! Clearly, that can not be correct. The answer is to provide a test before the recursive JSR instruction. In the case of the subroutine FACT, if R0 is 1, we are done, since 1! = 1. If n is not equal 1, we save the value in R1, so we can store n in R1, load R0 with n-1 and JSR FACT. When FACT returns with (n-1)! in R0, we multiply it by n (which was stored in R1), producing n!, which we load into R0, restore R1 to the value expected by the calling program, and RET. If we assume the LC-3 has a MUL instruction, the basic structure of the FACT subroutine takes the following form: FACT ST R1, Save1 ; Callee save R1 ADD R1,R0,#-1 ; Test if R0=1 BRz DONE ; If R0=1, R0 also contains (1)!, so we are done ADD R1,R0,#0 ; Save n in R1, to be used after we compute (n-1)! ADD R0,R1, #-1 ; Set R0 to n-1, and then call FACT B JSR FACT ; On RET, R0 will contain (n-1)! MUL R0,R0,R1 ; Multiply n times (n-1)!, yielding n! in R0 DONE LD R1, Save1 ; Callee restore R1 RET Save1 .BLKW 1 Since the LC-3 does not have a MUL instruction, this will require another subroutine call, but we are ignoring that here in order to focus on the essence of recursion. Unfortunately, the code we have written will not work. To see why it will not work, Figure <ref> shows the flow of instruction execution, as we would like it to be. The main program calls the subroutine with a JSR instruction at address A. This causes",
    "675": "(1)!, so we are done ADD R1,R0,#0 ; Save n in R1, to be used after we compute (n-1)! ADD R0,R1, #-1 ; Set R0 to n-1, and then call FACT B JSR FACT ; On RET, R0 will contain (n-1)! MUL R0,R0,R1 ; Multiply n times (n-1)!, yielding n! in R0 DONE LD R1, Save1 ; Callee restore R1 RET Save1 .BLKW 1 Since the LC-3 does not have a MUL instruction, this will require another subroutine call, but we are ignoring that here in order to focus on the essence of recursion. Unfortunately, the code we have written will not work. To see why it will not work, Figure <ref> shows the flow of instruction execution, as we would like it to be. The main program calls the subroutine with a JSR instruction at address A. This causes the code labeled #1 to excute. At address B, the subroutine FACT calls itself with the instruction JSR FACT. This causes the code labeled #2 to execute, and so forth. < g r a p h i c s > Execution flow for recursive FACTORIAL subroutines Note that when the main program executes the instruction JSR FACT, the return linkage A+1 is saved in R7. In the block of code labeled #1, the instruction at address B (JSR FACT) stores its return linkage B+1 in R7, destroying A+1, so there is no way to get back to the main program. Bad! In fact: very, very bad! We can solve this problem by pushing the address A+1 onto a stack before executing JSR FACT at address B. After we subsequently return to address B+1, we can then pop the stack, and load the address A+1 into R7 before we execute the instruction RET back to the main program. Also, note that the instruction ADD R1,R0,#0 in #1 loads the value n into R1, and in #2, the instruction ADD R1,R0,#0 loads the value n-1 into R1, thereby wiping out the value n that had been put there by the code in",
    "676": "A+1 is saved in R7. In the block of code labeled #1, the instruction at address B (JSR FACT) stores its return linkage B+1 in R7, destroying A+1, so there is no way to get back to the main program. Bad! In fact: very, very bad! We can solve this problem by pushing the address A+1 onto a stack before executing JSR FACT at address B. After we subsequently return to address B+1, we can then pop the stack, and load the address A+1 into R7 before we execute the instruction RET back to the main program. Also, note that the instruction ADD R1,R0,#0 in #1 loads the value n into R1, and in #2, the instruction ADD R1,R0,#0 loads the value n-1 into R1, thereby wiping out the value n that had been put there by the code in #1. Thus, when the instruction flow gets back to #1) where the value n is needed by the instruction MUL R0,R0,R1, it is no longer there. It was previously wiped out. Again, very, very bad! We can solve this problem with a stack also. That is, instead of moving the value n to R1 before loading n-1 into R0, we push n onto the stack, and then pop it when we need it after returning from the subroutine with (n-1)! in R0. Finally, we note that the first instruction in our subroutine saves R1 in Save1 and the last instruction before the RET restores it to R1. We do this so that from the standpoint of the calling program, the value in R1 before the subroutine is the same as the value in R1 after the subroutine, even though the subroutine used R1 in performing its job. However, since our subroutine is recursive, when FACT is called by the JSR instruction at address B, R1 does not contain the value it had in the main program, but instead it has the value last stored in R1 by the ADD R1,R0,#0 instruction. Thus after the JSR FACT instruction is executed, the",
    "677": "push n onto the stack, and then pop it when we need it after returning from the subroutine with (n-1)! in R0. Finally, we note that the first instruction in our subroutine saves R1 in Save1 and the last instruction before the RET restores it to R1. We do this so that from the standpoint of the calling program, the value in R1 before the subroutine is the same as the value in R1 after the subroutine, even though the subroutine used R1 in performing its job. However, since our subroutine is recursive, when FACT is called by the JSR instruction at address B, R1 does not contain the value it had in the main program, but instead it has the value last stored in R1 by the ADD R1,R0,#0 instruction. Thus after the JSR FACT instruction is executed, the first instruction of the recursively called subroutine FACT will save that value, wiping out the value that the main program had stored in R1 when it called FACT. We can solve this problem with a stack also. We simply replace the ST R1,Save1 with a push and LD R1,Save1 with a pop. If we make these changes (and if the LC-3 had a MUL opcode), the recursive subroutine would work as we would like it to. The resulting subroutine is shown in Figure <ref> (with almost all instructions explained via comments): 36pc[fontsize=911] FACT ADD R6,R6,#-1 STR R1,R6,#0 ; Push Caller's R1 on the stack, so we can use R1. ; ADD R1,R0,#-1 ; If n=1, we are done since 1! = 1 BRz NO_RECURSE ; ADD R6,R6,#-1 STR R7,R6,#0 ; Push return linkage onto stack ADD R6,R6,#-1 STR R0,R6,#0 ; Push n on the stack ; ADD R0,R0,#-1 ; Form n-1, argument of JSR B JSR FACT LDR R1,R6,#0 ; Pop n from the stack ADD R6,R6,#1 MUL R0,R0,R1 ; form n*(n-1)! ; LDR R7,R6,#0 ; Pop return linkage into R7 ADD R6,R6,#1 NO_RECURSE LDR R1,R6,#0 ; Pop caller's R1 back into R1 ADD R6,R6,#1 RET The recursive subroutine FACT",
    "678": "LC-3 had a MUL opcode), the recursive subroutine would work as we would like it to. The resulting subroutine is shown in Figure <ref> (with almost all instructions explained via comments): 36pc[fontsize=911] FACT ADD R6,R6,#-1 STR R1,R6,#0 ; Push Caller's R1 on the stack, so we can use R1. ; ADD R1,R0,#-1 ; If n=1, we are done since 1! = 1 BRz NO_RECURSE ; ADD R6,R6,#-1 STR R7,R6,#0 ; Push return linkage onto stack ADD R6,R6,#-1 STR R0,R6,#0 ; Push n on the stack ; ADD R0,R0,#-1 ; Form n-1, argument of JSR B JSR FACT LDR R1,R6,#0 ; Pop n from the stack ADD R6,R6,#1 MUL R0,R0,R1 ; form n*(n-1)! ; LDR R7,R6,#0 ; Pop return linkage into R7 ADD R6,R6,#1 NO_RECURSE LDR R1,R6,#0 ; Pop caller's R1 back into R1 ADD R6,R6,#1 RET The recursive subroutine FACT The main program calls FACT with R0=n. The code in #1 executes, with JSR FACT being called with R0 = n-1. At this point, the stack contains the three entries pushed, as shown in Figure <ref>a. When the JSR FACT instruction in #3 executes, with R0 = n-3, the contents of the stack contains the nine entries as shown in Figure <ref>b. < g r a p h i c s > The stack during two instances of executing the FACTORIAL subroutine The obvious question you should ask at this point is, \"Why is this such a bad use of recursion, particularly when its representation n! = n * (n-1)! is so elegant?\" To answer this question, we first note how many instructions are executed and how much time is wasted pushing and popping elements off the stack. AND, the second question you should ask is, \"Is there a better way to compute n!?\" Consider this alternative: 36pc[fontsize=911] FACT ST R1,SAVE_R1 ADD R1,R0,#0 ADD R0,R0, #-1 BRz DONE AGAIN MUL R1,R1,R0 ADD R0,R0,#-1 ; R0 gets next integer for MUL BRnp AGAIN DONE ADD R0,R1,#0 ; Move n! to R0 LD R1,SAVE_R1 RET SAVE_R1 .BLKW 1 Implementing FACT iteratively (i.e.,",
    "679": "Figure <ref>b. < g r a p h i c s > The stack during two instances of executing the FACTORIAL subroutine The obvious question you should ask at this point is, \"Why is this such a bad use of recursion, particularly when its representation n! = n * (n-1)! is so elegant?\" To answer this question, we first note how many instructions are executed and how much time is wasted pushing and popping elements off the stack. AND, the second question you should ask is, \"Is there a better way to compute n!?\" Consider this alternative: 36pc[fontsize=911] FACT ST R1,SAVE_R1 ADD R1,R0,#0 ADD R0,R0, #-1 BRz DONE AGAIN MUL R1,R1,R0 ADD R0,R0,#-1 ; R0 gets next integer for MUL BRnp AGAIN DONE ADD R0,R1,#0 ; Move n! to R0 LD R1,SAVE_R1 RET SAVE_R1 .BLKW 1 Implementing FACT iteratively (i.e., without recursion) §.§ Fibonacci, an even worse example Another bad use of recursion is to evaluate the Fibonacci number FIB(n). The Fibonacci numbers are defined for all non-negative integers as follows: FIB(0)=0, FIB(1)=1, and if n > 1, FIB(n) = FIB(n-1) + FIB(n-2). The expression is beautifully elegant, but the execution time is horrendous. Figure <ref> shows a pictorial view of the recursive subroutine FIB. Note that the subroutine FIB is represented as a \"capital F\", and inside the capital F there are two more instances of the capital F. < g r a p h i c s > Pictorial representation of the recursive FIB subroutine The following recursive subroutine computes FIB(n). 36pc[fontsize=911] ;FIB subroutine ; + FIB(0) = 0 ; + FIB(1) = 1 ; + FIB(n) = FIB(n-1) + FIB(n-1) ; ; Input is in R0 ; Return answer in R1 ; FIB ADD R6, R6, #-1 STR R7, R6, #0 ; Push R7, the return linkage ADD R6, R6, #-1 STR R0, R6, #0 ; Push R0, the value of n ADD R6, R6, #-1 STR R2, R6, #0 ; Push R2, which is needed in the subroutine ; Check for base case AND R2, R0,",
    "680": "of the recursive subroutine FIB. Note that the subroutine FIB is represented as a \"capital F\", and inside the capital F there are two more instances of the capital F. < g r a p h i c s > Pictorial representation of the recursive FIB subroutine The following recursive subroutine computes FIB(n). 36pc[fontsize=911] ;FIB subroutine ; + FIB(0) = 0 ; + FIB(1) = 1 ; + FIB(n) = FIB(n-1) + FIB(n-1) ; ; Input is in R0 ; Return answer in R1 ; FIB ADD R6, R6, #-1 STR R7, R6, #0 ; Push R7, the return linkage ADD R6, R6, #-1 STR R0, R6, #0 ; Push R0, the value of n ADD R6, R6, #-1 STR R2, R6, #0 ; Push R2, which is needed in the subroutine ; Check for base case AND R2, R0, #-2 BRnp SKIP ; Z=0 if R0=0,1 ADD R1, R0, #0 ; R0 is the answer BRnzp DONE ; Not a base case, do the recursion SKIP ADD R0, R0, #-1 JSR FIB ; R1 = FIB(n-1) ADD R2, R1, #0 ; Move result before calling FIB again ADD R0, R0, #-1 JSR FIB ; R1 = FIB(n-2) ADD R1, R2, R1 ; R1 = FIB(n-1) + FIB(n-2) ; Restore registers and return DONE LDR R2, R6, #0 ADD R6, R6, #1 LDR R0, R6, #0 ADD R6, R6, #1 LDR R7, R6, #0 ADD R6, R6, #1 RET A recursive implementation of Fibonacci As with all recursive subroutines, we first need to test for the base cases. In this case, we AND n with xFFFE, which produces a non-zero result for all n except n=1 and n=0. If n = 0 or 1, we are effectively done. We move n into R1, restore R2, R0, and R7 (actually, only R2 needs to be restored) and return. If n is not 0 or 1, we need to recursively call FIB twice, once with argument n-1 and once with argument n-2. Finally we add FIB(n-1) to FIB(n-2), put the result in",
    "681": "R2, R1 ; R1 = FIB(n-1) + FIB(n-2) ; Restore registers and return DONE LDR R2, R6, #0 ADD R6, R6, #1 LDR R0, R6, #0 ADD R6, R6, #1 LDR R7, R6, #0 ADD R6, R6, #1 RET A recursive implementation of Fibonacci As with all recursive subroutines, we first need to test for the base cases. In this case, we AND n with xFFFE, which produces a non-zero result for all n except n=1 and n=0. If n = 0 or 1, we are effectively done. We move n into R1, restore R2, R0, and R7 (actually, only R2 needs to be restored) and return. If n is not 0 or 1, we need to recursively call FIB twice, once with argument n-1 and once with argument n-2. Finally we add FIB(n-1) to FIB(n-2), put the result in R1, retore R2, R0, and R7, and return. Note that the recursive subroutine FIB(n) calls FIB twice: once for FIB(n-1) and once for FIB(n-2). FIB(n-1) must call FIB(n-2) and FIB(n-3), and FIB(n-2) must call FIB(n-3) and FIB(n-4). That means FIB(n-2) must be evaluated twice and FIB(n-3) will have to be evaluated three times. Question: Suppose n=10. How many times must this recursive algorithm compute the same function FIB(5)? Compare this algorithm with the non-recursive algorithm, wherein FIB(n) is evaluated iteratively. 36pc[fontsize=911] FIB ST R1,SaveR1 ST R2,SaveR2 ST R3,SaveR3 ST R4,SaveR4 ST R5,SaveR5 ; NOT R0,R0 ADD R0,R0,#1 ; R0 contains -n AND R1,R1,#0 ; Suppose n=0 ADD R5,R1,R0 ; R5 = 0 -n BRz DONE ; if n=0, done almost AND R3,R2,#0 ; if n>0, set up R3 = FIB(0) = 0 ADD R1,R3,#1 ; Suppose n=1 ADD R5,R1,R0 ; R5 = 1-n BRz DONE ; if n=1, done almost ADD R4,R1,#0 ; if n>1, set up R4 = FIB(1) = 1 ; AGAIN ADD R1,R1,#1 ; We begin the iteration of FIB(i) ADD R2,R3,#0 : R2= FIB(i-2) ADD R3,R4,#0 : R3= FIB(i-1) ADD R4,R2,R3 ; R4 = FIB(i) ADD R5,R1,R0 ; is R1=n ? BRn AGAIN ; ADD R0,R4,#0",
    "682": "this recursive algorithm compute the same function FIB(5)? Compare this algorithm with the non-recursive algorithm, wherein FIB(n) is evaluated iteratively. 36pc[fontsize=911] FIB ST R1,SaveR1 ST R2,SaveR2 ST R3,SaveR3 ST R4,SaveR4 ST R5,SaveR5 ; NOT R0,R0 ADD R0,R0,#1 ; R0 contains -n AND R1,R1,#0 ; Suppose n=0 ADD R5,R1,R0 ; R5 = 0 -n BRz DONE ; if n=0, done almost AND R3,R2,#0 ; if n>0, set up R3 = FIB(0) = 0 ADD R1,R3,#1 ; Suppose n=1 ADD R5,R1,R0 ; R5 = 1-n BRz DONE ; if n=1, done almost ADD R4,R1,#0 ; if n>1, set up R4 = FIB(1) = 1 ; AGAIN ADD R1,R1,#1 ; We begin the iteration of FIB(i) ADD R2,R3,#0 : R2= FIB(i-2) ADD R3,R4,#0 : R3= FIB(i-1) ADD R4,R2,R3 ; R4 = FIB(i) ADD R5,R1,R0 ; is R1=n ? BRn AGAIN ; ADD R0,R4,#0 ; if n>1, R0=FIB(n) BRnzp RESTORE DONE ADD R0,R1,#0 ; if n=0,1, FIB(n)=n RESTORE LD R1,SaveR1 LD R2,SaveR2 LD R3,SaveR3 LD R4,SaveR4 LD R5,SaveR5 RET An iterative solution to Fibonacci Much, much faster execution time! §.§ The maze, a good example The reason for shying away from using recursion to compute factorial or Fibonacci is simply that the iterative algorithms are simple enough to understand without the horrendous execution time penalty of recursion. However, it is important to point out that there are times when the expressive beauty of recursion is useful to attack a complicated problem. Such is the case with the following problem, involving a maze: Given a maze and a starting position within the maze, write a program that determines whether or not there is a way out of the maze from your starting postion. A maze A maze can be any size, n by m. For example, Figure <ref> illustrates a 6x6 maze. < g r a p h i c s > Example of a maze Each of the 36 cells of the maze can be characterized by whether there is a door to the north, east, south, or west, and whether there is a",
    "683": "are simple enough to understand without the horrendous execution time penalty of recursion. However, it is important to point out that there are times when the expressive beauty of recursion is useful to attack a complicated problem. Such is the case with the following problem, involving a maze: Given a maze and a starting position within the maze, write a program that determines whether or not there is a way out of the maze from your starting postion. A maze A maze can be any size, n by m. For example, Figure <ref> illustrates a 6x6 maze. < g r a p h i c s > Example of a maze Each of the 36 cells of the maze can be characterized by whether there is a door to the north, east, south, or west, and whether there is a door from the cell to the outside world. Each cell is represented by one word of memory, as follows: 36pc[fontsize=911] Bit[4]=1 if there is a door to the outside world. Bit[4]=0 if no door. Bit[3]=1 if there is a door to the cell to the north. Bit[3]=0 if no door. Bit[2]=1 if there is a door to the cell to the east. Bit[2]=0 if no door. Bit[1]=1 if there is a door to the cell to the south. Bit[1]=0 if no door. Bit[0]=1 if there is a door to the cell to the west. Bit[0]=0 if no door. Specification of each cell in the maze The words are stored in row major order, i.e., Row 1 is stored, then row 2, then row 3, etc. The complete specification of the 6 by 6 maze is shown in Figure <ref>. 36pc[fontsize=911] 00 .ORIG x5000 01 MAZE .FILL x0006 02 .FILL x0007 03 .FILL x0005 04 .FILL x0005 05 .FILL x0003 06 .FILL x0000 07 ; second row: indices 6 to 11 08 .FILL x0008 09 .FILL x000A 0A .FILL x0004 0B .FILL x0003 0C .FILL x000C 0D .FILL x0015 0E ; third row: indices 12 to 17 0F .FILL x0000 10",
    "684": "the east. Bit[2]=0 if no door. Bit[1]=1 if there is a door to the cell to the south. Bit[1]=0 if no door. Bit[0]=1 if there is a door to the cell to the west. Bit[0]=0 if no door. Specification of each cell in the maze The words are stored in row major order, i.e., Row 1 is stored, then row 2, then row 3, etc. The complete specification of the 6 by 6 maze is shown in Figure <ref>. 36pc[fontsize=911] 00 .ORIG x5000 01 MAZE .FILL x0006 02 .FILL x0007 03 .FILL x0005 04 .FILL x0005 05 .FILL x0003 06 .FILL x0000 07 ; second row: indices 6 to 11 08 .FILL x0008 09 .FILL x000A 0A .FILL x0004 0B .FILL x0003 0C .FILL x000C 0D .FILL x0015 0E ; third row: indices 12 to 17 0F .FILL x0000 10 .FILL x000C 11 .FILL x0001 12 .FILL x000A 13 .FILL x0002 14 .FILL x0002 15 ; fourth row: indices 18 to 23 16 .FILL x0006 17 .FILL x0005 18 .FILL x0007 19 .FILL x000D 1A .FILL x000B 1B .FILL x000A 1C ; fifth row: indices 24 to 29 1D .FILL x000A 1E .FILL x0000 1F .FILL x000A 20 .FILL x0002 21 .FILL x0008 22 .FILL x000A 23 ; sixth row: indices 30 to 35 24 .FILL x0008 25 .FILL x0000 26 .FILL x001A 27 .FILL x000C 28 .FILL x0001 29 .FILL x0008 2A .END Specification of the maze of Figure 8.20 A recursive subroutine to exit the maze Our job is to develop an algorithm to determine whether we can exit a maze from a given starting position within the maze. With all the intricate paths that our attempts can take, keeping track of all that bookkeeping looks daunting. Recursion allows us to not have to keep track of the paths at all! Figure <ref> shows a pictorial view of a recursive subroutine FIND_EXIT, an algorithm for determining whether or not we can exit the maze. Note that the subroutine FIND_EXIT is shown as an octagon, and inside the octagon",
    "685": "21 .FILL x0008 22 .FILL x000A 23 ; sixth row: indices 30 to 35 24 .FILL x0008 25 .FILL x0000 26 .FILL x001A 27 .FILL x000C 28 .FILL x0001 29 .FILL x0008 2A .END Specification of the maze of Figure 8.20 A recursive subroutine to exit the maze Our job is to develop an algorithm to determine whether we can exit a maze from a given starting position within the maze. With all the intricate paths that our attempts can take, keeping track of all that bookkeeping looks daunting. Recursion allows us to not have to keep track of the paths at all! Figure <ref> shows a pictorial view of a recursive subroutine FIND_EXIT, an algorithm for determining whether or not we can exit the maze. Note that the subroutine FIND_EXIT is shown as an octagon, and inside the octagon there are four more instances of octagons, indicating recursive calls to FIND_EXIT. If we can exit the maze, we will return from the subroutine with R1=1, if not, we will return with R1=0. < g r a p h i c s > Pictorial representation of the recursive subroutine to exit the maze The algorithm works as follows: In each cell, we first ask if there is an exit from this cell to the outside world. If yes, we return the value 1 and return. If not, we ask whether we should try the cell to the north, the east, the south, or the west. In order to try a cell in any direction, clearly there must be a door to the cell in that direction. Further, we want to be sure we do not end up in an infinite loop where for example, there are doors that allow us to go North one cell, and from there East one cell, and from there South one cell, and from there West one cell, putting us right back where we started. To prevent situations like that from happening, we put a \"breadcrumb\" in each cell we visit, and only go to",
    "686": "cell, we first ask if there is an exit from this cell to the outside world. If yes, we return the value 1 and return. If not, we ask whether we should try the cell to the north, the east, the south, or the west. In order to try a cell in any direction, clearly there must be a door to the cell in that direction. Further, we want to be sure we do not end up in an infinite loop where for example, there are doors that allow us to go North one cell, and from there East one cell, and from there South one cell, and from there West one cell, putting us right back where we started. To prevent situations like that from happening, we put a \"breadcrumb\" in each cell we visit, and only go to a cell and JSR FIND_EXIT if we have not visited that cell before. Thus, our algorithm: a. From our cell, we ask if we can exit. If yes, we are done. We exit with R1=1. b. If not, we put a breadcrumb in our cell. Our breadcrumb is bit[15] of the word corresponding to our current cell. We set it to 1. c. We ask two questions: Is there a door to the north, and have we never visited the cell to the North before? If the answer to both is yes, we set the address to the cell to the North, and JSR FIND_EXIT. We set the address to the cell to the north by simply subtracting 6 from the address of the current cell. Why 6? Because the cells are stored in row major order and the number of columns in the maze is 6. d. If the answer to either question is no, or if going north resulted in failure, we ask: Is there a door to the East, and have we never visited that cell before? If the answer to both is yes, we set the address to the address of the cell to the East",
    "687": "to 1. c. We ask two questions: Is there a door to the north, and have we never visited the cell to the North before? If the answer to both is yes, we set the address to the cell to the North, and JSR FIND_EXIT. We set the address to the cell to the north by simply subtracting 6 from the address of the current cell. Why 6? Because the cells are stored in row major order and the number of columns in the maze is 6. d. If the answer to either question is no, or if going north resulted in failure, we ask: Is there a door to the East, and have we never visited that cell before? If the answer to both is yes, we set the address to the address of the cell to the East (by adding 1 to the address) and JSR FIND_EXIT. e. If going East does not get us out, we repeat the question for South, and if that does not work, then for West. f. If we end up with no door to the West to a cell we have not visited, or if there is a door and we haven't visited, but it results in failure, we are done. We can not exit the maze from our starting position. We set R1=0, and return. Figure <ref> shows a recursive algorithm that determines if we can exit the maze, given our starting address. 36pc[fontsize=911] ; Recursive subroutine that determines if there is a path from current cell ; to the outside world. ; input: R0, current cell address ; output: R1, YES (1) or NO (0) .ORIG x4000 01 FIND_EXIT ; save modified registers into the stack. 02 ADD R6, R6, #-1 03 STR R2, R6, #0 ; R2 holds the cell data of the caller 04 ADD R6, R6, #-1 05 STR R3, R6, #0 ; R3 holds the cell address of the caller 06 ADD R6, R6, #-1 07 STR R7, R6, #0 ; R7 holds the PC of",
    "688": "visited, but it results in failure, we are done. We can not exit the maze from our starting position. We set R1=0, and return. Figure <ref> shows a recursive algorithm that determines if we can exit the maze, given our starting address. 36pc[fontsize=911] ; Recursive subroutine that determines if there is a path from current cell ; to the outside world. ; input: R0, current cell address ; output: R1, YES (1) or NO (0) .ORIG x4000 01 FIND_EXIT ; save modified registers into the stack. 02 ADD R6, R6, #-1 03 STR R2, R6, #0 ; R2 holds the cell data of the caller 04 ADD R6, R6, #-1 05 STR R3, R6, #0 ; R3 holds the cell address of the caller 06 ADD R6, R6, #-1 07 STR R7, R6, #0 ; R7 holds the PC of the caller 08 09 ; Move cell address to R3, since we need to use R0 0A ; as the input to recursive subroutine calls. 0B ADD R3, R0, #0 0C 0D ; If the exit is in this cell, return YES 0E LDR R2, R0, #0 ; R2 now holds the current cell data 0F LD R7, EXIT_MASK 10 AND R7, R2, R7 11 BRnp DONE_YES 12 13 ; Put breadcrumb in the current cell. 14 LD R7, BREADCRUMB 15 ADD R2, R2, R7 16 STR R2, R0, #0 17 18 ; check the north cell for a path to exit 19 CHECK_NORTH LD R7, NORTH_MASK 1A AND R7, R2, R7 1B BRz CHECK_EAST ; If north is blocked, check east 1C LDR R7, R3, #-6 1D BRn CHECK_EAST ; If a breadcrumb in the north cell, check east 1E ADD R0, R3, #-6 1F JSR FIND_EXIT ; Recursively check the north cell 20 ADD R1, R1, #0 21 BRp DONE_YES ; If a path from north cell found, return YES 22 23 ; check the north cell for a path to exit 24 CHECK_EAST LD R7, EAST_MASK 25 AND R7, R2, R7 26 BRz CHECK_SOUTH ; If the",
    "689": "AND R7, R2, R7 11 BRnp DONE_YES 12 13 ; Put breadcrumb in the current cell. 14 LD R7, BREADCRUMB 15 ADD R2, R2, R7 16 STR R2, R0, #0 17 18 ; check the north cell for a path to exit 19 CHECK_NORTH LD R7, NORTH_MASK 1A AND R7, R2, R7 1B BRz CHECK_EAST ; If north is blocked, check east 1C LDR R7, R3, #-6 1D BRn CHECK_EAST ; If a breadcrumb in the north cell, check east 1E ADD R0, R3, #-6 1F JSR FIND_EXIT ; Recursively check the north cell 20 ADD R1, R1, #0 21 BRp DONE_YES ; If a path from north cell found, return YES 22 23 ; check the north cell for a path to exit 24 CHECK_EAST LD R7, EAST_MASK 25 AND R7, R2, R7 26 BRz CHECK_SOUTH ; If the way to east is blocked, check south 27 LDR R7, R3, #1 28 BRn CHECK_SOUTH ; If a breadcrumb in the east cell, check south 29 ADD R0, R3, #1 2A JSR FIND_EXIT ; Recursively check the east cell 2B ADD R1, R1, #0 2C BRp DONE_YES ; If a path from east cell found, return YES 2D a recursive subroutine to determine if there is an exit from the maze36pc[fontsize=911] 2E ; check the south cell for a path to exit 2F CHECK_SOUTH LD R7, SOUTH_MASK 30 AND R7, R2, R7 31 BRz CHECK_WEST ; If the way to south is blocked, check west 32 LDR R7, R3, #6 33 BRn CHECK_WEST ; If a breadcrumb in the south cell, check west 34 ADD R0, R3, #6 35 JSR FIND_EXIT ; Recursively check the south cell 36 ADD R1, R1, #0 37 BRp DONE_YES ; If a path from south cell found, return YES 38 39 ; check the west cell for a path to exit 3A CHECK_WEST LD R7, WEST_MASK 3B AND R7, R2, R7 3C BRz DONE_NO ; If the way to west is blocked, return NO 3D LDR R7, R3, #-1 3E BRn DONE_NO ; If",
    "690": "subroutine to determine if there is an exit from the maze36pc[fontsize=911] 2E ; check the south cell for a path to exit 2F CHECK_SOUTH LD R7, SOUTH_MASK 30 AND R7, R2, R7 31 BRz CHECK_WEST ; If the way to south is blocked, check west 32 LDR R7, R3, #6 33 BRn CHECK_WEST ; If a breadcrumb in the south cell, check west 34 ADD R0, R3, #6 35 JSR FIND_EXIT ; Recursively check the south cell 36 ADD R1, R1, #0 37 BRp DONE_YES ; If a path from south cell found, return YES 38 39 ; check the west cell for a path to exit 3A CHECK_WEST LD R7, WEST_MASK 3B AND R7, R2, R7 3C BRz DONE_NO ; If the way to west is blocked, return NO 3D LDR R7, R3, #-1 3E BRn DONE_NO ; If a breadcrumb in the west cell, return NO 3F ADD R0, R3, #-1 40 JSR FIND_EXIT ; Recursively check the west cell 41 ADD R1, R1, #0 42 BRp DONE_YES ; If a path from west cell found, return YES 43 44 DONE_NO AND R1, R1, #0 45 BR RESTORE 46 47 DONE_YES AND R1, R1, #0 48 ADD R1, R1, #1 49 4A RESTORE ADD R0, R3, #0 ; restore R0 from R3 4B ; restore the rest of the modified registers from the stack. 4C LDR R7, R6, #0 4D ADD R6, R6, #1 4E LDR R3, R6, #0 4F ADD R6, R6, #1 50 LDR R2, R6, #0 51 ADD R6, R6, #1 52 RET 53 54 BREADCRUMB .FILL x8000 55 EXIT_MASK .FILL x0010 56 NORTH_MASK .FILL x0008 57 EAST_MASK .FILL x0004 58 SOUTH_MASK .FILL x0002 59 WEST_MASK .FILL x0001 5A .END a recursive subroutine to determine if there is an exit from the maze (continued) § THE QUEUE Our next data structure is the queue. Recall that the property that defined the concept of \"stack\" was LIFO, the last thing we pushed onto the stack is the first thing we pop off the stack. The defining",
    "691": "R1, #1 49 4A RESTORE ADD R0, R3, #0 ; restore R0 from R3 4B ; restore the rest of the modified registers from the stack. 4C LDR R7, R6, #0 4D ADD R6, R6, #1 4E LDR R3, R6, #0 4F ADD R6, R6, #1 50 LDR R2, R6, #0 51 ADD R6, R6, #1 52 RET 53 54 BREADCRUMB .FILL x8000 55 EXIT_MASK .FILL x0010 56 NORTH_MASK .FILL x0008 57 EAST_MASK .FILL x0004 58 SOUTH_MASK .FILL x0002 59 WEST_MASK .FILL x0001 5A .END a recursive subroutine to determine if there is an exit from the maze (continued) § THE QUEUE Our next data structure is the queue. Recall that the property that defined the concept of \"stack\" was LIFO, the last thing we pushed onto the stack is the first thing we pop off the stack. The defining property of the abstract data type queue is FIFO. FIFO stands for \"First in First out.\" The data structure \"queue\" is like a queue in a polite supermarket, or a polite ticket counter. That is, the first person in line is the first person serviced. In the context of the data structure, this means we need to keep track of two ends of the storage structure: a FRONT pointer for servicing (i.e., removing elements from the front of the queue) and a REAR pointer for entering (i.e., inserting into the rear of the queue). Figure <ref> shows a block of six sequential memory locations that have been allocated for storing elements in the queue. The queue grows from x8000 to x8005. We arbitrarily assign the FRONT pointer to the location just before the first element of the queue. We assign the REAR pointer to the location containing the most recent element that was added to the queue. Let's use R3 as our FRONT pointer and R4 as our REAR pointer. < g r a p h i c s > A queue allocated to memory locations x8000 to x8005 Figure <ref>a shows a queue in which five values were entered",
    "692": "two ends of the storage structure: a FRONT pointer for servicing (i.e., removing elements from the front of the queue) and a REAR pointer for entering (i.e., inserting into the rear of the queue). Figure <ref> shows a block of six sequential memory locations that have been allocated for storing elements in the queue. The queue grows from x8000 to x8005. We arbitrarily assign the FRONT pointer to the location just before the first element of the queue. We assign the REAR pointer to the location containing the most recent element that was added to the queue. Let's use R3 as our FRONT pointer and R4 as our REAR pointer. < g r a p h i c s > A queue allocated to memory locations x8000 to x8005 Figure <ref>a shows a queue in which five values were entered into the queue. Since FRONT = x8001, the values 45 in memory location x8000 and 17 in x8001 must have been removed, and the front element of the queue is 23, the value contained in x8002. Note that the values 45 and 17 are still contained in memory locations x8000 and x8001, even though they have been removed. Like the Stack, studied already, that is the nature of load instructions. When a value is removed by means of a load instruction, the contents of the memory location is not erased. The contents of the memory location are simply copied into the destination register. However, since FRONT contains the address x8001, there is no way to load from locations x8000 and x8001 as long as locations x8000 to x8005 behave like a queue – i.e., as long as the accesses are FIFO. §.§ The basic operations: remove from front, insert at rear Since FRONT points to the location just in front of first element in the queue, we remove a value by first incrementing FRONT, and then loading the value stored at that incremented address. In our example, the next value to be removed is the value 23, which is at",
    "693": "Stack, studied already, that is the nature of load instructions. When a value is removed by means of a load instruction, the contents of the memory location is not erased. The contents of the memory location are simply copied into the destination register. However, since FRONT contains the address x8001, there is no way to load from locations x8000 and x8001 as long as locations x8000 to x8005 behave like a queue – i.e., as long as the accesses are FIFO. §.§ The basic operations: remove from front, insert at rear Since FRONT points to the location just in front of first element in the queue, we remove a value by first incrementing FRONT, and then loading the value stored at that incremented address. In our example, the next value to be removed is the value 23, which is at the front of the queue, in memory location x8002. The following code removes 23 from the queue: ADD R3,R3,#1 LDR R0,R3,#0 yielding the structure in Figure <ref>b. Since REAR = x8004, the last value to enter the queue is 74. The values in in the queue in Figure <ref>b are 2, and 74. To insert another element (for example, 10) at the back of the queue, the following code is executed: ADD R4,R4,#1 STR R0,R4,#0 resulting in Figure <ref>c. §.§ Wrap-around At first blush, it looks like we can not insert any more elements into the queue. Not so! When we remove a value from the queue, that location becomes available for storing another element. We do that by allowing the available storage locations to wrap around. For example, suppose we want to add 20 to the queue. Since there is nothing stored in x8000 (recall 45 had been previously removed), we can store 20 in x8000. The result is shown in Figure <ref>d. \"Wrap around\" works by having our removal and insertion algorithms test the contents of FRONT and REAR for the value x8005. If we wish to insert, and REAR contains x8005, we know we have reached the",
    "694": "at the back of the queue, the following code is executed: ADD R4,R4,#1 STR R0,R4,#0 resulting in Figure <ref>c. §.§ Wrap-around At first blush, it looks like we can not insert any more elements into the queue. Not so! When we remove a value from the queue, that location becomes available for storing another element. We do that by allowing the available storage locations to wrap around. For example, suppose we want to add 20 to the queue. Since there is nothing stored in x8000 (recall 45 had been previously removed), we can store 20 in x8000. The result is shown in Figure <ref>d. \"Wrap around\" works by having our removal and insertion algorithms test the contents of FRONT and REAR for the value x8005. If we wish to insert, and REAR contains x8005, we know we have reached the end of our available storage and we must see if x8000 is available. If we wish to remove, we must first see if FRONT contains the address x8005. If it does, the front of the queue is in x8000. Thus our code for remove and insert have to include a test for wrap-around. The code for remove becomes: LD R2, LAST ADD R2,R3,R2 BRnp SKIP_1 LD R3,FIRST BR SKIP_2 SKIP_1 ADD R3,R3,#1 SKIP_2 LDR R0,R3,#0 ; R0 gets the front of the queue RET LAST .FILL x7FFB ; LAST contains the negative of 8005 FIRST .FILL x8000 The code for insert is similar. If REAR contains x8005, we need to set R4 to x8000 before we can insert an element at the rear of the queue. The code to insert is as follows: LD R2, LAST ADD R2,R4,R2 BRnp SKIP_1 LD R4,FIRST BR SKIP_2 SKIP_1 ADD R4,R4,#1 SKIP_2 STR R0,R4,#0 ; R0 gets the front of the queue RET LAST .FILL 7FFB ; LAST contains the negative of 8005 FIRST .FILL x8000 §.§ How many elements can we store in a queue? Let's look again at Figure <ref>d. There are four values in the queue: 2, 74, 10, and 20.",
    "695": "LAST ADD R2,R3,R2 BRnp SKIP_1 LD R3,FIRST BR SKIP_2 SKIP_1 ADD R3,R3,#1 SKIP_2 LDR R0,R3,#0 ; R0 gets the front of the queue RET LAST .FILL x7FFB ; LAST contains the negative of 8005 FIRST .FILL x8000 The code for insert is similar. If REAR contains x8005, we need to set R4 to x8000 before we can insert an element at the rear of the queue. The code to insert is as follows: LD R2, LAST ADD R2,R4,R2 BRnp SKIP_1 LD R4,FIRST BR SKIP_2 SKIP_1 ADD R4,R4,#1 SKIP_2 STR R0,R4,#0 ; R0 gets the front of the queue RET LAST .FILL 7FFB ; LAST contains the negative of 8005 FIRST .FILL x8000 §.§ How many elements can we store in a queue? Let's look again at Figure <ref>d. There are four values in the queue: 2, 74, 10, and 20. Suppose we insert 30 and 40 at the rear of the queue, producing Figure <ref> e. Both R3 and R4 contain the same address (x8002), and the queue is full. Now suppose we start removing elements from the front of the queue. If we remove 2, which is at the front of the queue, R3 will contain the address x8003. If we remove the remaining five elements in the queue, we will have what is shown in Figure <ref>f. Note that the FRONT and REAR pointers for figure e and f are identical, yet Figure <ref>e describes a full queue and Figure <ref>f describes an empty queue! Clearly that is not acceptable. Our answer is to allow a queue to store only n-1 elements if space for n elements have been allocated. That is, if inserting an nth element into the queue would cause FRONT to equal REAR, we do not allow that insertion. We declare the queue full when there are n-1 elements in the queue. Let's look again at the queue in Figure <ref>d. There are four elements in the queue, from front to rear: 2, 74, 10, and 20, and two empty slots, x8001 and x8002. We",
    "696": "If we remove the remaining five elements in the queue, we will have what is shown in Figure <ref>f. Note that the FRONT and REAR pointers for figure e and f are identical, yet Figure <ref>e describes a full queue and Figure <ref>f describes an empty queue! Clearly that is not acceptable. Our answer is to allow a queue to store only n-1 elements if space for n elements have been allocated. That is, if inserting an nth element into the queue would cause FRONT to equal REAR, we do not allow that insertion. We declare the queue full when there are n-1 elements in the queue. Let's look again at the queue in Figure <ref>d. There are four elements in the queue, from front to rear: 2, 74, 10, and 20, and two empty slots, x8001 and x8002. We can insert 30 in x8001, producing Figure <ref>a. That is, 30 is the 5th element inserted in the queue. Since 6 words have been allocated for the queue, and we now have 5 elements in the queue. We declare the queue full, and do not allow a 6th element to be inserted. Suppose we now start removing elements from the queue until the queue is empty, as shown in Figure <ref>b. Now there is no ambiguity between a full and empty queue since if the queue is empty, FRONT=REAR. < g r a p h i c s > A full queue and an empty queue §.§ Tests for Underflow, Overflow As was the case with the stack, we can only remove an element from a queue if there are elements in the queue. Likewise, we can only insert elements in the queue if it is not full. If the queue is empty and we try to remove an element, we have an underflow condition. If the queue is full and we try to insert an element, we have an overflow condition. In both cases, if we are using a subroutine to manage the queue, we need to report success",
    "697": "queue until the queue is empty, as shown in Figure <ref>b. Now there is no ambiguity between a full and empty queue since if the queue is empty, FRONT=REAR. < g r a p h i c s > A full queue and an empty queue §.§ Tests for Underflow, Overflow As was the case with the stack, we can only remove an element from a queue if there are elements in the queue. Likewise, we can only insert elements in the queue if it is not full. If the queue is empty and we try to remove an element, we have an underflow condition. If the queue is full and we try to insert an element, we have an overflow condition. In both cases, if we are using a subroutine to manage the queue, we need to report success or failure to the calling program. As with the stack, we will use R5 for this purpose. The test for underflow is straightforward. We saw from Figure <ref> that if FRONT=REAR, the queue is empty. Our code to test for underflow is therefore AND R5,R5,#0 ; Initialize R5 to 0 NOT R2,R3 ADD R2,R2,#1 ; R2 contains negative of R3 ADD R2,R2,R4 BRz UNDERFLOW ; code to remove the front of the queue and return success. UNDERFLOW ADD R5,R5,#1 RET That is, we first check to see if the queue is empty; i.e., if R3=R4. If so, we branch to UNDERFLOW, where we set R5 to failure, restore R1, and return. If not, carry out the code to remove the front of the queue. The test for overflow is similar. To insert an element to the back of the queue, we first increment the REAR pointer. If that causes FRONT=REAR, then the queue already contains n-1 elements, which means it is full so we can not insert any more elements. We decrement the REAR pointer, set R5 to 1, and return. §.§ The complete story We conclude our attention to queues with a subroutine that allows elements to be removed",
    "698": "ADD R2,R2,R4 BRz UNDERFLOW ; code to remove the front of the queue and return success. UNDERFLOW ADD R5,R5,#1 RET That is, we first check to see if the queue is empty; i.e., if R3=R4. If so, we branch to UNDERFLOW, where we set R5 to failure, restore R1, and return. If not, carry out the code to remove the front of the queue. The test for overflow is similar. To insert an element to the back of the queue, we first increment the REAR pointer. If that causes FRONT=REAR, then the queue already contains n-1 elements, which means it is full so we can not insert any more elements. We decrement the REAR pointer, set R5 to 1, and return. §.§ The complete story We conclude our attention to queues with a subroutine that allows elements to be removed from the front or inserted into the rear of the queue, wraps around when one of the pointers reaches the last element, and returns with a report of success (R5=0) or failure (R5=1) depending on whether the access succeeds or the access fails due to an underflow or overflow condition. To make this concrete, we will tie this subroutine to the queue of Figure <ref>, where we have allocated locations x8000 to x8005 for our queue, x8000 being the FIRST location and x8005 being the LAST location. To insert, we first have to make sure the queue is not full. To do that, we increment the REAR pointer (R4) and then test REAR=FRONT. If the REAR pointer was initially x8005, we increment REAR by setting it to x8000; i.e., we need to wrap around. If the queue is full, we need to set REAR back to its original value, and return, reporting failure (R5=1). If the queue is not full we store the item we wish to insert (which is in R0) in REAR, and return, reporting success (R5=0). To remove, we first make sure the queue is not empty by testing whether REAR=FRONT. If REAR=FRONT, the queue is empty,",
    "699": "the queue of Figure <ref>, where we have allocated locations x8000 to x8005 for our queue, x8000 being the FIRST location and x8005 being the LAST location. To insert, we first have to make sure the queue is not full. To do that, we increment the REAR pointer (R4) and then test REAR=FRONT. If the REAR pointer was initially x8005, we increment REAR by setting it to x8000; i.e., we need to wrap around. If the queue is full, we need to set REAR back to its original value, and return, reporting failure (R5=1). If the queue is not full we store the item we wish to insert (which is in R0) in REAR, and return, reporting success (R5=0). To remove, we first make sure the queue is not empty by testing whether REAR=FRONT. If REAR=FRONT, the queue is empty, so we return, reporting failure. If REAR is not the same as FRONT, the queue is not empty so we can remove the front element. To do this we first test to see if FRONT=x8005. if it is, we set FRONT=x8000. If it isn't, we increment FRONT. In both cases, we then load the value from that memory location into R0, and return, reporting success. Figure <ref> shows the complete subroutine. 36pc[fontsize=911] 00 ;Input: R0 for item to be inserted, R3 is FRONT, R4 is REAR 01 ;Output: R0 for item to be removed 02 ; 03 INSERT ST R1,SaveR1 ; Save register we need 04 AND R5,R5,#0 ; Set R5 to success code 05 ; Initialization complete 06 LD R1,NEG_LAST 07 ADD R1,R1,R4 ; R1 = REAR MINUS x8005 08 BRnp SKIP1 ; SKIP WRAP AROUND 09 LD R4,FIRST ; WRAP AROUND, R4=x8000 0A BR SKIP2 0B SKIP1 ADD R4,R4,#1 ; NO WRAP AROUND, R4=R4+1 0C SKIP2 NOT R1,R4 0D ADD R1,R1,#1 ; R1= NEG REAR 0E ADD R1,R1,R3 ; R1= FRONT-REAR 0F BRz FULL 10 STR R0,R4,#0 ; DO THE INSERT 11 BR DONE 12 FULL LD R1,NEG_FIRST 13 ADD R1,R1,R4 ; R1 = REAR MINUS x8000 14",
    "700": "R0, and return, reporting success. Figure <ref> shows the complete subroutine. 36pc[fontsize=911] 00 ;Input: R0 for item to be inserted, R3 is FRONT, R4 is REAR 01 ;Output: R0 for item to be removed 02 ; 03 INSERT ST R1,SaveR1 ; Save register we need 04 AND R5,R5,#0 ; Set R5 to success code 05 ; Initialization complete 06 LD R1,NEG_LAST 07 ADD R1,R1,R4 ; R1 = REAR MINUS x8005 08 BRnp SKIP1 ; SKIP WRAP AROUND 09 LD R4,FIRST ; WRAP AROUND, R4=x8000 0A BR SKIP2 0B SKIP1 ADD R4,R4,#1 ; NO WRAP AROUND, R4=R4+1 0C SKIP2 NOT R1,R4 0D ADD R1,R1,#1 ; R1= NEG REAR 0E ADD R1,R1,R3 ; R1= FRONT-REAR 0F BRz FULL 10 STR R0,R4,#0 ; DO THE INSERT 11 BR DONE 12 FULL LD R1,NEG_FIRST 13 ADD R1,R1,R4 ; R1 = REAR MINUS x8000 14 BRnp SKIP3 15 LD R4,LAST ; UNDO WRAP AROUND, REAR=x8005 16 BR SKIP4 17 SKIP3 ADD R4,R4,#-1 ; NO WRAP AROUND, R4=R4-1 18 SKIP4 ADD R5,R5,#1 ; R5=FAILURE 19 BR DONE 1A ; 1B REMOVE ST R1,SaveR1 ; Save register we need 1C AND R5,R5,#0 ; Set R5 to success code 1D ; Initialization complete 1E NOT R1,R4 1F ADD R1,R1,#1 ; R1= NEG REAR 20 ADD R1,R1,R3 ; R1= FRONT-REAR 21 BRz EMPTY 22 LD R1, NEG_LAST 23 ADD R1,R1,R3 ; R1= FRONT MINUS x8005 24 BRnp SKIP5 25 LD R3, FIRST ; R3=x8000 26 BR SKIP6 27 SKIP5 ADD R3,R3,#1 ; R3=R3+1 28 SKIP6 LDR R0,R3,#0 ; DO THE REMOVE 29 BR DONE 2A EMPTY ADD R5,R5.#1 ; R5=FAILURE 2B DONE LD R1,SaveR1 ; Restore register 2C RET 2D FIRST .FILL x8000 2E NEG_FIRST .FILL x8000 2F LAST .FILL x8005 30 NEG_LAST .FILL x7FFB 31 SaveR1 .BLKW 1 The complete queue subroutine § CHARACTER STRINGS Our final data structure: the character string! The last data structure we will study in Chapter 8 is the character string, where data is organized as a one-dimensional array of ASCII codes, usually representing a person's name, address, or some other alphanumeric string.",
    "701": "R1,R1,#1 ; R1= NEG REAR 20 ADD R1,R1,R3 ; R1= FRONT-REAR 21 BRz EMPTY 22 LD R1, NEG_LAST 23 ADD R1,R1,R3 ; R1= FRONT MINUS x8005 24 BRnp SKIP5 25 LD R3, FIRST ; R3=x8000 26 BR SKIP6 27 SKIP5 ADD R3,R3,#1 ; R3=R3+1 28 SKIP6 LDR R0,R3,#0 ; DO THE REMOVE 29 BR DONE 2A EMPTY ADD R5,R5.#1 ; R5=FAILURE 2B DONE LD R1,SaveR1 ; Restore register 2C RET 2D FIRST .FILL x8000 2E NEG_FIRST .FILL x8000 2F LAST .FILL x8005 30 NEG_LAST .FILL x7FFB 31 SaveR1 .BLKW 1 The complete queue subroutine § CHARACTER STRINGS Our final data structure: the character string! The last data structure we will study in Chapter 8 is the character string, where data is organized as a one-dimensional array of ASCII codes, usually representing a person's name, address, or some other alphanumeric string. Figure <ref> shows a character string representing the name of the famous late Stanford professor Bill Linvill, stored in 13 consecutive words of memory, starting at location x5000. The ASCII code for each letter of his name is stored in a separate word of memory. Since an ASCII code consists of one byte of memory, we add a leading x00 to each location. For example, x5000 contains x0042 since the ASCII code for a capital \"B\" is x42. We need 13 memory locations, one word for each of the 11 letters in his name, one word for the ASCII code x20 representing the space between his first and last names, and finally the null character x0000 to indicate that we have reached the end of the character string. Different alphanumeric strings require character strings of different lengths, but that is no problem since we allocate however many words of memory are needed, followed by the null character x0000 to indicate the end of the character string. < g r a p h i c s > Character string representing the name \"Bill Linvill\" A common use of a character string is to identify a body of information associated with a",
    "702": "to each location. For example, x5000 contains x0042 since the ASCII code for a capital \"B\" is x42. We need 13 memory locations, one word for each of the 11 letters in his name, one word for the ASCII code x20 representing the space between his first and last names, and finally the null character x0000 to indicate that we have reached the end of the character string. Different alphanumeric strings require character strings of different lengths, but that is no problem since we allocate however many words of memory are needed, followed by the null character x0000 to indicate the end of the character string. < g r a p h i c s > Character string representing the name \"Bill Linvill\" A common use of a character string is to identify a body of information associated with a particular person. Figure <ref> shows such a body of information (often called a personnel record) associated with an employee of a company. < g r a p h i c s > Mary Jones' personnel record Our example personnel record consists of six words of sequential memory, starting at location x4000, as follows: 1. The first word contains the starting address of a character string containing the person's last name. The pointer, in location x4000 is the address x6000. The six-word character string, starting at location x6000, contains the ASCII code for \"Jones,\" terminated with the null character. 2. The second word, at x4001, contains a pointer to the character string of the person's first name, in this case \"Mary,\" starting at location x4508. 3. The third word, at x4002, contains a pointer (xCA9B) to her 9-digit social security number, the unique identifier for all persons working in the United States. 4. The fourth word, at x4003, contains her salary (in thousands of dollars). 5. The fifth word contains how long she has worked for the company. 6. The sixth word is a pointer (x8E25) to the character string identifying her job title, in this case \"Engineer.\" In summary, an",
    "703": "address of a character string containing the person's last name. The pointer, in location x4000 is the address x6000. The six-word character string, starting at location x6000, contains the ASCII code for \"Jones,\" terminated with the null character. 2. The second word, at x4001, contains a pointer to the character string of the person's first name, in this case \"Mary,\" starting at location x4508. 3. The third word, at x4002, contains a pointer (xCA9B) to her 9-digit social security number, the unique identifier for all persons working in the United States. 4. The fourth word, at x4003, contains her salary (in thousands of dollars). 5. The fifth word contains how long she has worked for the company. 6. The sixth word is a pointer (x8E25) to the character string identifying her job title, in this case \"Engineer.\" In summary, an employee named Mary Jones, social security number 012654621, an Engineer, has been with the company 4 years, and earns $84,000/year salary. One can write computer programs that examine employee records looking for various personnel information. For example, if one wanted to know an employee's salary, a program could examine employee records, looking for that employee. The program would call a subroutine that compares the character string representing an employee's Social Security Number with the characters of the social security number of the person the subroutine is searching for. If all the characters match, the subroutine would return a success code (R5=0), and the program would go on to read the salary information in the fourth word of the personnel record. If all the characters do not match, the subroutine would return a failure code (R5=1), and the program would call the subroutine with the starting address of another employee's social security number. Figure <ref> is a subroutine that compares two character strings to see if they are identical. 36pc[fontsize=911] STRCMP ST R0,SaveR0 ST R1,SaveR1 ST R2,SaveR2 ST R3,SaveR3 ; AND R5,R5,#0 ; R5 <– Match ; NEXTCHAR LDR R2,R0,#0 ; R2 contains character from 1st string LDR R3,R1,#0 ; R3",
    "704": "subroutine that compares the character string representing an employee's Social Security Number with the characters of the social security number of the person the subroutine is searching for. If all the characters match, the subroutine would return a success code (R5=0), and the program would go on to read the salary information in the fourth word of the personnel record. If all the characters do not match, the subroutine would return a failure code (R5=1), and the program would call the subroutine with the starting address of another employee's social security number. Figure <ref> is a subroutine that compares two character strings to see if they are identical. 36pc[fontsize=911] STRCMP ST R0,SaveR0 ST R1,SaveR1 ST R2,SaveR2 ST R3,SaveR3 ; AND R5,R5,#0 ; R5 <– Match ; NEXTCHAR LDR R2,R0,#0 ; R2 contains character from 1st string LDR R3,R1,#0 ; R3 contains character from 2nd string BRnp COMPARE ; String is not done, continue comparing ADD R2,R2,#0 BRz DONE ; If both strings done, match found COMPARE NOT R2,R2 ADD R2,R2,#1 ; R2 contains negative of character ADD R2,R2,R3 ; Compare the 2 characters BRnp FAIL ; Not equal, no match ADD R0,R0,#1 ADD R1,R1,#1 BRnzp NEXTCHAR ; Move on to next pair of characters ; FAIL ADD R5,R5,#1 ; R5 <– No match ; DONE LD R0,SaveR0 LD R1,SaveR1 LD R2,SaveR2 LD R3,SaveR3 RET ; SaveR0 .BLKW 1 SaveR1 .BLKW 1 SaveR2 .BLKW 1 SaveR3 .BLKW 1 Subroutine to compare two character strings Another example: A character string representing an \"integer.\" We can also represent arbitrarily long integers by means of character strings. For example, Figure <ref> is a character string representing the integer 79,245. < g r a p h i c s > A character string, representing the integer 79,245, with one ASCII code per decimal digit Figure <ref> is a subroutine that examines such a character string to be sure that in fact all ASCII codes represent decimal digits. If all the entries in the character string are ASCII codes of decimal digits (between x30 and x39),",
    "705": "next pair of characters ; FAIL ADD R5,R5,#1 ; R5 <– No match ; DONE LD R0,SaveR0 LD R1,SaveR1 LD R2,SaveR2 LD R3,SaveR3 RET ; SaveR0 .BLKW 1 SaveR1 .BLKW 1 SaveR2 .BLKW 1 SaveR3 .BLKW 1 Subroutine to compare two character strings Another example: A character string representing an \"integer.\" We can also represent arbitrarily long integers by means of character strings. For example, Figure <ref> is a character string representing the integer 79,245. < g r a p h i c s > A character string, representing the integer 79,245, with one ASCII code per decimal digit Figure <ref> is a subroutine that examines such a character string to be sure that in fact all ASCII codes represent decimal digits. If all the entries in the character string are ASCII codes of decimal digits (between x30 and x39), the subroutine returns success (R=0). If not, the subroutine returns failure (R5=1). 36pc[fontsize=911] ; Input: R0 contains the starting address of the character string ; Output: R5=0, success; R5=1, failure. ; TEST_INTEGER ST R1,SaveR1 ; Save registers needed by subroutine ST R2,SaveR2 ST R3,SaveR3 ST R4,SaveR4 ; AND R5,R5,#0 ; Initialize success code to R5=0, success LD R2,ASCII_0 ; R2=xFFD0, the negative of ASCII code x30 LD R3,ASCII_9 ; R3=xFFC7, the negative of ASCII code x39 ; NEXT_CHAR LDR R1,R0,#0 ; Load next character BRz SUCCESS ADD R4,R1,R2 BRn BAD ; R1 is less than x30, not a decimal digit ADD R4,R1,R3 BRp BAD ; R1 is greater than x39, not a decimal digit ADD R0,R0,#1 ; Character good! Prepare for next character BR NEXT_CHAR ; BAD ADD R5,R5,#1 ; R5 contains failure code SUCCESS LD R4,SaveR4 ; Restore registers LD R3,SaveR3 LD R2,SaveR2 LD R1,SaveR1 RET ASCII_0 .FILL xFFD0 ASCII_9 .FILL xFFC7 SaveR1 .BLKW 1 SaveR2 .BLKW 1 SaveR3 .BLKW 1 SaveR4 .BLKW 1 Subroutine to determine if a character string represents an integer 8.1 What are the defining characteristics of a stack? 8.2 What is an advantage to using the model in Figure 10.3 to implement a stack",
    "706": "the negative of ASCII code x30 LD R3,ASCII_9 ; R3=xFFC7, the negative of ASCII code x39 ; NEXT_CHAR LDR R1,R0,#0 ; Load next character BRz SUCCESS ADD R4,R1,R2 BRn BAD ; R1 is less than x30, not a decimal digit ADD R4,R1,R3 BRp BAD ; R1 is greater than x39, not a decimal digit ADD R0,R0,#1 ; Character good! Prepare for next character BR NEXT_CHAR ; BAD ADD R5,R5,#1 ; R5 contains failure code SUCCESS LD R4,SaveR4 ; Restore registers LD R3,SaveR3 LD R2,SaveR2 LD R1,SaveR1 RET ASCII_0 .FILL xFFD0 ASCII_9 .FILL xFFC7 SaveR1 .BLKW 1 SaveR2 .BLKW 1 SaveR3 .BLKW 1 SaveR4 .BLKW 1 Subroutine to determine if a character string represents an integer 8.1 What are the defining characteristics of a stack? 8.2 What is an advantage to using the model in Figure 10.3 to implement a stack versus the model in Figure 10.2? 8.3 The LC-3 ISA has been augmented with the following Push and Pop instructions. Push Rn pushes the value in Register n onto the stack. Pop Rn removes a value from the stack and loads it into Rn. The figure below shows a snapshot of the eight registers of the LC-3 BEFORE and AFTER the following six stack operations are performed. Identify (a)–(d). 810 BEFORE AFTER 2-25-51cR0 1|c|x0000 912PUSH R4 R0 1|c|x1111 2-25-51cR1 1|c|x1111 912PUSH (a) R1 1|c|x1111 2-25-51cR2 1|c|x2222 912POP (b) R2 1|c|x3333 2-25-51cR3 1|c|x3333 912PUSH (c) R3 1|c|x3333 2-25-51cR4 1|c|x4444 912POP R2 R4 1|c|x4444 2-25-51cR5 1|c|x5555 912POP (d) R5 1|c|x5555 2-25-51cR6 1|c|x6666 R6 1|c|x6666 2-25-51cR7 1|c|x7777 R7 1|c|x4444 2-25-5 8.4 Write a function that implements another stack function, peek. Peek returns the value of the first element on the stack without removing the element from the stack. Peek should also do underflow error checking. (Why is overflow error checking unnecessary?) 8.5 How would you check for underflow and overflow conditions if you implemented a stack using the model in Figure 10.2? Rewrite the PUSH and POP routines to model a stack implemented as in Figure 10.2, that is, one in which the",
    "707": "the following six stack operations are performed. Identify (a)–(d). 810 BEFORE AFTER 2-25-51cR0 1|c|x0000 912PUSH R4 R0 1|c|x1111 2-25-51cR1 1|c|x1111 912PUSH (a) R1 1|c|x1111 2-25-51cR2 1|c|x2222 912POP (b) R2 1|c|x3333 2-25-51cR3 1|c|x3333 912PUSH (c) R3 1|c|x3333 2-25-51cR4 1|c|x4444 912POP R2 R4 1|c|x4444 2-25-51cR5 1|c|x5555 912POP (d) R5 1|c|x5555 2-25-51cR6 1|c|x6666 R6 1|c|x6666 2-25-51cR7 1|c|x7777 R7 1|c|x4444 2-25-5 8.4 Write a function that implements another stack function, peek. Peek returns the value of the first element on the stack without removing the element from the stack. Peek should also do underflow error checking. (Why is overflow error checking unnecessary?) 8.5 How would you check for underflow and overflow conditions if you implemented a stack using the model in Figure 10.2? Rewrite the PUSH and POP routines to model a stack implemented as in Figure 10.2, that is, one in which the data entries move with each operation. 8.6 Rewrite the PUSH and POP routines such that the stack on which they operate holds elements that take up two memory locations each. 8.7 Rewrite the PUSH and POP routines to handle stack elements of arbitrary sizes. 8.8 The following operations are performed on a stack: PUSH A, PUSH B, POP, PUSH C, PUSH D, POP, PUSH E, POP, POP, PUSH F a. What does the stack contain after the ? b. At which point does the stack contain the most elements? Without removing the elements left on the stack from the previous operations, we perform: PUSH G, PUSH H, PUSH I, PUSH J, POP, PUSH K, POP, POP, POP, PUSH L, POP, POP, PUSH M c. What does the stack contain now? 8.9 The input stream of a stack is a list of all the elements we pushed onto the stack, in the order that we pushed them. The input stream from Exercise 10.8 was The output stream is a list of all the elements that are popped off the stack, in the order that they are popped off. a. What is the output stream from Exercise 10.8? Hint: BDE … b.",
    "708": "PUSH D, POP, PUSH E, POP, POP, PUSH F a. What does the stack contain after the ? b. At which point does the stack contain the most elements? Without removing the elements left on the stack from the previous operations, we perform: PUSH G, PUSH H, PUSH I, PUSH J, POP, PUSH K, POP, POP, POP, PUSH L, POP, POP, PUSH M c. What does the stack contain now? 8.9 The input stream of a stack is a list of all the elements we pushed onto the stack, in the order that we pushed them. The input stream from Exercise 10.8 was The output stream is a list of all the elements that are popped off the stack, in the order that they are popped off. a. What is the output stream from Exercise 10.8? Hint: BDE … b. If the input stream is ZYXWVUTSR, create a sequence of pushes and pops such that the output stream is YXVUWZSRT. c. If the input stream is ZYXW, how many different output streams can be created? 8.10 STAR It is easier to identify borders between cities on a map if adjacent cities are colored with different colors. For example, in a map of Texas, one would not color Austin and Pflugerville with the same color, since doing so would obscure the border between the two cities. Shown below is the recursive subroutine EXAMINE. EXAMINE examines the data structure representing a map to see if any pair of adjacent cities have the same color. Each node in the data structure contains the city's color and the addresses of the cities it borders. If no pair of adjacent cities have the same color, EXAMINE returns the value 0 in R1. If at least one pair of adjacent cities have the same color, EXAMINE returns the value 1 in R1. The main program supplies the address of a node representing one of the cities in R0 before executing JSR EXAMINE. [t]0.5 .ORIG x4000 EXAMINE ADD R6, R6, #-1 STR R0, R6, #0 ADD R6,",
    "709": "map of Texas, one would not color Austin and Pflugerville with the same color, since doing so would obscure the border between the two cities. Shown below is the recursive subroutine EXAMINE. EXAMINE examines the data structure representing a map to see if any pair of adjacent cities have the same color. Each node in the data structure contains the city's color and the addresses of the cities it borders. If no pair of adjacent cities have the same color, EXAMINE returns the value 0 in R1. If at least one pair of adjacent cities have the same color, EXAMINE returns the value 1 in R1. The main program supplies the address of a node representing one of the cities in R0 before executing JSR EXAMINE. [t]0.5 .ORIG x4000 EXAMINE ADD R6, R6, #-1 STR R0, R6, #0 ADD R6, R6, #-1 STR R2, R6, #0 ADD R6, R6, #-1 STR R3, R6, #0 ADD R6, R6, #-1 STR R7, R6, #0 AND R1, R1, #0 ; Initialize output R1 to 0 LDR R7, R0, #0 BRn RESTORE ; Skip this node if it has already been visited LD R7, BREADCRUMB STR R7, R0, #0 ; Mark this node as visited LDR R2, R0, #1 ; R2 = color of current node ADD R3, R0, #2 AGAIN LDR R0, R3, #0 ; R0 = neighbor node address BRz RESTOR LDR R7, R0, #1 NOT R7, R7 ; <– Breakpoint here ADD R7, R7, #1 ADD R7, R2, R7 ; Compare current color to neighbor's color BRz BAD JSR EXAMINE ; Recursively examine the coloring of next neighbor ADD R1, R1, #0 BRp RESTORE ; If neighbor returns R1=1, this node should return R1=1 ADD R3, R3, #1 BR AGAIN ; Try next neighbor BAD ADD R1, R1, #1 RESTORE LDR R7, R6, #0 ADD R6, R6, #1 LDR R3, R6, #0 ADD R6, R6, #1 LDR R2, R6, #0 ADD R6, R6, #1 LDR R0, R6, #0 ADD R6, R6, #1 RET BREADCRUMB .FILL x8000 .END Your job is to",
    "710": "visited LDR R2, R0, #1 ; R2 = color of current node ADD R3, R0, #2 AGAIN LDR R0, R3, #0 ; R0 = neighbor node address BRz RESTOR LDR R7, R0, #1 NOT R7, R7 ; <– Breakpoint here ADD R7, R7, #1 ADD R7, R2, R7 ; Compare current color to neighbor's color BRz BAD JSR EXAMINE ; Recursively examine the coloring of next neighbor ADD R1, R1, #0 BRp RESTORE ; If neighbor returns R1=1, this node should return R1=1 ADD R3, R3, #1 BR AGAIN ; Try next neighbor BAD ADD R1, R1, #1 RESTORE LDR R7, R6, #0 ADD R6, R6, #1 LDR R3, R6, #0 ADD R6, R6, #1 LDR R2, R6, #0 ADD R6, R6, #1 LDR R0, R6, #0 ADD R6, R6, #1 RET BREADCRUMB .FILL x8000 .END Your job is to construct the data structure representing a particular map. Before executing JSR EXAMINE, R0 is set to x6100 (the address of one of the nodes), and a breakpoint is set at x4012. The table below shows relevant information collected each time the breakpoint was encountered during the running of EXAMINE. PC R0 R2 R7 x4012 x6200 x0042 x0052 x4012 x6100 x0052 x0042 x4012 x6300 x0052 x0047 x4012 x6200 x0047 x0052 x4012 x6400 x0047 x0052 x4012 x6100 x0052 x0042 x4012 x6300 x0052 x0047 x4012 x6500 x0052 x0047 x4012 x6100 x0047 x0042 x4012 x6200 x0047 x0052 x4012 x6400 x0047 x0052 x4012 x6500 x0052 x0047 x4012 x6400 x0042 x0052 x4012 x6500 x0042 x0047 Construct the data structure for the particular map that corresponds to the relevant information obtained from the breakpoints. Note: We are asking you to construct the data structure as it exists AFTER the recursive subroutine has executed. < g r a p h i c s > 8.11 ADD The following program needs to be assembled and stored in LC-3 Memory. How many LC-3 memory locations are required to store the assembled program? .ORIG x4000 AND R0,R0,#0 ADD R1,R0,#0 ADD R0,R0,#4 LD R2,B A LDR R3,R2,#0 ADD R1,R1,R3 ADD R2,R2,#1 ADD",
    "711": "x0042 x4012 x6300 x0052 x0047 x4012 x6200 x0047 x0052 x4012 x6400 x0047 x0052 x4012 x6100 x0052 x0042 x4012 x6300 x0052 x0047 x4012 x6500 x0052 x0047 x4012 x6100 x0047 x0042 x4012 x6200 x0047 x0052 x4012 x6400 x0047 x0052 x4012 x6500 x0052 x0047 x4012 x6400 x0042 x0052 x4012 x6500 x0042 x0047 Construct the data structure for the particular map that corresponds to the relevant information obtained from the breakpoints. Note: We are asking you to construct the data structure as it exists AFTER the recursive subroutine has executed. < g r a p h i c s > 8.11 ADD The following program needs to be assembled and stored in LC-3 Memory. How many LC-3 memory locations are required to store the assembled program? .ORIG x4000 AND R0,R0,#0 ADD R1,R0,#0 ADD R0,R0,#4 LD R2,B A LDR R3,R2,#0 ADD R1,R1,R3 ADD R2,R2,#1 ADD R0,R0,#-1 BRnp A JSR SHIFTR ADD R1,R4,#0 JSR SHIFTR ST R4,C TRAP x25 B .BLKW 1 C .BLKW 1 .END How many memory locations are required to store the assembled program? What is the address of the location labeled C? Before the program of part can execute, the location labeled B must be loaded by some external means. You can assume that happens before this program starts executing. The program also contains a subroutine whose starting address is SHIFTR. Recall in class, we talked about subroutine libraries (collections of subroutines) that are linked with your program to provide one complete executable image. You can assume that the subroutine starting at location SHIFTR is available for the above program to use. SHIFTR takes the value in R1, shifts it right one bit, and stores the result in R4. After the program executes, what is in location C? 8.12STAR Many cities, like New York City, Stockholm, Konigsberg, etc. consist of several areas, connected by bridges. The figure below shows a map of FiveParts, a city made up of five areas A,B,C,D,E, with the areas connected by 9 bridges as shown. < g r a p h i c s > The following",
    "712": "assume that happens before this program starts executing. The program also contains a subroutine whose starting address is SHIFTR. Recall in class, we talked about subroutine libraries (collections of subroutines) that are linked with your program to provide one complete executable image. You can assume that the subroutine starting at location SHIFTR is available for the above program to use. SHIFTR takes the value in R1, shifts it right one bit, and stores the result in R4. After the program executes, what is in location C? 8.12STAR Many cities, like New York City, Stockholm, Konigsberg, etc. consist of several areas, connected by bridges. The figure below shows a map of FiveParts, a city made up of five areas A,B,C,D,E, with the areas connected by 9 bridges as shown. < g r a p h i c s > The following program prompts the user to enter two areas, and then stores the number of bridges from the first area to the second in location x4500. Your job: On the next page, design the data structure for the city of FiveParts that the program below will use to count the number of bridges between two areas. [t]0.5 .ORIG x3000 LEA R0, FROM TRAP x22 TRAP x20 ; Inputs a char without banner NOT R1, R0 ADD R1, R1, #1 LEA R0, TO TRAP x22 TRAP x20 NOT R0, R0 ADD R0, R0, #1 AND R5, R5, #0 LDI R2, HEAD SEARCH BRz DONE LDR R3, R2, #0 ADD R7, R1, R3 BRz FOUND_FROM LDR R2, R2, #1 BRnzp SEARCH FOUND_FROM ADD R2, R2, #2 NEXT_BRIDGE LDR R3, R2, #0 BRz DONE LDR R4, R3, #0 ADD R7, R0, R4 BRnp SKIP ADD R5, R5, #1 ; Increment Counter SKIP ADD R2, R2, #1 BRnzp NEXT_BRIDGE DONE STI R5, ANSWER HALT HEAD .FILL x3050 ANSWER .FILL x4500 FROM .STRINGZ \"FROM: \" TO .STRINGZ \"TO: \" .END Your job is to provide the contents of the memory locations that are needed to specify the data structure for the city of FiveParts, which is",
    "713": "FROM TRAP x22 TRAP x20 ; Inputs a char without banner NOT R1, R0 ADD R1, R1, #1 LEA R0, TO TRAP x22 TRAP x20 NOT R0, R0 ADD R0, R0, #1 AND R5, R5, #0 LDI R2, HEAD SEARCH BRz DONE LDR R3, R2, #0 ADD R7, R1, R3 BRz FOUND_FROM LDR R2, R2, #1 BRnzp SEARCH FOUND_FROM ADD R2, R2, #2 NEXT_BRIDGE LDR R3, R2, #0 BRz DONE LDR R4, R3, #0 ADD R7, R0, R4 BRnp SKIP ADD R5, R5, #1 ; Increment Counter SKIP ADD R2, R2, #1 BRnzp NEXT_BRIDGE DONE STI R5, ANSWER HALT HEAD .FILL x3050 ANSWER .FILL x4500 FROM .STRINGZ \"FROM: \" TO .STRINGZ \"TO: \" .END Your job is to provide the contents of the memory locations that are needed to specify the data structure for the city of FiveParts, which is needed by the program on the previous page. We have given you the HEAD pointer for the data structure and in addition, five memory locations and the contents of those five locations. We have also supplied more than enough sequential memory locations after each of the five to enable you to finish the job. Use as many of these memory locations as you need. < g r a p h i c s > 8.13 Our code to compute n factorial worked for all positive integers n. As promised in the text, your assignment here: Augment the iterative solution to FACT to also work for 0!. 8.14 As you know, the LC-3 ADD instruction adds 16-bit 2's complement integers. If we wanted to add 32-bit 2's complement integers, we could do that with the program shown below. Note that the program requires calling subroutine X which stores into R0 the carry that results from adding R1 and R2. Fill in the missing pieces of both the program and the subroutine X, as identified by the empty boxes. Each empty box corresponds to one instruction or the operands of one instruction. Note that a 32-bit operand requires two 16-bit memory locations.",
    "714": "locations as you need. < g r a p h i c s > 8.13 Our code to compute n factorial worked for all positive integers n. As promised in the text, your assignment here: Augment the iterative solution to FACT to also work for 0!. 8.14 As you know, the LC-3 ADD instruction adds 16-bit 2's complement integers. If we wanted to add 32-bit 2's complement integers, we could do that with the program shown below. Note that the program requires calling subroutine X which stores into R0 the carry that results from adding R1 and R2. Fill in the missing pieces of both the program and the subroutine X, as identified by the empty boxes. Each empty box corresponds to one instruction or the operands of one instruction. Note that a 32-bit operand requires two 16-bit memory locations. A 32-bit operand Y has Y[15:0] stored in address A, and Y[31:16] stored in address A+1. .ORIG x3000 LEA R3, NUM1 LEA R4, NUM2 LEA R5, RESULT LDR R1, R3, #0 LDR R2, R4, #0 ADD R0, R1, R2 STR R0, R5, #0 ————— (a) LDR ———– (b) LDR ———– (c) ADD R0, R1, R2 ————— (d) TRAP x25 X ST R4, SAVER4 AND R0, R0, #0 AND R4, R1, R2 BRn ———– (e) ADD R1, R1, #0 BRn ———– (f) ADD ———– (g) BRn ADDING BRnzp EXIT ADDING ADD R4, R1, R2 BRn EXIT LABEL ADD R0, R0, #1 EXIT LD R4, SAVER4 RET NUM1 .BLKW 2 NUM2 .BLKW 2 RESULT .BLKW 2 SAVER4 .BLKW 1 .END 8.15STAR A program encounters a breakpoint and halts. The computer operator does not change the state of the computer in any way, but immediately presses the run button to resume execution. The table below shows the contents of MAR and MDR for the first nine memory accesses that the LC-3 performs after resuming execution. Your job: Fill in the missing entries. 1in [h!]1.0in 0.25in 1st: 0.25in 2nd: 0.25in 3rd: 0.25in 4th: 0.25in 5th: 0.25in 6th: 0.25in 7th: 0.25in 8th: 0.25in 9th: [h!]1.0in",
    "715": "NUM1 LEA R4, NUM2 LEA R5, RESULT LDR R1, R3, #0 LDR R2, R4, #0 ADD R0, R1, R2 STR R0, R5, #0 ————— (a) LDR ———– (b) LDR ———– (c) ADD R0, R1, R2 ————— (d) TRAP x25 X ST R4, SAVER4 AND R0, R0, #0 AND R4, R1, R2 BRn ———– (e) ADD R1, R1, #0 BRn ———– (f) ADD ———– (g) BRn ADDING BRnzp EXIT ADDING ADD R4, R1, R2 BRn EXIT LABEL ADD R0, R0, #1 EXIT LD R4, SAVER4 RET NUM1 .BLKW 2 NUM2 .BLKW 2 RESULT .BLKW 2 SAVER4 .BLKW 1 .END 8.15STAR A program encounters a breakpoint and halts. The computer operator does not change the state of the computer in any way, but immediately presses the run button to resume execution. The table below shows the contents of MAR and MDR for the first nine memory accesses that the LC-3 performs after resuming execution. Your job: Fill in the missing entries. 1in [h!]1.0in 0.25in 1st: 0.25in 2nd: 0.25in 3rd: 0.25in 4th: 0.25in 5th: 0.25in 6th: 0.25in 7th: 0.25in 8th: 0.25in 9th: [h!]1.0in MAR MDR 0.25in x5020 0.25in xF0F0 0.25in 0.25in x2000 x020A 0.25in x040A 0.25in x61FE 0.25in 0.25in xC1C0 0.25in x4002 xF025"
}