\documentclass{patt}
\usepackage{xr}
\usepackage{xr}
\usepackage{alltt}
\usepackage{longtable}
\usepackage[section]{placeins}
\externaldocument{chap10}
\graphicspath{{../art/ch08/},{../art/designelements/},{../art/designelements/UnNumberedArt/}}

\setcounter{part}{1}
\setcounter{chapter}{7}
\setcounter{page}{199}

 \makeatletter
 \def\@makechapterhead#1{%
  \begingroup
  \parindent \z@%
  \vspace*{-8.5\p@}%
  \begin{picture}(0,0)
    \put(432,-577){\includegraphics[width=0.723333in,height=9.52667in]{PattChp.eps}}
    \put(428,-577){\rule{1\p@}{9.52667in}}
    \put(381.5,-181){\vbox{%
        \includegraphics{PattIcon1\ifnum\value{part}=0
            a\else b\fi.eps}\vspace{1pc}\par
        \includegraphics{PattIcon2\ifnum\value{part}=5
            a\else b\fi.eps}\vspace{1pc}\par
        \includegraphics{PattIcon3\ifnum\value{part}=5
            a\else b\fi.eps}\vspace{1pc}\par
        \includegraphics{PattIcon4\ifnum\value{part}=5
            a\else b\fi.eps}\vspace{1pc}\par
        \includegraphics{PattIcon5\ifnum\value{part}=5
            a\else b\fi.eps}\vspace{1pc}}}
  \end{picture}%
  \settowidth{\chapternumberwidth}{\fontsize{12}{12}\selectfont\industriasolid\trackonefifty{chapter}}%
  \hfill\parbox{\chapternumberwidth}{%
    \centering\industriasolid
    \centerline{\hss\fontsize{12}{12}\selectfont\trackonefifty{chapter}\hss}\par\vspace{1.5pc}
    \centerline{\sans\fontsize{72}{12}\selectfont\colour\thechapter}}
  \par
  \vspace{6.48pc}
  {\industriasolid\fontsize{30}{32}\selectfont\trackten{#1}\par}%
  \vspace{1.5pc}%
  {\colour\rule{36.4pc}{4\p@}}
  \vspace{4pt}
  \endgroup}
\makeatother

\begin{document}

\chapter{Data Structures}\label{chapt:data_structures}

Up to now, each item of information we have processed with the computer
has been a single value -- either an integer, a floating point number, or
an ASCII character.  The real world is filled with items of information
far more complex than simple, single numbers.  A company's organization
chart and a list of items arranged in alphabetical order are two examples.
We call these complex items of information {\em abstract data types}, or more
colloquially: {\em data structures}.  In this chapter, we will study three
abstract data types: stacks, queues, and character strings.  We will 
write programs to solve problems that require 
expressing information according to its structure.  There are other abstract 
data types to be sure, but we will leave those for Chapter 15, after we have 
introduced you to the C programming language.  

Before we get to stacks, queues, and character strings, however, we introduce 
a new concept that will prove very useful in manipulating data structures: 
{\em subroutines}, or what is also called {\em functions}.

%8.1
\section{Subroutines}

It is often useful to be able to invoke a program
fragment multiple times within the same program without having to
specify its details in the sourrce program each time it
is needed.  Also, in the real world of computer software development, it is 
often (usually?) the case that one software engineer writes a program that 
requires such fragments and another software engineer writes the fragments.

Or, one might require a fragment that has been supplied by the
manufacturer or by some independent software supplier.  It is almost
always the case that collections of such fragments are available to
user programmers to free them from having to write their own.  These
collections are referred to as {\em libraries}.  An example is the
Math Library, which consists of fragments\index{libraries} that
compute such functions as {\bf square root,} {\bf sine,} and {\bf
arctangent}.  In fact, because the Math Library exists, user programmers 
can get the computer to compute those functions without even having to know 
how to write a program fragment to do it! 

For all of these reasons, it is good to have a way to use program
fragments efficiently.  Such program fragments are called {\em
subroutines,} or alternatively, {\em procedures}, or in C terminology,
{\em functions}.\index{subroutine}\index{procedure}\index{function}

Figure~\ref{fig:piece.of.code} provides a simple illustration of a part of a
program, call it "piece-of-code-A," containing fragments that must be executed 
multiple times within piece-of-code-A.  Figure~\ref{fig:piece.of.code}
will be studied in detail in Chapter~9, but for now, let's ignore everything
about it except the 3-instruction sequences starting at symbolic addresses 
L1, L2, L3, and L4.  


\begin{figure}[h!]
\begin{Verbatim}[fontsize=\fontsize{9}{11}\selectfont]
01  START   ST      R1,SaveR1   ; Save registers needed
02          ST      R2,SaveR2   ; by this routine
03          ST      R3,SaveR3
04  ;
05          LD      R2,Newline
06  L1      LDI     R3,DSR
07          BRzp    L1          ; Loop until monitor is ready
08          STI     R2,DDR      ; Move cursor to new clean line
09  ;
0A          LEA     R1,Prompt   ; Starting address of prompt string
0B  Loop    LDR     R0,R1,#0    ; Write the input prompt
0C          BRz     Input       ; End of prompt string
0D  L2      LDI     R3,DSR
0E          BRzp    L2          ; Loop until monitor is ready
0F          STI     R0,DDR      ; Write next prompt character
10          ADD     R1,R1,#1    ; Increment prompt pointer
11          BRnzp   Loop        ; Get next prompt character
12  ;
13  Input   LDI     R3,KBSR
14          BRzp    Input       ; Poll until a character is typed
15          LDI     R0,KBDR     ; Load input character into R0
16  L3      LDI     R3,DSR
17          BRzp    L3          ; Loop until monitor is ready
18          STI     R0,DDR      ; Echo input character
19  ;
1A  L4      LDI     R3,DSR
1B          BRzp    L4          ; Loop until monitor is ready
1C          STI     R2,DDR      ; Move cursor to new clean line
1D          LD      R1,SaveR1   ; Restore registers
1E          LD      R2,SaveR2   ; to original values
1F          LD      R3,SaveR3
20          JMP     R7          ; Do the program's next task
21  ;
22  SaveR1  .BLKW   1           ; Memory for registers saved
23  SaveR2  .BLKW   1
24  SaveR3  .BLKW   1
25  DSR     .FILL   xFE04
26  DDR     .FILL   xFE06
27  KBSR    .FILL   xFE00
28  KBDR    .FILL   xFE02
29  Newline .FILL   x000A       ; ASCII code for newline
2A  Prompt  .STRINGZ ``Input a character>''
\end{Verbatim}
\caption{Instruction sequence (Piece-of-code-A) we will study in detail in Chapter 9}
\label{fig:piece.of.code}
\end{figure}

\FloatBarrier

Each of these four 3-instruction sequences do the following:

\begin{colorverbatim}
                    label   LDI   R3,DSR
                            BRzp  label
                            STI   Reg,DDR
\end{colorverbatim}


Each of the four instances uses a different label (L1, L2, L3, L4) but
that is not a problem since in each instance the only purpose of the label 
is to branch back from the BRzp instruction to the LDI instruction.

Two of the four program fragments store the contents of R0 and the
other two store the contents of R2, but that is easy to take care of,
as we will see.  The main point is that, aside from the small nuisance
of which register is being used for the source of the STI
instruction, the four program fragments do exactly the same thing, and
it is wasteful to require the programmer to write the code four times.
The subroutine call/return mechanism enables the programmer to write the
code only once.

\FloatBarrier
\subsection{The Call/Return Mechanism}

The Call/Return mechanism allows us to execute this one 3-instruction
sequence multiple times by requiring us to include it as a
subroutine in our program only once.

Figure~\ref{fig:subroutines} shows the instruction
execution flow for a program with and without subroutines.

\begin{figure}[h]
\centerline{\includegraphics{pat67509_0907.eps}}
\caption{Instruction execution flow with/without subroutines}
\label{fig:subroutines}
\end{figure}

Note in Figure~\ref{fig:subroutines}, that without subroutines, 
the programmer has 
to provide the same code A after X, after Y, and after Z.  With subroutines,
the programmer has to provide the code A only once. The programmer uses the 
Call/Return mechanism to direct the computer each time via the 
{\bf Call instruction} to the 
code A, and after the computer has executed the code A, to the
{\bf Return instruction} to the 
proper next instruction to be executed in the program.

We refer to the program that contains the call as the 
{\em caller}, and the subroutine that contains the return as the {\em callee}.

The Call/Return mechanism consists of two instructions. The first instruction
{\bf JSR(R)} is in the caller program and does two things: it loads the PC with 
the starting address of the subroutine and it loads R7 with the address 
immediately after the address of the JSR(R) instruction.  The address 
immediately after the address of the JSR(R) instruction is the address to 
come back to after executing the subroutine.  We call the address we come back 
to the {\em return linkage}.  The second instruction {\bf JMP R7} is the last 
instruction in the subroutine (i.e., in the callee program).  
It loads the PC with the contents of R7, 
the address just after the address of the JSR instruction, completing the
round trip flow of control from the caller to the callee and back. 

\FloatBarrier

\subsection{JSR(R) -- the instruction that calls the subroutine}

The LC-3 specifies one control instruction for calling subroutines, its
opcode is {\bf 0100}.
The instruction uses one of two addressing modes for computing the starting
address of the subroutine, PC-relative addressing or Base Register addressing.
The LC-3 assembly language provides two different mnemonic names for the
opcode, JSR and JSRR, depending on which addressing mode is used.

As was said above, JSR(R) instruction does two things.  Like all control 
instructions, it loads the PC, overwriting the incremented PC that was
loaded during the FETCH phase of JSR(R) instruction.  In this case the
starting address of the subroutine is computed, and loaded into the PC.
The second thing the JSR(R) instruction does is save the return 
address in R7.  The return address is the incremented PC, which is the 
address of the instruction following the JSR(R) instruction in the calling 
program.

The JSR(R) instruction consists of three parts.
\begin{center}
\begin{tabular}{cccccccccccccccc}
15 & 14 & 13 & 12 & 11 & 10 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\
\hline
\multicolumn{4}{|c}{Opcode} &\multicolumn{1}{|c}{A} &
\multicolumn{11}{|c|}{\raisebox{-1pt}{Address evaluation bits}} \\
\hline
\end{tabular}
\end{center}

Bits [15:12] contain the opcode, 0100.  Bit [11] specifies the
addressing mode, the value 1 if the addressing mode is PC-relative,
and the value 0 if the addressing mode is Base Register addressing.  
Bits [10:0] contain information that is used to obtain the starting
address of the subroutine.  The only difference between JSR and JSRR
is the addressing mode that is used for evaluating the starting
address of the subroutine.

\paragraph{JSR}

The JSR instruction computes the target address of the
subroutine by sign-extending the 11-bit offset (bits [10:0]) of the
instruction to 16 bits and adding that to the incremented PC.  This
addressing mode is almost identical to the addressing mode of another
control instruction, the
BR instruction, except 11 bits of PCoffset are used, rather than
nine bits as is the case for BR.

If the following JSR instruction is stored in location x4200,
its execution will cause the PC to be loaded with x3E05 (i.e., xFC04 + x4201)
and R7 to be loaded with x4201.
\begin{center}
\begin{tabular}{cccccccccccccccc}
15 & 14 & 13 & 12 & 11 & 10 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\
\hline
\multicolumn{1}{|c}{\raisebox{-1pt}{0}}&\multicolumn{1}{c}{\raisebox{-1pt}{1}}&
\multicolumn{1}{c}{\raisebox{-1pt}{0}}&\multicolumn{1}{c}{\raisebox{-1pt}{0}}&
\multicolumn{1}{|c}{\raisebox{-1pt}{1}}&\multicolumn{1}{|c}{\raisebox{-1pt}{1}}&
\multicolumn{1}{c}{\raisebox{-1pt}{0}}&
\multicolumn{1}{c}{\raisebox{-1pt}{0}}&
\multicolumn{1}{c}{\raisebox{-1pt}{0}}&
\multicolumn{1}{c}{\raisebox{-1pt}{0}}&
\multicolumn{1}{c}{\raisebox{-1pt}{0}}&\multicolumn{1}{c}{\raisebox{-1pt}{0}}&\multicolumn{1}{c}{\raisebox{-1pt}{0}}
&\multicolumn{1}{c}{\raisebox{-1pt}{1}}&\multicolumn{1}{c}{\raisebox{-1pt}{0}}&\multicolumn{1}{c|}{\raisebox{-1pt}{0}}\\
\hline
\multicolumn{4}{c}{JSR} &\multicolumn{1}{c}{A} &
\multicolumn{11}{c}{PCoffset11}\\
\end{tabular}
\end{center}

\paragraph{JSRR}

The JSRR instruction is exactly like the JSR instruction except for
the addressing mode.  {\bf JSRR} obtains the starting address of the
subroutine in exactly the same way the JMP instruction does, that is,
bits [8:6] identifies the Base Register, whose contents are loaded 
into the PC.

If the following JSRR instruction is stored in location x420A, and
if R5 contains x3002, the execution of the JSRR will cause R7 to
be loaded with x420B, and the PC to be loaded with
x3002.\questionmark[-26pt]

{\em Question:} What important feature does the JSRR instruction
provide that the JSR instruction does not provide?

\begin{center}
\begin{tabular}{cccccccccccccccc}
15 & 14 & 13 & 12 & 11 & 10 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\
\hline
\multicolumn{1}{|c}{\raisebox{-1pt}{0}}&\multicolumn{1}{c}{\raisebox{-1pt}{1}}&
\multicolumn{1}{c}{\raisebox{-1pt}{0}}&\multicolumn{1}{c}{\raisebox{-1pt}{0}}&
\multicolumn{1}{|c}{\raisebox{-1pt}{0}}&\multicolumn{1}{|c}{\raisebox{-1pt}{0}}&
\multicolumn{1}{c}{\raisebox{-1pt}{0}}&\multicolumn{1}{|c}{\raisebox{-1pt}{1}}&
\multicolumn{1}{c}{\raisebox{-1pt}{0}}&\multicolumn{1}{c}{\raisebox{-1pt}{1}}&
\multicolumn{1}{|c}{\raisebox{-1pt}{0}}&\multicolumn{1}{c}{\raisebox{-1pt}{0}}&
\multicolumn{1}{c}{\raisebox{-1pt}{0}}&\multicolumn{1}{c}{\raisebox{-1pt}{0}}&
\multicolumn{1}{c}{\raisebox{-1pt}{0}}&\multicolumn{1}{c|}{\raisebox{-1pt}{0}}\\
\hline
\multicolumn{4}{c}{JSRR} &\multicolumn{1}{c}{A} &\multicolumn{2}{c}{} &\multicolumn{3}{c}{BaseR} &\multicolumn{6}{c}{}\\
\end{tabular}
\end{center}

\FloatBarrier
\subsection{Saving and Restoring Registers}\index{saving and restoring register}

We have known for a long time that every time an instruction loads a value into
a register, the value that was previously in that register is lost.  Thus,  
we need to save the value in a register
\begin{itemize}
\item if that value will be destroyed by some subsequent instruction, and
\item if we will need it after that subsequent instruction.
\end{itemize}

This can be a problem when dealing with subroutines.
\\
Let's examine again the piece of code in Figure~\ref{fig:piece.of.code}.
Suppose this piece of code is a subroutine called by the instruction JSR START 
in some caller program, which we will call CALLER.  

Suppose before CALLER executes JSR START, it computes values that it loads 
into R1, R2, and R3.  In our subroutine starting at START, the instruction 
on line 05 loads a value into R2, the instruction on line 06 loads a value 
into R3, and the instruction on line 0A loads a value into R1.  What would
happen if CALLER needed those values after returning from the subroutine that 
begins at START.  Too bad!  Since the subroutine destroyed the values in 
R1, R2, and R3 by executing the instructions in lines 05, 06, and 0A, those 
values are lost to CALLER  when it resumes execution after the JMP R7 
instruction on line 20 of the subroutine.  Of course this is unacceptable.  

We prevent it from happening during the first part of our subroutine, i.e.,
during initialization.  In lines 01, 02, and 03, the contents of
R1, R2, and R3 are stored in memory locations SaveR1, SaveR2, and SaveR3.
Three locations in the subroutine (lines 22, 23, and 24) have been set aside
for the purpose of saving those register values.
And, in lines 1D, 1E, and 1F (just before the JMP R7 instruction) the values
stored there are put back into R1, R2, and R3.  That is, 
before the subroutine uses R1, R2,
and R3 for its own use, the subroutine {\bf saves} the values put there by the
calling program.  And, before the subroutine returns to the calling program,
those values are put back (i.e., {\bf restored}) where the calling program 
has a right to expect them.
 
We call this technique {\em callee save} because the subroutine (i.e., the
callee) saves and restores the registers.  It makes sense to have the 
subroutine save the registers because the subroutine knows which registers it
needs to do the work of the subroutine.  There really is no reason to
burden the person writing the caller program to know which registers the
subroutine needs.  

We could of course have the caller program save all the registers before
JSR START, and then the subroutine would not have to bother saving any of them.
Some programs do that, and in fact, some ISAs have JSR instructions that do
that as part of the execution of the JSR instruction.  But, if we wish to
eliminate unnecessary saves and restores, we can do so in this case by having
the callee save only the registers it needs.

We should also point out that since JMP START loads the return linkage in R7,
whatever was in R7 is destroyed by the execution of the JMP START instruction. 
Therefore, if the calling program had stored a value in R7 before calling the
subroutine at START, and needed that value after returning from the subroutine,
the caller program would have to save and restore R7.  Why should the caller
program save and restore R7?  Because the caller program knows that the contents
of R7 will be destroyed by execution of JMP START.  We call this 
{\em caller save} because the calling program saves and restores the register
value.

The message is this: If a value in a register will be needed after
something else is stored in that register, we must {\em save} it
before the something else happens and {\em restore} it before we can
subsequently use it.  We save a register value by storing it in
memory; we restore it by loading it back into the register.  

The save/restore problem can be handled either by the calling
program before the JSR occurs or by the subroutine.  We will see
in Section~9.3 that the same problem exists for another class of
calling/called routines, those due to system calls.

In summary, We use the term {\em caller-save} if the calling program 
handles the problem.\index{caller-save} We use the term {\em callee-save} 
if the called program handles the \index{callee-save} problem.  The
appropriate one to handle the problem is the one that knows which
registers will be destroyed by subsequent actions.

The callee knows which registers it needs to do the job of the called
program.  Therefore, before it starts, it saves those registers with a
sequence of stores.  After it finishes, it restores those registers
with a sequence of loads.  And it sets aside memory locations to save
those register values.  

The caller knows what damage will be done by instructions under its
control. It knows that each instance of a JSR instruction will destroy
what is in R7.  So, before the JSR instruction is executed, R7 is saved.  
After the caller program resumes execution (upon completion of the 
subroutine), R7 is restored.

\subsection{Library Routines}\label{library_routines}

We noted early in this section that there are many uses for the
Call/Return mechanism, among them the ability of a user program to
call library subroutines that are usually delivered as part of the
computer system.  Libraries are provided as a convenience to the user
programmer.  They are legitimately advertised as {\em productivity
enhancers} since they allow the application programmer to use them without
having to know or learn much of their inner details.  For example, it is
often the case that a programmer knows what a square root is (we abbreviate 
{\bf SQRT}), and may need to use sqrt(x) for some value x but does not
have a clue as to how to write a program to perform sqrt, and probably would
rather not have to learn how.

A simple example illustrates the point: We have lost our key and need
to get into our apartment.  We can lean a ladder up against the wall
so that the ladder touches the bottom of our open window, 24 feet
above the ground.  There is a 10-foot flower bed on the ground along
the edge of the wall, so we need to keep the base of the ladder
outside the flower bed.  How big a ladder do we need so that we can
lean it against the wall and climb through the window?  Or, stated
less colorfully: If the sides of a right triangle are 24 feet and 10
feet, how big is the hypotenuse (see Figure~\ref{fig:24_10_26})?

\begin{figure}[h]
\centerline{\includegraphics{pat67509_0910.eps}}
\caption{Solving for the length of the hypotenuse}
\label{fig:24_10_26}
\end{figure}

We remember from high school that Pythagoras answered that one for
us:
\begin{equation*}
c^2 = a^2 + b^2
\end{equation*}

\noindent Knowing $a$ and $b$, we can easily solve for $c$ by taking
the square root of the sum of $a^2$ and $b^2$. Taking the sum is not
hard---the LC-3 ADD instruction can do that job. The square is also
not hard; we can multiply two numbers by a sequence of additions.  But
how does one get the square root? The structure of our solution is
shown in Figure~\ref{fig:sqrt_internal}.

\begin{figure}[h]
\begin{Verbatim}[fontsize=\fontsize{9}{10}\selectfont]
01             ...
02             ...
03             LD      R0,SIDE1
04             BRz     S1
05             JSR     SQUARE
06     S1      ADD     R1,R0,#0
07             LD      R0,SIDE2
08             BRz     S2
09             JSR     SQUARE
0A     S2      ADD     R0,R0,R1
0B             JSR     SQRT
0C             ST      R0,HYPOT
0D             BRnzp   NEXT_TASK
0E     SQUARE  ADD     R2,R0,#0
0F             ADD     R3,R0,#0
10     AGAIN   ADD     R2,R2,#-1
11             BRz     DONE
12             ADD     R0,R0,R3
13             BRnzp   AGAIN
14     DONE    RET
15     SQRT    ...             ; R0 <-- SQRT(R0)
16             ...             ;
17             ...             ; How do we write this subroutine?
18             ...             ;
19             ...             ;
1A             RET
1B     SIDE1   .BLKW   1
1C     SIDE2   .BLKW   1
1D     HYPOT   .BLKW   1
1E             ...
1F             ...
\end{Verbatim}
\caption{A program fragment to compute the hypotenuse of a right triangle}
\label{fig:sqrt_internal}
\end{figure}

The subroutine SQRT has yet to be written. If it were not for the Math
Library, the programmer would have to pick up a math book (or get
someone to do it for him/her), check out the Newton-Raphson method,
and produce the missing subroutine.

However, with the Math Library, the problem pretty much goes away.
Since the Math Library supplies a number of subroutines (including
SQRT), the user programmer can continue to be ignorant of the likes of
Newton-Raphson.  The user still needs to know the label of the target
address of the library routine that performs the square root function,
where to put the argument x, and where to expect the result SQRT(x).
But these are easy conventions that can be obtained from the
documentation associated with the Math Library.

If the library routine starts at address SQRT, and the argument is
provided in R0 to the library routine, and the result is obtained in R0
from the library routine, Figure~\ref{fig:sqrt_internal} reduces to
Figure~\ref{fig:sqrt_external}.

\begin{figure}[h]
\begin{Verbatim}[fontsize=\fontsize{9}{10}\selectfont,commandchars=\\\{\}]
01             ...
02             ...
03             \textcolor{SPOThundred}{.EXTERNAL SQRT}
04             ...
05             ...
06             LD      R0,SIDE1
07             BRz     S1
08             JSR     SQUARE
09     S1      ADD     R1,R0,#0
0A             LD      R0,SIDE2
0B             BRz     S2
0C             JSR     SQUARE
0D     S2      ADD     R0,R0,R1 ; R0 contains argument x
0E             LD      R4,BASE  ; BASE contains starting address of SQRT routine
0F             JSRR    R4
10             ST      R0,HYPOT
11             BRnzp   NEXT_TASK
12     SQUARE  ADD     R2,R0,#0
13             ADD     R3,R0,#0
14     AGAIN   ADD     R2,R2,#-1
15             BRz     DONE
16             ADD     R0,R0,R3
17             BRnzp   AGAIN
18     DONE    RET
19     BASE    .FILL   \textcolor{SPOThundred}{SQRT}
1A     SIDE1   .BLKW   1
1B     SIDE2   .BLKW   1
1C     HYPOT   .BLKW   1
1D             ...
1E             ...
\end{Verbatim}
\caption{The program fragment of Figure~\ref{fig:24_10_26}, using a library routine}
\label{fig:sqrt_external}
\end{figure}

\FloatBarrier
Two things are worth noting:
\begin{itemize}
\item {\em Thing 1}---The programmer no longer has to worry about how
  to compute the square root function.  The library routine does that
  for us.
\item {\em Thing 2}---The pseudo-op .EXTERNAL.  We already saw in
  Section~7.4.2 that\index{.EXTERNAL} this pseudo-op tells the
  assembler that the label (SQRT), which is needed to assemble the
  .FILL pseudo-op in line 19, will be supplied by some other program
  fragment (i.e., module) and will be combined with this program
  fragment (i.e., module) when the {\em executable image} is produced.
  The\index{executable image} executable image is the binary module
  that actually executes.  The executable image is produced at {\em
    link} time.\index{link time}\index{linker}
\end{itemize}

This notion of combining multiple modules at link time to produce an
executable image is the normal case. Figure~\ref{fig:exec_image}
illustrates the process. You will see concrete examples of this when
we work with the programming language C in the second half of this
course.

\begin{figure}[h!]
\begin{minipage}{36pc}
\centerline{\includegraphics{pat67509_0913.eps}}
\caption{An executable image constructed from multiple files}
\label{fig:exec_image}
\end{minipage}
\end{figure}

Most application software requires library routines from various
libraries.  It would be very inefficient for the typical programmer to
produce all of them---assuming the typical programmer were able to produce
such routines in the first place.  We have mentioned routines from the
Math Library.  There are also a number of preprocessing routines for
producing {\em pretty} graphic images.  There are other routines for a
number of other tasks where it would make no sense at all to have the
programmer write them from scratch.  It is much easier to require only
(1)~appropriate documentation so that the interface between the
library routine and the program that calls that routine is clear, and
(2) the use of the proper pseudo-ops such as .EXTERNAL in the source
program.  The linker can then produce an executable image at link time
from the separately assembled modules.

\FloatBarrier
%8.2
\section{The Stack}

Now we are ready to study some data structures.  The first and most 
important data structure is the stack.

\subsection{The Stack---An Abstract Data Type}

Throughout your future interaction with computers (use -- software, or 
design -- hardware), you will encounter 
the storage mechanism known as a {\em stack} again and again.  Stacks can be
implemented in \index{stack} many different ways, and we will get to
that momentarily.  But first, it is important to know that the concept
of a stack has nothing to do with how it is implemented. The concept
of a stack is the specification of how it is to be {\em accessed}.
That is, the defining notion of a stack is that the {\bf last}
thing you stored in the stack is the {\bf first} thing you remove from it.
That is what makes a stack different from everything else in
the\lightbulb[-20pt] world. Simply put: Last In, First Out, or LIFO.
\index{Last In, First Out} \index{LIFO}

In the terminology of computer programming languages, we say the stack
is an example of an {\em abstract data type}. That is, an abstract
data type is a \index{abstract data type} storage mechanism that is
defined by the operations performed on it and not at all by the
specific manner in which it is implemented.  In this section, you will 
see stacks implemented as sequential locations in memory.  

\subsection{Two Example Implementations}

A coin holder in the armrest next to the driver of an automobile is an example 
of a stack. The first quarter you take to pay the highway toll is the last
quarter you added to the stack of quarters. As you add quarters, you
push the earlier quarters down into the coin holder.

Figure~\ref{fig:coin.holder} shows the behavior of a coin
holder. Initially, as shown in Figure~\ref{fig:coin.holder}a, the coin
holder is empty. The first highway toll is 75 cents, and you give the
toll collector a dollar. He gives you 25 cents change, a 1995
quarter, which you insert into the coin holder.  The coin holder
appears as shown in Figure~\ref{fig:coin.holder}b.

\begin{figure}[h]
\centerline{\includegraphics{pat67509_1001.eps}}
\caption{A coin holder in an automobile
  armrest$\!$---$\!$example of a stack}
\label{fig:coin.holder}
\end{figure}

There are special terms for the insertion and removal of elements from
a stack. We say we {\em push} an element onto the stack when we insert
it. We say we {\em pop} an element from the stack when we \index{push}
\index{pop} remove it.

The second highway toll is \$4.25, and you give the toll collector
\$5.00. She gives you 75 cents change, which you insert into the coin
holder: first a 1982 quarter, then a 1998 quarter, and finally, a 1996
quarter. Now the coin holder is as shown in
Figure~\ref{fig:coin.holder}c.  The third toll is 50 cents, and you
remove (pop) the top two quarters from the coin holder: the 1996
quarter first and then the 1998 quarter. The coin holder is then as
shown in Figure~\ref{fig:coin.holder}d.

The coin holder is an example of a stack, {\bf precisely} because it
obeys the LIFO requirement. Each time you insert a quarter, you do so
at the top. Each time you remove a quarter, you do so from the top.
The last coin you inserted is the first coin you remove. Therefore, it
is a stack.

Another implementation of a stack, sometimes referred to as a computer 
hardware stack, is shown in Figure~\ref{fig:hardware.stack}. Its behavior
resembles that of the coin holder we just described. It consists of
some number of hardware registers, each of which can store a value. The
example of Figure~\ref{fig:hardware.stack} contains five registers. As
each value is added to the stack or removed from the stack, the
values {\bf already} on the stack {\bf move.}

\begin{figure}[h]
\centerline{\includegraphics{pat67509_1002.eps}}
\caption{A stack, implemented in hardware---data
entries move}
\label{fig:hardware.stack}
\end{figure}

In Figure~\ref{fig:hardware.stack}a, the stack is initially shown as
empty. Access is always via the first element, which is labeled
{\footnotesize{TOP}}.  If the value 18 is pushed on to the stack, we
have Figure~\ref{fig:hardware.stack}b. If the three values, 31, 5, and
12, are pushed (in that order), the result is as shown in 
Figure~\ref{fig:hardware.stack}c. Finally, if two values are popped
from the stack, we have Figure~\ref{fig:hardware.stack}d.  A distinguishing 
feature of the stack of Figure~\ref{fig:hardware.stack} is that, like the 
quarters in the coin holder, as each value is added or removed, {\bf all the 
other values already on the stack move}.

%10.1.3
\subsection{Implementation in Memory}

By far the most common implementation of a stack in a computer is as
shown in Figure~\ref{fig:stack.in.memory}. This stack consists of a
sequence of memory locations along with a mechanism, called the {\em
stack pointer,}, \index{stack pointer} which keeps track of the {\bf top} 
of the stack.  We use R6 to contain the address of the top of the stack.  
That is, in the LC-3, R6 is the stack pointer.  

In Figure~\ref{fig:stack.in.memory}, five memory locations (x3FFF to x3FFB) 
are provided for the stack.  The actual locations comprising the stack at any 
single instant of time are the consecutive locations from x3FFF to the location 
specified in R6, i.e., the top of the stack.  For example, in 
Figure~\ref{fig:stack.in.memory}c, the stack consists of the contents of 
locations x3FFF, x3FFE, x3FFD, and x3FFC.

\begin{figure}[h]
\begin{minipage}{36pc}
\centerline{\includegraphics{pat67509_1003.eps}}
\end{minipage}
\caption{A stack, implemented in memory---data entries do not move}
\label{fig:stack.in.memory}
\end{figure}

\noindent
Figure~\ref{fig:stack.in.memory}a shows an initially empty stack.  Since
there are no values on the stack, the stack pointer contains the address x4000, 
the address of the memory location just after the memory locations reserved for
the stack.  Why this makes sense will be clear after we show the actual
code for pushing values onto and popping values off of the stack.  
Figure~\ref{fig:stack.in.memory}b shows the stack after pushing
the value 18. Note that the stack pointer contains the address x3FFF, which
is the new top of the stack.

Figure~\ref{fig:stack.in.memory}c shows the stack after pushing the values 
31, 5, and 12, in that order. Note that the values inserted into the stack
are stored in memory locations having decreasing addresses.  We say the stack 
{\em grows toward zero}.  Finally, Figure~\ref{fig:stack.in.memory}d shows 
the stack after popping the top two elements off the stack.  

Note that those two elements (the values 5 and 12) that were popped are still 
present in memory locations x3FFD and x3FFC. However, as we will see 
momentarily, those values 5 and 12 cannot be accessed from memory, as long as 
{\bf every} access to memory is controlled by the stack mechanism.

Note also that, unlike the coin holder and computer hardware stack 
implementations
discussed in the previous section, when values are pushed and popped to and 
from a stack implemented in sequential memory locations, the data already 
stored on the stack {\bf does not physically move}.  

\paragraph{Push}

We push a value onto the stack by executing the two-instruction sequence

\begin{colorverbatim}
                 PUSH        ADD   R6,R6,#-1
                             STR   R0,R6,#0
\end{colorverbatim}

\noindent
In Figure~\ref{fig:stack.in.memory}a, R6 contains x4000, indicating that
the stack is empty.  To push the value 18 onto the stack, we decrement R6, 
the stack pointer, so the address in R6 (i.e., address x3FFF) corresponds 
to the location where we want to store the value we are pushing onto the
stack.  The actual push is done by first loading 18 into R0, and then 
executing STR R0,R6,\#0. This stores the contents of R0 into memory location 
x3FFF.

That is, to push a value onto the stack, we first load that value into R0.
Then we decrement R6, which contained the previous top of the stack.
Then we execute STR R0,R6,\#0, which stores the contents of R0 into the memory 
location whose address is in R6.  

The three values 31, 5, and 12 are pushed onto the stack by loading
each in turn into R0, and then executing the two-instruction sequence.
In Figure~\ref{fig:stack.in.memory}c, R6 (the stack pointer) contains
x3FFC, indicating that the top of the stack is location x3FFC and that
12 was the last value pushed.

\paragraph{Pop}

To pop a value from the stack, the value is read and the stack pointer
is incremented. The following two-instruction sequence

\begin{colorverbatim}
                 POP         LDR   R0,R6,#0
                             ADD   R6,R6,#1
\end{colorverbatim}

\noindent pops the value contained in the top of the stack and loads it into 
R0.  The stack pointer (R6) is incremented to indicate that the old value at 
the top of the stack has been popped and is no longer on the stack, and we have
a new value at the top of the stack.

If the stack were as shown in Figure~\ref{fig:stack.in.memory}c and we
executed the sequence twice, we would pop two values from the
stack. In this case, we would first remove the 12, and then the 5.  Assuming 
the purpose of popping two values is to use those two values, we would, of 
course, have to move the 12 from R0 to some other location before calling POP 
a second time.

Note that after 12 and 5 are popped, R6 contains x3FFE, indicating that 12 
and 5 are no longer on the stack and that the top of the stack is 31.  
Figure~\ref{fig:stack.in.memory}d shows the stack after that sequence
of operations. 

Note that the values 12 and 5 are still stored in
memory locations x3FFD and x3FFC, respectively.  However, since the
stack requires that we push by executing the PUSH sequence and pop by
executing the POP sequence, we cannot read the values 12 and 5 if we
obey the rules. The fancy name for "the rules" is the {\em stack
protocol}.  \index{stack protocol}

\paragraph{Underflow}

What happens if we now attempt to pop three values from the stack?
Since only two values remain on the stack, we would have a problem.
Attempting to pop items that have not been previously pushed results
in an {\em underflow} \index{underflow} situation. In our example, we
can test for underflow by comparing the stack pointer with x4000,
which would be the contents of R6 if there were nothing left on the
stack to pop. If UNDERFLOW is the label of a routine that handles the
underflow condition, our resulting POP sequence would be

\begin{colorverbatim}
        POP      LD      R1,EMPTY
                 ADD     R2,R6,R1      ; Compare stack
                 BRz     UNDERFLOW     ; pointer with x4000.
        ;
                 LDR     R0,R6,#0
                 ADD     R6,R6,#1
        ;
                 RET
        EMPTY    .FILL   xC000         ; EMPTY <-- negative of x4000
\end{colorverbatim}

Rather than have the POP routine immediately jump to the UNDERFLOW
routine if the POP is unsuccessful, it is often useful to have the POP
routine return to the calling program with the underflow information
contained in a register.  We will use R5 to provide
success/failure information. Figure~\ref{fig:pop.flow.chart} is a
flowchart showing how the POP routine could be augmented, using R5 to
report this success/failure information.

\begin{figure}[h]
\centerline{\includegraphics{pat67509_1004.eps}}
\caption{POP routine, including test for underflow}
\label{fig:pop.flow.chart}
\end{figure}

Upon return from the POP routine, the calling program would
examine R5 to determine whether the POP completed successfully (R5
$=$ 0), or not (R5 $=$ 1).

\looseness=1
Note that since the POP routine reports success or failure in R5,
whatever was stored in R5 {\bf before} the POP routine was called is
lost. Thus, it is the job of the calling program to save the contents
of R5 before the JSR instruction is executed if the value stored there
will be needed later. Recall from Section~8.1.3 that this is an example 
of a caller-save situation.

The resulting POP routine is shown in the following instruction sequence.  

\begin{colorverbatim}
        POP      AND     R5,R5,#0
                 LD      R1,EMPTY
                 ADD     R2,R6,R1
                 BRz     Failure
                 LDR     R0,R6,#0
                 ADD     R6,R6,#1
                 RET
        Failure  ADD     R5,R5,#1
                 RET
        EMPTY    .FILL   xC000         ; EMPTY <-- -x4000
\end{colorverbatim}

\paragraph{Overflow}

What happens when we run out of available space and we try to push a
value onto the stack? Since we cannot store values where there is no
space, we have an {\em overflow} situation. We can test for overflow by
\index{overflow} comparing the stack pointer with (in the example of
Figure~\ref{fig:stack.in.memory}) x3FFB.  If they are equal, we have
no place to push another value onto the stack.  If OVERFLOW is the
label of a routine that handles the overflow condition, our resulting
PUSH sequence would be

\begin{colorverbatim}
      PUSH       LD      R1,MAX
                 ADD     R2,R6,R1
                 BRz     OVERFLOW
      ;
                 ADD     R6,R6,#-1
                 STR     R0,R6,#0
      ;
                 RET
      MAX        .FILL   xC005         ; MAX <-- negative of x3FFB
\end{colorverbatim}

\looseness=1
In the same way that it is useful to have the POP routine return to
the calling program with success/failure information, rather than
immediately jumping to the UNDERFLOW routine, it is useful to have the
PUSH routine act similarly.

We augment the PUSH routine with instructions to store 0 (success) or
1 (failure) in R5, depending on whether or not the push completed
successfully. Upon return from the PUSH routine, the calling program
would examine R5 to determine whether the PUSH completed successfully
(R5 $=$ 0) or not (R5 $=$ 1).

Note again that since the PUSH routine reports success or failure in
R5, we have another example of a caller-save situation. That is, since
whatever was stored in R5 before the PUSH routine was called is lost,
it is the job of the calling program to save the contents of R5 before
the JSR instruction is executed if the value stored in R5 will be needed
later.

The resulting PUSH routine is shown in the following instruction sequence.  

\begin{colorverbatim}

      PUSH       AND     R5,R5,#0
                 LD      R1,MAX
                 ADD     R2,R6,R1
                 BRz     Failure
                 ADD     R6,R6,#-1
                 STR     R0,R6,#0
                 RET
      Failure    ADD     R5,R5,#1
                 RET
      MAX        .FILL   xC005         ; MAX <-- -x3FFB
\end{colorverbatim}

\subsection{The Complete Picture}

The POP and PUSH routines allow us to use memory locations x3FFF
through x3FFB as a five-entry stack. If we wish to push a value onto
the stack, we simply load that value into R0 and execute JSR PUSH. To
pop a value from the stack into R0, we simply execute JSR POP. If we
wish to change the location or the size of the stack, we adjust BASE
and MAX accordingly.

Before leaving this topic, we should be careful to clean up an important 
detail that we discussed in Section~8.1.3.  The subroutines PUSH and POP 
make use of R1 and R2, and there is no reason why the calling program would
know that.  Therefore,   it is the job of the subroutine (callee-save) to 
save R1 and R2 before using them, and restoring them before returning to 
the calling program.  

The PUSH and POP routines also write to R5.  But, as we have already pointed 
out, the calling program knows that the subroutine will report success or 
failure
in R5, so it is the job of the calling program to save R5 before executing the
JSR instruction if the value stored in R5 will be needed later.  As discussed
in Section~8.1.3, this is an example of caller-save.

The final code for our PUSH and POP operations is shown in
Figure~\ref{fig:stack.protocol}.

\begin{figure}[h]
\begin{minipage}{36pc}
\begin{Verbatim}[fontsize=\fontsize{9}{11}\selectfont]
01   ;
02   ; Subroutines for carrying out the PUSH and POP functions.  This
03   ; program works with a stack consisting of memory locations x3FFF
04   ; through x3FFB.  R6 is the stack pointer.
05   ;
06   POP            AND     R5,R5,#0       ; R5 <-- success
07                  ST      R1,Save1       ; Save registers that
08                  ST      R2,Save2       ; are needed by POP
09                  LD      R1,EMPTY       ; EMPTY contains -x4000
0B                  ADD     R2,R6,R1       ; Compare stack pointer to x4000
0C                  BRz     fail_exit      ; Branch if stack is empty
0D   ;
0E                  LDR     R0,R6,#0       ; The actual "pop"
0F                  ADD     R6,R6,#1       ; Adjust stack pointer
10                  BRnzp   success_exit
11   ;
12   PUSH           AND     R5,R5,#0
13                  ST      R1,Save1       ; Save registers that
14                  ST      R2,Save2       ; are needed by PUSH
15                  LD      R1,FULL        ; FULL contains -x3FFB
16                  ADD     R2,R6,R1       ; Compare stack pointer to x3FFB
17                  BRz     fail_exit      ; Branch if stack is full
18   ;
19                  ADD     R6,R6,#-1      ; Adjust stack pointer
1A                  STR     R0,R6,#0       ; The actual "push"
1B   success_exit   LD      R2,Save2       ; Restore original
1C                  LD      R1,Save1       ; register values
1D                  RET
1E   ;
1F   fail_exit      LD      R2,Save2       ; Restore original
20                  LD      R1,Save1       ; register values
21                  ADD     R5,R5,#1       ; R5 <-- failure
22                  RET
23   ;
24   EMPTY          .FILL   xC000          ; EMPTY contains -x4000
25   FULL           .FILL   xC005          ; FULL contains  -x3FFB
26   Save1          .FILL   x0000
27   Save2          .FILL   x0000
\end{Verbatim}
\caption{The stack protocol}
\label{fig:stack.protocol}
\end{minipage}
\end{figure}

\FloatBarrier
%8.3  
\section{Recursion, a powerful technique when used appropriately}

Recursion is a mechanism for expressing a function {\em in terms of itself}.  
Some have referred to it as picking oneself up by one's bootstraps, since at 
first blush, it looks like magic -- which, of course, it isn't.

When used appropriately, the expressive power of recursion is going to save us 
a lot of headaches.  When used whimsically, recursion is going to require 
unnecessary activity, resulting in longer execution time and wasted energy.  

The mechanism is so important that we will study it in greater detail later in
the book after we have raised the level of abstraction to programming in a
high level language.  However, since a critical concept needed to understand
the implementation of recursion is the stack, which we have just studied, it
is useful to show by means of examples just when using recursion is warranted 
and when using it is not a good idea.

We will examine two ill-advised uses of recursion.  We will also examine 
a problem where using the expressive power of recursion is very helpful.

%8.3.1
\subsection{Bad example Number 1: Factorial}

The simplest example to illustrate recursion is the function {\bf factorial}.  
The equation

\begin{center}
		n! = n * (n-1)!
\end{center}

\noindent
says it all.  We are expressing factorial in terms of factorial!  How we can
write a program to do this we will see momentarily.

Assume the subroutine FACT (Factorial) is supplied with a positive integer n 
in R0, and returns with the value n! in R0.  (We will save 0! for an exercise
at the end of the chapter.)

Figure~\ref{fig:factorial.structure} shows a pictorial view of the 
recursive subroutine.
We represent the subroutine FACT as a hexagon, and inside the 
hexagon is another instance of the hexagon!  We call the subroutine recursive 
because inside the FACT subroutine is an instruction JSR FACT.

\begin{figure}[h]
\centerline{\includegraphics[scale=0.4]{factorial.structure.eps}}
\caption{Flow chart for a recursive FACTORIAL subroutine}
\label{fig:factorial.structure}
\end{figure}

The subroutine first tests to see if n=1.  If so, we are done, 
since (1)! =1.  It is important to emphasize that every recursive subroutine 
must have such an initial test to see if we should execute the recursive call. 
Without this test, the subroutine would call itself (JSR FACT) 
an infinite number of times!  Clearly, that can not be correct.  The answer 
is to provide a test before the recursive JSR instruction.  In the case of the
subroutine FACT, if R0 is 1, we are done, since 1! = 1.

If n is not equal 1, we save the value in R1, so we can store n in R1, 
load R0 with n-1 and JSR FACT.  When
FACT returns with (n-1)! in R0, we multiply it by n (which was stored in R1),
producing n!, which we load into R0, restore R1 to the value expected by the
calling program, and RET.  

If we assume the LC-3 has a MUL instruction, the basic structure of the FACT
subroutine takes the following form:

\begin{colorverbatim}
FACT    ST    R1, Save1  ; Callee save R1
        ADD   R1,R0,#-1  ; Test if R0=1
        BRz   DONE       ; If R0=1, R0 also contains (1)!, so we are done
        ADD   R1,R0,#0   ; Save n in R1, to be used after we compute (n-1)!
        ADD   R0,R1, #-1 ; Set R0 to n-1, and then call FACT
B       JSR   FACT       ; On RET, R0 will contain (n-1)!
        MUL   R0,R0,R1   ; Multiply n times (n-1)!, yielding n! in R0
DONE    LD    R1, Save1  ; Callee restore R1
        RET
Save1   .BLKW 1
\end{colorverbatim}

Since the LC-3 does not have a MUL instruction, this will require another 
subroutine call, but we are ignoring that here in order to focus on the 
essence of recursion.

Unfortunately, the code we have written will not work.  To see why it will not 
work, Figure~\ref{fig:factorial.flow} shows the flow of instruction execution, 
as we would like
it to be.  The main program calls the subroutine with a JSR instruction at 
address A.  This causes the 
code labeled \#1 to excute.  At address B, the subroutine FACT calls itself 
with the instruction JSR FACT.  This causes the code labeled \#2 to execute, 
and so forth.

\begin{figure}[h]
\centerline{\includegraphics[scale=0.5]{factorial.flow.eps}}
\caption{Execution flow for recursive FACTORIAL subroutines}
\label{fig:factorial.flow}
\end{figure}

\FloatBarrier
Note that when the main program executes the instruction JSR FACT, the 
return linkage A+1 is saved in R7.  In the block of code labeled \#1, the 
instruction at address B (JSR FACT) stores its return linkage B+1 in R7, 
destroying A+1, so there is no way to get back to the main program.  Bad!  
In fact: very, very bad!

We can solve this problem by pushing the address A+1 onto a stack before 
executing JSR FACT at address B.  After we subsequently return to 
address B+1, we can then pop the stack, and load the address A+1 into R7
before we execute the instruction RET back to the main program.

Also, note that the instruction ADD R1,R0,\#0 in \#1 loads the value n
into R1, and in \#2, the instruction ADD R1,R0,\#0 loads the value n-1 into
R1, thereby wiping out the value n that had been put there by the code in \#1.
Thus, when the instruction flow gets back to \#1) where the value n is needed
by the instruction MUL R0,R0,R1, it is no longer there.  It was previously
wiped out.  Again, very, very bad!

We can solve this problem with a stack also.  That is, instead of moving the
value n to R1 before loading n-1 into R0, we push n onto the stack, and then
pop it when we need it after returning from the subroutine with (n-1)! in R0.

Finally, we note that the first instruction in our subroutine saves R1 in
Save1 and the last instruction before the RET restores it to R1.  We do this
so that from the standpoint of the calling program, the value in R1 before the 
subroutine is the same as the value in R1 after the subroutine, even though 
the subroutine used R1 in performing its job.  However, since our subroutine
is recursive, when FACT is called by the JSR instruction at address B, R1 does 
not contain the value it had in the main program, but instead it has the value
last stored in R1 by the ADD R1,R0,\#0 instruction.  Thus after the JSR FACT
instruction is executed, the first instruction of the recursively called
subroutine FACT will save that value, wiping out the value that the main
program had stored in R1 when it called FACT.  

We can solve this problem with a stack also.  We simply replace the 
ST R1,Save1 with a push and LD R1,Save1 with a pop.  

If we make these changes (and if the LC-3 had a MUL opcode), the recursive
subroutine would work as we would like it to.  The resulting subroutine is
shown in Figure~\ref{fig:recursiveFACT}
(with almost all instructions explained via comments):

\begin{figure}[h!]
\begin{minipage}{36pc}
\begin{Verbatim}[fontsize=\fontsize{9}{11}\selectfont]
FACT       ADD  R6,R6,#-1
	   STR  R1,R6,#0   ; Push Caller's R1 on the stack, so we can use R1.
;
           ADD  R1,R0,#-1  ; If n=1, we are done since 1! = 1
           BRz  NO_RECURSE  
;
           ADD  R6,R6,#-1
           STR  R7,R6,#0   ; Push return linkage onto stack
           ADD  R6,R6,#-1
           STR  R0,R6,#0   ; Push n on the stack
;
           ADD  R0,R0,#-1   ; Form n-1, argument of JSR           
B          JSR  FACT
           LDR  R1,R6,#0   ; Pop n from the stack
           ADD  R6,R6,#1
           MUL  R0,R0,R1   ; form n*(n-1)!
;
           LDR  R7,R6,#0   ; Pop return linkage into R7
           ADD  R6,R6,#1
NO_RECURSE LDR  R1,R6,#0   ; Pop caller's R1 back into R1
           ADD  R6,R6,#1
           RET
\end{Verbatim}
\caption{The recursive subroutine FACT}
\label{fig:recursiveFACT}
\end{minipage}
\end{figure}

The main program calls FACT with R0=n.  The code in \#1 executes, with 
JSR FACT being called with R0 = n-1.  At this point, the stack contains the 
three entries pushed, as shown in Figure~\ref{fig:factorial.stack}a.  When 
the JSR FACT instruction in \#3 executes, with R0 = n-3, the contents of the 
stack contains the nine entries as shown in Figure~\ref{fig:factorial.stack}b.

\begin{figure}[h]
\centerline{\includegraphics[scale=0.7]{factorial.stack.eps}}
\caption{The stack during two instances of executing the FACTORIAL subroutine}
\label{fig:factorial.stack}
\end{figure}

\FloatBarrier
The obvious question you should ask at this point is, "Why is this such a
bad use of recursion, particularly when its representation n! = n * (n-1)!
is so elegant?"  To answer this question, we first note how many
instructions are executed and how much time is wasted pushing and popping
elements off the stack.  AND, the second question you should ask is, "Is there 
a better way to compute n!?"

Consider this alternative:

\begin{figure}[h!]
\begin{minipage}{36pc}
\begin{Verbatim}[fontsize=\fontsize{9}{11}\selectfont]

FACT    ST   R1,SAVE_R1
        ADD  R1,R0,#0
        ADD  R0,R0, #-1
        BRz  DONE
AGAIN   MUL  R1,R1,R0
        ADD  R0,R0,#-1  ; R0 gets next integer for MUL
        BRnp AGAIN
DONE    ADD  R0,R1,#0   ; Move n! to R0
        LD   R1,SAVE_R1
        RET
SAVE_R1 .BLKW 1
\end{Verbatim}
\caption{Implementing FACT iteratively (i.e., without recursion)                    }
\label{fig:zzzzzz}
\end{minipage}
\end{figure}

\FloatBarrier
%8.3.2. 
\subsection{Fibonacci, an even worse example}

Another bad use of recursion is to evaluate the Fibonacci number FIB(n).
The Fibonacci numbers are defined for all non-negative integers as follows:
FIB(0)=0, FIB(1)=1, and if n > 1, FIB(n) = FIB(n-1) + FIB(n-2).  The expression
is beautifully elegant, but the execution time is horrendous.  

Figure~\ref{fig:pictorial.FIB} shows a pictorial view of the recursive 
subroutine FIB.  Note that the subroutine FIB is represented as a "capital F", 
and inside the capital F there are two more instances of the capital F.  

\begin{figure}[h]
\centerline{\includegraphics[scale=0.6]{pictorial.FIB.eps}}
\caption{Pictorial representation of the recursive FIB subroutine}
\label{fig:pictorial.FIB}
\end{figure}

\FloatBarrier
The following recursive subroutine computes FIB(n).

\begin{figure}[h!]
\begin{minipage}{36pc}
\begin{Verbatim}[fontsize=\fontsize{9}{11}\selectfont]
;FIB subroutine
; + FIB(0) = 0
; + FIB(1) = 1
; + FIB(n) = FIB(n-1) + FIB(n-1)
;
; Input is in R0
; Return answer in R1
;
FIB     ADD R6, R6, #-1
        STR R7, R6, #0  ; Push R7, the return linkage
        ADD R6, R6, #-1
        STR R0, R6, #0  ; Push R0, the value of n
        ADD R6, R6, #-1
        STR R2, R6, #0  ; Push R2, which is needed in the subroutine

; Check for base case
        AND R2, R0, #-2
        BRnp SKIP        ; Z=0 if R0=0,1
        ADD R1, R0, #0   ; R0 is the answer
        BRnzp DONE

; Not a base case, do the recursion
SKIP    ADD R0, R0, #-1
        JSR FIB         ; R1 = FIB(n-1)
        ADD R2, R1, #0  ; Move result before calling FIB again
        ADD R0, R0, #-1
        JSR FIB         ; R1 = FIB(n-2)
        ADD R1, R2, R1  ; R1 = FIB(n-1) + FIB(n-2)

; Restore registers and return
DONE    LDR R2, R6, #0
        ADD R6, R6, #1
        LDR R0, R6, #0
        ADD R6, R6, #1
        LDR R7, R6, #0
        ADD R6, R6, #1
        RET
\end{Verbatim}
\caption{A recursive implementation of Fibonacci}
\label{fig:aaa}
\end{minipage}
\end{figure}

\FloatBarrier
As with all recursive subroutines, we first need to test for the base cases.
In this case, we AND n with xFFFE, which produces a non-zero result for all
n except n=1 and n=0.  If n = 0 or 1, we are effectively done.  We move n
into R1, restore R2, R0, and R7 (actually, only R2 needs to be restored) and
return.

If n is not 0 or 1, we need to recursively call FIB twice, once with argument
n-1 and once with argument n-2.  Finally we add FIB(n-1) to FIB(n-2), put the
result in R1, retore R2, R0, and R7, and return.

Note that the recursive subroutine FIB(n) calls FIB twice: once for FIB(n-1) 
and once for FIB(n-2).  FIB(n-1) must call FIB(n-2) and FIB(n-3), and FIB(n-2) 
must call FIB(n-3) and FIB(n-4).  That means FIB(n-2) must be evaluated twice 
and FIB(n-3) will have to be evaluated three times.

Question: Suppose n=10.  How many times must this recursive algorithm compute
the same function FIB(5)?

Compare this algorithm with the non-recursive algorithm, wherein FIB(n) is
evaluated iteratively.

\begin{figure}[h!]
\begin{minipage}{36pc}
\begin{Verbatim}[fontsize=\fontsize{9}{11}\selectfont]

FIB     ST    R1,SaveR1
        ST    R2,SaveR2
        ST    R3,SaveR3
        ST    R4,SaveR4
        ST    R5,SaveR5
;
	NOT   R0,R0
	ADD   R0,R0,#1  ; R0 contains -n
	AND   R1,R1,#0  ; Suppose n=0
	ADD   R5,R1,R0  ; R5 = 0 -n
	BRz   DONE      ; if n=0, done almost
	AND   R3,R2,#0  ; if n>0, set up R3 = FIB(0) = 0
	ADD   R1,R3,#1  ; Suppose n=1
	ADD   R5,R1,R0  ; R5 = 1-n
	BRz   DONE      ; if n=1, done almost
	ADD   R4,R1,#0  ; if n>1, set up R4 = FIB(1) = 1
;
AGAIN   ADD   R1,R1,#1  ; We begin the iteration of FIB(i)
	ADD   R2,R3,#0  : R2= FIB(i-2)
	ADD   R3,R4,#0  : R3= FIB(i-1)
	ADD   R4,R2,R3  ; R4 = FIB(i)
	ADD   R5,R1,R0  ; is R1=n ?
	BRn   AGAIN
;
	ADD   R0,R4,#0  ; if n>1, R0=FIB(n)
	BRnzp RESTORE
DONE    ADD   R0,R1,#0  ; if n=0,1, FIB(n)=n
RESTORE LD    R1,SaveR1
	LD    R2,SaveR2
	LD    R3,SaveR3
	LD    R4,SaveR4
	LD    R5,SaveR5
	RET
\end{Verbatim}
\caption{An iterative solution to Fibonacci}
\label{fig:bb}
\end{minipage}
\end{figure}

Much, much faster execution time!

\FloatBarrier
%8.3.3
\subsection{The maze, a good example}

The reason for shying away from using recursion to compute factorial or 
Fibonacci is simply that the iterative algorithms are simple enough to
understand without the horrendous execution time penalty of recursion.
However, it is important to point out that there are times when the expressive
beauty of recursion is useful to attack a complicated problem.  Such is the
case with the following problem, involving a maze: Given a maze and a starting 
position within the maze, write a program that determines whether or not there 
is a way out of the maze from your starting postion.

\paragraph{A maze} 

A maze can be any size, n by m.  For example, Figure~\ref{fig:pictorial-maze}
illustrates a 6x6 maze.  

\begin{figure}[h]
\centerline{\includegraphics{pictorial.maze.eps}}
\caption{Example of a maze}
\label{fig:pictorial-maze}
\end{figure}

\noindent
Each of the 36 cells of the maze
can be characterized by whether there is a door to the north, east, 
south, or west, and whether there is a door from the cell to the outside 
world.  Each cell is represented by one word of memory, as follows:

\begin{figure}[h!]
\begin{minipage}{36pc}
\begin{Verbatim}[fontsize=\fontsize{9}{11}\selectfont]
Bit[4]=1 if there is a door to the outside world.  Bit[4]=0 if no door.
Bit[3]=1 if there is a door to the cell to the north.  Bit[3]=0 if no door.
Bit[2]=1 if there is a door to the cell to the east.  Bit[2]=0 if no door.
Bit[1]=1 if there is a door to the cell to the south.  Bit[1]=0 if no door.
Bit[0]=1 if there is a door to the cell to the west.  Bit[0]=0 if no door.
\end{Verbatim}
\caption{Specification of each cell in the maze}
\label{fig:cc}
\end{minipage}
\end{figure}

\noindent
The words are stored in row major order, i.e., Row 1 is stored, then row 2, 
then row 3, etc.  The complete specification of the 6 by 6 maze is shown
in Figure~\ref{fig:coded-maze}. 

\begin{figure}[h!]
\begin{minipage}{36pc}
\begin{Verbatim}[fontsize=\fontsize{9}{11}\selectfont]
00             .ORIG x5000
01 MAZE        .FILL x0006
02             .FILL x0007
03             .FILL x0005
04             .FILL x0005
05             .FILL x0003
06             .FILL x0000
07 ; second row: indices 6 to 11
08             .FILL x0008
09             .FILL x000A
0A             .FILL x0004
0B             .FILL x0003
0C             .FILL x000C
0D             .FILL x0015
0E ; third row: indices 12 to 17
0F             .FILL x0000
10             .FILL x000C
11             .FILL x0001
12             .FILL x000A
13             .FILL x0002
14             .FILL x0002
15 ; fourth row: indices 18 to 23
16             .FILL x0006
17             .FILL x0005
18             .FILL x0007
19             .FILL x000D
1A             .FILL x000B
1B             .FILL x000A
1C ; fifth row: indices 24 to 29
1D             .FILL x000A
1E             .FILL x0000
1F             .FILL x000A
20             .FILL x0002
21             .FILL x0008
22             .FILL x000A
23 ; sixth row: indices 30 to 35
24             .FILL x0008
25             .FILL x0000
26             .FILL x001A
27             .FILL x000C
28             .FILL x0001
29             .FILL x0008
2A             .END
\end{Verbatim}
\caption{Specification of the maze of Figure 8.20}
\label{fig:coded-maze}
\end{minipage}
\end{figure}

\FloatBarrier
\paragraph{A recursive subroutine to exit the maze}

Our job is to develop an algorithm to determine whether we can exit a maze from 
a given starting position within the maze.  With all the intricate paths that 
our attempts can take, keeping track of all that bookkeeping looks daunting.
Recursion allows us to not have to keep track of the paths at all!  
Figure~\ref{fig:pictorial.MAZE} shows a pictorial view of a recursive 
subroutine FIND\_EXIT, an algorithm for determining whether or not we can 
exit the maze.  Note that the subroutine FIND\_EXIT is shown as an octagon, 
and inside the octagon there are four more instances of octagons, indicating
recursive calls to FIND\_EXIT.  If we can exit the maze, we will return 
from the subroutine with R1=1, if not, we will return with R1=0.

\begin{figure}[h]
\centerline{\includegraphics[scale=0.7]{pictorial.FIND_EXIT.eps}}
\caption{Pictorial representation of the recursive subroutine to exit the maze}
\label{fig:pictorial.MAZE} 
\end{figure} 

The algorithm works as follows: In each cell, we first ask if there is an exit
from this cell to the outside world.  If yes, we return the value 1 and return.
If not, we ask whether we should try the cell to the north, the east, the
south, or the west.  In order to try a cell in any direction, clearly there must
be a door to the cell in that direction.  Further, we want to be sure we do not
end up in an infinite loop where for example, there are doors that allow us to
go North one cell, and from there East one cell, and from there South one cell,
and from there West one cell, putting us right back where we started.  To 
prevent situations like that from happening, we put a "breadcrumb" in each 
cell we visit, and only go to a cell and JSR FIND\_EXIT if we have not visited 
that cell before.

Thus, our algorithm:

a. From our cell, we ask if we can exit.  If yes, we are done. We exit with 
R1=1.

b. If not, we put a breadcrumb in our cell.  Our breadcrumb is bit[15] of 
the word corresponding to our current cell.  We set it to 1.

c. We ask two questions: Is there a door to the north, and have we never visited
the cell to the North before?  If the answer to both is yes, we set the
address to the cell to the North, and JSR FIND\_EXIT.  We set the address to 
the cell to the north by simply subtracting 6 from the address of the current 
cell.  Why 6?  Because the cells are stored in row major order and the number 
of columns in the maze is 6.

d. If the answer to either question is no, or if going north resulted in 
failure, we ask: Is there a door to the East, and have we never visited that 
cell before?  If the answer to both is yes, we set the address to the address
of the cell to the East (by adding 1 to the address) and JSR FIND\_EXIT.

e. If going East does not get us out, we repeat the question for South, and 
if that does not work, then for West.

f. If we end up with no door to the West to a cell we have not visited, or
if there is a door and we haven't visited, but it results in failure, we are
done.  We can not exit the maze from our starting position.  We set R1=0, and
return. 

Figure~\ref{fig:maze.algorithm} shows a recursive algorithm that determines
if we can exit the maze, given our starting address.  

\begin{figure}[h!]
\begin{minipage}{36pc}
\begin{Verbatim}[fontsize=\fontsize{9}{11}\selectfont]
; Recursive subroutine that determines if there is a path from current cell
; to the outside world.
; input: R0, current cell address
; output: R1, YES (1) or NO (0)
            .ORIG x4000

01 FIND_EXIT   ; save modified registers into the stack.
02             ADD R6, R6, #-1
03             STR R2, R6, #0   ; R2 holds the cell data of the caller
04             ADD R6, R6, #-1
05             STR R3, R6, #0   ; R3 holds the cell address of the caller
06             ADD R6, R6, #-1
07             STR R7, R6, #0   ; R7 holds the PC of the caller
08
09             ; Move cell address to R3, since we need to use R0
0A             ; as the input to recursive subroutine calls.
0B             ADD R3, R0, #0
0C 
0D             ; If the exit is in this cell, return YES
0E             LDR R2, R0, #0   ; R2 now holds the current cell data
0F             LD  R7, EXIT_MASK
10             AND R7, R2, R7
11             BRnp DONE_YES
12 
13             ; Put breadcrumb in the current cell.
14             LD  R7, BREADCRUMB
15             ADD R2, R2, R7
16             STR R2, R0, #0
17 
18             ; check the north cell for a path to exit
19 CHECK_NORTH LD  R7, NORTH_MASK
1A             AND R7, R2, R7
1B             BRz CHECK_EAST    ; If north is blocked, check east
1C             LDR R7, R3, #-6
1D             BRn CHECK_EAST    ; If a breadcrumb in the north cell, check east
1E             ADD R0, R3, #-6
1F             JSR FIND_EXIT     ; Recursively check the north cell
20             ADD R1, R1, #0
21             BRp DONE_YES      ; If a path from north cell found, return YES
22 
23             ; check the north cell for a path to exit
24 CHECK_EAST  LD  R7, EAST_MASK
25             AND R7, R2, R7
26             BRz CHECK_SOUTH   ; If the way to east is blocked, check south
27             LDR R7, R3, #1
28             BRn CHECK_SOUTH   ; If a breadcrumb in the east cell, check south
29             ADD R0, R3, #1
2A             JSR FIND_EXIT     ; Recursively check the east cell
2B             ADD R1, R1, #0
2C             BRp DONE_YES      ; If a path from east cell found, return YES
2D 
\end{Verbatim}
\caption{a recursive subroutine to determine if there is an exit from the maze}
\label{fig:maze.algorithm}
\end{minipage}
\end{figure}

\begin{figure}[h!]
\begin{minipage}{36pc}
\begin{Verbatim}[fontsize=\fontsize{9}{11}\selectfont]

2E             ; check the south cell for a path to exit
2F CHECK_SOUTH LD  R7, SOUTH_MASK
30             AND R7, R2, R7
31             BRz CHECK_WEST    ; If the way to south is blocked, check west
32             LDR R7, R3, #6
33             BRn CHECK_WEST    ; If a breadcrumb in the south cell, check west
34             ADD R0, R3, #6
35             JSR FIND_EXIT     ; Recursively check the south cell
36             ADD R1, R1, #0
37             BRp DONE_YES      ; If a path from south cell found, return YES
38
39             ; check the west cell for a path to exit
3A CHECK_WEST  LD  R7, WEST_MASK
3B             AND R7, R2, R7
3C             BRz DONE_NO       ; If the way to west is blocked, return NO
3D             LDR R7, R3, #-1
3E             BRn DONE_NO       ; If a breadcrumb in the west cell, return NO
3F             ADD R0, R3, #-1
40             JSR FIND_EXIT     ; Recursively check the west cell
41             ADD R1, R1, #0
42             BRp DONE_YES      ; If a path from west cell found, return YES
43 
44 DONE_NO     AND R1, R1, #0
45             BR  RESTORE
46 
47 DONE_YES    AND R1, R1, #0
48             ADD R1, R1, #1
49 
4A RESTORE     ADD R0, R3, #0 ; restore R0 from R3
4B             ; restore the rest of the modified registers from the stack.
4C             LDR R7, R6, #0
4D             ADD R6, R6, #1
4E             LDR R3, R6, #0
4F             ADD R6, R6, #1
50             LDR R2, R6, #0
51             ADD R6, R6, #1
52             RET
53 
54 BREADCRUMB  .FILL x8000
55 EXIT_MASK   .FILL x0010
56 NORTH_MASK  .FILL x0008
57 EAST_MASK   .FILL x0004
58 SOUTH_MASK  .FILL x0002
59 WEST_MASK   .FILL x0001
5A             .END
\end{Verbatim}
\caption{a recursive subroutine to determine if there is an exit from the maze (continued)}
\label{fig:xxxxx}
\end{minipage}
\end{figure}

%8.4 
\section{The Queue}

Our next data structure is the {\em queue}.
Recall that the property that defined the concept of "stack" was LIFO, the last
thing we pushed onto the stack is the first thing we pop off the stack.  
The defining property of the abstract data type {\em queue} is {\bf FIFO}.  
FIFO stands for "First in First out."  The data structure "queue" is like a
queue in a polite supermarket, or a polite ticket counter.  That is, the first 
person in line is the first person serviced.  In the context of the data
structure, this means we need to keep track of two ends of the storage 
structure: a FRONT pointer for servicing (i.e., removing elements from the 
front of the queue) and a REAR pointer for entering (i.e., inserting into the 
rear of the queue).

Figure~\ref{fig:first.queue} shows a block of six sequential memory locations 
that have been
allocated for storing elements in the queue.  The queue grows from x8000 to 
x8005.  We arbitrarily assign the FRONT pointer to the location just before 
the first element of the queue.  We assign the REAR pointer to the location 
containing the most recent element that was added to the queue.  Let's use R3 
as our FRONT pointer and R4 as our REAR pointer.  

\begin{figure}[h]
\centerline{\includegraphics[scale=0.5]{first.queue.eps}}
\caption{A queue allocated to memory locations x8000 to x8005}
\label{fig:first.queue}
\end{figure}

\FloatBarrier
Figure~\ref{fig:first.queue}a shows a queue in which five values were entered 
into the queue.  Since FRONT = x8001, the values 45 in memory location x8000 
and 17 in x8001 must have been removed, and the front element of the queue 
is 23, the value contained in x8002.   

Note that the values 45 and 17 are still contained in memory locations x8000 
and x8001, even though they have been removed.  Like the Stack, studied 
already, that is the nature of load instructions.  When a value is removed by 
means of a load instruction, the contents of the memory location is not erased.
The contents of the memory location are simply copied into the destination 
register.  However,  since FRONT contains the address x8001, there is no way 
to load from locations x8000 and x8001 as long as locations x8000 to x8005 
behave like a queue -- i.e., as long as the accesses are FIFO.  

\subsection{The basic operations: remove from front, insert at rear}

Since FRONT points to the location just in front of first element in the 
queue, we remove a value by first incrementing FRONT, and then loading the
value stored at that incremented address.  In our example, the next value to 
be removed is the value 23, which is at the front of the queue, in memory 
location x8002.  The following code {\em removes} 23 from the queue:

\begin{colorverbatim}
		    ADD   R3,R3,#1
                    LDR   R0,R3,#0
\end{colorverbatim}
\noindent
yielding the structure in Figure~\ref{fig:first.queue}b.

Since REAR = x8004, the last value to enter the queue is 74.  The values in
in the queue in Figure~\ref{fig:first.queue}b are 2, and 74.  To 
{\em insert} another element (for example, 10) at the back of the queue, 
the following code is executed:

\begin{colorverbatim}
		    ADD   R4,R4,#1
                    STR   R0,R4,#0
\end{colorverbatim}

\noindent
resulting in Figure~\ref{fig:first.queue}c.

\subsection{Wrap-around}

At first blush, it looks like we can not insert any more elements into the 
queue.  Not so!  When we remove a value from the queue, that location becomes 
available for storing another element.  We do that by allowing the available 
storage locations to {\em wrap around}.  For example, suppose we want to add 
20 to the queue.  Since there is nothing stored in x8000 (recall 45 had been
previously removed), we can store 20 in x8000.  The result is shown in 
Figure~\ref{fig:first.queue}d.  

"Wrap around" works by having our removal and insertion algorithms test the
contents of FRONT and REAR for the value x8005.  If we wish to insert, and
REAR contains x8005, we know we have reached the end of our available storage
and we must see if x8000 is available.  If we wish to remove, we must first
see if FRONT contains the address x8005.  If it does, the front of the queue
is in x8000.  Thus our code for remove and insert have to include a test for
wrap-around.  The code for remove becomes:

\begin{colorverbatim}
                    LD   R2, LAST
                    ADD  R2,R3,R2
                    BRnp SKIP_1
                    LD   R3,FIRST
                    BR   SKIP_2
	   SKIP_1   ADD  R3,R3,#1
           SKIP_2   LDR  R0,R3,#0 ; R0 gets the front of the queue
                    RET
           LAST     .FILL x7FFB   ; LAST contains the negative of 8005
           FIRST    .FILL x8000
\end{colorverbatim}

The code for insert is similar.  If REAR contains x8005, we need to set 
R4 to x8000 before we can insert an element at the rear of the queue.  The
code to insert is as follows:

\begin{colorverbatim}
                    LD   R2, LAST
                    ADD  R2,R4,R2
                    BRnp SKIP_1
                    LD   R4,FIRST
                    BR   SKIP_2
	   SKIP_1   ADD  R4,R4,#1
           SKIP_2   STR  R0,R4,#0 ; R0 gets the front of the queue
                    RET
           LAST     .FILL 7FFB   ; LAST contains the negative of 8005
           FIRST    .FILL x8000
\end{colorverbatim}

\subsection{How many elements can we store in a queue?}

Let's look again at Figure~\ref{fig:first.queue}d.  There are four values 
in the queue: 2, 74, 10, and 20.  Suppose we insert 30 and 40 at the rear of 
the queue, producing Figure~\ref{fig:first.queue} e.
Both R3 and R4 contain the same address (x8002), and the queue is full.
Now suppose we start removing elements from the front of the queue.  If we
remove 2, which is at the front of the queue, R3 will contain the address 
x8003.  If we remove the remaining five elements in the queue, we will have 
what is shown in Figure~\ref{fig:first.queue}f.  Note that the FRONT and REAR 
pointers for figure e and f are identical, yet Figure~\ref{fig:first.queue}e 
describes a full queue and Figure~\ref{fig:first.queue}f describes an
empty queue!  Clearly that is not acceptable.

Our answer is to allow a queue to store only n-1 elements if space for 
n elements have been allocated.  That is, if inserting an nth element 
into the queue would cause FRONT to equal REAR, we do not allow that 
insertion.  We declare the queue full when there are n-1 elements in the queue.

Let's look again at the queue in Figure~\ref{fig:first.queue}d.  There are 
four elements in the 
queue, from front to rear: 2, 74, 10, and 20, and two empty slots, x8001 and 
x8002.  We can insert 30 in x8001, producing Figure~\ref{fig:full.empty.queue}a.
That is, 30 is the 5th element inserted in the queue. Since 6 words have been 
allocated for the queue, and we now have 5 elements in the queue. We declare
the queue full, and do not allow a 6th element to be inserted.  Suppose we 
now start removing elements from the queue until the queue is empty, as shown 
in Figure~\ref{fig:full.empty.queue}b.  Now there is no ambiguity between a 
full and empty queue since if the queue is empty, FRONT=REAR. 


\begin{figure}[h]
\centerline{\includegraphics[scale=0.7]{full.empty.queue.eps}}
\caption{A full queue and an empty queue}
\label{fig:full.empty.queue}
\end{figure}

\FloatBarrier
\subsection{Tests for Underflow, Overflow}

As was the case with the stack, we can only remove an element from a queue if 
there are elements in the queue.  Likewise, we can only insert elements in the
queue if it is not full.  If the queue is empty and we try to remove an element,
we have an {\em underflow} condition.  If the queue is full and we try to
insert an element, we have an overflow condition.  In both cases, if we are
using a subroutine to manage the queue, we need to report success or failure 
to the calling program.  As with the stack, we will use R5 for this purpose.

The test for underflow is straightforward.  We saw from 
Figure~\ref{fig:full.empty.queue} that if FRONT=REAR, the queue is empty.  
Our code to test for underflow is therefore

\begin{colorverbatim}
                    AND   R5,R5,#0  ; Initialize R5 to 0
                    NOT   R2,R3
                    ADD   R2,R2,#1  ; R2 contains negative of R3
                    ADD   R2,R2,R4
                    BRz   UNDERFLOW
                    ; code to remove the front of the queue and return success.
 UNDERFLOW          ADD   R5,R5,#1
                    RET
\end{colorverbatim}
 
\noindent
That is, we first check to see if the queue is empty; i.e., if R3=R4.  If so, 
we branch to UNDERFLOW, where we set R5 to failure, restore R1, and return.
If not, carry out the code to remove the front of the queue.
 
The test for overflow is similar.  To insert an element to the back of the
queue, we first increment the REAR pointer.  If that causes FRONT=REAR, then
the queue already contains n-1 elements, which means it is full so we can not 
insert any more elements.  We decrement the REAR pointer, set R5 to 1, and 
return.

\subsection{The complete story}

We conclude our attention to queues with a subroutine that allows elements
to be removed from the front or inserted into the rear of the queue, wraps 
around when one of the pointers reaches the last element, and returns with a
report of success (R5=0) or failure (R5=1) depending on whether the access 
succeeds or the access fails due to an underflow or overflow condition.

To make this concrete, we will tie this subroutine to the queue of 
Figure~\ref{fig:first.queue}, where we have allocated locations x8000 to
x8005 for our queue, x8000 being the FIRST location and x8005 being the
LAST location.

To insert, we first have to make sure the queue is not full.  To do that, we
increment the REAR pointer (R4) and then test REAR=FRONT.  If the REAR pointer 
was initially x8005, we increment REAR by setting it to x8000; i.e., we need to
wrap around.  If the queue is full, we need to set REAR back to its original 
value, and return, reporting failure (R5=1).  If the queue is not full we 
store the item we wish to insert (which is in R0) in REAR, and return, 
reporting success (R5=0).

To remove, we first make sure the queue is not empty by testing whether
REAR=FRONT.  If REAR=FRONT, the queue is empty, so we return, reporting failure.
If REAR is not the same as FRONT, the queue is not empty so we can remove the
front element.  To do this we first test to see if FRONT=x8005. if it is, we
set FRONT=x8000.  If it isn't, we increment FRONT.  In both cases, we then
load the value from that memory location into R0, and return, reporting success.

Figure~\ref{fig:complete.queue.subroutine} shows the complete subroutine.

\begin{figure}[h!]
\begin{minipage}{36pc}
\begin{Verbatim}[fontsize=\fontsize{9}{11}\selectfont]

00 ;Input: R0 for item to be inserted, R3 is FRONT, R4 is REAR
01 ;Output: R0 for item to be removed
02                             ;
03 INSERT    ST    R1,SaveR1   ; Save register we need
04           AND   R5,R5,#0    ; Set R5 to success code
05                            ; Initialization complete                  
06           LD    R1,NEG_LAST    
07           ADD   R1,R1,R4    ; R1 = REAR MINUS x8005
08           BRnp  SKIP1       ; SKIP WRAP AROUND
09           LD    R4,FIRST    ; WRAP AROUND, R4=x8000
0A           BR    SKIP2
0B SKIP1     ADD   R4,R4,#1    ; NO WRAP AROUND, R4=R4+1
0C SKIP2     NOT   R1,R4
0D           ADD   R1,R1,#1    ; R1= NEG REAR
0E           ADD   R1,R1,R3    ; R1= FRONT-REAR
0F           BRz   FULL
10           STR   R0,R4,#0    ; DO THE INSERT
11           BR    DONE
12 FULL      LD    R1,NEG_FIRST
13           ADD   R1,R1,R4    ; R1 = REAR MINUS x8000
14           BRnp  SKIP3
15           LD    R4,LAST     ; UNDO WRAP AROUND, REAR=x8005
16           BR    SKIP4
17 SKIP3     ADD   R4,R4,#-1   ; NO WRAP AROUND, R4=R4-1
18 SKIP4     ADD   R5,R5,#1    ; R5=FAILURE
19           BR    DONE
1A                             ;
1B REMOVE    ST    R1,SaveR1   ; Save register we need
1C           AND   R5,R5,#0    ; Set R5 to success code
1D                            ; Initialization complete                  
1E           NOT   R1,R4
1F           ADD   R1,R1,#1    ; R1= NEG REAR
20           ADD   R1,R1,R3    ; R1= FRONT-REAR
21           BRz   EMPTY 
22           LD    R1, NEG_LAST
23           ADD   R1,R1,R3    ; R1= FRONT MINUS x8005
24           BRnp  SKIP5
25           LD    R3, FIRST   ; R3=x8000
26           BR    SKIP6
27 SKIP5     ADD   R3,R3,#1    ; R3=R3+1
28 SKIP6     LDR   R0,R3,#0    ; DO THE REMOVE      
29           BR    DONE
2A EMPTY     ADD   R5,R5.#1    ; R5=FAILURE
2B DONE      LD    R1,SaveR1   ; Restore register
2C           RET
2D FIRST     .FILL x8000
2E NEG_FIRST .FILL x8000
2F LAST      .FILL x8005
30 NEG_LAST  .FILL x7FFB
31 SaveR1    .BLKW 1

\end{Verbatim}
\caption{The complete queue subroutine}
\label{fig:complete.queue.subroutine}
\end{minipage}
\end{figure}

\FloatBarrier
%8.5
\section{Character strings}

Our final data structure: the character string!

The last data structure we will study in Chapter 8 is the character string, 
where data is organized as a one-dimensional array of ASCII codes, usually
representing a person's name, address, or some other alphanumeric string.
Figure~\ref{fig:bill.linvill} shows a character 
string representing the name of the famous late Stanford professor Bill Linvill,
stored in 13 consecutive words of memory, starting at location x5000.  The 
ASCII code for each letter of his name is stored in a separate word of memory.
Since an ASCII code consists of one byte of memory, we add a leading x00 to 
each location.  For example, x5000 contains x0042 since the ASCII code for a 
capital "B" is x42.  We need 13 memory locations, one word for each of the 11 
letters in his name, one word for the ASCII code x20 representing the space 
between his first and last names, and finally the null character x0000 to 
indicate that we have reached the end of the character string.  Different 
alphanumeric strings require character strings of different lengths, but 
that is no problem since we allocate however many words of memory are needed, 
followed by the null character x0000 to indicate the end of the 
character string.

\begin{figure}[h]
\centerline{\includegraphics[scale=0.7]{bill.linvill.eps}}
\caption{Character string representing the name "Bill Linvill"}
\label{fig:bill.linvill}
\end{figure}

\FloatBarrier
A common use of a character string is to identify a body of information
associated with a particular person.  Figure~\ref{fig:personnel.record} shows 
such a body of information (often called a personnel record) associated with 
an employee of a company.  

\begin{figure}[h]
\centerline{\includegraphics{personnel.record.eps}}
\caption{Mary Jones' personnel record}
\label{fig:personnel.record}
\end{figure}

\FloatBarrier
Our example personnel record consists of six words of sequential memory, 
starting at location x4000, as follows:

\noindent
1. The first word contains the starting address of a character 
string containing the person's last name.  The pointer, in location x4000 is the
address x6000.  The six-word character string, starting at location x6000,
contains the ASCII code for "Jones," terminated with the null character.\\
2. The second word, at x4001, contains a pointer to the character string
of the person's first name, in this case "Mary," starting at location x4508.\\
3. The third word, at x4002, contains a pointer (xCA9B) to her 9-digit 
social security number, the unique identifier for all persons working in the
United States.\\
4. The fourth word, at x4003, contains her salary (in thousands of dollars).\\
5. The fifth word contains how long she has worked for the company.\\
6. The sixth word is a pointer (x8E25) to the character string identifying 
her job title, in this case "Engineer."\\

In summary, an employee named Mary Jones, social security number 012654621, 
an Engineer, has been with the company 4 years, and earns \$84,000/year salary. 

One can write computer programs that examine employee records looking for 
various personnel information.  For example, if one wanted to know an 
employee's salary, a program could examine employee records, looking for 
that employee.  The program would call a subroutine that compares the 
character string representing an employee's Social Security Number with the 
characters of the social security number of the person  
the subroutine is searching for.  If all the characters match, the 
subroutine would return a success code (R5=0), and the program would go on to
read the salary information in the fourth word of the personnel record.  If all
the characters do not match, the subroutine would return a failure code (R5=1), 
and the program would call the subroutine with the starting address of another 
employee's social security number. 

Figure~\ref{fig:string.compare} is a subroutine that compares two character 
strings to see if they are identical.  

\begin{figure}[h!]
\begin{minipage}{36pc}
\begin{Verbatim}[fontsize=\fontsize{9}{11}\selectfont]
STRCMP    ST     R0,SaveR0
          ST     R1,SaveR1
          ST     R2,SaveR2
          ST     R3,SaveR3
;
          AND    R5,R5,#0  ; R5 <-- Match
;
NEXTCHAR  LDR    R2,R0,#0  ; R2 contains character from 1st string
          LDR    R3,R1,#0  ; R3 contains character from 2nd string
          BRnp   COMPARE   ; String is not done, continue comparing
          ADD    R2,R2,#0
          BRz    DONE      ; If both strings done, match found
COMPARE   NOT    R2,R2
          ADD    R2,R2,#1  ; R2 contains negative of character
          ADD    R2,R2,R3  ; Compare the 2 characters
          BRnp   FAIL      ; Not equal, no match
          ADD    R0,R0,#1
          ADD    R1,R1,#1
          BRnzp  NEXTCHAR  ; Move on to next pair of characters
;
FAIL      ADD    R5,R5,#1  ; R5 <-- No match
;
DONE   LD     R0,SaveR0
          LD     R1,SaveR1
          LD     R2,SaveR2
          LD     R3,SaveR3
          RET
;
SaveR0    .BLKW  1
SaveR1    .BLKW  1
SaveR2    .BLKW  1
SaveR3    .BLKW  1
\end{Verbatim}
\caption{Subroutine to compare two character strings}
\label{fig:string.compare}
\end{minipage}
\end{figure}

\FloatBarrier
\paragraph{Another example: A character string representing an "integer."} 
We can also represent arbitrarily long integers by means of character 
strings.  For example, Figure~\ref{fig:integer.string} is a character string 
representing the integer 79,245.  

\begin{figure}[h]
\centerline{\includegraphics[scale=0.8]{integer.string.eps}}
\caption{A character string, representing the integer 79,245, with one 
ASCII code per decimal digit}
\label{fig:integer.string}
\end{figure}

\FloatBarrier
Figure~\ref{fig:test.for.integer} is a subroutine that examines such a 
character string to be sure that in fact all ASCII codes represent decimal 
digits.  If all the entries in the character string are ASCII codes of 
decimal digits (between x30 and x39), the subroutine returns success (R=0).  
If not, the subroutine returns failure (R5=1).

\begin{figure}[h!]
\begin{minipage}{36pc}
\begin{Verbatim}[fontsize=\fontsize{9}{11}\selectfont]

; Input: R0 contains the starting address of the character string
; Output: R5=0, success; R5=1, failure.
;
TEST_INTEGER   ST   R1,SaveR1  ; Save registers needed by subroutine 
               ST   R2,SaveR2
               ST   R3,SaveR3
               ST   R4,SaveR4
;
               AND  R5,R5,#0   ; Initialize success code to R5=0, success
               LD   R2,ASCII_0 ; R2=xFFD0, the negative of ASCII code x30
               LD   R3,ASCII_9 ; R3=xFFC7, the negative of ASCII code x39
;
   NEXT_CHAR   LDR  R1,R0,#0   ; Load next character
               BRz  SUCCESS
               ADD  R4,R1,R2
               BRn  BAD        ; R1 is less than x30, not a decimal digit
               ADD  R4,R1,R3   
               BRp  BAD        ; R1 is greater than x39, not a decimal digit 
               ADD  R0,R0,#1   ; Character good!  Prepare for next character
               BR   NEXT_CHAR
;
         BAD   ADD  R5,R5,#1   ; R5 contains failure code
     SUCCESS   LD   R4,SaveR4  ; Restore registers
               LD   R3,SaveR3
               LD   R2,SaveR2
               LD   R1,SaveR1
               RET
     ASCII_0        .FILL xFFD0
     ASCII_9        .FILL xFFC7
      SaveR1   .BLKW 1
      SaveR2   .BLKW 1
      SaveR3   .BLKW 1
      SaveR4   .BLKW 1

\end{Verbatim}
\caption{Subroutine to determine if a character string represents an integer}
\label{fig:test.for.integer}
\end{minipage}
\end{figure}

\FloatBarrier
\begin{exercises}

\item [8.1]
  What are the defining characteristics of a stack?

\item [8.2]
  What is an advantage to using the model in Figure~10.3 to implement
  a stack versus the model in Figure~10.2?

\item [8.3]
  The LC-3 ISA has been augmented with the following Push and Pop
  instructions. Push Rn pushes the value in Register n onto the stack.
  Pop Rn removes a value from the stack and loads it into Rn. The
  figure below shows a snapshot of the eight registers of the LC-3
  BEFORE and AFTER the following six stack operations are
  performed. Identify (a)--(d).

\begin{center}
{\fontsize{8}{10}\selectfont\sans\begin{tabular}{ccl@{\ \,}cc}
& {\bf BEFORE} & & & {\bf AFTER}\\
\cline{2-2}\cline{5-5}
\multicolumn{1}{c}{R0} & \multicolumn{1}{|c|}{x0000} & {\tt \fontsize{9}{12}\selectfont\color{seventyblack}PUSH R4} & R0 &
\multicolumn{1}{|c|}{x1111}\\
\cline{2-2}\cline{5-5}
\multicolumn{1}{c}{R1} & \multicolumn{1}{|c|}{x1111} & {\tt \fontsize{9}{12}\selectfont\color{seventyblack}PUSH \!\!\!\! (a)} & R1 &
\multicolumn{1}{|c|}{x1111}\\
\cline{2-2}\cline{5-5}
\multicolumn{1}{c}{R2} & \multicolumn{1}{|c|}{x2222} & {\tt \fontsize{9}{12}\selectfont\color{seventyblack}POP \,\!\! (b)} & R2 &
\multicolumn{1}{|c|}{x3333}\\
\cline{2-2}\cline{5-5}
\multicolumn{1}{c}{R3} & \multicolumn{1}{|c|}{x3333} & {\tt \fontsize{9}{12}\selectfont\color{seventyblack}PUSH \!\!\!\! (c)} & R3 &
\multicolumn{1}{|c|}{x3333}\\
\cline{2-2}\cline{5-5}
\multicolumn{1}{c}{R4} & \multicolumn{1}{|c|}{x4444} & {\tt \fontsize{9}{12}\selectfont\color{seventyblack}POP \ R2} & R4 &
\multicolumn{1}{|c|}{x4444}\\
\cline{2-2}\cline{5-5}
\multicolumn{1}{c}{R5} & \multicolumn{1}{|c|}{x5555} & {\tt \fontsize{9}{12}\selectfont\color{seventyblack}POP \,\!\! (d)} & R5 &
\multicolumn{1}{|c|}{x5555}\\
\cline{2-2}\cline{5-5}
\multicolumn{1}{c}{R6} & \multicolumn{1}{|c|}{x6666} & & R6 &
\multicolumn{1}{|c|}{x6666}\\
\cline{2-2}\cline{5-5}
\multicolumn{1}{c}{R7} & \multicolumn{1}{|c|}{x7777} & & R7 &
\multicolumn{1}{|c|}{x4444}\\
\cline{2-2}\cline{5-5}
\end{tabular}}
\end{center}

\item [8.4]
  Write a function that implements another stack function, peek. Peek
  returns the value of the first element on the stack without removing
  the element from the stack. Peek should also do underflow error
  checking. (Why is overflow error checking unnecessary?)

\item [8.5]
  How would you check for underflow and overflow conditions if you
  implemented a stack using the model in Figure~10.2?  Rewrite the
  PUSH and POP routines to model a stack implemented as in 
  Figure~10.2, that is, one in which the data entries move with 
  each operation.

\item [8.6]
  Rewrite the PUSH and POP routines such that the stack on which they
  operate holds elements that take up two memory locations each.

\item [8.7]
  Rewrite the PUSH and POP routines to handle stack elements of
  arbitrary sizes.

\item [8.8]
  The following operations are performed on a stack:

\begin{colorverbatim}
PUSH A, PUSH B, POP, PUSH C, PUSH D, POP, PUSH E,
POP, POP, PUSH F
\end{colorverbatim}

\begin{enumerate}[a.]
\item[a.] What does the stack contain after the
  \texttt{PUSH F}?

\item[b.] At which point does the stack contain the most elements?
  Without removing the elements left on the stack from the previous
  operations, we perform:

\begin{colorverbatim}
PUSH G, PUSH H, PUSH I, PUSH J, POP, PUSH K,
POP, POP, POP, PUSH L, POP, POP, PUSH M
\end{colorverbatim}

\item[c.] What does the stack contain now?
\end{enumerate}

\item [8.9]
  The input stream of a stack is a list of all the elements we pushed
  onto the stack, in the order that we pushed them. The input stream
  from Exercise 10.8 was \verb|ABCDEFGHIJKLM|

  The output stream is a list of all the elements that are popped off
  the stack, in the order that they are popped off.

\begin{enumerate}[a.]
\item[a.] What is the output stream from Exercise 10.8?\break
{\em Hint:} BDE $\ldots$

\item[b.] If the input stream is ZYXWVUTSR, create a sequence of
  pushes and pops such that the output stream is YXVUWZSRT.

\item[c.] If the input stream is ZYXW, how many different output
  streams can be created?
\end{enumerate}


\item[8.10] STAR It is easier to identify borders between cities on a map if adjacent cities are colored with different colors.  For example, in a map of Texas, one would not color Austin and Pflugerville with the same color, since doing so would obscure
the border between the two cities. \\

\noindent
Shown below is the recursive subroutine EXAMINE.  EXAMINE examines the data
structure representing a map to see if any pair of adjacent cities have the
same color.  Each node in the data structure contains the city's color and the
addresses of the cities it borders.  If no pair of adjacent cities have the
same color, EXAMINE returns the value 0 in R1.  If at least one pair of
adjacent cities have the same color, EXAMINE returns the value 1 in R1.  The
main program supplies the address of a node representing one of the cities in
R0 before executing JSR EXAMINE. \\

%\begin{center}
\begin{minipage}[t]{0.5\linewidth}
{
\begin{alltt}
        .ORIG x4000
EXAMINE ADD R6, R6, #-1
        STR R0, R6, #0
        ADD R6, R6, #-1
        STR R2, R6, #0
        ADD R6, R6, #-1
        STR R3, R6, #0
        ADD R6, R6, #-1
        STR R7, R6, #0

        AND R1, R1, #0  ; Initialize output R1 to 0
        LDR R7, R0, #0
        BRn RESTORE     ; Skip this node if it has already been visited

        LD  R7, BREADCRUMB
        STR R7, R0, #0  ; Mark this node as visited
        LDR R2, R0, #1  ; R2 = color of current node
        ADD R3, R0, #2

AGAIN   LDR R0, R3, #0  ; R0 = neighbor node address
        BRz RESTOR
        LDR R7, R0, #1
        NOT R7, R7      ; <-- Breakpoint here
        ADD R7, R7, #1
        ADD R7, R2, R7  ; Compare current color to neighbor's color
        BRz BAD
        JSR EXAMINE     ; Recursively examine the coloring of next neighbor
        ADD R1, R1, #0
        BRp RESTORE     ; If neighbor returns R1=1, this node should return R1=1
        ADD R3, R3, #1
        BR  AGAIN       ; Try next neighbor

BAD     ADD R1, R1, #1
RESTORE LDR R7, R6, #0
        ADD R6, R6, #1
        LDR R3, R6, #0
        ADD R6, R6, #1
        LDR R2, R6, #0
        ADD R6, R6, #1
        LDR R0, R6, #0
        ADD R6, R6, #1
        RET

BREADCRUMB .FILL x8000
        .END
\end{alltt}
}
\end{minipage}
%\end{center}
\noindent

\noindent
Your job is to construct the data structure representing a particular map.
Before executing JSR EXAMINE, R0 is set to x6100 (the address of one of the
nodes), and a breakpoint is set at x4012.  The table below shows relevant
information collected each time the breakpoint was encountered during the
running of EXAMINE. \\

\begin{tabular}{|c|c|c|c|}
\hline
  PC    & R0    & R2    & R7    \\ \hline
  x4012 & x6200 & x0042 & x0052 \\ \hline 
  x4012 & x6100 & x0052 & x0042 \\ \hline 
  x4012 & x6300 & x0052 & x0047 \\ \hline 
  x4012 & x6200 & x0047 & x0052 \\ \hline 
  x4012 & x6400 & x0047 & x0052 \\ \hline 
  x4012 & x6100 & x0052 & x0042 \\ \hline 
  x4012 & x6300 & x0052 & x0047 \\ \hline 
  x4012 & x6500 & x0052 & x0047 \\ \hline 
  x4012 & x6100 & x0047 & x0042 \\ \hline 
  x4012 & x6200 & x0047 & x0052 \\ \hline 
  x4012 & x6400 & x0047 & x0052 \\ \hline 
  x4012 & x6500 & x0052 & x0047 \\ \hline 
  x4012 & x6400 & x0042 & x0052 \\ \hline 
  x4012 & x6500 & x0042 & x0047 \\ \hline 
\end{tabular}

\vspace{0.2in}
\noindent
Construct the data structure for the particular map that corresponds to
the relevant information obtained from the breakpoints. Note: We are asking
you to construct the data structure as it exists AFTER the recursive
subroutine has executed.
\vspace{0.2in}

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.25]{811_mapnodes.eps}
\end{center}
\end{figure}

\item[8.11] ADD The following program needs to be assembled and stored in LC-3 Memory.
How many LC-3 memory locations are required to store the assembled program?

\begin{alltt}
        .ORIG x4000
        AND  R0,R0,#0
        ADD  R1,R0,#0
        ADD  R0,R0,#4
        LD   R2,B
A       LDR  R3,R2,#0
        ADD  R1,R1,R3
        ADD  R2,R2,#1
        ADD  R0,R0,#-1
        BRnp A
        JSR  SHIFTR
        ADD  R1,R4,#0
        JSR  SHIFTR
        ST   R4,C
        TRAP x25
B       .BLKW 1
C       .BLKW 1
        .END
\end{alltt}
\noindent 
How many memory locations are required to store the assembled program?  

\vspace{0.3in}
\noindent What is the address of the location labeled C?

\vspace{0.3in}
\noindent
Before the program of part can execute, the location labeled B must be loaded by some external means.  You can assume that happens before this program starts executing.  The program also contains a subroutine whose starting address is SHIFTR.  Recall in class, we talked about subroutine libraries (collections of subroutines) that are linked with your program to provide one complete executable image.  You can assume that the subroutine starting at location SHIFTR is available for the above program to use. SHIFTR takes the value in R1, shifts it right one bit, and stores the result in R4. \\

\vspace{0.1in}
\noindent 
After the program executes, what is in location C?

\item[8.12]STAR Many cities, like New York City, Stockholm, Konigsberg, etc.
consist of several areas, connected by bridges.  The figure below shows a
map of FiveParts, a city made up of five areas A,B,C,D,E, with the areas
connected by 9 bridges as shown. \\

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.4]{813_bridges.eps}
\end{center}
\end{figure}

\noindent
The following program prompts the user to enter two areas, and then stores the
number of bridges from the first area to the second in location x4500.  Your
job: On the next page, design the data structure for the city of FiveParts that
the program below will use to count the number of bridges between two areas. \\

%\begin{center}
\begin{minipage}[t]{0.5\linewidth}
\begin{flushleft}
{
\begin{alltt}
            .ORIG x3000
            LEA R0, FROM
            TRAP x22
            TRAP x20      ; Inputs a char without banner
            NOT R1, R0
            ADD R1, R1, #1
            LEA R0, TO
            TRAP x22
            TRAP x20
            NOT R0, R0
            ADD R0, R0, #1
            AND R5, R5, #0
            LDI R2, HEAD
SEARCH      BRz DONE
            LDR R3, R2, #0
            ADD R7, R1, R3
            BRz FOUND_FROM
            LDR R2, R2, #1
            BRnzp SEARCH
FOUND_FROM  ADD R2, R2, #2
NEXT_BRIDGE LDR R3, R2, #0
            BRz DONE
            LDR R4, R3, #0
            ADD R7, R0, R4
            BRnp SKIP
            ADD R5, R5, #1  ; Increment Counter
SKIP        ADD R2, R2, #1
            BRnzp NEXT_BRIDGE
DONE        STI R5, ANSWER
            HALT
HEAD        .FILL x3050
ANSWER      .FILL x4500
FROM        .STRINGZ "FROM: "
TO          .STRINGZ "TO: "
            .END
\end{alltt}
}
\end{flushleft}
\end{minipage}
%\end{center}

\noindent
Your job is to provide the contents of the memory locations that are needed to
specify the data structure for the city of FiveParts, which is needed by the
program on the previous page.  We have given you the HEAD pointer for the data
structure and in addition, five memory locations and the contents of those five
locations.  We have also supplied more than enough sequential memory locations
after each of the five to enable you to finish the job.  Use as many of these
memory locations as you need.
\vspace{0.2in}

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.4]{813_nodes.eps}
\end{center}
\end{figure}

\item[8.13] Our code to compute n factorial worked for all positive integers
n.  As promised in the text, your assignment here: Augment the iterative
solution to FACT to also work for 0!.

\item[8.14] As you know, the LC-3 ADD instruction adds 16-bit 2's complement integers.  If we wanted to add 32-bit 2's complement integers, we could do that with the program shown below.  Note that the program requires calling subroutine X which stores into R0 the carry that results from adding R1 and R2. \\

Fill in the missing pieces of both the program and the subroutine X, as identified by the empty boxes. Each empty box corresponds to {\bf one} instruction or the operands of {\bf one} instruction.

\noindent Note that a 32-bit operand requires two 16-bit memory locations.  A 32-bit operand Y has Y[15:0] stored in address A, and Y[31:16] stored in address 
A+1. \\

\begin{alltt}

.ORIG   x3000 
        LEA R3, NUM1
        LEA R4, NUM2
        LEA R5, RESULT
        LDR R1, R3, #0
        LDR   R2, R4, #0
        ADD R0, R1, R2
        STR R0, R5, #0
        --------------- (a)
        LDR ----------- (b)
        LDR ----------- (c)
        ADD R0, R1, R2
        --------------- (d)
        TRAP  x25

X       ST  R4, SAVER4
        AND   R0, R0, #0
        AND R4, R1, R2
        BRn ----------- (e)
        ADD R1, R1, #0
        BRn ----------- (f)
        ADD ----------- (g)
        BRn ADDING
        BRnzp EXIT
ADDING  ADD   R4, R1, R2
        BRn EXIT
LABEL   ADD   R0, R0, #1
EXIT    LD  R4, SAVER4
        RET

NUM1    .BLKW 2
NUM2    .BLKW 2
RESULT  .BLKW 2
SAVER4  .BLKW 1

.END
\end{alltt}

\item[8.15]STAR A program encounters a breakpoint and halts.  The computer operator does not change the state of the computer in any way, but immediately presses the {\bf run} button to resume execution.\\

\noindent The table below shows the contents of MAR and MDR for the first nine
memory accesses that the LC-3 performs after resuming execution.\\

\noindent Your job: Fill in the missing entries.\\

\begin{figure}[h!]
    \centering
    \unitlength1in
    \begin{minipage}[h!]{1.0in}

\begin{tabular}{c}
\\
\raisebox{0.25in}{} 1st:\\
\raisebox{0.25in}{} 2nd:\\
\raisebox{0.25in}{} 3rd:\\
\raisebox{0.25in}{} 4th:\\
\raisebox{0.25in}{} 5th:\\
\raisebox{0.25in}{} 6th:\\
\raisebox{0.25in}{} 7th:\\
\raisebox{0.25in}{} 8th:\\
\raisebox{0.25in}{} 9th:\\
\end{tabular}
\end{minipage}
    \hspace{-0.6in}\begin{minipage}[h!]{1.0in}

\begin{tabular}{|c|c|} \hline
\ \ \ MAR\ \ \  & \ \ \ MDR\ \ \ \\
\hline
\raisebox{0.25in}{} & x5020\\
\hline
\raisebox{0.25in}{} & xF0F0\\
\hline
\raisebox{0.25in}{} &\\
\hline
\raisebox{0.25in}{} x2000 & x020A\\
\hline
\raisebox{0.25in}{} & x040A\\
\hline
\raisebox{0.25in}{} & x61FE\\
\hline
\raisebox{0.25in}{} & \\
\hline
\raisebox{0.25in}{} & xC1C0\\
\hline
\raisebox{0.25in}{} x4002 & xF025\\
\hline
\end{tabular}
\end{minipage}
\end{figure}

\end{exercises}
\end{document}
\end{exercises}
\end{document}
