\documentclass{patt}
\usepackage[section]{placeins}
\graphicspath{{../art/appendix/},{../art/designelements/},{../art/designelements/UnNumberedArt/}}

\setcounter{page}{521}

\makeatletter

\renewcommand{\apphead}[2]{%
  \clearpage\vspace*{-8pt}
  \noindent\parbox[t]{21pc}{\raggedright\sans\fontsize{24}{28}\fontseries{bk}%
    \selectfont\MakeUppercase{#1}}\parbox[t]{7pc}{\sans\fontseries{bk}\fontsize{14}{28}\selectfont
    \raggedright #2}\@afterindentfalse\@afterheading\vspace*{-1pc}}

\renewcommand{\appbhead}[1]{%
  \goodbreak\vspace{6pt}
  \begingroup
  \noindent\raggedright{\sans\fontsize{12}{14}\fontseries{bk}\selectfont
  #1\par}\endgroup\medskip\@afterindentfalse\@afterheading}


\makeatother


\begin{document}

\appendix
\setcounter{chapter}{1}

\chapter*{The LC-3 ISA}

\renewcommand{\thefootnote}{\fnsymbol{footnote}}

\vspace{-6pt}

\section{Overview}

The Instruction Set Architecture (ISA) of the LC-3 is
defined as follows:

\begin{description}
\leftskip18pt
\item[Memory address space] 16 bits,
corresponding to $2^{16}$ locations, each containing one word (16
bits). Addresses are numbered from 0 (i.e, x0000) to 65,535 (i.e.,
xFFFF). Addresses are used to identify memory locations and memory-mapped
I/O device registers. Certain regions of memory are reserved for special uses,
as described in Figure~A.1.

% Figure 1
\begin{figure}
\vspace{-12pt}
\centerline{\includegraphics[scale=0.6]{address_space.eps}}
\caption{Memory map of the LC-3}
\end{figure}

Locations x0000 to x2FFF comprise privileged memory, and are only accessible
if the process is executing in Supervisor mode (PSR[15]=0).  Locations x3000 to
xFDFF comprise memory available to user code and data.  Addresses xFE00 to xFFFF
specify input and output device registers and special internal processor registers that are also only accessible if the process is executing in Supervisor
mode (PSR[15]=0).  For purposes of controlling access to these device registers,
their addresses are also considered part of privileged memory.

\item[Memory-mapped I/O] Input and output are handled by load/store (LD/ST, 
LDI/STI, LDR/STR) instructions using memory addresses from xFE00 to xFFFF to 
designate each device register.  Table~A.1 lists the input and output device 
registers and internal processor registers that have been specified for the 
LC-3 thus far, along with their corresponding assigned addresses from 
the memory address space.

%Table A.1
\begin{table}[t]
\processtable{Device Register Assignments}
{\begin{tabular*}{28pc}{@{\hspace{6pt}\extracolsep{\fill}}llP{16pc}@{}}
%\toprule
\tabhead{Address} & \tabhead{I/O Register Name} & \tabhead{I/O Register Function}\\
\midrule
xFE00 & Keyboard status register (KBSR) & The ready bit (bit [15]) indicates if the
 keyboard has received a new character.\\
xFE02 & Keyboard data register (KBDR) & Bits [7:0] contain the last character typed
 on the keyboard.\\
xFE04 & Display status register (DSR) & The ready bit (bit [15]) indicates if the display
 device is ready to receive another character to print on the screen.\\
xFE06 & Display data register (DDR) & A character written in bits [7:0] 
 will be displayed on the screen.\\
xFFFC & Processor Status Register (PSR) & Contains privilege mode, priority level and condition codes
 of the currently executing process. \\
xFFFE & Machine control register (MCR) & Bit [15] is the clock enable bit. When cleared,
 instruction processing stops.\\
\botrule
\end{tabular*}}{}
\label{tab:io_map}
\end{table}

\item[Bit numbering] Bits of all quantities
are numbered, from right to left, starting with bit 0. The leftmost bit of
the contents of a memory location is bit 15.

\item[Instructions] Instructions are 16 bits wide. Bits
[15:12] specify the opcode (operation to be performed), bits [11:0]
provide further information that is needed to execute the instruction.
The specific operation of each LC-3 instruction is described in
Section~A.2.

\item[Illegal opcode exception] Bits [15:12]${}={}$1101 has not been specified.
If an instruction contains 1101 in bits [15:12], an illegal opcode exception
occurs. Section A.3 explains what happens.

\item[Program counter] A 16-bit register containing the address
of the next instruction to be processed.

\item[General purpose registers]
Eight 16-bit registers, numbered from 000 to 111 (R0 to R7).

\item[Condition codes] Three 1-bit registers: N (negative),
Z (zero), and P (positive). Load instructions (LD, LDI, and LDR)
and operate instructions (ADD, AND, and NOT) each load a
result into one of the eight general purpose registers. The
condition codes are set, based on whether that result, taken as a
16-bit 2's complement integer, is negative $({\rm N}=1;{\rm
Z},{\rm P}=0)$, zero $({\rm Z}=1;{\rm N},{\rm P}=0)$, or positive
$({\rm P}=1; {\rm N},{\rm Z}=0)$. All other LC-3 instructions
leave the condition codes unchanged.

\item[Interrupt processing] I/O devices have the
capability of interrupting the processor. Section A.3
describes the mechanism.

\item[Priority level] The LC-3 supports eight levels of priority.
Priority level 7 (PL7) is the highest, PL0 is the lowest. The priority level
of the currently executing process is specified in bits PSR[10:8].

\item[Processor status register (PSR)] A 16-bit register, containing status
information about the currently executing process. Seven bits of the PSR have
been defined thus far. PSR[15] specifies the privilege mode of the~executing
process. PSR[10:8] specifies the priority level of the currently executing
process. PSR[2:0] contains the condition codes. PSR[2] is N, PSR[1] is Z, and
PSR[0] is P.

\item[Supervisor mode] The LC-3 specifies two modes of operation, 
Supervisor mode
(privileged) and User mode (unprivileged). Interrupt service routines and trap 
service routines (i.e., system calls) execute
in Supervisor mode. The privilege mode is specified by PSR[15]. 
PSR[15]=0 indicates Supervisor mode; PSR[15]=1 indicates User mode.

\item[Privilege mode exception] The RTI instruction executes in Supervisor mode.
If the processor attempts to execute the RTI instruction while in User mode,
a privilege mode exception occurs. Section A.3 explains what happens.

\item[Access Control Violation (ACV) Exception] An ACV exception occurs if a 
process attempts to access a location in privileged memory (either a location
in System Space or a device register having an address from xFE00 to xFFFF)
while operating in User mode.   Section A.3 explains what happens.

\item[Supervisor Stack] A region of memory in system space accessible via the 
Supervisor Stack Pointer (SSP). When PSR[15]=0, the stack pointer (R6) is SSP.
When the processor is operating in User mode (PSR[15]=1), the SSP is stored in
Saved\_SSP.

\item[User Stack] A region of memory in user space accessible via
the User Stack Pointer (USP). When PSR[15]=1, the stack pointer (R6) is USP.
When the processor is operating in Supervisor mode (PSR[15]=0), the USP is
stored in Saved\_USP
\end{description}

%A.2
\section{The Instruction Set}
\label{appLC2:insts}

The LC-3 supports a rich, but lean, instruction set. Each 16-bit
instruction consists of an opcode (bits[15:12]) plus 12 additional bits
to specify the other information that is needed to carry out that
instruction. Figure~A.2 summarizes the 15 different opcodes in
the LC-3 and the specification of the remaining bits of each instruction.
The 16th 4-bit opcode is not specified, but is reserved for future use.

In the following pages,
the instructions will be described in greater detail. Table~A.2 is
provided to help understand those descriptions.  For each
instruction, we show the assembly language representation, the
format of the 16-bit instruction, the operation of the instruction, an
English-language description of its operation, and one or more examples of
the instruction. Where relevant, additional notes about the instruction are
also provided.

%Table A.2
\begin{table}[t]
\vspace{-8pt} \processtable{Notational Conventions}
{\begin{tabular}{@{\hspace{6pt}}lP{24pc}@{}}
\tabhead{Notation} & \tabhead{Meaning}\\
\midrule
xNumber & The number in hexadecimal notation. Example: xF2A1\\
\#Number & The number in decimal notation. Example \#793\\
bNumber & The number in binary. Example b10011\\
A[l:r] & The {\bf field} delimited by bit [l] on the left and bit
[r] on the right, of the
 datum A. For example, if PC contains 0011001100111111, then
 PC[15:9] is 0011001. PC[2:2] is 1. If l and r are the same bit
 number, we generally write PC[2].\\
BaseR & Base Register; one of R0..R7, specified by bits [8:6] of the 
 instruction, used in conjunction with a six-bit offset to
 compute Base$+$offset addresses (LDR and STR), or alone to identify the 
 target address of a control instruction (JMP and JSRR).\\
DR & Destination Register; one of R0..R7, which specifies the register 
 a result should be written to.\\
imm5 & A 5-bit immediate value (bits [4:0] of an instruction), when
 used as a literal (immediate) value. Taken as a 5-bit, 2's
 complement integer, it is sign-extended to 16 bits before it is used. 
 Range: $-16..15$. \\
INTV & An 8-bit value, supplied along with an interrupting event; used
to determine the starting address of an interrupt service routine.
The eight bits form an offset from the starting address of the interrupt 
vector table. The corresponding location in the interrupt vector table 
contains the starting address of the corresponding interrupt service routine. 
Range {0..255}. \\
LABEL & An assembly language construct that identifies a location
 symbolically (i.e., by
 means of a name, rather than its 16-bit address). \\
mem[address] & Denotes the contents of memory at the given address. \\
offset6 & A 6-bit signed 2's complement integer (bits [5:0] of an instruction),
 used with the Base$+$offset addressing mode. Bits [5:0] are 
 sign-extended to 16~bits and then added to the Base Register to form an
 address. Range: $-32..31$. \\
PC & Program Counter; 16-bit register that contains the
 memory address of the {\it next} instruction to be fetched. For example,
 if the instruction at address A is not a control instruction, during 
 its execution, the PC contains the address ${\rm A}+1$, indicating that 
 the next instruction to be executed is contained in memory 
 location ${\rm A}+1$. \\
PCoffset9 &A 9-bit signed 2's complement integer (bits [8:0] of an 
 instruction), used with the
 PC$+$offset addressing mode. Bits [8:0] are sign-extended to 16 bits and then
 added to the incremented PC to form an address. Range $-256..255$. \\
PCoffset11 &An 11-bit signed 2's complement integer (bits [10:0] of an 
instruction), used with the JSR opcode to compute the target address of a 
subroutine call.  Bits [10:0] are sign-extended to 16 bits and then added to 
the incremented PC to form the target address. Range $-1024..1023$.\\
PSR & Processor Status Register. A 16-bit register that contains
status information of the process that is executing. Seven bits 
of the PSR have been specified.  PSR[15]${}={}$privilege mode.
PSR[10:8] = Priority Level.  PSR[2:0] contains the condition codes. 
PSR[2]= N, PSR[1]= Z, PSR[0]= P.\\
Saved\texttt{\_}SSP & Saved Supervisor Stack Pointer.  The processor is 
 executing in either Supervisor mode or User mode.  If in User mode, 
 R6, the stack pointer, is the User Stack Pointer (USP).  The Supervisor
 Stack Pointer (SSP) is stored in Saved\texttt{\_}SSP.  When the privilege mode
 changes from User mode to Supervisor mode, Saved\texttt{\_}USP is loaded 
 with R6 and R6 is loaded with Saved\texttt{\_}SSP.\\
Saved\texttt{\_}USP & Saved User Stack Pointer.  The User Stack Pointer is 
 stored in Saved\texttt{\_}USP when the processor is executing in Supervisor 
 mode.  See Saved\texttt{\_}SSP.\\
setcc() & Indicates that condition codes N, Z, and P are set based
 on the value of the result written to DR.\\
SEXT(A) & Sign-extend A. The most significant bit of A is replicated 
 as many times as necessary to extend A to 16 bits. For example, 
 if ${\rm A}=110000$, then SEXT(A)${}={}$1111 1111 1111 0000.\\
SP & The current stack pointer. R6 is the current stack pointer.
 There are two stacks, one for each privilege mode. SP is SSP if
 ${\rm PSR}[15]=0$; SP is USP if ${\rm PSR}[15]=1$.\\
SR, SR1, SR2 & Source Register; one of R0..R7 which specifies the
 register from which a source operand is obtained.\\
SSP & The Supervisor Stack Pointer. \\
%Supervisor Stack Pointer; the stack pointer when PSR[15] = 0, i.e.,
%the processor is running in supervisor (privileged) mode. See also
%section~A.1, Supervisor Stack. \\ [3.0pt]
%%
trapvect8 & An 8-bit value; (bits [7:0] of an instruction), used
 with the TRAP opcode to determine the starting address of a trap
 service routine. Bits [7:0] are taken as an unsigned integer and
 zero-extended to 16 bits. This is the address of the memory
 location containing the starting address of the corresponding service 
 routine. Range {0..255}.\\
%trapvect8 & Eight-bit trap number used in the TRAP instruction. When
%zero-extended to 16 bits it is the address of the memory location
%containing the starting address of the corresponding trap service routine.
%Range {0..255}. \\ [3.0pt]
%%
USP & The User Stack Pointer. \\
ZEXT(A) & Zero-extend A. Zeros are appended to the leftmost bit
 of A to extend it to 16 bits. For example, if ${\rm A}=110000$, then
 ZEXT(A)${}={}$0000 0000 0011 0000. \\
\botrule
\end{tabular}}{}
\vspace{-6pt} \label{tab:notation}
\end{table}

% Figure A.2
\begin{figure}[h]
\centerline{\includegraphics{APPA02.eps}} \label{fig:insts}
\caption{Format of the entire LC-3 instruction set. {\bf Note:}
$+$ indicates instructions that modify condition codes}
\end{figure}

\apphead{Add}{\hfill Addition} \label{page:add_inst}

 \vspace{4pt}

\appbhead{Assembler Formats}


\begin{appverbatim}
ADD    DR, SR1, SR2
ADD    DR, SR1, imm5
\end{appverbatim}

\vspace{2pt}

\appbhead{Encodings}

\includegraphics[width=3.50in]{add.eps}

 \vspace{4pt}

\appbhead{Operation}
{\ttfamily{\ttfamily\color{seventyblack}\small\begin{tabbing}
col\=col\=col\kill
if (bit[5] $==$ 0)\\
\>\> $\text{{DR}\,=\,{SR}1\,+\,{SR}2;}$\\
else\\
\>\> $\text{{DR}\,=\,{SR}1\,+\,\text{SEXT(imm5)};}$\\
setcc();
\end{tabbing}}}

\vspace{4pt}

\appbhead{Description}
If bit [5] is 0, the second source operand is obtained from SR2.
If bit [5] is 1, the second source operand is obtained by sign-extending the
imm5 field to 16 bits. In both cases, the second source operand is added to
the contents of SR1 and the result stored in DR. The condition codes are set,
based on whether the result is negative, zero, or positive.

 \vspace{4pt}

\appbhead{Examples}
\begin{tabular}{@{\hspace{1.5pc}}l@{\quad}l@{\qquad}l@{}}
ADD   & R2, R3, R4     & ; ${\rm R}2 \leftarrow{\rm R}3+{\rm R}4$ \\
ADD   & R2, R3, \#7    & ; ${\rm R}2 \leftarrow {\rm R}3+7$
\end{tabular}

\apphead{And}{\vspace{-18pt}\hspace{-4.1pc}\hbox{Bit-wise Logical AND}}

 \vspace{1.3pc}

\appbhead{Assembler Formats}

\begin{appverbatim}
AND   DR, SR1, SR2
AND   DR, SR1, imm5
\end{appverbatim}

\vspace{4pt}

\appbhead{Encodings}

\includegraphics[width=3.50in]{and.eps}

\appbhead{Operation}

{\ttfamily\color{seventyblack}\small\begin{tabbing}
col\=col\=col\kill
if (bit[5] $==$ 0)\\
\>\>$\text{{DR}\,=\,{SR}1}$ \text{AND SR2;}\\
else \\
\>\>$\text{{DR}\,=\,{SR}1}$ \text{AND SEXT(imm5);}\\
setcc();
\end{tabbing}}

\vspace{4pt}

\appbhead{Description}

If bit [5] is 0, the second source operand is obtained from SR2.
If bit [5] is 1, the second source operand is obtained by sign-extending the
imm5 field to 16 bits. In either case, the second source operand and the
contents of SR1 are bit-wise ANDed, and the result stored in DR. The condition
codes are set, based on whether the binary value produced, taken as a
2's complement integer, is negative, zero, or positive.

 \vspace{4pt}

\appbhead{Examples}

\begin{tabular}{@{\hspace{1.5pc}}l@{\quad}l@{\qquad}l@{}}
AND   & R2, R3, R4    & ;${\rm R}2 \leftarrow {\rm R}3$ AND R4 \\
AND   & R2, R3, \#7   & ;${\rm R}2 \leftarrow {\rm R}3$ AND 7
\end{tabular}

\apphead{Br}{\vspace*{-16pt}\hspace{-3.5pc} \hbox{Conditional Branch}}

\vspace{4pt}

\renewcommand{\thefootnote}{\fnsymbol{footnote}}

\vspace{14pt}

\appbhead{Assembler Formats}

 \vspace*{6pt}

\begin{tabular}{@{}l@{\quad}l@{\qquad}l@{\quad}l@{}}
BRn & LABEL  & BRzp  & LABEL \\
BRz & LABEL  & BRnp  & LABEL \\
BRp & LABEL  & BRnz  & LABEL \\
BR$^{\dagger}$
    & LABEL  & BRnzp & LABEL
\end{tabular}

\footnotetext[2]{The assembly language opcode BR is interpreted the
  same as BRnzp; that is, always branch to the target address.}

 \vspace{10pt}

\appbhead{Encoding}

\includegraphics[width=3.50in]{br.eps}

\renewcommand{\thefootnote}{\fnsymbol{footnote}}

 \vspace{4pt}

\appbhead{Operation}

{\ttfamily{\ttfamily\color{seventyblack}\small\begin{tabbing}
col\=col\=col\kill
if ((n AND N) OR (z AND Z) OR (p AND P)) \\
\>$\text{{PC}\,=\,{PC}}{}^{\ddag}\,\text{+}\,{}$ \text{SEXT(PCoffset9);}
\end{tabbing}}}

\footnotetext[3]{This is the incremented PC.}

\vspace{10pt}

\appbhead{Description}

The condition codes specified by bits [11:9] are tested.
If bit [11] is 1, N is tested; if bit [11] is 0, N is not tested.
If bit [10] is 1, Z is tested, etc. If any of the condition codes
tested is 1, the program branches to the memory location specified 
by adding the sign-extended PCoffset9 field to the incremented PC.

 \vspace{10pt}

\appbhead{Examples}

\begin{tabular}{@{\hspace{1.5pc}}l@{\quad}l@{\qquad}l@{}}
BRzp & LOOP     & ; Branch to LOOP if the last result was zero or
positive. \\
BR\footnotemark[2] &
 NEXT         & ; Unconditionally branch to NEXT.
\end{tabular}

%%%% JMP\RET
%%%%
\apphead{Jmp \break Ret}{\hspace{-5.5pc}Jump \break \hbox{\hspace{-5.5pc}Return from Subroutine}}

 \vspace{30pt}

\appbhead{Assembler Formats}

\begin{appverbatim}
JMP    BaseR
RET
\end{appverbatim}

 \vspace{4pt}

\appbhead{Encoding}

\includegraphics[width=4.00in]{jmp2.eps}

\smallskip

\noindent
\includegraphics[width=4.00in]{ret2.eps}

 \vspace{4pt}

\appbhead{Operation}

{\ttfamily\color{seventyblack}\small\begin{tabbing}
 $\text{PC}=\text{BaseR}$;
\end{tabbing}}

 \vspace{4pt}

\appbhead{Description}

The program unconditionally jumps to the location specified by
the contents
of the base register. Bits [8:6] identify the base register.

 \vspace{4pt}

\appbhead{Examples}

\begin{tabular}{@{\hspace{1.5pc}}l@{\quad}l@{\qquad}l@{}}
JMP & R2 & ; ${\rm PC}\leftarrow {\rm R}2$ \\
RET &    & ; ${\rm PC}\leftarrow {\rm R}7$
\end{tabular}

 \vspace{4pt}

\appbhead{Note}

The RET instruction is a special case of the JMP instruction, normally
used in the return from a subroutine.  The
PC is loaded with~the contents of R7, which contains the linkage
back to the instruction following the subroutine call instruction.

%%%%
%%%% JSR\JSRR
%%%%
\apphead{Jsr \break Jsrr}{\vspace*{-17pt}\hspace{-3.5pc}\hbox{Jump to Subroutine}}

\bigskip \vspace{10pt}

\appbhead{Assembler Formats}

\begin{appverbatim}
JSR      LABEL
JSRR   BaseR
\end{appverbatim}

 \vspace{4pt}

\appbhead{Encoding}

\includegraphics[width=4.00in]{jsr2.eps}

 \vspace{4pt}

\appbhead{Operation}
{\ttfamily\color{seventyblack}\small\begin{tabbing}
col\=col\=col\kill
$\text{{TEMP}\,=\,{PC};}^{\dag}$\\
if (bit[11] $==$ 0)\\
\>$\text{PC}=\text{BaseR}$;\\
else \\
\>$\text{{PC}\,=\,{PC}}$\text{\footnotemark[2]} $+$ SEXT(PCoffset11);\\
$\text{{R}7\,=\,{TEMP};}$
\end{tabbing}}

\footnotetext[2]{This is the incremented PC.}

 \vspace*{4pt}

\appbhead{Description}

First, the incremented PC is saved in a temporary location. Then
the PC is loaded with the address of the first instruction of the
subroutine, which will cause an unconditional jump to that address after
the current instruction completes execution. The
address of the subroutine is obtained from the base register (if
bit [11] is 0), or the address is computed by sign-extending bits
[10:0] and adding this value to the incremented PC (if bit [11] is
1). Finally, R7 is loaded with the value stored in the temporary
location. This is the linkage back to the calling routine.

  \vspace{4pt}

\appbhead{Examples}

\begin{tabular}{@{\hspace{1.5pc}}l@{\enskip}l@{\enskip}l@{}}
JSR  & QUEUE & ; Put the address of the instruction following JSR into R7; \\
     &       & ; Jump to QUEUE. \\
JSRR & R3    & ; Put the address of the instruction following JSRR into R7; \\
     &       & ; Jump to the address contained in R3.
\end{tabular}

%%%%
%%%% LD
%%%%

\apphead{Ld}{\hfill Load}

\bigskip  \vspace{4pt}

\appbhead{Assembler Format}

\begin{appverbatim}
LD    DR, LABEL
\end{appverbatim}

\vspace{4pt}

\appbhead{Encoding}

\includegraphics[width=3.50in]{ld.eps}

\vspace{4pt}

\appbhead{Operation}

{\ttfamily{\ttfamily\color{seventyblack}\small\begin{tabbing}
col\=col\=col\kill
if (computed address is in privileged memory AND PSR[15] == 1)\\
\>Initiate ACV exception;\\
else\\
\>DR${}={}$mem[PC$^{\dag}$ $+$ SEXT(PCoffset9)];\\
\>setcc();
\end{tabbing}}}

\footnotetext[2]{This is the incremented PC.}

 \vspace{4pt}

\appbhead{Description}

An address is computed by sign-extending bits [8:0] to 16 bits
and adding this value to the incremented PC. 
If the address is to privileged memory and PSR[15]=1, initiate ACV exception.
If not, the contents of memory at this address are loaded into DR. The condition
codes are set, based on whether the value loaded is negative, zero, or
positive.

\vspace{4pt}

\appbhead{Example}

\begin{tabular}{@{\hspace{1.5pc}}l@{\quad}l@{\qquad}l@{}}
LD & R4, VALUE & ; ${\rm R}4 \leftarrow \text{mem}$[VALUE]
\end{tabular}

%%%%
%%%% LDI
%%%%

\apphead{Ldi}{\vspace{-17pt}\hbox{Load Indirect}}

 \vspace{14pt}

\appbhead{Assembler Format}

\begin{appverbatim}
LDI  DR, LABEL
\end{appverbatim}

 \vspace{4pt}

\appbhead{Encoding}

\includegraphics[width=3.50in]{ldi.eps}

\vspace{4pt}

\appbhead{Operation}
{\ttfamily{\ttfamily\color{seventyblack}\small\begin{tabbing}
col\=col\=col\kill
if (either computed address is in privileged memory AND PSR[15] == 1)\\
\>Initiate ACV exception;\\
else\\
\>DR${}={}$mem[mem[PC$^{\dagger}$ $+$ SEXT(PCoffset9)]];\\
\>setcc();
\end{tabbing}}}

\footnotetext[2]{This is the incremented PC.}

 \vspace{4pt}

 \appbhead{Description}

An address is computed by sign-extending bits [8:0] to 16 bits and
adding this value to the incremented PC. What is stored in memory at this
address is the address of the data to be loaded into DR. 
If either address is to privileged memory and PSR[15]=1, initiate ACV exception.
If not, the data is loaded and the condition codes are set, based on whether 
the value loaded is negative, zero, or positive.

 \vspace{4pt}

\appbhead{Example}

\begin{tabular}{@{\hspace{1.5pc}}l@{\quad}l@{\qquad}l@{}}
LDI & R4, ONEMORE  &  ; ${\rm R}4 \leftarrow\text{mem}$[mem[ONEMORE]]
\end{tabular}

%%%%
%%%% LDR
%%%%
\apphead{Ldr}{\vspace{-18pt}\hspace{-2.4pc}\hbox{Load Base$+$offset}}

 \vspace{14pt}

\appbhead{Assembler Format}

\begin{appverbatim}
LDR   DR, BaseR, offset6
\end{appverbatim}

 \vspace{4pt}

\appbhead{Encoding}

\includegraphics[width=3.50in]{ldw.eps}

\vspace{4pt}

\appbhead{Operation}
{\ttfamily{\ttfamily\color{seventyblack}\small\begin{tabbing}
col\=col\=col\kill
If (computed address is in privileged memory AND PSR[15] == 1)\\
\>Initiate ACV exception;\\
else\\
\>DR${}={}$mem[BaseR $+$ SEXT(offset6)];\\
\>setcc();
\end{tabbing}}}

 \vspace{4pt}

\appbhead{Description}

An address is computed by sign-extending bits [5:0] to 16 bits
and adding this value to the contents of the register specified by bits
[8:6].  If the computed address is to privileged memory and PSR[15]=1, initiate ACV exception.
If not, the contents of memory at this address are loaded into DR.
The condition codes are set, based on whether the value loaded
is negative, zero, or positive.

\vspace{4pt}

\appbhead{Example}

\begin{tabular}{@{\hspace{1.5pc}}l@{\quad}l@{\qquad}l@{}}
LDR & R4, R2, \#$-$5 \quad ; ${\rm R}4 \leftarrow\text{mem}$[R2${}-{}$5]
\end{tabular}

%%%%
%%%% LEA
%%%%
\apphead{Lea}{\vspace{-16pt}\hspace{-6pc}\hbox{Load Effective Address}}

 \vspace{15pt}

\appbhead{Assembler Format}

\begin{appverbatim}
LEA     DR, LABEL
\end{appverbatim}

 \vspace{4pt}

\appbhead{Encoding}

\includegraphics[width=3.50in]{lea.eps}

\vspace{4pt}

\appbhead{Operation}
{\ttfamily{\ttfamily\color{seventyblack}\small\begin{tabbing}
col\=col\=col\kill
DR${}={}$PC$^{\dag}$ $+$ SEXT(PCoffset9);\\
\end{tabbing}}}

\footnotetext[2]{This is the incremented PC.}

  \vspace{4pt}

\appbhead{Description}

An address is computed by sign-extending bits [8:0] to 16 bits and
adding this value to the incremented PC. This address is loaded into
DR.\footnote[3]{The LEA instruction computes an address but does NOT read memory.
  Instead, the address itself is loaded into DR.}

\vspace{4pt}

\appbhead{Example}

\begin{tabular}{@{\hspace{1.5pc}}l@{\quad}l@{\qquad}l@{}}
LEA &  R4, TARGET & ; ${\rm R}4 \leftarrow\text{address}$ of TARGET.
\end{tabular}

 \bgroup
\makeatletter

\renewcommand{\apphead}[2]{%
  \clearpage\vspace*{-8pt}
  \noindent\parbox[t]{21pc}{\raggedright\sans\fontsize{24}{28}\fontseries{bk}%
    \selectfont\MakeUppercase{#1}}\parbox[t]{14pc}{\sans\fontseries{bk}\fontsize{14}{28}\selectfont
    \raggedright #2}\@afterindentfalse\@afterheading\vspace*{-1pc}}

\makeatother


%%%%
%%%% NOT
%%%%
\apphead{Not}{\hspace{-4.4pc}\hbox{Bit-Wise Complement}}

 \vspace{14pt}

\appbhead{Assembler Format}

\begin{appverbatim}
NOT    DR, SR
\end{appverbatim}

 \vspace{4pt}

\appbhead{Encoding}

\includegraphics[width=3.50in]{not.eps}

\vspace{4pt}

\appbhead{Operation}
{\ttfamily{\ttfamily\color{seventyblack}\small\begin{tabbing}
col\=col\=col\kill
$\text{{DR}\,=\,}\text{NOT}$(SR); \\
setcc();
\end{tabbing}}}

 \vspace{4pt}

\appbhead{Description}

The bit-wise complement of the contents of SR
is stored in DR. The condition
codes are set, based on whether the binary value produced, taken as a
2's complement integer, is negative, zero, or positive.

\vspace{4pt}

\appbhead{Example}

\begin{tabular}{@{\hspace{1.5pc}}l@{\quad}l@{\qquad}l@{}}
NOT & R4, R2 & ; ${\rm R}4\leftarrow\text{NOT}$(R2)
\end{tabular}
 \egroup

%%%%
%%%% RET
%%%%

\renewcommand{\thefootnote}{\fnsymbol{footnote}}

\apphead{RET\protect\footnotemark[2]}{\vspace{-18pt}\hspace{-5.6pc}\hbox{Return from
  Subroutine}}

 \vspace{14pt}

\appbhead{Assembler Format}

\footnotetext[2]{The RET instruction is a specific encoding of the JMP
  instruction. See also JMP.}

\vspace{4pt}

\begin{unlist}
\item RET
\end{unlist}

 \vspace{4pt}

\appbhead{Encoding}

\includegraphics[width=3.50in]{ret.eps}

\vspace{4pt}

\appbhead{Operation}
{\ttfamily{\ttfamily\color{seventyblack}\small\begin{tabbing}
  PC = R7;
\end{tabbing}}}

 \vspace{4pt}

\enlargethispage{12pt}

\appbhead{Description}

The PC is loaded with the value in R7. Its normal use is to cause 
a return from a previous JSR(R) instruction.

\vspace{4pt}

\appbhead{Example}

\begin{tabular}{@{\hspace{1.5pc}}l@{\quad}l@{\qquad}l@{}}
RET & ; ${\rm PC}\leftarrow{\rm R}7$
\end{tabular}

%%%%
%%%% RTI
%%%%

 \bgroup
 \makeatletter
\renewcommand{\apphead}[2]{%
  \clearpage\vspace*{-21pt}
  \noindent\parbox[t]{21.1pc}{\raggedright\sans\fontsize{24}{28}\fontseries{bk}%
    \selectfont\MakeUppercase{#1}}\parbox[t]{7pc}{\sans\fontseries{bk}\fontsize{14}{28}\selectfont
    \raggedright #2}\@afterindentfalse\@afterheading\vspace*{-1pc}}
 \makeatother

 \apphead{Rti}{\vspace{-18pt}\hspace{-4.6pc}\hbox{Return from Trap or Interrupt}}

 \vspace{10pt}

\appbhead{Assembler Format}


\begin{unlist}
\item RTI
\end{unlist}

 \vspace{-0.2in}

\appbhead{Encoding}
\vspace{-0.1in}
\includegraphics[width=3.50in]{rti.eps}

\vspace{-4pt}

\appbhead{Operation}
{\ttfamily{\ttfamily\color{seventyblack}\small\begin{tabbing}
\=col\=col\=col\kill
\>\text{if (PSR[15] $==$ 1)} \\
\>\>\text{Initiate a privilege mode exception;}\\
\>\text{else} \\
\>\>$\text{{PC}\,=\,}\text{mem}$\text{[R6]; R6 is the SSP, PC is restored} \\
\>\>$\text{{R}6\,=\,{R}6+1;}$ \\
\>\>$\text{{TEMP}\,=\,{mem}}$\text{[R6];} \\
\>\>$\text{{R}6\,=\,{R}6+1;}$ \text{system stack completes POP before saved PSR is restored}\\
\>\>$\text{{PSR}\,=\,\text{TEMP};}$ \text{PSR is restored} \\
\>\>\text{if (PSR[15] $==$ 1)}\\ 
\>\>\>Saved{\textunderscore}SSP=R6 and R6=Saved{\textunderscore}USP;
\end{tabbing}}}

\vspace{-4pt}

%\enlargethispage{12pt}

\appbhead{Description}

If the processor is running in User mode, a privilege mode exception occurs.  
If in Supervisor mode, the top two elements on the System Stack are popped and 
loaded into PC, PSR.  After PSR is restored, if the processor is running in
User mode, the SSP is saved in Saved\_SSP, and R6 is loaded with Saved\_USP.

\vspace{-3pt}

\appbhead{Example}

\begin{tabular}{@{\hspace{1.5pc}}l@{\quad}l@{\qquad}l@{}}
RTI & ; PC, PSR $\leftarrow$ top two values popped off stack.
\end{tabular}

% \enlargethispage{12pt}
\vspace{-1pt}
\appbhead{Note}

RTI is the last instruction in both interrupt and trap service 
routines and returns control to the program that was running.
In both cases the relevant service routine is initiated by first pushing
the PSR and PC of the program that is running onto the System Stack. Then
the starting address of the appropriate service routine is loaded into the
PC, and the service routine executes with Supervisor privilege. The last 
instruction in the service 
routine is RTI, which returns control to the interrupted program by 
popping two values off the Supervisor Stack to restore the PC and PSR. 
In the case of an interrupt, the PC is restored to the address of~the 
instruction that was about to be processed when the interrupt was initiated. 
In the case of an exception, the PC is restored to either the address of the
instruction that caused the exception or the address of the following
instruction, depending on whether the instruction that caused the
exception is to be re-executed. In the case of a TRAP service routine,
the PC is restored to the instruction following the TRAP instruction in
the calling routine.  In the case of an interrupt or TRAP, the PSR
is restored to the value it had when the interrupt was initiated. In
the case of an exception, the PSR is restored to the value it had when
the exception occurred or to some modified value, depending on the
exception.  See also Section~A.3.
 \egroup

%
\begingroup
  \makeatletter
 \pagestyle{empty}
 \makeatother

%%%%
%%%% ST
%%%%

\apphead{St}{\vspace{-18pt}\hfill Store}

\bigskip

\vspace{4pt}

\appbhead{Assembler Format}

\begin{appverbatim}
ST    SR, LABEL
\end{appverbatim}

\vspace{4pt}

\appbhead{Encoding}

\includegraphics[width=3.50in]{st.eps}

\vspace{4pt}

\appbhead{Operation}
{\ttfamily{\ttfamily\color{seventyblack}\small\begin{tabbing}
col\=col\kill 
if (computed address is in privileged memory AND PSR[15] == 1)\\
\>Initiate ACV exception;\\
else\\
\>mem[PC\footnote[2]{This is the incremented PC.} $+$
SEXT(PCoffset9)] $=$ SR;
\end{tabbing}}}

\footnotetext[2]{This is the incremented PC.}

\vspace{4pt}

\appbhead{Description}

If the computed address is to privileged memory and PSR[15]=1, initiate ACV exception.
If not, the contents of the register specified by SR are stored in the memory
location whose address is computed by sign-extending bits [8:0] to 16
bits and adding this value to the incremented PC.

\vspace{4pt}

\appbhead{Example}

\begin{tabular}{@{\hspace{1.5pc}}l@{\quad}l@{\qquad}l@{}}
ST & R4, HERE  & ; mem[HERE] $\leftarrow$ R4
\end{tabular}
 \endgroup

%%%%
%%%% STI
%%%%
\apphead{Sti}{\hspace{-4pt}\hbox{Store Indirect}}

 \vspace{14pt}

\appbhead{Assembler Format}

\begin{appverbatim}
STI   SR, LABEL
\end{appverbatim}

 \vspace{4pt}

\appbhead{Encoding}

\includegraphics[width=3.50in]{sti.eps}

\vspace{4pt}

\appbhead{Operation}
{\ttfamily{\ttfamily\color{seventyblack}\small\begin{tabbing}
col\=col\kill 
if (either computed address is in privileged memory AND PSR[15] == 1)\\
\>Initiate ACV exception;\\
else \\
\>mem[mem[PC\footnotemark[2] $+$ SEXT(PCoffset9)]] $=$
SR;
\end{tabbing}}}

 \vspace{4pt}

\footnotetext[2]{This is the incremented PC.}

\appbhead{Description}

If either computed address is to privileged memory and PSR[15]=1, initiate ACV exception.
If not, the contents of the register specified by SR are stored in the
memory location whose address is obtained as follows: Bits [8:0] are
sign-extended to 16 bits and added to the incremented PC.
What is in memory at this address is the address of the
location to which the data in SR is stored.

\vspace{4pt}

\appbhead{Example}

\begin{tabular}{@{\quad\enskip\enskip}l@{\quad}l@{\qquad}l@{}}
STI & R4, NOT\_HERE & ; mem[mem[NOT\_HERE]] $\leftarrow$ R4
\end{tabular}

%%%%
%%%% STR
%%%%
\apphead{Str}{\vspace{-18pt}\hspace{-2.7pc}\hbox{Store~Base$+$offset}}

 \vspace{14pt}

\appbhead{Assembler Format}

\begin{appverbatim}
STR   SR, BaseR, offset6
\end{appverbatim}

 \vspace{4pt}

\appbhead{Encoding}

\includegraphics[width=3.50in]{stw.eps}

\vspace{4pt}

\appbhead{Operation}
{\ttfamily{\ttfamily\color{seventyblack}\small\begin{tabbing}
col\=col\kill 
if (computed address is in privileged memory AND PSR[15] == 1)\\
\>Initiate ACV exception;\\
else\\
\>mem[BaseR $+$ SEXT(offset6)] $=$ SR;
\end{tabbing}}}

\vspace{4pt}

\appbhead{Description}

If the computed address is to privileged memory and PSR[15]=1, initiate ACV exception.
If not, the contents of the register specified by SR are stored in the
memory location whose address is computed by sign-extending bits [5:0] to
16 bits and adding this value to the contents of the register specified by
bits [8:6].

\vspace{4pt}

\appbhead{Example}

\begin{tabular}{@{\hspace{1.5pc}}l@{\quad}l@{\qquad}l@{}}
STR & R4, R2, \#5 & ; mem[R2+5] $\leftarrow$ R4
\end{tabular}

%%%%
%%%% TRAP
%%%%

%\label{page:trap_inst}
%{\ttfamily\small\begin{tabbing}

\apphead{Trap}{\hfill\hbox{System Call}}

\bigskip

\vspace{4pt}

\appbhead{Assembler Format}

\begin{appverbatim}
TRAP   trapvector8
\end{appverbatim}

 \vspace{4pt}

\appbhead{Encoding}

\includegraphics[width=3.50in]{trap.eps}

\vspace{4pt}

\appbhead{Operation}

{\ttfamily{\ttfamily\color{seventyblack}\small\begin{tabbing}
col\=col\=col\kill
TEMP=PSR;\\
$\text{if (PSR[15] == 1)}$\\
\>Saved\_USP=R6 and R6=Saved\_SSP;\\
\>PSR[15]=0;\\
$\text{Push TEMP,PC\footnotemark[2] on the system stack}$\\
$\text{{PC}\,=\,}\text{mem}$\text{[ZEXT(trapvect8)];}
\end{tabbing}}}

\footnotetext[2]{This is the incremented PC.}

 \vspace{4pt}

\appbhead{Description}

If the the program is executing in User mode, the user stack pointer must be 
saved and the system stack pointer loaded.  Then the PSR and PC are pushed 
on the system stack.  (This enables a return to the instruction physically 
following the TRAP instruction in the
original program after the last instruction in the service routine (RTI)
has completed execution.) Then the PC is loaded with the starting address 
of the system call specified by trapvector8. The starting address is 
contained in the memory location whose address is obtained by zero-extending
trapvector8 to 16 bits.

\vspace{4pt}

\appbhead{Example}

\begin{tabular}{@{\hspace{1.7pc}}l@{\quad}l@{\quad}l@{}}
TRAP & x23 & ; Directs the operating system to execute the {\bf IN}
system call. \\
     &     & ; The starting address of this system call is contained
     in \\
     &     & ; memory  location x0023.
\end{tabular}

\appbhead{Note}

Memory locations x0000 through x00FF, 256 in all, are available
to contain starting addresses for system calls specified by their corresponding
trap vectors. This region of memory is called the Trap Vector Table.
Table~A.3 describes the functions performed by the service routines corresponding
to trap vectors x20 to~x25.

%%%%
%%%% UNUSED OPCODE
%%%%
\apphead{\hspace{-2pc}}{\hspace{-1.2pc}\hbox{Unused Opcode}}

\appbhead{Assembler Format}

\vspace{4pt}

\begin{unlist}
\item none
\end{unlist}

\vspace{4pt}

\appbhead{Encoding}

\includegraphics[width=3.50in]{nop.eps}

\vspace{4pt}

\appbhead{Operation}

Initiate an illegal opcode exception.

\vspace{4pt}

\appbhead{Description}

If an illegal opcode is encountered, an illegal opcode exception occurs.

\vspace{4pt}

\appbhead{Note}

The opcode 1101 has been reserved for future use. It is currently not
defined. If the instruction currently executing
has bits [15:12]${}={}$1101, an illegal opcode exception occurs. Section A.3
describes what happens.

\newpage

\renewcommand{\thefootnote}{\arabic{footnote}}

%Table A.3
\begin{table}[t]
\processtable{Trap Service Routines}
{\begin{tabular}{@{\hspace{6pt}\extracolsep{\fill}}llP{24pc}@{}}
\tabhead{Trap Vector} & \tabhead{Assembler Name} & \tabhead{Description}\\
\midrule
x20 & GETC & Read a single character from the
keyboard. The character is not echoed onto
the console. Its ASCII code is copied into
 R0. The high eight bits of R0 are cleared.\\
x21 & OUT & Write a character in R0[7:0] to the console display.\\
x22 & PUTS & Write a string of ASCII characters to the console display.
 The characters
 are contained in consecutive memory locations, one character per
 memory location, starting with the address specified in R0.
 Writing terminates with the occurrence of x0000 in a memory
 location.\\
x23 & IN & Print a prompt on the screen and read a single character from
 the keyboard. The character is echoed onto the console monitor,
 and its
 ASCII code is copied into R0. The high eight bits of R0 are
         cleared.\\
x24 & PUTSP & Write a string of ASCII characters to the console. The characters
 are contained in consecutive memory locations, two characters per
 memory location, starting with the address specified in R0.
 The ASCII code contained in bits [7:0] of a memory location
 is written to the console first. Then the ASCII code contained
 in bits [15:8] of that memory location is written to the
 console. (A character string consisting of an odd number of
 characters to be written will have x00 in bits [15:8] of the
 memory location containing the last character to be written.)
 Writing terminates with the occurrence of x0000 in a memory
 location.\\
x25 & HALT & Halt execution and print a message on the console. \\
\botrule
\end{tabular}}{}
\label{tab:trap}
 \vspace{12pt}
\end{table}



\section{Interrupt and Exception Processing}

As has been discussed in detail in Chapter~9, events external to the program 
that is running can interrupt the
processor. A common example of an external event is interrupt-driven I/O.
It is also the case that the processor can be interrupted by exceptional
events that occur while the program is running that are caused by the program
itself. An example of such an ``internal'' event is the presence of an unused
opcode in the computer program that is running.

Associated with each event that can interrupt the processor is an 8-bit
vector that provides an entry point into a 256-entry
{\em interrupt vector table}. The starting address of the interrupt vector
table is x0100. That is, the interrupt vector table occupies memory
locations x0100 to x01FF. Each entry in the interrupt vector table contains
the starting address of the service routine that handles the needs of the
corresponding event. These service routines execute in Supervisor mode.

Half (128) of these entries, locations x0100 to x017F, provide the starting
addresses of routines that service events caused by the running program
itself. These routines are called {\em exception service routines} because
they handle exceptional events, that is, events that prevent the program from
executing normally. The other half of the entries, locations x0180
to x01FF, provide the starting addresses of routines that service events that
are external to the program that is running, such as requests from
I/O devices. These routines are called {\em interrupt service routines}.

\subsection{Interrupts}

At this time, an LC-3 computer system provides only one I/O device
that can interrupt the processor. That device is the keyboard.
It interrupts at priority level PL4 and supplies the interrupt vector x80.

An I/O device can interrupt the processor if it wants service, if its
Interrupt Enable
(IE) bit is set, and if the priority of its request is greater than the
priority of any other event that wants to interrupt and greater than the 
priority of the program that is running.

Assume a program is running at a priority level less than 4, and
someone strikes a key on the keyboard. If the IE bit of the KBSR
is 1, the currently executing program is interrupted at the end of the
current instruction cycle. The interrupt service routine is {\bf initiated} as
follows:

\bgroup
\begin{enumerate}\leftskip6pt\labelsep=3pt
\item
The PSR of the interrupted process is saved in TEMP.
\item
The processor sets the privilege mode to Supervisor mode (PSR[15]=0).
\item
The processor sets the priority level to PL4, the priority level of the
interrupting device (PSR[10:8]=100).
\item
If the interrupted process is in User mode, R6 is saved in Saved\_USP and R6
is loaded with the Supervisor Stack Pointer (SSP).
\item
TEMP and the PC of the interrupted process are pushed onto the Supervisor
Stack.
\item
The keyboard supplies its 8-bit interrupt vector, in this case x80.
\item
The processor expands that vector to x0180, the corresponding 16-bit
address in the interrupt vector table.
\item
The PC is loaded with the contents of memory location x0180, the address of
the first instruction in the keyboard interrupt service routine.
\end{enumerate}
\egroup

 \noindent The processor then begins execution of the
interrupt service routine.

\looseness-1The last instruction executed in an interrupt service
routine is RTI. The top two elements of the Supervisor Stack are
popped and loaded into the PC and PSR registers. R6 is loaded with
the appropriate stack pointer, depending on the new value of
PSR[15]. Processing then continues where the interrupted program
left~off.

\vspace{-6pt}

\subsection{Exceptions}

At this time, the LC-3 ISA specifies three exception conditions: privilege
mode violation, illegal opcode, and access control violation (ACV).  
The privilege mode violation occurs if
the processor attempts to execute the RTI instruction while running in User 
mode.  The illegal opcode exception occurs if the processor attempts to 
execute an instruction having the unused opcode (Bits [15:12] == 1101).
The ACV exception occurs if the processor attempts to access privileged
memory (i.e., a memory location in System Space or a device register having
an address from xFE00 to xFFFF while running in User mode).

Exceptions are handled as soon as they are detected. They are {\em initiated}
very much like interrupts are initiated, that is:

%The way they are
%handled is very similar to the way interrupts are handled.


% For example,

\bgroup
\begin{enumerate}\leftskip6pt\labelsep=3pt
\item
The PSR of the process causing the exception is saved in TEMP.
\item
The processor sets the privilege mode to Supervisor mode (PSR[15]=0).
\item
If the process causing the exception is in User mode, R6 is saved 
in Saved\_USP and R6 is loaded with the Supervisor Stack Pointer (SSP).
\item
TEMP and the PC of the process causing the exception are pushed onto the 
Supervisor Stack.
\item
The exception supplies its 8-bit vector. In the case of the Privilege mode 
violation, that vector is x00. In the case of the illegal opcode, that vector 
is x01.  In the case of the ACV exception, that vector is x02.
\item
The processor expands that vector to x0100, x0101, or x0102, the corresponding 
16-bit address in the interrupt vector table.
\item
The PC is loaded with the contents of memory location x0100, x0101, or x0102,
the address of the first instruction in the corresponding exception service
routine.
\end{enumerate}
\egroup

\noindent
The processor then begins execution of the exception service routine.

The details of the exception service routine depends on the
exception and the way in which the operating system wishes to handle
that exception.

In many cases, the exception service routine can
correct any problem caused by the exceptional event and then continue
processing the original program.
In those cases the last instruction in the exception service routine is RTI,
which pops the top two elements from the Supervisor Stack and loads them
into the PC and PSR registers. The program then resumes execution with
the problem corrected.

In some cases, the cause of the exceptional event is sufficiently catastrophic 
that the exception service routine removes the program from further processing.

Another difference between the handling of interrupts and the handling of
exceptions is the
priority level of the processor during the execution of the service routine.
In the case of exceptions, we normally do not change the priority level when
we service the exception. The priority level of a program is the urgency
with which it needs to be executed. In the case of the exceptions
specified by the LC-3 ISA, the urgency of a program is not changed by the
fact that a privilege mode violation occurred or there was an illegal opcode
in the program or the program attempted to access privileged memory while it
was in User mode.

\end{document}
